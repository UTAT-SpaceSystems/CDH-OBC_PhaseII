
Main_Program.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000b1bc  00080000  00080000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000438  20070000  0008b1bc  00018000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000d150  20070438  0008b5f4  00018438  2**2
                  ALLOC
  3 .stack        00002000  2007d588  00098744  00018438  2**0
                  ALLOC
  4 .ARM.attributes 00000029  00000000  00000000  00018438  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00018461  2**0
                  CONTENTS, READONLY
  6 .debug_info   00019391  00000000  00000000  000184bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000363e  00000000  00000000  0003184d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00007870  00000000  00000000  00034e8b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000014e0  00000000  00000000  0003c6fb  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000012e0  00000000  00000000  0003dbdb  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001c549  00000000  00000000  0003eebb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0001a576  00000000  00000000  0005b404  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00067035  00000000  00000000  0007597a  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  000044bc  00000000  00000000  000dc9b0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00080000 <_sfixed>:
   80000:	2007f588 	.word	0x2007f588
   80004:	00085ea9 	.word	0x00085ea9
   80008:	00085ea1 	.word	0x00085ea1
   8000c:	00085ea1 	.word	0x00085ea1
   80010:	00085ea1 	.word	0x00085ea1
   80014:	00085ea1 	.word	0x00085ea1
   80018:	00085ea1 	.word	0x00085ea1
	...
   8002c:	00086351 	.word	0x00086351
   80030:	00085ea1 	.word	0x00085ea1
   80034:	00000000 	.word	0x00000000
   80038:	00086515 	.word	0x00086515
   8003c:	00086559 	.word	0x00086559
   80040:	00085ea1 	.word	0x00085ea1
   80044:	00085ea1 	.word	0x00085ea1
   80048:	00085ea1 	.word	0x00085ea1
   8004c:	00085ea1 	.word	0x00085ea1
   80050:	00085ea1 	.word	0x00085ea1
   80054:	00085ea1 	.word	0x00085ea1
   80058:	00085ea1 	.word	0x00085ea1
   8005c:	00085ea1 	.word	0x00085ea1
   80060:	00085ea1 	.word	0x00085ea1
   80064:	00085ea1 	.word	0x00085ea1
   80068:	00000000 	.word	0x00000000
   8006c:	0008585d 	.word	0x0008585d
   80070:	00085875 	.word	0x00085875
   80074:	0008588d 	.word	0x0008588d
   80078:	000858a5 	.word	0x000858a5
	...
   80084:	00084345 	.word	0x00084345
   80088:	00085ea1 	.word	0x00085ea1
   8008c:	00085ea1 	.word	0x00085ea1
   80090:	00085ea1 	.word	0x00085ea1
   80094:	00085ea1 	.word	0x00085ea1
   80098:	00085ea1 	.word	0x00085ea1
   8009c:	00085ea1 	.word	0x00085ea1
   800a0:	00083eb5 	.word	0x00083eb5
   800a4:	00000000 	.word	0x00000000
   800a8:	00085ea1 	.word	0x00085ea1
   800ac:	00085ea1 	.word	0x00085ea1
   800b0:	00085ea1 	.word	0x00085ea1
   800b4:	00085ea1 	.word	0x00085ea1
   800b8:	00085ea1 	.word	0x00085ea1
   800bc:	00085ea1 	.word	0x00085ea1
   800c0:	00085ea1 	.word	0x00085ea1
   800c4:	00085ea1 	.word	0x00085ea1
   800c8:	00085ea1 	.word	0x00085ea1
   800cc:	00085ea1 	.word	0x00085ea1
   800d0:	00085ea1 	.word	0x00085ea1
   800d4:	00085ea1 	.word	0x00085ea1
   800d8:	00085ea1 	.word	0x00085ea1
   800dc:	00085ea1 	.word	0x00085ea1
   800e0:	00085ea1 	.word	0x00085ea1
   800e4:	00085ea1 	.word	0x00085ea1
   800e8:	00085ea1 	.word	0x00085ea1
   800ec:	000889c5 	.word	0x000889c5
   800f0:	000888c5 	.word	0x000888c5

000800f4 <__do_global_dtors_aux>:
   800f4:	b510      	push	{r4, lr}
   800f6:	4c05      	ldr	r4, [pc, #20]	; (8010c <__do_global_dtors_aux+0x18>)
   800f8:	7823      	ldrb	r3, [r4, #0]
   800fa:	b933      	cbnz	r3, 8010a <__do_global_dtors_aux+0x16>
   800fc:	4b04      	ldr	r3, [pc, #16]	; (80110 <__do_global_dtors_aux+0x1c>)
   800fe:	b113      	cbz	r3, 80106 <__do_global_dtors_aux+0x12>
   80100:	4804      	ldr	r0, [pc, #16]	; (80114 <__do_global_dtors_aux+0x20>)
   80102:	f3af 8000 	nop.w
   80106:	2301      	movs	r3, #1
   80108:	7023      	strb	r3, [r4, #0]
   8010a:	bd10      	pop	{r4, pc}
   8010c:	20070438 	.word	0x20070438
   80110:	00000000 	.word	0x00000000
   80114:	0008b1bc 	.word	0x0008b1bc

00080118 <frame_dummy>:
   80118:	b508      	push	{r3, lr}
   8011a:	4b06      	ldr	r3, [pc, #24]	; (80134 <frame_dummy+0x1c>)
   8011c:	b11b      	cbz	r3, 80126 <frame_dummy+0xe>
   8011e:	4806      	ldr	r0, [pc, #24]	; (80138 <frame_dummy+0x20>)
   80120:	4906      	ldr	r1, [pc, #24]	; (8013c <frame_dummy+0x24>)
   80122:	f3af 8000 	nop.w
   80126:	4806      	ldr	r0, [pc, #24]	; (80140 <frame_dummy+0x28>)
   80128:	6803      	ldr	r3, [r0, #0]
   8012a:	b113      	cbz	r3, 80132 <frame_dummy+0x1a>
   8012c:	4b05      	ldr	r3, [pc, #20]	; (80144 <frame_dummy+0x2c>)
   8012e:	b103      	cbz	r3, 80132 <frame_dummy+0x1a>
   80130:	4798      	blx	r3
   80132:	bd08      	pop	{r3, pc}
   80134:	00000000 	.word	0x00000000
   80138:	0008b1bc 	.word	0x0008b1bc
   8013c:	2007043c 	.word	0x2007043c
   80140:	0008b1bc 	.word	0x0008b1bc
   80144:	00000000 	.word	0x00000000

00080148 <spi_get_peripheral_select_mode>:
 * \param p_spi Pointer to an SPI instance.
 *
 * \return 1 for Variable mode, 0 for fixed mode.
 */
static inline uint32_t spi_get_peripheral_select_mode(Spi *p_spi)
{
   80148:	b480      	push	{r7}
   8014a:	b083      	sub	sp, #12
   8014c:	af00      	add	r7, sp, #0
   8014e:	6078      	str	r0, [r7, #4]
	if (p_spi->SPI_MR & SPI_MR_PS) {
   80150:	687b      	ldr	r3, [r7, #4]
   80152:	685b      	ldr	r3, [r3, #4]
   80154:	f003 0302 	and.w	r3, r3, #2
   80158:	2b00      	cmp	r3, #0
   8015a:	d001      	beq.n	80160 <spi_get_peripheral_select_mode+0x18>
		return 1;
   8015c:	2301      	movs	r3, #1
   8015e:	e000      	b.n	80162 <spi_get_peripheral_select_mode+0x1a>
	} else {
		return 0;
   80160:	2300      	movs	r3, #0
	}
}
   80162:	4618      	mov	r0, r3
   80164:	370c      	adds	r7, #12
   80166:	46bd      	mov	sp, r7
   80168:	f85d 7b04 	ldr.w	r7, [sp], #4
   8016c:	4770      	bx	lr
   8016e:	bf00      	nop

00080170 <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
   80170:	b580      	push	{r7, lr}
   80172:	b082      	sub	sp, #8
   80174:	af00      	add	r7, sp, #0
   80176:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
   80178:	6878      	ldr	r0, [r7, #4]
   8017a:	4b02      	ldr	r3, [pc, #8]	; (80184 <sysclk_enable_peripheral_clock+0x14>)
   8017c:	4798      	blx	r3
}
   8017e:	3708      	adds	r7, #8
   80180:	46bd      	mov	sp, r7
   80182:	bd80      	pop	{r7, pc}
   80184:	00085b29 	.word	0x00085b29

00080188 <spi_enable_clock>:
 * \brief Enable SPI clock.
 *
 * \param p_spi Pointer to an SPI instance.
 */
void spi_enable_clock(Spi *p_spi)
{
   80188:	b580      	push	{r7, lr}
   8018a:	b082      	sub	sp, #8
   8018c:	af00      	add	r7, sp, #0
   8018e:	6078      	str	r0, [r7, #4]
#if (SAM4S || SAM3S || SAM3N || SAM3U || SAM4E || SAM4N || SAMG)
	UNUSED(p_spi);
	sysclk_enable_peripheral_clock(ID_SPI);
#elif (SAM3XA || SAM4C || SAM4CP || SAM4CM)
	if (p_spi == SPI0) {
   80190:	687a      	ldr	r2, [r7, #4]
   80192:	4b04      	ldr	r3, [pc, #16]	; (801a4 <spi_enable_clock+0x1c>)
   80194:	429a      	cmp	r2, r3
   80196:	d102      	bne.n	8019e <spi_enable_clock+0x16>
		sysclk_enable_peripheral_clock(ID_SPI0);
   80198:	2018      	movs	r0, #24
   8019a:	4b03      	ldr	r3, [pc, #12]	; (801a8 <spi_enable_clock+0x20>)
   8019c:	4798      	blx	r3
	}
	#endif
#elif SAM4L
	sysclk_enable_peripheral_clock(p_spi);
#endif
}
   8019e:	3708      	adds	r7, #8
   801a0:	46bd      	mov	sp, r7
   801a2:	bd80      	pop	{r7, pc}
   801a4:	40008000 	.word	0x40008000
   801a8:	00080171 	.word	0x00080171

000801ac <spi_set_peripheral_chip_select_value>:
 *                 The decode mode can be enabled/disabled by follow functions:
 *                 \ref spi_enable_peripheral_select_decode,
 *                 \ref spi_disable_peripheral_select_decode.
 */
void spi_set_peripheral_chip_select_value(Spi *p_spi, uint32_t ul_value)
{
   801ac:	b480      	push	{r7}
   801ae:	b083      	sub	sp, #12
   801b0:	af00      	add	r7, sp, #0
   801b2:	6078      	str	r0, [r7, #4]
   801b4:	6039      	str	r1, [r7, #0]
	p_spi->SPI_MR &= (~SPI_MR_PCS_Msk);
   801b6:	687b      	ldr	r3, [r7, #4]
   801b8:	685b      	ldr	r3, [r3, #4]
   801ba:	f423 2270 	bic.w	r2, r3, #983040	; 0xf0000
   801be:	687b      	ldr	r3, [r7, #4]
   801c0:	605a      	str	r2, [r3, #4]
	p_spi->SPI_MR |= SPI_MR_PCS(ul_value);
   801c2:	687b      	ldr	r3, [r7, #4]
   801c4:	685a      	ldr	r2, [r3, #4]
   801c6:	683b      	ldr	r3, [r7, #0]
   801c8:	041b      	lsls	r3, r3, #16
   801ca:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
   801ce:	431a      	orrs	r2, r3
   801d0:	687b      	ldr	r3, [r7, #4]
   801d2:	605a      	str	r2, [r3, #4]
}
   801d4:	370c      	adds	r7, #12
   801d6:	46bd      	mov	sp, r7
   801d8:	f85d 7b04 	ldr.w	r7, [sp], #4
   801dc:	4770      	bx	lr
   801de:	bf00      	nop

000801e0 <spi_set_delay_between_chip_select>:
 *
 * \param p_spi Pointer to an SPI instance.
 * \param ul_delay Delay between chip selects (in number of MCK clocks).
 */
void spi_set_delay_between_chip_select(Spi *p_spi, uint32_t ul_delay)
{
   801e0:	b480      	push	{r7}
   801e2:	b083      	sub	sp, #12
   801e4:	af00      	add	r7, sp, #0
   801e6:	6078      	str	r0, [r7, #4]
   801e8:	6039      	str	r1, [r7, #0]
	p_spi->SPI_MR &= (~SPI_MR_DLYBCS_Msk);
   801ea:	687b      	ldr	r3, [r7, #4]
   801ec:	685b      	ldr	r3, [r3, #4]
   801ee:	f023 427f 	bic.w	r2, r3, #4278190080	; 0xff000000
   801f2:	687b      	ldr	r3, [r7, #4]
   801f4:	605a      	str	r2, [r3, #4]
	p_spi->SPI_MR |= SPI_MR_DLYBCS(ul_delay);
   801f6:	687b      	ldr	r3, [r7, #4]
   801f8:	685a      	ldr	r2, [r3, #4]
   801fa:	683b      	ldr	r3, [r7, #0]
   801fc:	061b      	lsls	r3, r3, #24
   801fe:	431a      	orrs	r2, r3
   80200:	687b      	ldr	r3, [r7, #4]
   80202:	605a      	str	r2, [r3, #4]
}
   80204:	370c      	adds	r7, #12
   80206:	46bd      	mov	sp, r7
   80208:	f85d 7b04 	ldr.w	r7, [sp], #4
   8020c:	4770      	bx	lr
   8020e:	bf00      	nop

00080210 <spi_read>:
 *
 * \retval SPI_OK on Success.
 * \retval SPI_ERROR_TIMEOUT on Time-out.
 */
spi_status_t spi_read(Spi *p_spi, uint16_t *us_data, uint8_t *p_pcs)
{
   80210:	b580      	push	{r7, lr}
   80212:	b086      	sub	sp, #24
   80214:	af00      	add	r7, sp, #0
   80216:	60f8      	str	r0, [r7, #12]
   80218:	60b9      	str	r1, [r7, #8]
   8021a:	607a      	str	r2, [r7, #4]
	uint32_t timeout = SPI_TIMEOUT;
   8021c:	f643 2398 	movw	r3, #15000	; 0x3a98
   80220:	617b      	str	r3, [r7, #20]
	static uint32_t reg_value;

	while (!(p_spi->SPI_SR & SPI_SR_RDRF)) {
   80222:	e006      	b.n	80232 <spi_read+0x22>
		if (!timeout--) {
   80224:	697b      	ldr	r3, [r7, #20]
   80226:	1e5a      	subs	r2, r3, #1
   80228:	617a      	str	r2, [r7, #20]
   8022a:	2b00      	cmp	r3, #0
   8022c:	d101      	bne.n	80232 <spi_read+0x22>
			return SPI_ERROR_TIMEOUT;
   8022e:	2301      	movs	r3, #1
   80230:	e01d      	b.n	8026e <spi_read+0x5e>
spi_status_t spi_read(Spi *p_spi, uint16_t *us_data, uint8_t *p_pcs)
{
	uint32_t timeout = SPI_TIMEOUT;
	static uint32_t reg_value;

	while (!(p_spi->SPI_SR & SPI_SR_RDRF)) {
   80232:	68fb      	ldr	r3, [r7, #12]
   80234:	691b      	ldr	r3, [r3, #16]
   80236:	f003 0301 	and.w	r3, r3, #1
   8023a:	2b00      	cmp	r3, #0
   8023c:	d0f2      	beq.n	80224 <spi_read+0x14>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	reg_value = p_spi->SPI_RDR;
   8023e:	68fb      	ldr	r3, [r7, #12]
   80240:	689a      	ldr	r2, [r3, #8]
   80242:	4b0d      	ldr	r3, [pc, #52]	; (80278 <spi_read+0x68>)
   80244:	601a      	str	r2, [r3, #0]
	if (spi_get_peripheral_select_mode(p_spi)) {
   80246:	68f8      	ldr	r0, [r7, #12]
   80248:	4b0c      	ldr	r3, [pc, #48]	; (8027c <spi_read+0x6c>)
   8024a:	4798      	blx	r3
   8024c:	4603      	mov	r3, r0
   8024e:	2b00      	cmp	r3, #0
   80250:	d007      	beq.n	80262 <spi_read+0x52>
		*p_pcs = (uint8_t) ((reg_value & SPI_RDR_PCS_Msk) >> SPI_RDR_PCS_Pos);
   80252:	4b09      	ldr	r3, [pc, #36]	; (80278 <spi_read+0x68>)
   80254:	681b      	ldr	r3, [r3, #0]
   80256:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
   8025a:	0c1b      	lsrs	r3, r3, #16
   8025c:	b2da      	uxtb	r2, r3
   8025e:	687b      	ldr	r3, [r7, #4]
   80260:	701a      	strb	r2, [r3, #0]
	}
	*us_data = (uint16_t) (reg_value & SPI_RDR_RD_Msk);
   80262:	4b05      	ldr	r3, [pc, #20]	; (80278 <spi_read+0x68>)
   80264:	681b      	ldr	r3, [r3, #0]
   80266:	b29a      	uxth	r2, r3
   80268:	68bb      	ldr	r3, [r7, #8]
   8026a:	801a      	strh	r2, [r3, #0]

	return SPI_OK;
   8026c:	2300      	movs	r3, #0
   8026e:	b25b      	sxtb	r3, r3
}
   80270:	4618      	mov	r0, r3
   80272:	3718      	adds	r7, #24
   80274:	46bd      	mov	sp, r7
   80276:	bd80      	pop	{r7, pc}
   80278:	20070454 	.word	0x20070454
   8027c:	00080149 	.word	0x00080149

00080280 <spi_write>:
 * \retval SPI_OK on Success.
 * \retval SPI_ERROR_TIMEOUT on Time-out.
 */
spi_status_t spi_write(Spi *p_spi, uint16_t us_data,
		uint8_t uc_pcs, uint8_t uc_last)
{
   80280:	b580      	push	{r7, lr}
   80282:	b084      	sub	sp, #16
   80284:	af00      	add	r7, sp, #0
   80286:	6078      	str	r0, [r7, #4]
   80288:	8079      	strh	r1, [r7, #2]
   8028a:	707a      	strb	r2, [r7, #1]
   8028c:	703b      	strb	r3, [r7, #0]
	uint32_t timeout = SPI_TIMEOUT;
   8028e:	f643 2398 	movw	r3, #15000	; 0x3a98
   80292:	60fb      	str	r3, [r7, #12]
	uint32_t value;

	while (!(p_spi->SPI_SR & SPI_SR_TDRE)) {
   80294:	e006      	b.n	802a4 <spi_write+0x24>
		if (!timeout--) {
   80296:	68fb      	ldr	r3, [r7, #12]
   80298:	1e5a      	subs	r2, r3, #1
   8029a:	60fa      	str	r2, [r7, #12]
   8029c:	2b00      	cmp	r3, #0
   8029e:	d101      	bne.n	802a4 <spi_write+0x24>
			return SPI_ERROR_TIMEOUT;
   802a0:	2301      	movs	r3, #1
   802a2:	e020      	b.n	802e6 <spi_write+0x66>
		uint8_t uc_pcs, uint8_t uc_last)
{
	uint32_t timeout = SPI_TIMEOUT;
	uint32_t value;

	while (!(p_spi->SPI_SR & SPI_SR_TDRE)) {
   802a4:	687b      	ldr	r3, [r7, #4]
   802a6:	691b      	ldr	r3, [r3, #16]
   802a8:	f003 0302 	and.w	r3, r3, #2
   802ac:	2b00      	cmp	r3, #0
   802ae:	d0f2      	beq.n	80296 <spi_write+0x16>
		if (!timeout--) {
			return SPI_ERROR_TIMEOUT;
		}
	}

	if (spi_get_peripheral_select_mode(p_spi)) 
   802b0:	6878      	ldr	r0, [r7, #4]
   802b2:	4b0f      	ldr	r3, [pc, #60]	; (802f0 <spi_write+0x70>)
   802b4:	4798      	blx	r3
   802b6:	4603      	mov	r3, r0
   802b8:	2b00      	cmp	r3, #0
   802ba:	d00e      	beq.n	802da <spi_write+0x5a>
		{
		value = SPI_TDR_TD(us_data) | SPI_TDR_PCS(uc_pcs);
   802bc:	887a      	ldrh	r2, [r7, #2]
   802be:	787b      	ldrb	r3, [r7, #1]
   802c0:	041b      	lsls	r3, r3, #16
   802c2:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
   802c6:	4313      	orrs	r3, r2
   802c8:	60bb      	str	r3, [r7, #8]
		if (uc_last) 
   802ca:	783b      	ldrb	r3, [r7, #0]
   802cc:	2b00      	cmp	r3, #0
   802ce:	d006      	beq.n	802de <spi_write+0x5e>
		{
			value |= SPI_TDR_LASTXFER;
   802d0:	68bb      	ldr	r3, [r7, #8]
   802d2:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
   802d6:	60bb      	str	r3, [r7, #8]
   802d8:	e001      	b.n	802de <spi_write+0x5e>
		}
	}	
	else 
	{
		value = SPI_TDR_TD(us_data);
   802da:	887b      	ldrh	r3, [r7, #2]
   802dc:	60bb      	str	r3, [r7, #8]
	}

	p_spi->SPI_TDR = value;
   802de:	687b      	ldr	r3, [r7, #4]
   802e0:	68ba      	ldr	r2, [r7, #8]
   802e2:	60da      	str	r2, [r3, #12]
	
	//pio_toggle_pin(LED0_GPIO);

	return SPI_OK;
   802e4:	2300      	movs	r3, #0
   802e6:	b25b      	sxtb	r3, r3
}
   802e8:	4618      	mov	r0, r3
   802ea:	3710      	adds	r7, #16
   802ec:	46bd      	mov	sp, r7
   802ee:	bd80      	pop	{r7, pc}
   802f0:	00080149 	.word	0x00080149

000802f4 <spi_set_clock_polarity>:
 * \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 * \param ul_polarity Default clock state is logical one(high)/zero(low).
 */
void spi_set_clock_polarity(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_polarity)
{
   802f4:	b480      	push	{r7}
   802f6:	b085      	sub	sp, #20
   802f8:	af00      	add	r7, sp, #0
   802fa:	60f8      	str	r0, [r7, #12]
   802fc:	60b9      	str	r1, [r7, #8]
   802fe:	607a      	str	r2, [r7, #4]
	if (ul_polarity) {
   80300:	687b      	ldr	r3, [r7, #4]
   80302:	2b00      	cmp	r3, #0
   80304:	d00c      	beq.n	80320 <spi_set_clock_polarity+0x2c>
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CPOL;
   80306:	68fb      	ldr	r3, [r7, #12]
   80308:	68ba      	ldr	r2, [r7, #8]
   8030a:	320c      	adds	r2, #12
   8030c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   80310:	f043 0101 	orr.w	r1, r3, #1
   80314:	68fb      	ldr	r3, [r7, #12]
   80316:	68ba      	ldr	r2, [r7, #8]
   80318:	320c      	adds	r2, #12
   8031a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   8031e:	e00b      	b.n	80338 <spi_set_clock_polarity+0x44>
	} else {
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CPOL);
   80320:	68fb      	ldr	r3, [r7, #12]
   80322:	68ba      	ldr	r2, [r7, #8]
   80324:	320c      	adds	r2, #12
   80326:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   8032a:	f023 0101 	bic.w	r1, r3, #1
   8032e:	68fb      	ldr	r3, [r7, #12]
   80330:	68ba      	ldr	r2, [r7, #8]
   80332:	320c      	adds	r2, #12
   80334:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	}
}
   80338:	3714      	adds	r7, #20
   8033a:	46bd      	mov	sp, r7
   8033c:	f85d 7b04 	ldr.w	r7, [sp], #4
   80340:	4770      	bx	lr
   80342:	bf00      	nop

00080344 <spi_set_clock_phase>:
 * \param p_spi Pointer to an SPI instance.
 *  \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 *  \param ul_phase Data capture on the rising/falling edge of clock.
 */
void spi_set_clock_phase(Spi *p_spi, uint32_t ul_pcs_ch, uint32_t ul_phase)
{
   80344:	b480      	push	{r7}
   80346:	b085      	sub	sp, #20
   80348:	af00      	add	r7, sp, #0
   8034a:	60f8      	str	r0, [r7, #12]
   8034c:	60b9      	str	r1, [r7, #8]
   8034e:	607a      	str	r2, [r7, #4]
	if (ul_phase) {
   80350:	687b      	ldr	r3, [r7, #4]
   80352:	2b00      	cmp	r3, #0
   80354:	d00c      	beq.n	80370 <spi_set_clock_phase+0x2c>
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_NCPHA;
   80356:	68fb      	ldr	r3, [r7, #12]
   80358:	68ba      	ldr	r2, [r7, #8]
   8035a:	320c      	adds	r2, #12
   8035c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   80360:	f043 0102 	orr.w	r1, r3, #2
   80364:	68fb      	ldr	r3, [r7, #12]
   80366:	68ba      	ldr	r2, [r7, #8]
   80368:	320c      	adds	r2, #12
   8036a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   8036e:	e00b      	b.n	80388 <spi_set_clock_phase+0x44>
	} else {
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_NCPHA);
   80370:	68fb      	ldr	r3, [r7, #12]
   80372:	68ba      	ldr	r2, [r7, #8]
   80374:	320c      	adds	r2, #12
   80376:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   8037a:	f023 0102 	bic.w	r1, r3, #2
   8037e:	68fb      	ldr	r3, [r7, #12]
   80380:	68ba      	ldr	r2, [r7, #8]
   80382:	320c      	adds	r2, #12
   80384:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	}
}
   80388:	3714      	adds	r7, #20
   8038a:	46bd      	mov	sp, r7
   8038c:	f85d 7b04 	ldr.w	r7, [sp], #4
   80390:	4770      	bx	lr
   80392:	bf00      	nop

00080394 <spi_configure_cs_behavior>:
 * \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 * \param ul_cs_behavior Behavior of the Chip Select after transfer.
 */
void spi_configure_cs_behavior(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_cs_behavior)
{
   80394:	b480      	push	{r7}
   80396:	b085      	sub	sp, #20
   80398:	af00      	add	r7, sp, #0
   8039a:	60f8      	str	r0, [r7, #12]
   8039c:	60b9      	str	r1, [r7, #8]
   8039e:	607a      	str	r2, [r7, #4]
	if (ul_cs_behavior == SPI_CS_RISE_FORCED) {
   803a0:	687b      	ldr	r3, [r7, #4]
   803a2:	2b04      	cmp	r3, #4
   803a4:	d118      	bne.n	803d8 <spi_configure_cs_behavior+0x44>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
   803a6:	68fb      	ldr	r3, [r7, #12]
   803a8:	68ba      	ldr	r2, [r7, #8]
   803aa:	320c      	adds	r2, #12
   803ac:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   803b0:	f023 0108 	bic.w	r1, r3, #8
   803b4:	68fb      	ldr	r3, [r7, #12]
   803b6:	68ba      	ldr	r2, [r7, #8]
   803b8:	320c      	adds	r2, #12
   803ba:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSNAAT;
   803be:	68fb      	ldr	r3, [r7, #12]
   803c0:	68ba      	ldr	r2, [r7, #8]
   803c2:	320c      	adds	r2, #12
   803c4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   803c8:	f043 0104 	orr.w	r1, r3, #4
   803cc:	68fb      	ldr	r3, [r7, #12]
   803ce:	68ba      	ldr	r2, [r7, #8]
   803d0:	320c      	adds	r2, #12
   803d2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   803d6:	e02a      	b.n	8042e <spi_configure_cs_behavior+0x9a>
	} else if (ul_cs_behavior == SPI_CS_RISE_NO_TX) {
   803d8:	687b      	ldr	r3, [r7, #4]
   803da:	2b00      	cmp	r3, #0
   803dc:	d118      	bne.n	80410 <spi_configure_cs_behavior+0x7c>
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSAAT);
   803de:	68fb      	ldr	r3, [r7, #12]
   803e0:	68ba      	ldr	r2, [r7, #8]
   803e2:	320c      	adds	r2, #12
   803e4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   803e8:	f023 0108 	bic.w	r1, r3, #8
   803ec:	68fb      	ldr	r3, [r7, #12]
   803ee:	68ba      	ldr	r2, [r7, #8]
   803f0:	320c      	adds	r2, #12
   803f2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_CSNAAT);
   803f6:	68fb      	ldr	r3, [r7, #12]
   803f8:	68ba      	ldr	r2, [r7, #8]
   803fa:	320c      	adds	r2, #12
   803fc:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   80400:	f023 0104 	bic.w	r1, r3, #4
   80404:	68fb      	ldr	r3, [r7, #12]
   80406:	68ba      	ldr	r2, [r7, #8]
   80408:	320c      	adds	r2, #12
   8040a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
   8040e:	e00e      	b.n	8042e <spi_configure_cs_behavior+0x9a>
	} else if (ul_cs_behavior == SPI_CS_KEEP_LOW) {
   80410:	687b      	ldr	r3, [r7, #4]
   80412:	2b08      	cmp	r3, #8
   80414:	d10b      	bne.n	8042e <spi_configure_cs_behavior+0x9a>
		p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_CSAAT;
   80416:	68fb      	ldr	r3, [r7, #12]
   80418:	68ba      	ldr	r2, [r7, #8]
   8041a:	320c      	adds	r2, #12
   8041c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   80420:	f043 0108 	orr.w	r1, r3, #8
   80424:	68fb      	ldr	r3, [r7, #12]
   80426:	68ba      	ldr	r2, [r7, #8]
   80428:	320c      	adds	r2, #12
   8042a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	}
}
   8042e:	3714      	adds	r7, #20
   80430:	46bd      	mov	sp, r7
   80432:	f85d 7b04 	ldr.w	r7, [sp], #4
   80436:	4770      	bx	lr

00080438 <spi_set_bits_per_transfer>:
 * \param ul_bits Number of bits (8~16), use the pattern defined
 *        in the device header file.
 */
void spi_set_bits_per_transfer(Spi *p_spi, uint32_t ul_pcs_ch,
		uint32_t ul_bits)
{
   80438:	b480      	push	{r7}
   8043a:	b085      	sub	sp, #20
   8043c:	af00      	add	r7, sp, #0
   8043e:	60f8      	str	r0, [r7, #12]
   80440:	60b9      	str	r1, [r7, #8]
   80442:	607a      	str	r2, [r7, #4]
	p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_BITS_Msk);
   80444:	68fb      	ldr	r3, [r7, #12]
   80446:	68ba      	ldr	r2, [r7, #8]
   80448:	320c      	adds	r2, #12
   8044a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   8044e:	f023 01f0 	bic.w	r1, r3, #240	; 0xf0
   80452:	68fb      	ldr	r3, [r7, #12]
   80454:	68ba      	ldr	r2, [r7, #8]
   80456:	320c      	adds	r2, #12
   80458:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	p_spi->SPI_CSR[ul_pcs_ch] |= ul_bits;
   8045c:	68fb      	ldr	r3, [r7, #12]
   8045e:	68ba      	ldr	r2, [r7, #8]
   80460:	320c      	adds	r2, #12
   80462:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   80466:	687b      	ldr	r3, [r7, #4]
   80468:	ea42 0103 	orr.w	r1, r2, r3
   8046c:	68fb      	ldr	r3, [r7, #12]
   8046e:	68ba      	ldr	r2, [r7, #8]
   80470:	320c      	adds	r2, #12
   80472:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   80476:	3714      	adds	r7, #20
   80478:	46bd      	mov	sp, r7
   8047a:	f85d 7b04 	ldr.w	r7, [sp], #4
   8047e:	4770      	bx	lr

00080480 <spi_calc_baudrate_div>:
 * \return Divider or error code.
 *   \retval > 0  Success.
 *   \retval < 0  Error.
 */
int16_t spi_calc_baudrate_div(const uint32_t baudrate, uint32_t mck)
{
   80480:	b480      	push	{r7}
   80482:	b085      	sub	sp, #20
   80484:	af00      	add	r7, sp, #0
   80486:	6078      	str	r0, [r7, #4]
   80488:	6039      	str	r1, [r7, #0]
	int baud_div = div_ceil(mck, baudrate);
   8048a:	683a      	ldr	r2, [r7, #0]
   8048c:	687b      	ldr	r3, [r7, #4]
   8048e:	4413      	add	r3, r2
   80490:	1e5a      	subs	r2, r3, #1
   80492:	687b      	ldr	r3, [r7, #4]
   80494:	fbb2 f3f3 	udiv	r3, r2, r3
   80498:	60fb      	str	r3, [r7, #12]

	/* The value of baud_div is from 1 to 255 in the SCBR field. */
	if (baud_div <= 0 || baud_div > 255) {
   8049a:	68fb      	ldr	r3, [r7, #12]
   8049c:	2b00      	cmp	r3, #0
   8049e:	dd02      	ble.n	804a6 <spi_calc_baudrate_div+0x26>
   804a0:	68fb      	ldr	r3, [r7, #12]
   804a2:	2bff      	cmp	r3, #255	; 0xff
   804a4:	dd02      	ble.n	804ac <spi_calc_baudrate_div+0x2c>
		return -1;
   804a6:	f64f 73ff 	movw	r3, #65535	; 0xffff
   804aa:	e001      	b.n	804b0 <spi_calc_baudrate_div+0x30>
	}

	return baud_div;
   804ac:	68fb      	ldr	r3, [r7, #12]
   804ae:	b29b      	uxth	r3, r3
   804b0:	b21b      	sxth	r3, r3
}
   804b2:	4618      	mov	r0, r3
   804b4:	3714      	adds	r7, #20
   804b6:	46bd      	mov	sp, r7
   804b8:	f85d 7b04 	ldr.w	r7, [sp], #4
   804bc:	4770      	bx	lr
   804be:	bf00      	nop

000804c0 <spi_set_baudrate_div>:
 * \param ul_pcs_ch Peripheral Chip Select channel (0~3).
 * \param uc_baudrate_divider Baudrate divider from MCK.
 */
void spi_set_baudrate_div(Spi *p_spi, uint32_t ul_pcs_ch,
		uint8_t uc_baudrate_divider)
{
   804c0:	b480      	push	{r7}
   804c2:	b085      	sub	sp, #20
   804c4:	af00      	add	r7, sp, #0
   804c6:	60f8      	str	r0, [r7, #12]
   804c8:	60b9      	str	r1, [r7, #8]
   804ca:	4613      	mov	r3, r2
   804cc:	71fb      	strb	r3, [r7, #7]
	p_spi->SPI_CSR[ul_pcs_ch] &= (~SPI_CSR_SCBR_Msk);
   804ce:	68fb      	ldr	r3, [r7, #12]
   804d0:	68ba      	ldr	r2, [r7, #8]
   804d2:	320c      	adds	r2, #12
   804d4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   804d8:	f423 417f 	bic.w	r1, r3, #65280	; 0xff00
   804dc:	68fb      	ldr	r3, [r7, #12]
   804de:	68ba      	ldr	r2, [r7, #8]
   804e0:	320c      	adds	r2, #12
   804e2:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_SCBR(uc_baudrate_divider);
   804e6:	68fb      	ldr	r3, [r7, #12]
   804e8:	68ba      	ldr	r2, [r7, #8]
   804ea:	320c      	adds	r2, #12
   804ec:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   804f0:	79fb      	ldrb	r3, [r7, #7]
   804f2:	021b      	lsls	r3, r3, #8
   804f4:	b29b      	uxth	r3, r3
   804f6:	ea42 0103 	orr.w	r1, r2, r3
   804fa:	68fb      	ldr	r3, [r7, #12]
   804fc:	68ba      	ldr	r2, [r7, #8]
   804fe:	320c      	adds	r2, #12
   80500:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   80504:	3714      	adds	r7, #20
   80506:	46bd      	mov	sp, r7
   80508:	f85d 7b04 	ldr.w	r7, [sp], #4
   8050c:	4770      	bx	lr
   8050e:	bf00      	nop

00080510 <spi_set_transfer_delay>:
 * \param uc_dlybs Delay before SPCK (in number of MCK clocks).
 * \param uc_dlybct Delay between consecutive transfers (in number of MCK clocks).
 */
void spi_set_transfer_delay(Spi *p_spi, uint32_t ul_pcs_ch,
		uint8_t uc_dlybs, uint8_t uc_dlybct)
{
   80510:	b480      	push	{r7}
   80512:	b085      	sub	sp, #20
   80514:	af00      	add	r7, sp, #0
   80516:	60f8      	str	r0, [r7, #12]
   80518:	60b9      	str	r1, [r7, #8]
   8051a:	71fa      	strb	r2, [r7, #7]
   8051c:	71bb      	strb	r3, [r7, #6]
	p_spi->SPI_CSR[ul_pcs_ch] &= ~(SPI_CSR_DLYBS_Msk | SPI_CSR_DLYBCT_Msk);
   8051e:	68fb      	ldr	r3, [r7, #12]
   80520:	68ba      	ldr	r2, [r7, #8]
   80522:	320c      	adds	r2, #12
   80524:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   80528:	b299      	uxth	r1, r3
   8052a:	68fb      	ldr	r3, [r7, #12]
   8052c:	68ba      	ldr	r2, [r7, #8]
   8052e:	320c      	adds	r2, #12
   80530:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_DLYBS(uc_dlybs)
   80534:	68fb      	ldr	r3, [r7, #12]
   80536:	68ba      	ldr	r2, [r7, #8]
   80538:	320c      	adds	r2, #12
   8053a:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
   8053e:	79fb      	ldrb	r3, [r7, #7]
   80540:	041b      	lsls	r3, r3, #16
   80542:	f403 017f 	and.w	r1, r3, #16711680	; 0xff0000
			| SPI_CSR_DLYBCT(uc_dlybct);
   80546:	79bb      	ldrb	r3, [r7, #6]
   80548:	061b      	lsls	r3, r3, #24
   8054a:	430b      	orrs	r3, r1
 */
void spi_set_transfer_delay(Spi *p_spi, uint32_t ul_pcs_ch,
		uint8_t uc_dlybs, uint8_t uc_dlybct)
{
	p_spi->SPI_CSR[ul_pcs_ch] &= ~(SPI_CSR_DLYBS_Msk | SPI_CSR_DLYBCT_Msk);
	p_spi->SPI_CSR[ul_pcs_ch] |= SPI_CSR_DLYBS(uc_dlybs)
   8054c:	ea42 0103 	orr.w	r1, r2, r3
   80550:	68fb      	ldr	r3, [r7, #12]
   80552:	68ba      	ldr	r2, [r7, #8]
   80554:	320c      	adds	r2, #12
   80556:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
			| SPI_CSR_DLYBCT(uc_dlybct);
}
   8055a:	3714      	adds	r7, #20
   8055c:	46bd      	mov	sp, r7
   8055e:	f85d 7b04 	ldr.w	r7, [sp], #4
   80562:	4770      	bx	lr

00080564 <errorASSERT>:
/* @Note: This function shall halt the regular operation of this task	*/
/* for a maximum of 5 minutes.											*/
/* @Note: *data should point to an array of at least 147 bytes.			*/
/************************************************************************/
int errorASSERT(uint8_t task, uint8_t code, uint32_t error, uint8_t* data, SemaphoreHandle_t mutex)
{
   80564:	b590      	push	{r4, r7, lr}
   80566:	b089      	sub	sp, #36	; 0x24
   80568:	af00      	add	r7, sp, #0
   8056a:	60ba      	str	r2, [r7, #8]
   8056c:	607b      	str	r3, [r7, #4]
   8056e:	4603      	mov	r3, r0
   80570:	73fb      	strb	r3, [r7, #15]
   80572:	460b      	mov	r3, r1
   80574:	73bb      	strb	r3, [r7, #14]
	uint8_t i;
	TickType_t wait_time = 5 * 60 * 1000;
   80576:	4ba1      	ldr	r3, [pc, #644]	; (807fc <errorASSERT+0x298>)
   80578:	617b      	str	r3, [r7, #20]
	uint32_t timeout = 5 * 60 * 1000;
   8057a:	4ba0      	ldr	r3, [pc, #640]	; (807fc <errorASSERT+0x298>)
   8057c:	61bb      	str	r3, [r7, #24]
	int ret_val = 0;
   8057e:	2300      	movs	r3, #0
   80580:	613b      	str	r3, [r7, #16]
	for(i = 0; i < 147; i++)
   80582:	2300      	movs	r3, #0
   80584:	77fb      	strb	r3, [r7, #31]
   80586:	e009      	b.n	8059c <errorASSERT+0x38>
	{
		high_error_array[i] = *(data + i);	// Load the data into the high_error_array.
   80588:	7ffb      	ldrb	r3, [r7, #31]
   8058a:	7ffa      	ldrb	r2, [r7, #31]
   8058c:	6879      	ldr	r1, [r7, #4]
   8058e:	440a      	add	r2, r1
   80590:	7811      	ldrb	r1, [r2, #0]
   80592:	4a9b      	ldr	r2, [pc, #620]	; (80800 <errorASSERT+0x29c>)
   80594:	54d1      	strb	r1, [r2, r3]
{
	uint8_t i;
	TickType_t wait_time = 5 * 60 * 1000;
	uint32_t timeout = 5 * 60 * 1000;
	int ret_val = 0;
	for(i = 0; i < 147; i++)
   80596:	7ffb      	ldrb	r3, [r7, #31]
   80598:	3301      	adds	r3, #1
   8059a:	77fb      	strb	r3, [r7, #31]
   8059c:	7ffb      	ldrb	r3, [r7, #31]
   8059e:	2b92      	cmp	r3, #146	; 0x92
   805a0:	d9f2      	bls.n	80588 <errorASSERT+0x24>
	{
		high_error_array[i] = *(data + i);	// Load the data into the high_error_array.
	}
	high_error_array[151] = (uint8_t)((error & 0xFF000000) >> 24);
   805a2:	68bb      	ldr	r3, [r7, #8]
   805a4:	0e1b      	lsrs	r3, r3, #24
   805a6:	b2da      	uxtb	r2, r3
   805a8:	4b95      	ldr	r3, [pc, #596]	; (80800 <errorASSERT+0x29c>)
   805aa:	f883 2097 	strb.w	r2, [r3, #151]	; 0x97
	high_error_array[150] = (uint8_t)((error & 0x00FF0000) >> 16);
   805ae:	68bb      	ldr	r3, [r7, #8]
   805b0:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   805b4:	0c1b      	lsrs	r3, r3, #16
   805b6:	b2da      	uxtb	r2, r3
   805b8:	4b91      	ldr	r3, [pc, #580]	; (80800 <errorASSERT+0x29c>)
   805ba:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
	high_error_array[149] = (uint8_t)((error & 0x0000FF00) > 8);
   805be:	68bb      	ldr	r3, [r7, #8]
   805c0:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   805c4:	2b08      	cmp	r3, #8
   805c6:	bf94      	ite	ls
   805c8:	2300      	movls	r3, #0
   805ca:	2301      	movhi	r3, #1
   805cc:	b2db      	uxtb	r3, r3
   805ce:	461a      	mov	r2, r3
   805d0:	4b8b      	ldr	r3, [pc, #556]	; (80800 <errorASSERT+0x29c>)
   805d2:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
	high_error_array[148] = (uint8_t)(error & 0x000000FF);
   805d6:	68bb      	ldr	r3, [r7, #8]
   805d8:	b2da      	uxtb	r2, r3
   805da:	4b89      	ldr	r3, [pc, #548]	; (80800 <errorASSERT+0x29c>)
   805dc:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
	high_error_array[147] = task;
   805e0:	4b87      	ldr	r3, [pc, #540]	; (80800 <errorASSERT+0x29c>)
   805e2:	7bfa      	ldrb	r2, [r7, #15]
   805e4:	f883 2093 	strb.w	r2, [r3, #147]	; 0x93
	high_error_array[146] = code;
   805e8:	4b85      	ldr	r3, [pc, #532]	; (80800 <errorASSERT+0x29c>)
   805ea:	7bba      	ldrb	r2, [r7, #14]
   805ec:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92

	if (xSemaphoreTake(Highsev_Mutex, wait_time) == pdTRUE)		// Attempt to acquire Mutex, block for max 5 minutes.
   805f0:	4b84      	ldr	r3, [pc, #528]	; (80804 <errorASSERT+0x2a0>)
   805f2:	681b      	ldr	r3, [r3, #0]
   805f4:	4618      	mov	r0, r3
   805f6:	2100      	movs	r1, #0
   805f8:	697a      	ldr	r2, [r7, #20]
   805fa:	2300      	movs	r3, #0
   805fc:	4c82      	ldr	r4, [pc, #520]	; (80808 <errorASSERT+0x2a4>)
   805fe:	47a0      	blx	r4
   80600:	4603      	mov	r3, r0
   80602:	2b01      	cmp	r3, #1
   80604:	d107      	bne.n	80616 <errorASSERT+0xb2>
	{
		xQueueSendToBack(high_sev_to_fdir_fifo, high_error_array, wait_time);		// This should return pdTrue
   80606:	4b81      	ldr	r3, [pc, #516]	; (8080c <errorASSERT+0x2a8>)
   80608:	681b      	ldr	r3, [r3, #0]
   8060a:	4618      	mov	r0, r3
   8060c:	497c      	ldr	r1, [pc, #496]	; (80800 <errorASSERT+0x29c>)
   8060e:	697a      	ldr	r2, [r7, #20]
   80610:	2300      	movs	r3, #0
   80612:	4c7f      	ldr	r4, [pc, #508]	; (80810 <errorASSERT+0x2ac>)
   80614:	47a0      	blx	r4
	}
	xSemaphoreGive(Highsev_Mutex);
   80616:	4b7b      	ldr	r3, [pc, #492]	; (80804 <errorASSERT+0x2a0>)
   80618:	681b      	ldr	r3, [r3, #0]
   8061a:	4618      	mov	r0, r3
   8061c:	2100      	movs	r1, #0
   8061e:	2200      	movs	r2, #0
   80620:	2300      	movs	r3, #0
   80622:	4c7b      	ldr	r4, [pc, #492]	; (80810 <errorASSERT+0x2ac>)
   80624:	47a0      	blx	r4
	// Release the currently acquired mutex lock if there is one.
	if(mutex)
   80626:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   80628:	2b00      	cmp	r3, #0
   8062a:	d005      	beq.n	80638 <errorASSERT+0xd4>
	xSemaphoreGive(mutex);
   8062c:	6b38      	ldr	r0, [r7, #48]	; 0x30
   8062e:	2100      	movs	r1, #0
   80630:	2200      	movs	r2, #0
   80632:	2300      	movs	r3, #0
   80634:	4c76      	ldr	r4, [pc, #472]	; (80810 <errorASSERT+0x2ac>)
   80636:	47a0      	blx	r4
	// Wait for the error to be resolved.
	switch(task)
   80638:	7bfb      	ldrb	r3, [r7, #15]
   8063a:	3b04      	subs	r3, #4
   8063c:	2b0a      	cmp	r3, #10
   8063e:	f200 8111 	bhi.w	80864 <errorASSERT+0x300>
   80642:	a201      	add	r2, pc, #4	; (adr r2, 80648 <errorASSERT+0xe4>)
   80644:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   80648:	00080675 	.word	0x00080675
   8064c:	00080865 	.word	0x00080865
   80650:	000806a5 	.word	0x000806a5
   80654:	000806d5 	.word	0x000806d5
   80658:	00080705 	.word	0x00080705
   8065c:	00080735 	.word	0x00080735
   80660:	00080765 	.word	0x00080765
   80664:	00080795 	.word	0x00080795
   80668:	00080865 	.word	0x00080865
   8066c:	000807c5 	.word	0x000807c5
   80670:	000807f5 	.word	0x000807f5
	{
		case HK_TASK_ID:
			hk_fdir_signal = 1;
   80674:	4b67      	ldr	r3, [pc, #412]	; (80814 <errorASSERT+0x2b0>)
   80676:	2201      	movs	r2, #1
   80678:	701a      	strb	r2, [r3, #0]
			while(hk_fdir_signal & timeout--){taskYIELD();}	// Wait until the problem is solved for a maximum of 5 minutes.
   8067a:	e001      	b.n	80680 <errorASSERT+0x11c>
   8067c:	4b66      	ldr	r3, [pc, #408]	; (80818 <errorASSERT+0x2b4>)
   8067e:	4798      	blx	r3
   80680:	4b64      	ldr	r3, [pc, #400]	; (80814 <errorASSERT+0x2b0>)
   80682:	781b      	ldrb	r3, [r3, #0]
   80684:	461a      	mov	r2, r3
   80686:	69bb      	ldr	r3, [r7, #24]
   80688:	1e59      	subs	r1, r3, #1
   8068a:	61b9      	str	r1, [r7, #24]
   8068c:	4013      	ands	r3, r2
   8068e:	2b00      	cmp	r3, #0
   80690:	d1f4      	bne.n	8067c <errorASSERT+0x118>
			ret_val = -1;
   80692:	f04f 33ff 	mov.w	r3, #4294967295
   80696:	613b      	str	r3, [r7, #16]
			if(!hk_fdir_signal)
   80698:	4b5e      	ldr	r3, [pc, #376]	; (80814 <errorASSERT+0x2b0>)
   8069a:	781b      	ldrb	r3, [r3, #0]
   8069c:	2b00      	cmp	r3, #0
   8069e:	d101      	bne.n	806a4 <errorASSERT+0x140>
				ret_val =  1;
   806a0:	2301      	movs	r3, #1
   806a2:	613b      	str	r3, [r7, #16]
		case TIME_TASK_ID:
			time_fdir_signal = 1;
   806a4:	4b5d      	ldr	r3, [pc, #372]	; (8081c <errorASSERT+0x2b8>)
   806a6:	2201      	movs	r2, #1
   806a8:	701a      	strb	r2, [r3, #0]
			while(time_fdir_signal & timeout--){taskYIELD();}
   806aa:	e001      	b.n	806b0 <errorASSERT+0x14c>
   806ac:	4b5a      	ldr	r3, [pc, #360]	; (80818 <errorASSERT+0x2b4>)
   806ae:	4798      	blx	r3
   806b0:	4b5a      	ldr	r3, [pc, #360]	; (8081c <errorASSERT+0x2b8>)
   806b2:	781b      	ldrb	r3, [r3, #0]
   806b4:	461a      	mov	r2, r3
   806b6:	69bb      	ldr	r3, [r7, #24]
   806b8:	1e59      	subs	r1, r3, #1
   806ba:	61b9      	str	r1, [r7, #24]
   806bc:	4013      	ands	r3, r2
   806be:	2b00      	cmp	r3, #0
   806c0:	d1f4      	bne.n	806ac <errorASSERT+0x148>
			ret_val = -1;
   806c2:	f04f 33ff 	mov.w	r3, #4294967295
   806c6:	613b      	str	r3, [r7, #16]
			if(!time_fdir_signal)
   806c8:	4b54      	ldr	r3, [pc, #336]	; (8081c <errorASSERT+0x2b8>)
   806ca:	781b      	ldrb	r3, [r3, #0]
   806cc:	2b00      	cmp	r3, #0
   806ce:	d101      	bne.n	806d4 <errorASSERT+0x170>
				ret_val = 1;
   806d0:	2301      	movs	r3, #1
   806d2:	613b      	str	r3, [r7, #16]
		case COMS_TASK_ID:
			coms_fdir_signal = 1;
   806d4:	4b52      	ldr	r3, [pc, #328]	; (80820 <errorASSERT+0x2bc>)
   806d6:	2201      	movs	r2, #1
   806d8:	701a      	strb	r2, [r3, #0]
			while(coms_fdir_signal & timeout--){taskYIELD();}
   806da:	e001      	b.n	806e0 <errorASSERT+0x17c>
   806dc:	4b4e      	ldr	r3, [pc, #312]	; (80818 <errorASSERT+0x2b4>)
   806de:	4798      	blx	r3
   806e0:	4b4f      	ldr	r3, [pc, #316]	; (80820 <errorASSERT+0x2bc>)
   806e2:	781b      	ldrb	r3, [r3, #0]
   806e4:	461a      	mov	r2, r3
   806e6:	69bb      	ldr	r3, [r7, #24]
   806e8:	1e59      	subs	r1, r3, #1
   806ea:	61b9      	str	r1, [r7, #24]
   806ec:	4013      	ands	r3, r2
   806ee:	2b00      	cmp	r3, #0
   806f0:	d1f4      	bne.n	806dc <errorASSERT+0x178>
			ret_val = -1;
   806f2:	f04f 33ff 	mov.w	r3, #4294967295
   806f6:	613b      	str	r3, [r7, #16]
			if(!coms_fdir_signal)
   806f8:	4b49      	ldr	r3, [pc, #292]	; (80820 <errorASSERT+0x2bc>)
   806fa:	781b      	ldrb	r3, [r3, #0]
   806fc:	2b00      	cmp	r3, #0
   806fe:	d101      	bne.n	80704 <errorASSERT+0x1a0>
				ret_val =  1;
   80700:	2301      	movs	r3, #1
   80702:	613b      	str	r3, [r7, #16]
		case EPS_TASK_ID:
			eps_fdir_signal = 1;
   80704:	4b47      	ldr	r3, [pc, #284]	; (80824 <errorASSERT+0x2c0>)
   80706:	2201      	movs	r2, #1
   80708:	701a      	strb	r2, [r3, #0]
			while(eps_fdir_signal & timeout--){taskYIELD();}
   8070a:	e001      	b.n	80710 <errorASSERT+0x1ac>
   8070c:	4b42      	ldr	r3, [pc, #264]	; (80818 <errorASSERT+0x2b4>)
   8070e:	4798      	blx	r3
   80710:	4b44      	ldr	r3, [pc, #272]	; (80824 <errorASSERT+0x2c0>)
   80712:	781b      	ldrb	r3, [r3, #0]
   80714:	461a      	mov	r2, r3
   80716:	69bb      	ldr	r3, [r7, #24]
   80718:	1e59      	subs	r1, r3, #1
   8071a:	61b9      	str	r1, [r7, #24]
   8071c:	4013      	ands	r3, r2
   8071e:	2b00      	cmp	r3, #0
   80720:	d1f4      	bne.n	8070c <errorASSERT+0x1a8>
			ret_val = -1;
   80722:	f04f 33ff 	mov.w	r3, #4294967295
   80726:	613b      	str	r3, [r7, #16]
			if(!eps_fdir_signal)
   80728:	4b3e      	ldr	r3, [pc, #248]	; (80824 <errorASSERT+0x2c0>)
   8072a:	781b      	ldrb	r3, [r3, #0]
   8072c:	2b00      	cmp	r3, #0
   8072e:	d101      	bne.n	80734 <errorASSERT+0x1d0>
				ret_val = 1;
   80730:	2301      	movs	r3, #1
   80732:	613b      	str	r3, [r7, #16]
		case PAY_TASK_ID:
			pay_fdir_signal = 1;
   80734:	4b3c      	ldr	r3, [pc, #240]	; (80828 <errorASSERT+0x2c4>)
   80736:	2201      	movs	r2, #1
   80738:	701a      	strb	r2, [r3, #0]
			while(pay_fdir_signal & timeout--){taskYIELD();}
   8073a:	e001      	b.n	80740 <errorASSERT+0x1dc>
   8073c:	4b36      	ldr	r3, [pc, #216]	; (80818 <errorASSERT+0x2b4>)
   8073e:	4798      	blx	r3
   80740:	4b39      	ldr	r3, [pc, #228]	; (80828 <errorASSERT+0x2c4>)
   80742:	781b      	ldrb	r3, [r3, #0]
   80744:	461a      	mov	r2, r3
   80746:	69bb      	ldr	r3, [r7, #24]
   80748:	1e59      	subs	r1, r3, #1
   8074a:	61b9      	str	r1, [r7, #24]
   8074c:	4013      	ands	r3, r2
   8074e:	2b00      	cmp	r3, #0
   80750:	d1f4      	bne.n	8073c <errorASSERT+0x1d8>
			ret_val = -1;
   80752:	f04f 33ff 	mov.w	r3, #4294967295
   80756:	613b      	str	r3, [r7, #16]
			if(!pay_fdir_signal)
   80758:	4b33      	ldr	r3, [pc, #204]	; (80828 <errorASSERT+0x2c4>)
   8075a:	781b      	ldrb	r3, [r3, #0]
   8075c:	2b00      	cmp	r3, #0
   8075e:	d101      	bne.n	80764 <errorASSERT+0x200>
				ret_val = 1;
   80760:	2301      	movs	r3, #1
   80762:	613b      	str	r3, [r7, #16]
		case OBC_PACKET_ROUTER_ID:
			opr_fdir_signal = 1;
   80764:	4b31      	ldr	r3, [pc, #196]	; (8082c <errorASSERT+0x2c8>)
   80766:	2201      	movs	r2, #1
   80768:	701a      	strb	r2, [r3, #0]
			while(opr_fdir_signal & timeout--){taskYIELD();}
   8076a:	e001      	b.n	80770 <errorASSERT+0x20c>
   8076c:	4b2a      	ldr	r3, [pc, #168]	; (80818 <errorASSERT+0x2b4>)
   8076e:	4798      	blx	r3
   80770:	4b2e      	ldr	r3, [pc, #184]	; (8082c <errorASSERT+0x2c8>)
   80772:	781b      	ldrb	r3, [r3, #0]
   80774:	461a      	mov	r2, r3
   80776:	69bb      	ldr	r3, [r7, #24]
   80778:	1e59      	subs	r1, r3, #1
   8077a:	61b9      	str	r1, [r7, #24]
   8077c:	4013      	ands	r3, r2
   8077e:	2b00      	cmp	r3, #0
   80780:	d1f4      	bne.n	8076c <errorASSERT+0x208>
			ret_val = -1;
   80782:	f04f 33ff 	mov.w	r3, #4294967295
   80786:	613b      	str	r3, [r7, #16]
			if(!opr_fdir_signal)
   80788:	4b28      	ldr	r3, [pc, #160]	; (8082c <errorASSERT+0x2c8>)
   8078a:	781b      	ldrb	r3, [r3, #0]
   8078c:	2b00      	cmp	r3, #0
   8078e:	d101      	bne.n	80794 <errorASSERT+0x230>
				ret_val = 1;
   80790:	2301      	movs	r3, #1
   80792:	613b      	str	r3, [r7, #16]
		case SCHEDULING_TASK_ID:
			sched_fdir_signal = 1;
   80794:	4b26      	ldr	r3, [pc, #152]	; (80830 <errorASSERT+0x2cc>)
   80796:	2201      	movs	r2, #1
   80798:	701a      	strb	r2, [r3, #0]
			while(sched_fdir_signal & timeout--){taskYIELD();}
   8079a:	e001      	b.n	807a0 <errorASSERT+0x23c>
   8079c:	4b1e      	ldr	r3, [pc, #120]	; (80818 <errorASSERT+0x2b4>)
   8079e:	4798      	blx	r3
   807a0:	4b23      	ldr	r3, [pc, #140]	; (80830 <errorASSERT+0x2cc>)
   807a2:	781b      	ldrb	r3, [r3, #0]
   807a4:	461a      	mov	r2, r3
   807a6:	69bb      	ldr	r3, [r7, #24]
   807a8:	1e59      	subs	r1, r3, #1
   807aa:	61b9      	str	r1, [r7, #24]
   807ac:	4013      	ands	r3, r2
   807ae:	2b00      	cmp	r3, #0
   807b0:	d1f4      	bne.n	8079c <errorASSERT+0x238>
			ret_val = -1;
   807b2:	f04f 33ff 	mov.w	r3, #4294967295
   807b6:	613b      	str	r3, [r7, #16]
			if(!sched_fdir_signal)
   807b8:	4b1d      	ldr	r3, [pc, #116]	; (80830 <errorASSERT+0x2cc>)
   807ba:	781b      	ldrb	r3, [r3, #0]
   807bc:	2b00      	cmp	r3, #0
   807be:	d101      	bne.n	807c4 <errorASSERT+0x260>
				ret_val = 1;
   807c0:	2301      	movs	r3, #1
   807c2:	613b      	str	r3, [r7, #16]
		case WD_RESET_TASK_ID:
			wdt_fdir_signal = 1;
   807c4:	4b1b      	ldr	r3, [pc, #108]	; (80834 <errorASSERT+0x2d0>)
   807c6:	2201      	movs	r2, #1
   807c8:	701a      	strb	r2, [r3, #0]
			while(wdt_fdir_signal & timeout--){taskYIELD();}
   807ca:	e001      	b.n	807d0 <errorASSERT+0x26c>
   807cc:	4b12      	ldr	r3, [pc, #72]	; (80818 <errorASSERT+0x2b4>)
   807ce:	4798      	blx	r3
   807d0:	4b18      	ldr	r3, [pc, #96]	; (80834 <errorASSERT+0x2d0>)
   807d2:	781b      	ldrb	r3, [r3, #0]
   807d4:	461a      	mov	r2, r3
   807d6:	69bb      	ldr	r3, [r7, #24]
   807d8:	1e59      	subs	r1, r3, #1
   807da:	61b9      	str	r1, [r7, #24]
   807dc:	4013      	ands	r3, r2
   807de:	2b00      	cmp	r3, #0
   807e0:	d1f4      	bne.n	807cc <errorASSERT+0x268>
			ret_val = -1;
   807e2:	f04f 33ff 	mov.w	r3, #4294967295
   807e6:	613b      	str	r3, [r7, #16]
			if(!wdt_fdir_signal)
   807e8:	4b12      	ldr	r3, [pc, #72]	; (80834 <errorASSERT+0x2d0>)
   807ea:	781b      	ldrb	r3, [r3, #0]
   807ec:	2b00      	cmp	r3, #0
   807ee:	d101      	bne.n	807f4 <errorASSERT+0x290>
				ret_val = 1;
   807f0:	2301      	movs	r3, #1
   807f2:	613b      	str	r3, [r7, #16]
		case MEMORY_TASK_ID:
			mem_fdir_signal = 1;
   807f4:	4b10      	ldr	r3, [pc, #64]	; (80838 <errorASSERT+0x2d4>)
   807f6:	2201      	movs	r2, #1
   807f8:	701a      	strb	r2, [r3, #0]
			while(mem_fdir_signal & timeout--){taskYIELD();}
   807fa:	e021      	b.n	80840 <errorASSERT+0x2dc>
   807fc:	000493e0 	.word	0x000493e0
   80800:	2007b43c 	.word	0x2007b43c
   80804:	2007ade8 	.word	0x2007ade8
   80808:	00086dc1 	.word	0x00086dc1
   8080c:	2007b51c 	.word	0x2007b51c
   80810:	00086b01 	.word	0x00086b01
   80814:	2007b3e0 	.word	0x2007b3e0
   80818:	0008645d 	.word	0x0008645d
   8081c:	2007ae10 	.word	0x2007ae10
   80820:	2007ade4 	.word	0x2007ade4
   80824:	2007b398 	.word	0x2007b398
   80828:	2007b544 	.word	0x2007b544
   8082c:	2007ae18 	.word	0x2007ae18
   80830:	2007b514 	.word	0x2007b514
   80834:	2007b388 	.word	0x2007b388
   80838:	2007adfc 	.word	0x2007adfc
   8083c:	4b12      	ldr	r3, [pc, #72]	; (80888 <errorASSERT+0x324>)
   8083e:	4798      	blx	r3
   80840:	4b12      	ldr	r3, [pc, #72]	; (8088c <errorASSERT+0x328>)
   80842:	781b      	ldrb	r3, [r3, #0]
   80844:	461a      	mov	r2, r3
   80846:	69bb      	ldr	r3, [r7, #24]
   80848:	1e59      	subs	r1, r3, #1
   8084a:	61b9      	str	r1, [r7, #24]
   8084c:	4013      	ands	r3, r2
   8084e:	2b00      	cmp	r3, #0
   80850:	d1f4      	bne.n	8083c <errorASSERT+0x2d8>
			ret_val = -1;
   80852:	f04f 33ff 	mov.w	r3, #4294967295
   80856:	613b      	str	r3, [r7, #16]
			if(!mem_fdir_signal)
   80858:	4b0c      	ldr	r3, [pc, #48]	; (8088c <errorASSERT+0x328>)
   8085a:	781b      	ldrb	r3, [r3, #0]
   8085c:	2b00      	cmp	r3, #0
   8085e:	d101      	bne.n	80864 <errorASSERT+0x300>
				ret_val = 1;
   80860:	2301      	movs	r3, #1
   80862:	613b      	str	r3, [r7, #16]
		default:
			ret_val = -1;
   80864:	f04f 33ff 	mov.w	r3, #4294967295
   80868:	613b      	str	r3, [r7, #16]
	}
	if(mutex)
   8086a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   8086c:	2b00      	cmp	r3, #0
   8086e:	d005      	beq.n	8087c <errorASSERT+0x318>
		xSemaphoreTake(mutex, wait_time);
   80870:	6b38      	ldr	r0, [r7, #48]	; 0x30
   80872:	2100      	movs	r1, #0
   80874:	697a      	ldr	r2, [r7, #20]
   80876:	2300      	movs	r3, #0
   80878:	4c05      	ldr	r4, [pc, #20]	; (80890 <errorASSERT+0x32c>)
   8087a:	47a0      	blx	r4
	return ret_val;
   8087c:	693b      	ldr	r3, [r7, #16]
}
   8087e:	4618      	mov	r0, r3
   80880:	3724      	adds	r7, #36	; 0x24
   80882:	46bd      	mov	sp, r7
   80884:	bd90      	pop	{r4, r7, pc}
   80886:	bf00      	nop
   80888:	0008645d 	.word	0x0008645d
   8088c:	2007adfc 	.word	0x2007adfc
   80890:	00086dc1 	.word	0x00086dc1

00080894 <errorREPORT>:
/* @Note: This function does not halt regular operation, nor is the		*/
/* error fixed at this time.											*/
/* @Note: *data should point to an array of at least 147 bytes.			*/
/************************************************************************/
int errorREPORT(uint8_t task, uint8_t code, uint32_t error, uint8_t* data)
{
   80894:	b590      	push	{r4, r7, lr}
   80896:	b087      	sub	sp, #28
   80898:	af00      	add	r7, sp, #0
   8089a:	60ba      	str	r2, [r7, #8]
   8089c:	607b      	str	r3, [r7, #4]
   8089e:	4603      	mov	r3, r0
   808a0:	73fb      	strb	r3, [r7, #15]
   808a2:	460b      	mov	r3, r1
   808a4:	73bb      	strb	r3, [r7, #14]
	uint8_t i;
	TickType_t wait_time = 5 * 60 * 1000;
   808a6:	4b35      	ldr	r3, [pc, #212]	; (8097c <errorREPORT+0xe8>)
   808a8:	613b      	str	r3, [r7, #16]
	for(i = 0; i < 147; i++)
   808aa:	2300      	movs	r3, #0
   808ac:	75fb      	strb	r3, [r7, #23]
   808ae:	e009      	b.n	808c4 <errorREPORT+0x30>
	{
		low_error_array[i] = *(data + i);	// Load the data into the high_error_array.
   808b0:	7dfb      	ldrb	r3, [r7, #23]
   808b2:	7dfa      	ldrb	r2, [r7, #23]
   808b4:	6879      	ldr	r1, [r7, #4]
   808b6:	440a      	add	r2, r1
   808b8:	7811      	ldrb	r1, [r2, #0]
   808ba:	4a31      	ldr	r2, [pc, #196]	; (80980 <errorREPORT+0xec>)
   808bc:	54d1      	strb	r1, [r2, r3]
/************************************************************************/
int errorREPORT(uint8_t task, uint8_t code, uint32_t error, uint8_t* data)
{
	uint8_t i;
	TickType_t wait_time = 5 * 60 * 1000;
	for(i = 0; i < 147; i++)
   808be:	7dfb      	ldrb	r3, [r7, #23]
   808c0:	3301      	adds	r3, #1
   808c2:	75fb      	strb	r3, [r7, #23]
   808c4:	7dfb      	ldrb	r3, [r7, #23]
   808c6:	2b92      	cmp	r3, #146	; 0x92
   808c8:	d9f2      	bls.n	808b0 <errorREPORT+0x1c>
	{
		low_error_array[i] = *(data + i);	// Load the data into the high_error_array.
	}
	low_error_array[151] = (uint8_t)((error & 0xFF000000) >> 24);
   808ca:	68bb      	ldr	r3, [r7, #8]
   808cc:	0e1b      	lsrs	r3, r3, #24
   808ce:	b2da      	uxtb	r2, r3
   808d0:	4b2b      	ldr	r3, [pc, #172]	; (80980 <errorREPORT+0xec>)
   808d2:	f883 2097 	strb.w	r2, [r3, #151]	; 0x97
	low_error_array[150] = (uint8_t)((error & 0x00FF0000) >> 16);
   808d6:	68bb      	ldr	r3, [r7, #8]
   808d8:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   808dc:	0c1b      	lsrs	r3, r3, #16
   808de:	b2da      	uxtb	r2, r3
   808e0:	4b27      	ldr	r3, [pc, #156]	; (80980 <errorREPORT+0xec>)
   808e2:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
	low_error_array[149] = (uint8_t)((error & 0x0000FF00) > 8);
   808e6:	68bb      	ldr	r3, [r7, #8]
   808e8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   808ec:	2b08      	cmp	r3, #8
   808ee:	bf94      	ite	ls
   808f0:	2300      	movls	r3, #0
   808f2:	2301      	movhi	r3, #1
   808f4:	b2db      	uxtb	r3, r3
   808f6:	461a      	mov	r2, r3
   808f8:	4b21      	ldr	r3, [pc, #132]	; (80980 <errorREPORT+0xec>)
   808fa:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
	low_error_array[148] = (uint8_t)(error & 0x000000FF);
   808fe:	68bb      	ldr	r3, [r7, #8]
   80900:	b2da      	uxtb	r2, r3
   80902:	4b1f      	ldr	r3, [pc, #124]	; (80980 <errorREPORT+0xec>)
   80904:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
	low_error_array[147] = task;
   80908:	4b1d      	ldr	r3, [pc, #116]	; (80980 <errorREPORT+0xec>)
   8090a:	7bfa      	ldrb	r2, [r7, #15]
   8090c:	f883 2093 	strb.w	r2, [r3, #147]	; 0x93
	low_error_array[146] = code;
   80910:	4b1b      	ldr	r3, [pc, #108]	; (80980 <errorREPORT+0xec>)
   80912:	7bba      	ldrb	r2, [r7, #14]
   80914:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
	if (xSemaphoreTake(Lowsev_Mutex, wait_time) == pdTRUE)		// Attempt to acquire Mutex, block for max 5 minutes.
   80918:	4b1a      	ldr	r3, [pc, #104]	; (80984 <errorREPORT+0xf0>)
   8091a:	681b      	ldr	r3, [r3, #0]
   8091c:	4618      	mov	r0, r3
   8091e:	2100      	movs	r1, #0
   80920:	693a      	ldr	r2, [r7, #16]
   80922:	2300      	movs	r3, #0
   80924:	4c18      	ldr	r4, [pc, #96]	; (80988 <errorREPORT+0xf4>)
   80926:	47a0      	blx	r4
   80928:	4603      	mov	r3, r0
   8092a:	2b01      	cmp	r3, #1
   8092c:	d11f      	bne.n	8096e <errorREPORT+0xda>
	{
		if( xQueueSendToBack(low_sev_to_fdir_fifo, low_error_array, wait_time) != pdTRUE)
   8092e:	4b17      	ldr	r3, [pc, #92]	; (8098c <errorREPORT+0xf8>)
   80930:	681b      	ldr	r3, [r3, #0]
   80932:	4618      	mov	r0, r3
   80934:	4912      	ldr	r1, [pc, #72]	; (80980 <errorREPORT+0xec>)
   80936:	693a      	ldr	r2, [r7, #16]
   80938:	2300      	movs	r3, #0
   8093a:	4c15      	ldr	r4, [pc, #84]	; (80990 <errorREPORT+0xfc>)
   8093c:	47a0      	blx	r4
   8093e:	4603      	mov	r3, r0
   80940:	2b01      	cmp	r3, #1
   80942:	d00a      	beq.n	8095a <errorREPORT+0xc6>
		{
			xSemaphoreGive(Lowsev_Mutex);
   80944:	4b0f      	ldr	r3, [pc, #60]	; (80984 <errorREPORT+0xf0>)
   80946:	681b      	ldr	r3, [r3, #0]
   80948:	4618      	mov	r0, r3
   8094a:	2100      	movs	r1, #0
   8094c:	2200      	movs	r2, #0
   8094e:	2300      	movs	r3, #0
   80950:	4c0f      	ldr	r4, [pc, #60]	; (80990 <errorREPORT+0xfc>)
   80952:	47a0      	blx	r4
			return -1;
   80954:	f04f 33ff 	mov.w	r3, #4294967295
   80958:	e00b      	b.n	80972 <errorREPORT+0xde>
		}
		xSemaphoreGive(Lowsev_Mutex);
   8095a:	4b0a      	ldr	r3, [pc, #40]	; (80984 <errorREPORT+0xf0>)
   8095c:	681b      	ldr	r3, [r3, #0]
   8095e:	4618      	mov	r0, r3
   80960:	2100      	movs	r1, #0
   80962:	2200      	movs	r2, #0
   80964:	2300      	movs	r3, #0
   80966:	4c0a      	ldr	r4, [pc, #40]	; (80990 <errorREPORT+0xfc>)
   80968:	47a0      	blx	r4
		return 1;
   8096a:	2301      	movs	r3, #1
   8096c:	e001      	b.n	80972 <errorREPORT+0xde>
	}
	else
	return -1;
   8096e:	f04f 33ff 	mov.w	r3, #4294967295
}
   80972:	4618      	mov	r0, r3
   80974:	371c      	adds	r7, #28
   80976:	46bd      	mov	sp, r7
   80978:	bd90      	pop	{r4, r7, pc}
   8097a:	bf00      	nop
   8097c:	000493e0 	.word	0x000493e0
   80980:	2007ae58 	.word	0x2007ae58
   80984:	2007b4f0 	.word	0x2007b4f0
   80988:	00086dc1 	.word	0x00086dc1
   8098c:	2007b54c 	.word	0x2007b54c
   80990:	00086b01 	.word	0x00086b01

00080994 <xQueueSendToBackTask>:
/* any FIFO errors                                                      */
/* @Note: For use with FIFO to/from OPR									*/
/************************************************************************/
// direction: 1 = TO OPR, 0 = FROM OPR
BaseType_t xQueueSendToBackTask(uint8_t task, uint8_t direction, QueueHandle_t fifo, uint8_t *itemToQueue, TickType_t ticks)
{
   80994:	b480      	push	{r7}
   80996:	b087      	sub	sp, #28
   80998:	af00      	add	r7, sp, #0
   8099a:	60ba      	str	r2, [r7, #8]
   8099c:	607b      	str	r3, [r7, #4]
   8099e:	4603      	mov	r3, r0
   809a0:	73fb      	strb	r3, [r7, #15]
   809a2:	460b      	mov	r3, r1
   809a4:	73bb      	strb	r3, [r7, #14]
	uint8_t attempts = 0, error = 0;
   809a6:	2300      	movs	r3, #0
   809a8:	75fb      	strb	r3, [r7, #23]
   809aa:	2300      	movs	r3, #0
   809ac:	75bb      	strb	r3, [r7, #22]
	switch(task)
   809ae:	7bfb      	ldrb	r3, [r7, #15]
   809b0:	3b04      	subs	r3, #4
   809b2:	2b0a      	cmp	r3, #10
   809b4:	d822      	bhi.n	809fc <xQueueSendToBackTask+0x68>
   809b6:	a201      	add	r2, pc, #4	; (adr r2, 809bc <xQueueSendToBackTask+0x28>)
   809b8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   809bc:	000809e9 	.word	0x000809e9
   809c0:	000809fd 	.word	0x000809fd
   809c4:	000809f1 	.word	0x000809f1
   809c8:	000809fd 	.word	0x000809fd
   809cc:	000809f9 	.word	0x000809f9
   809d0:	000809fd 	.word	0x000809fd
   809d4:	000809fd 	.word	0x000809fd
   809d8:	000809ed 	.word	0x000809ed
   809dc:	000809fd 	.word	0x000809fd
   809e0:	000809fd 	.word	0x000809fd
   809e4:	000809f5 	.word	0x000809f5
	{
		case HK_TASK_ID:
		error = HK_FIFO_RW_ERROR;
   809e8:	2306      	movs	r3, #6
   809ea:	75bb      	strb	r3, [r7, #22]
		case SCHEDULING_TASK_ID:
		error = SCHED_FIFO_RW_ERROR;
   809ec:	2305      	movs	r3, #5
   809ee:	75bb      	strb	r3, [r7, #22]
		case TIME_TASK_ID:
		error = TM_FIFO_RW_ERROR;
   809f0:	2309      	movs	r3, #9
   809f2:	75bb      	strb	r3, [r7, #22]
		case MEMORY_TASK_ID:
		error = MEM_FIFO_RW_ERROR;
   809f4:	2316      	movs	r3, #22
   809f6:	75bb      	strb	r3, [r7, #22]
		case EPS_TASK_ID:
		error = EPS_FIFO_W_ERROR;
   809f8:	2321      	movs	r3, #33	; 0x21
   809fa:	75bb      	strb	r3, [r7, #22]
		default:
		return pdFAIL;
   809fc:	2300      	movs	r3, #0
		attempts++;
	}
	if (attempts == 3)
	errorREPORT(task, direction, error, itemToQueue);
	return pdPASS;
}
   809fe:	4618      	mov	r0, r3
   80a00:	371c      	adds	r7, #28
   80a02:	46bd      	mov	sp, r7
   80a04:	f85d 7b04 	ldr.w	r7, [sp], #4
   80a08:	4770      	bx	lr
   80a0a:	bf00      	nop

00080a0c <obc_packet_router>:
/************************************************************************/
/* OBC_PACKET_ROUTER (Function)											*/
/* @Purpose: This function is used to create the obc packet router task	*/
/************************************************************************/
TaskHandle_t obc_packet_router( void )
{
   80a0c:	b590      	push	{r4, r7, lr}
   80a0e:	b087      	sub	sp, #28
   80a10:	af04      	add	r7, sp, #16
		/* Start the two tasks as described in the comments at the top of this
		file. */
		TaskHandle_t temp_HANDLE = 0;
   80a12:	2300      	movs	r3, #0
   80a14:	607b      	str	r3, [r7, #4]
		xTaskCreate( prvOBCPacketRouterTask,					/* The function that implements the task. */
   80a16:	2302      	movs	r3, #2
   80a18:	9300      	str	r3, [sp, #0]
   80a1a:	1d3b      	adds	r3, r7, #4
   80a1c:	9301      	str	r3, [sp, #4]
   80a1e:	2300      	movs	r3, #0
   80a20:	9302      	str	r3, [sp, #8]
   80a22:	2300      	movs	r3, #0
   80a24:	9303      	str	r3, [sp, #12]
   80a26:	4806      	ldr	r0, [pc, #24]	; (80a40 <obc_packet_router+0x34>)
   80a28:	4906      	ldr	r1, [pc, #24]	; (80a44 <obc_packet_router+0x38>)
   80a2a:	f240 228a 	movw	r2, #650	; 0x28a
   80a2e:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   80a32:	4c05      	ldr	r4, [pc, #20]	; (80a48 <obc_packet_router+0x3c>)
   80a34:	47a0      	blx	r4
					"ON", 								/* The text name assigned to the task - for debug only as it is not used by the kernel. */
					configMINIMAL_STACK_SIZE * 5, 			/* The size of the stack to allocate to the task. */
					( void * ) OBC_PACKET_ROUTER_PARAMETER, 			/* The parameter passed to the task - just to check the functionality. */
					OBC_PACKET_ROUTER_PRIORITY, 			/* The priority assigned to the task. */
					&temp_HANDLE );								/* The task handle is not required, so NULL is passed. */
	return temp_HANDLE;
   80a36:	687b      	ldr	r3, [r7, #4]
}
   80a38:	4618      	mov	r0, r3
   80a3a:	370c      	adds	r7, #12
   80a3c:	46bd      	mov	sp, r7
   80a3e:	bd90      	pop	{r4, r7, pc}
   80a40:	00080a4d 	.word	0x00080a4d
   80a44:	0008b02c 	.word	0x0008b02c
   80a48:	00087335 	.word	0x00087335

00080a4c <prvOBCPacketRouterTask>:
/* required immediate command or it will send a scheduling request to	*/
/* the scheduling process. This task can also receive telemetry requests*/
/* from other tasks which come in FIFOs which have yet to be defined.	*/
/************************************************************************/
static void prvOBCPacketRouterTask( void *pvParameters )
{
   80a4c:	b590      	push	{r4, r7, lr}
   80a4e:	b085      	sub	sp, #20
   80a50:	af00      	add	r7, sp, #0
   80a52:	6078      	str	r0, [r7, #4]
	configASSERT( ( ( unsigned long ) pvParameters ) == OBC_PACKET_ROUTER_PARAMETER );
   80a54:	687a      	ldr	r2, [r7, #4]
   80a56:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   80a5a:	429a      	cmp	r2, r3
   80a5c:	d002      	beq.n	80a64 <prvOBCPacketRouterTask+0x18>
   80a5e:	4b67      	ldr	r3, [pc, #412]	; (80bfc <prvOBCPacketRouterTask+0x1b0>)
   80a60:	4798      	blx	r3
   80a62:	e7fe      	b.n	80a62 <prvOBCPacketRouterTask+0x16>

	int status;
	/* Initialize Global variables and flags */
	current_tc_fullf = 0;
   80a64:	4b66      	ldr	r3, [pc, #408]	; (80c00 <prvOBCPacketRouterTask+0x1b4>)
   80a66:	2200      	movs	r2, #0
   80a68:	701a      	strb	r2, [r3, #0]
	tc_sequence_count = 0;
   80a6a:	4b66      	ldr	r3, [pc, #408]	; (80c04 <prvOBCPacketRouterTask+0x1b8>)
   80a6c:	2200      	movs	r2, #0
   80a6e:	701a      	strb	r2, [r3, #0]
	new_tc_msg_high = 0;
   80a70:	4b65      	ldr	r3, [pc, #404]	; (80c08 <prvOBCPacketRouterTask+0x1bc>)
   80a72:	2200      	movs	r2, #0
   80a74:	601a      	str	r2, [r3, #0]
	new_tc_msg_low = 0;
   80a76:	4b65      	ldr	r3, [pc, #404]	; (80c0c <prvOBCPacketRouterTask+0x1c0>)
   80a78:	2200      	movs	r2, #0
   80a7a:	601a      	str	r2, [r3, #0]
	tc_verify_success_count = 0;
   80a7c:	4b64      	ldr	r3, [pc, #400]	; (80c10 <prvOBCPacketRouterTask+0x1c4>)
   80a7e:	2200      	movs	r2, #0
   80a80:	701a      	strb	r2, [r3, #0]
	hk_telem_count = 0;
   80a82:	4b64      	ldr	r3, [pc, #400]	; (80c14 <prvOBCPacketRouterTask+0x1c8>)
   80a84:	2200      	movs	r2, #0
   80a86:	701a      	strb	r2, [r3, #0]
	hk_def_report_count = 0;
   80a88:	4b63      	ldr	r3, [pc, #396]	; (80c18 <prvOBCPacketRouterTask+0x1cc>)
   80a8a:	2200      	movs	r2, #0
   80a8c:	701a      	strb	r2, [r3, #0]
	diag_telem_count = 0;
   80a8e:	4b63      	ldr	r3, [pc, #396]	; (80c1c <prvOBCPacketRouterTask+0x1d0>)
   80a90:	2200      	movs	r2, #0
   80a92:	701a      	strb	r2, [r3, #0]
	diag_def_report_count = 0;
   80a94:	4b62      	ldr	r3, [pc, #392]	; (80c20 <prvOBCPacketRouterTask+0x1d4>)
   80a96:	2200      	movs	r2, #0
   80a98:	701a      	strb	r2, [r3, #0]
	tc_verify_fail_count = 0;
   80a9a:	4b62      	ldr	r3, [pc, #392]	; (80c24 <prvOBCPacketRouterTask+0x1d8>)
   80a9c:	2200      	movs	r2, #0
   80a9e:	701a      	strb	r2, [r3, #0]
	tc_exec_success_count = 0;
   80aa0:	4b61      	ldr	r3, [pc, #388]	; (80c28 <prvOBCPacketRouterTask+0x1dc>)
   80aa2:	2200      	movs	r2, #0
   80aa4:	701a      	strb	r2, [r3, #0]
	tc_exec_fail_count = 0;
   80aa6:	4b61      	ldr	r3, [pc, #388]	; (80c2c <prvOBCPacketRouterTask+0x1e0>)
   80aa8:	2200      	movs	r2, #0
   80aaa:	701a      	strb	r2, [r3, #0]
	time_report_count = 0;
   80aac:	4b60      	ldr	r3, [pc, #384]	; (80c30 <prvOBCPacketRouterTask+0x1e4>)
   80aae:	2200      	movs	r2, #0
   80ab0:	701a      	strb	r2, [r3, #0]
	mem_dump_count = 0;
   80ab2:	4b60      	ldr	r3, [pc, #384]	; (80c34 <prvOBCPacketRouterTask+0x1e8>)
   80ab4:	2200      	movs	r2, #0
   80ab6:	701a      	strb	r2, [r3, #0]
	event_report_count = 0;
   80ab8:	4b5f      	ldr	r3, [pc, #380]	; (80c38 <prvOBCPacketRouterTask+0x1ec>)
   80aba:	2200      	movs	r2, #0
   80abc:	701a      	strb	r2, [r3, #0]
	sched_report_count = 0;
   80abe:	4b5f      	ldr	r3, [pc, #380]	; (80c3c <prvOBCPacketRouterTask+0x1f0>)
   80ac0:	2200      	movs	r2, #0
   80ac2:	701a      	strb	r2, [r3, #0]
	sched_command_count = 0;
   80ac4:	4b5e      	ldr	r3, [pc, #376]	; (80c40 <prvOBCPacketRouterTask+0x1f4>)
   80ac6:	2200      	movs	r2, #0
   80ac8:	701a      	strb	r2, [r3, #0]
	mem_check_count = 0;
   80aca:	4b5e      	ldr	r3, [pc, #376]	; (80c44 <prvOBCPacketRouterTask+0x1f8>)
   80acc:	2200      	movs	r2, #0
   80ace:	701a      	strb	r2, [r3, #0]
	sin_par_rep_count = 0;
   80ad0:	4b5d      	ldr	r3, [pc, #372]	; (80c48 <prvOBCPacketRouterTask+0x1fc>)
   80ad2:	2200      	movs	r2, #0
   80ad4:	701a      	strb	r2, [r3, #0]
	science_packet_count = 0;
   80ad6:	4b5d      	ldr	r3, [pc, #372]	; (80c4c <prvOBCPacketRouterTask+0x200>)
   80ad8:	2200      	movs	r2, #0
   80ada:	701a      	strb	r2, [r3, #0]
	clear_current_data();
   80adc:	4b5c      	ldr	r3, [pc, #368]	; (80c50 <prvOBCPacketRouterTask+0x204>)
   80ade:	4798      	blx	r3
	clear_current_command();
   80ae0:	4b5c      	ldr	r3, [pc, #368]	; (80c54 <prvOBCPacketRouterTask+0x208>)
   80ae2:	4798      	blx	r3
		//CURRENT_TC_PACKET = TC_BASE + 12;
		//task_spimem_write(OBC_PACKET_ROUTER_ID, TC_BASE + 8, CURRENT_TC_PACKET, 4);
	//}

	/* Initialize variable used in PUS Packets */
	version = 0;		// First 3 bits of the packet ID. (0 is default)
   80ae4:	4b5c      	ldr	r3, [pc, #368]	; (80c58 <prvOBCPacketRouterTask+0x20c>)
   80ae6:	2200      	movs	r2, #0
   80ae8:	701a      	strb	r2, [r3, #0]
	data_header = 1;	// Include the data field header in the PUS packet.
   80aea:	4b5c      	ldr	r3, [pc, #368]	; (80c5c <prvOBCPacketRouterTask+0x210>)
   80aec:	2201      	movs	r2, #1
   80aee:	701a      	strb	r2, [r3, #0]
	low_received = 0, high_received = 0;
   80af0:	4b5b      	ldr	r3, [pc, #364]	; (80c60 <prvOBCPacketRouterTask+0x214>)
   80af2:	2200      	movs	r2, #0
   80af4:	601a      	str	r2, [r3, #0]
   80af6:	4b5b      	ldr	r3, [pc, #364]	; (80c64 <prvOBCPacketRouterTask+0x218>)
   80af8:	2200      	movs	r2, #0
   80afa:	601a      	str	r2, [r3, #0]
	new_tc_msg_high = 0, new_tc_msg_low = 0;
   80afc:	4b42      	ldr	r3, [pc, #264]	; (80c08 <prvOBCPacketRouterTask+0x1bc>)
   80afe:	2200      	movs	r2, #0
   80b00:	601a      	str	r2, [r3, #0]
   80b02:	4b42      	ldr	r3, [pc, #264]	; (80c0c <prvOBCPacketRouterTask+0x1c0>)
   80b04:	2200      	movs	r2, #0
   80b06:	601a      	str	r2, [r3, #0]
	/* @non-terminating@ */	
	for( ;; )
	{
		if(!low_received)
   80b08:	4b55      	ldr	r3, [pc, #340]	; (80c60 <prvOBCPacketRouterTask+0x214>)
   80b0a:	681b      	ldr	r3, [r3, #0]
   80b0c:	2b00      	cmp	r3, #0
   80b0e:	d10f      	bne.n	80b30 <prvOBCPacketRouterTask+0xe4>
		{
			if(xQueueReceive(tc_msg_fifo, &new_tc_msg_low, xTimeToWait) == pdTRUE)
   80b10:	4b55      	ldr	r3, [pc, #340]	; (80c68 <prvOBCPacketRouterTask+0x21c>)
   80b12:	681a      	ldr	r2, [r3, #0]
   80b14:	4b55      	ldr	r3, [pc, #340]	; (80c6c <prvOBCPacketRouterTask+0x220>)
   80b16:	681b      	ldr	r3, [r3, #0]
   80b18:	4610      	mov	r0, r2
   80b1a:	493c      	ldr	r1, [pc, #240]	; (80c0c <prvOBCPacketRouterTask+0x1c0>)
   80b1c:	461a      	mov	r2, r3
   80b1e:	2300      	movs	r3, #0
   80b20:	4c53      	ldr	r4, [pc, #332]	; (80c70 <prvOBCPacketRouterTask+0x224>)
   80b22:	47a0      	blx	r4
   80b24:	4603      	mov	r3, r0
   80b26:	2b01      	cmp	r3, #1
   80b28:	d102      	bne.n	80b30 <prvOBCPacketRouterTask+0xe4>
				low_received = 1;
   80b2a:	4b4d      	ldr	r3, [pc, #308]	; (80c60 <prvOBCPacketRouterTask+0x214>)
   80b2c:	2201      	movs	r2, #1
   80b2e:	601a      	str	r2, [r3, #0]
		}
		if(low_received & !high_received)
   80b30:	4b4c      	ldr	r3, [pc, #304]	; (80c64 <prvOBCPacketRouterTask+0x218>)
   80b32:	681b      	ldr	r3, [r3, #0]
   80b34:	2b00      	cmp	r3, #0
   80b36:	bf14      	ite	ne
   80b38:	2300      	movne	r3, #0
   80b3a:	2301      	moveq	r3, #1
   80b3c:	b2db      	uxtb	r3, r3
   80b3e:	461a      	mov	r2, r3
   80b40:	4b47      	ldr	r3, [pc, #284]	; (80c60 <prvOBCPacketRouterTask+0x214>)
   80b42:	681b      	ldr	r3, [r3, #0]
   80b44:	4013      	ands	r3, r2
   80b46:	2b00      	cmp	r3, #0
   80b48:	d00f      	beq.n	80b6a <prvOBCPacketRouterTask+0x11e>
		{
			if(xQueueReceive(tc_msg_fifo, &new_tc_msg_high, xTimeToWait) == pdTRUE)
   80b4a:	4b47      	ldr	r3, [pc, #284]	; (80c68 <prvOBCPacketRouterTask+0x21c>)
   80b4c:	681a      	ldr	r2, [r3, #0]
   80b4e:	4b47      	ldr	r3, [pc, #284]	; (80c6c <prvOBCPacketRouterTask+0x220>)
   80b50:	681b      	ldr	r3, [r3, #0]
   80b52:	4610      	mov	r0, r2
   80b54:	492c      	ldr	r1, [pc, #176]	; (80c08 <prvOBCPacketRouterTask+0x1bc>)
   80b56:	461a      	mov	r2, r3
   80b58:	2300      	movs	r3, #0
   80b5a:	4c45      	ldr	r4, [pc, #276]	; (80c70 <prvOBCPacketRouterTask+0x224>)
   80b5c:	47a0      	blx	r4
   80b5e:	4603      	mov	r3, r0
   80b60:	2b01      	cmp	r3, #1
   80b62:	d102      	bne.n	80b6a <prvOBCPacketRouterTask+0x11e>
				high_received = 1;
   80b64:	4b3f      	ldr	r3, [pc, #252]	; (80c64 <prvOBCPacketRouterTask+0x218>)
   80b66:	2201      	movs	r2, #1
   80b68:	601a      	str	r2, [r3, #0]
		}
		if(high_received)		// Block on the TC_MSG_FIFO for a maximum of 10 ticks.
   80b6a:	4b3e      	ldr	r3, [pc, #248]	; (80c64 <prvOBCPacketRouterTask+0x218>)
   80b6c:	681b      	ldr	r3, [r3, #0]
   80b6e:	2b00      	cmp	r3, #0
   80b70:	d002      	beq.n	80b78 <prvOBCPacketRouterTask+0x12c>
		{
			status = receive_tc_msg();					// FAILURE_RECOVERY if status == -1.
   80b72:	4b40      	ldr	r3, [pc, #256]	; (80c74 <prvOBCPacketRouterTask+0x228>)
   80b74:	4798      	blx	r3
   80b76:	60f8      	str	r0, [r7, #12]
			//if (NEXT_TC_PACKET > (TC_BASE + 0x20000))
				//NEXT_TC_PACKET = TC_BASE + 12;
			//spimem_write(TC_BASE + 4, &NEXT_TC_PACKET, 4);	// Update the position of the next packet		
			//decode_telecommand();
		//}
		if(!receiving_tcf)
   80b78:	4b3f      	ldr	r3, [pc, #252]	; (80c78 <prvOBCPacketRouterTask+0x22c>)
   80b7a:	781b      	ldrb	r3, [r3, #0]
   80b7c:	2b00      	cmp	r3, #0
   80b7e:	d13c      	bne.n	80bfa <prvOBCPacketRouterTask+0x1ae>
		{
			if(xQueueReceive(tc_buffer, tc_to_decode, (TickType_t)1) == pdTRUE)
   80b80:	4b3e      	ldr	r3, [pc, #248]	; (80c7c <prvOBCPacketRouterTask+0x230>)
   80b82:	681b      	ldr	r3, [r3, #0]
   80b84:	4618      	mov	r0, r3
   80b86:	493e      	ldr	r1, [pc, #248]	; (80c80 <prvOBCPacketRouterTask+0x234>)
   80b88:	2201      	movs	r2, #1
   80b8a:	2300      	movs	r3, #0
   80b8c:	4c38      	ldr	r4, [pc, #224]	; (80c70 <prvOBCPacketRouterTask+0x224>)
   80b8e:	47a0      	blx	r4
   80b90:	4603      	mov	r3, r0
   80b92:	2b01      	cmp	r3, #1
   80b94:	d101      	bne.n	80b9a <prvOBCPacketRouterTask+0x14e>
				decode_telecommand();
   80b96:	4b3b      	ldr	r3, [pc, #236]	; (80c84 <prvOBCPacketRouterTask+0x238>)
   80b98:	4798      	blx	r3

			if (tm_down_fullf)
   80b9a:	4b3b      	ldr	r3, [pc, #236]	; (80c88 <prvOBCPacketRouterTask+0x23c>)
   80b9c:	781b      	ldrb	r3, [r3, #0]
   80b9e:	2b00      	cmp	r3, #0
   80ba0:	d006      	beq.n	80bb0 <prvOBCPacketRouterTask+0x164>
			{
				send_pus_packet_tm(tm_to_downlink[150]);		// FAILURE_RECOVERY			
   80ba2:	4b3a      	ldr	r3, [pc, #232]	; (80c8c <prvOBCPacketRouterTask+0x240>)
   80ba4:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
   80ba8:	4618      	mov	r0, r3
   80baa:	4b39      	ldr	r3, [pc, #228]	; (80c90 <prvOBCPacketRouterTask+0x244>)
   80bac:	4798      	blx	r3
   80bae:	e013      	b.n	80bd8 <prvOBCPacketRouterTask+0x18c>
			}
			else if(xQueueReceive(tm_buffer, tm_to_downlink, (TickType_t)1) == pdTRUE)
   80bb0:	4b38      	ldr	r3, [pc, #224]	; (80c94 <prvOBCPacketRouterTask+0x248>)
   80bb2:	681b      	ldr	r3, [r3, #0]
   80bb4:	4618      	mov	r0, r3
   80bb6:	4935      	ldr	r1, [pc, #212]	; (80c8c <prvOBCPacketRouterTask+0x240>)
   80bb8:	2201      	movs	r2, #1
   80bba:	2300      	movs	r3, #0
   80bbc:	4c2c      	ldr	r4, [pc, #176]	; (80c70 <prvOBCPacketRouterTask+0x224>)
   80bbe:	47a0      	blx	r4
   80bc0:	4603      	mov	r3, r0
   80bc2:	2b01      	cmp	r3, #1
   80bc4:	d108      	bne.n	80bd8 <prvOBCPacketRouterTask+0x18c>
			{
				tm_down_fullf = 1;
   80bc6:	4b30      	ldr	r3, [pc, #192]	; (80c88 <prvOBCPacketRouterTask+0x23c>)
   80bc8:	2201      	movs	r2, #1
   80bca:	701a      	strb	r2, [r3, #0]
				send_pus_packet_tm(tm_to_downlink[150]);		// FAILURE_RECOVERY
   80bcc:	4b2f      	ldr	r3, [pc, #188]	; (80c8c <prvOBCPacketRouterTask+0x240>)
   80bce:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
   80bd2:	4618      	mov	r0, r3
   80bd4:	4b2e      	ldr	r3, [pc, #184]	; (80c90 <prvOBCPacketRouterTask+0x244>)
   80bd6:	4798      	blx	r3
					//NEXT_TM_PACKET = TM_BASE + 12;
				//task_spimem_write(OBC_PACKET_ROUTER_ID, TM_BASE + 4, &NEXT_TM_PACKET, 4);	// Update the position of the next packet 
				//tm_down_fullf = 1;
				//send_pus_packet_tm(tm_to_downlink[150]);		// FAILURE_RECOVERY
			//}	
			exec_commands();
   80bd8:	4b2f      	ldr	r3, [pc, #188]	; (80c98 <prvOBCPacketRouterTask+0x24c>)
   80bda:	4798      	blx	r3
			xTimeToWait = 5; // Sleep task for 5 ticks.
   80bdc:	4b23      	ldr	r3, [pc, #140]	; (80c6c <prvOBCPacketRouterTask+0x220>)
   80bde:	2205      	movs	r2, #5
   80be0:	601a      	str	r2, [r3, #0]
			xLastWakeTime = xTaskGetTickCount();						// Delay for 10 ticks.
   80be2:	4b2e      	ldr	r3, [pc, #184]	; (80c9c <prvOBCPacketRouterTask+0x250>)
   80be4:	4798      	blx	r3
   80be6:	4602      	mov	r2, r0
   80be8:	4b2d      	ldr	r3, [pc, #180]	; (80ca0 <prvOBCPacketRouterTask+0x254>)
   80bea:	601a      	str	r2, [r3, #0]
			vTaskDelayUntil(&xLastWakeTime, xTimeToWait);
   80bec:	4b1f      	ldr	r3, [pc, #124]	; (80c6c <prvOBCPacketRouterTask+0x220>)
   80bee:	681b      	ldr	r3, [r3, #0]
   80bf0:	482b      	ldr	r0, [pc, #172]	; (80ca0 <prvOBCPacketRouterTask+0x254>)
   80bf2:	4619      	mov	r1, r3
   80bf4:	4b2b      	ldr	r3, [pc, #172]	; (80ca4 <prvOBCPacketRouterTask+0x258>)
   80bf6:	4798      	blx	r3
		}
	}
   80bf8:	e786      	b.n	80b08 <prvOBCPacketRouterTask+0xbc>
   80bfa:	e785      	b.n	80b08 <prvOBCPacketRouterTask+0xbc>
   80bfc:	000864f9 	.word	0x000864f9
   80c00:	2007ada9 	.word	0x2007ada9
   80c04:	20070462 	.word	0x20070462
   80c08:	20070470 	.word	0x20070470
   80c0c:	20070474 	.word	0x20070474
   80c10:	20070478 	.word	0x20070478
   80c14:	20070463 	.word	0x20070463
   80c18:	20070464 	.word	0x20070464
   80c1c:	20070468 	.word	0x20070468
   80c20:	20070469 	.word	0x20070469
   80c24:	20070479 	.word	0x20070479
   80c28:	2007046b 	.word	0x2007046b
   80c2c:	2007046c 	.word	0x2007046c
   80c30:	20070465 	.word	0x20070465
   80c34:	20070466 	.word	0x20070466
   80c38:	2007047a 	.word	0x2007047a
   80c3c:	2007047b 	.word	0x2007047b
   80c40:	2007047c 	.word	0x2007047c
   80c44:	2007046d 	.word	0x2007046d
   80c48:	2007046a 	.word	0x2007046a
   80c4c:	20070467 	.word	0x20070467
   80c50:	00081549 	.word	0x00081549
   80c54:	00081579 	.word	0x00081579
   80c58:	20070458 	.word	0x20070458
   80c5c:	2007045a 	.word	0x2007045a
   80c60:	20070848 	.word	0x20070848
   80c64:	2007084c 	.word	0x2007084c
   80c68:	2007b4e8 	.word	0x2007b4e8
   80c6c:	200705bc 	.word	0x200705bc
   80c70:	00086dc1 	.word	0x00086dc1
   80c74:	000811d5 	.word	0x000811d5
   80c78:	2007adcc 	.word	0x2007adcc
   80c7c:	2007b4f8 	.word	0x2007b4f8
   80c80:	20070718 	.word	0x20070718
   80c84:	00081631 	.word	0x00081631
   80c88:	2007b551 	.word	0x2007b551
   80c8c:	200707b0 	.word	0x200707b0
   80c90:	00081325 	.word	0x00081325
   80c94:	2007b500 	.word	0x2007b500
   80c98:	00080ca9 	.word	0x00080ca9
   80c9c:	00087771 	.word	0x00087771
   80ca0:	200705b8 	.word	0x200705b8
   80ca4:	000874b5 	.word	0x000874b5

00080ca8 <exec_commands>:
/* or tasks use to communicate with the OBC_PACKET_ROUTER. These are	*/
/* used so that other PUS services and tasks can downlink telemetry		*/
/* packets such as TC verification, event reports, or other	TM.			*/
/************************************************************************/
static void exec_commands(void)
{
   80ca8:	b590      	push	{r4, r7, lr}
   80caa:	b085      	sub	sp, #20
   80cac:	af04      	add	r7, sp, #16
	high = 0;
   80cae:	4b8a      	ldr	r3, [pc, #552]	; (80ed8 <exec_commands+0x230>)
   80cb0:	2200      	movs	r2, #0
   80cb2:	601a      	str	r2, [r3, #0]
	low = 0;
   80cb4:	4b89      	ldr	r3, [pc, #548]	; (80edc <exec_commands+0x234>)
   80cb6:	2200      	movs	r2, #0
   80cb8:	601a      	str	r2, [r3, #0]
	clear_current_command();
   80cba:	4b89      	ldr	r3, [pc, #548]	; (80ee0 <exec_commands+0x238>)
   80cbc:	4798      	blx	r3
	if(xQueueReceive(hk_to_obc_fifo, current_command, (TickType_t)1) == pdTRUE)	// Check to see if there is a command from HK and execute it.
   80cbe:	4b89      	ldr	r3, [pc, #548]	; (80ee4 <exec_commands+0x23c>)
   80cc0:	681b      	ldr	r3, [r3, #0]
   80cc2:	4618      	mov	r0, r3
   80cc4:	4988      	ldr	r1, [pc, #544]	; (80ee8 <exec_commands+0x240>)
   80cc6:	2201      	movs	r2, #1
   80cc8:	2300      	movs	r3, #0
   80cca:	4c88      	ldr	r4, [pc, #544]	; (80eec <exec_commands+0x244>)
   80ccc:	47a0      	blx	r4
   80cce:	4603      	mov	r3, r0
   80cd0:	2b01      	cmp	r3, #1
   80cd2:	d166      	bne.n	80da2 <exec_commands+0xfa>
	{
		packet_id = ((uint16_t)current_command[140]) << 8;
   80cd4:	4b84      	ldr	r3, [pc, #528]	; (80ee8 <exec_commands+0x240>)
   80cd6:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
   80cda:	021b      	lsls	r3, r3, #8
   80cdc:	b29a      	uxth	r2, r3
   80cde:	4b84      	ldr	r3, [pc, #528]	; (80ef0 <exec_commands+0x248>)
   80ce0:	801a      	strh	r2, [r3, #0]
		packet_id += (uint16_t)current_command[139];
   80ce2:	4b81      	ldr	r3, [pc, #516]	; (80ee8 <exec_commands+0x240>)
   80ce4:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
   80ce8:	461a      	mov	r2, r3
   80cea:	4b81      	ldr	r3, [pc, #516]	; (80ef0 <exec_commands+0x248>)
   80cec:	881b      	ldrh	r3, [r3, #0]
   80cee:	4413      	add	r3, r2
   80cf0:	b29a      	uxth	r2, r3
   80cf2:	4b7f      	ldr	r3, [pc, #508]	; (80ef0 <exec_commands+0x248>)
   80cf4:	801a      	strh	r2, [r3, #0]
		psc = ((uint16_t)current_command[138]) << 8;
   80cf6:	4b7c      	ldr	r3, [pc, #496]	; (80ee8 <exec_commands+0x240>)
   80cf8:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
   80cfc:	021b      	lsls	r3, r3, #8
   80cfe:	b29a      	uxth	r2, r3
   80d00:	4b7c      	ldr	r3, [pc, #496]	; (80ef4 <exec_commands+0x24c>)
   80d02:	801a      	strh	r2, [r3, #0]
		psc += (uint16_t)current_command[137];
   80d04:	4b78      	ldr	r3, [pc, #480]	; (80ee8 <exec_commands+0x240>)
   80d06:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
   80d0a:	461a      	mov	r2, r3
   80d0c:	4b79      	ldr	r3, [pc, #484]	; (80ef4 <exec_commands+0x24c>)
   80d0e:	881b      	ldrh	r3, [r3, #0]
   80d10:	4413      	add	r3, r2
   80d12:	b29a      	uxth	r2, r3
   80d14:	4b77      	ldr	r3, [pc, #476]	; (80ef4 <exec_commands+0x24c>)
   80d16:	801a      	strh	r2, [r3, #0]
		if(current_command[146] == HK_REPORT)
   80d18:	4b73      	ldr	r3, [pc, #460]	; (80ee8 <exec_commands+0x240>)
   80d1a:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
   80d1e:	2b19      	cmp	r3, #25
   80d20:	d112      	bne.n	80d48 <exec_commands+0xa0>
		{
			hk_telem_count++;
   80d22:	4b75      	ldr	r3, [pc, #468]	; (80ef8 <exec_commands+0x250>)
   80d24:	781b      	ldrb	r3, [r3, #0]
   80d26:	3301      	adds	r3, #1
   80d28:	b2da      	uxtb	r2, r3
   80d2a:	4b73      	ldr	r3, [pc, #460]	; (80ef8 <exec_commands+0x250>)
   80d2c:	701a      	strb	r2, [r3, #0]
			packetize_send_telemetry(HK_TASK_ID, HK_GROUND_ID, HK_SERVICE, HK_REPORT, hk_telem_count, 1, current_command);
   80d2e:	4b72      	ldr	r3, [pc, #456]	; (80ef8 <exec_commands+0x250>)
   80d30:	781b      	ldrb	r3, [r3, #0]
   80d32:	9300      	str	r3, [sp, #0]
   80d34:	2301      	movs	r3, #1
   80d36:	9301      	str	r3, [sp, #4]
   80d38:	4b6b      	ldr	r3, [pc, #428]	; (80ee8 <exec_commands+0x240>)
   80d3a:	9302      	str	r3, [sp, #8]
   80d3c:	2004      	movs	r0, #4
   80d3e:	2110      	movs	r1, #16
   80d40:	2203      	movs	r2, #3
   80d42:	2319      	movs	r3, #25
   80d44:	4c6d      	ldr	r4, [pc, #436]	; (80efc <exec_commands+0x254>)
   80d46:	47a0      	blx	r4
		}
		if(current_command[146] == HK_DEFINITON_REPORT)
   80d48:	4b67      	ldr	r3, [pc, #412]	; (80ee8 <exec_commands+0x240>)
   80d4a:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
   80d4e:	2b0a      	cmp	r3, #10
   80d50:	d112      	bne.n	80d78 <exec_commands+0xd0>
		{
			hk_def_report_count++;
   80d52:	4b6b      	ldr	r3, [pc, #428]	; (80f00 <exec_commands+0x258>)
   80d54:	781b      	ldrb	r3, [r3, #0]
   80d56:	3301      	adds	r3, #1
   80d58:	b2da      	uxtb	r2, r3
   80d5a:	4b69      	ldr	r3, [pc, #420]	; (80f00 <exec_commands+0x258>)
   80d5c:	701a      	strb	r2, [r3, #0]
			packetize_send_telemetry(HK_TASK_ID, HK_GROUND_ID, HK_SERVICE, HK_DEFINITON_REPORT, hk_def_report_count, 1, current_command);
   80d5e:	4b68      	ldr	r3, [pc, #416]	; (80f00 <exec_commands+0x258>)
   80d60:	781b      	ldrb	r3, [r3, #0]
   80d62:	9300      	str	r3, [sp, #0]
   80d64:	2301      	movs	r3, #1
   80d66:	9301      	str	r3, [sp, #4]
   80d68:	4b5f      	ldr	r3, [pc, #380]	; (80ee8 <exec_commands+0x240>)
   80d6a:	9302      	str	r3, [sp, #8]
   80d6c:	2004      	movs	r0, #4
   80d6e:	2110      	movs	r1, #16
   80d70:	2203      	movs	r2, #3
   80d72:	230a      	movs	r3, #10
   80d74:	4c61      	ldr	r4, [pc, #388]	; (80efc <exec_commands+0x254>)
   80d76:	47a0      	blx	r4
		}
		if(current_command[146] == TASK_TO_OPR_TCV)
   80d78:	4b5b      	ldr	r3, [pc, #364]	; (80ee8 <exec_commands+0x240>)
   80d7a:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
   80d7e:	2bdd      	cmp	r3, #221	; 0xdd
   80d80:	d10f      	bne.n	80da2 <exec_commands+0xfa>
		{
			send_tc_verification(packet_id, psc, current_command[145], current_command[144], 0, 2);		// Verify execution completion.
   80d82:	4b5b      	ldr	r3, [pc, #364]	; (80ef0 <exec_commands+0x248>)
   80d84:	8818      	ldrh	r0, [r3, #0]
   80d86:	4b5b      	ldr	r3, [pc, #364]	; (80ef4 <exec_commands+0x24c>)
   80d88:	8819      	ldrh	r1, [r3, #0]
   80d8a:	4b57      	ldr	r3, [pc, #348]	; (80ee8 <exec_commands+0x240>)
   80d8c:	f893 2091 	ldrb.w	r2, [r3, #145]	; 0x91
   80d90:	4b55      	ldr	r3, [pc, #340]	; (80ee8 <exec_commands+0x240>)
   80d92:	f893 3090 	ldrb.w	r3, [r3, #144]	; 0x90
   80d96:	2400      	movs	r4, #0
   80d98:	9400      	str	r4, [sp, #0]
   80d9a:	2402      	movs	r4, #2
   80d9c:	9401      	str	r4, [sp, #4]
   80d9e:	4c59      	ldr	r4, [pc, #356]	; (80f04 <exec_commands+0x25c>)
   80da0:	47a0      	blx	r4
		}
	}
	if(xQueueReceive(time_to_obc_fifo, current_command, (TickType_t)1) == pdTRUE)
   80da2:	4b59      	ldr	r3, [pc, #356]	; (80f08 <exec_commands+0x260>)
   80da4:	681b      	ldr	r3, [r3, #0]
   80da6:	4618      	mov	r0, r3
   80da8:	494f      	ldr	r1, [pc, #316]	; (80ee8 <exec_commands+0x240>)
   80daa:	2201      	movs	r2, #1
   80dac:	2300      	movs	r3, #0
   80dae:	4c4f      	ldr	r4, [pc, #316]	; (80eec <exec_commands+0x244>)
   80db0:	47a0      	blx	r4
   80db2:	4603      	mov	r3, r0
   80db4:	2b01      	cmp	r3, #1
   80db6:	d146      	bne.n	80e46 <exec_commands+0x19e>
	{
		packet_id = ((uint16_t)current_command[6]) << 8;
   80db8:	4b4b      	ldr	r3, [pc, #300]	; (80ee8 <exec_commands+0x240>)
   80dba:	799b      	ldrb	r3, [r3, #6]
   80dbc:	021b      	lsls	r3, r3, #8
   80dbe:	b29a      	uxth	r2, r3
   80dc0:	4b4b      	ldr	r3, [pc, #300]	; (80ef0 <exec_commands+0x248>)
   80dc2:	801a      	strh	r2, [r3, #0]
		packet_id += (uint16_t)current_command[5];
   80dc4:	4b48      	ldr	r3, [pc, #288]	; (80ee8 <exec_commands+0x240>)
   80dc6:	795b      	ldrb	r3, [r3, #5]
   80dc8:	461a      	mov	r2, r3
   80dca:	4b49      	ldr	r3, [pc, #292]	; (80ef0 <exec_commands+0x248>)
   80dcc:	881b      	ldrh	r3, [r3, #0]
   80dce:	4413      	add	r3, r2
   80dd0:	b29a      	uxth	r2, r3
   80dd2:	4b47      	ldr	r3, [pc, #284]	; (80ef0 <exec_commands+0x248>)
   80dd4:	801a      	strh	r2, [r3, #0]
		psc = ((uint16_t)current_command[4]) << 8;
   80dd6:	4b44      	ldr	r3, [pc, #272]	; (80ee8 <exec_commands+0x240>)
   80dd8:	791b      	ldrb	r3, [r3, #4]
   80dda:	021b      	lsls	r3, r3, #8
   80ddc:	b29a      	uxth	r2, r3
   80dde:	4b45      	ldr	r3, [pc, #276]	; (80ef4 <exec_commands+0x24c>)
   80de0:	801a      	strh	r2, [r3, #0]
		psc += (uint16_t)current_command[3];
   80de2:	4b41      	ldr	r3, [pc, #260]	; (80ee8 <exec_commands+0x240>)
   80de4:	78db      	ldrb	r3, [r3, #3]
   80de6:	461a      	mov	r2, r3
   80de8:	4b42      	ldr	r3, [pc, #264]	; (80ef4 <exec_commands+0x24c>)
   80dea:	881b      	ldrh	r3, [r3, #0]
   80dec:	4413      	add	r3, r2
   80dee:	b29a      	uxth	r2, r3
   80df0:	4b40      	ldr	r3, [pc, #256]	; (80ef4 <exec_commands+0x24c>)
   80df2:	801a      	strh	r2, [r3, #0]
		if(current_command[9] == TIME_REPORT)
   80df4:	4b3c      	ldr	r3, [pc, #240]	; (80ee8 <exec_commands+0x240>)
   80df6:	7a5b      	ldrb	r3, [r3, #9]
   80df8:	2b02      	cmp	r3, #2
   80dfa:	d112      	bne.n	80e22 <exec_commands+0x17a>
		{
			time_report_count++;
   80dfc:	4b43      	ldr	r3, [pc, #268]	; (80f0c <exec_commands+0x264>)
   80dfe:	781b      	ldrb	r3, [r3, #0]
   80e00:	3301      	adds	r3, #1
   80e02:	b2da      	uxtb	r2, r3
   80e04:	4b41      	ldr	r3, [pc, #260]	; (80f0c <exec_commands+0x264>)
   80e06:	701a      	strb	r2, [r3, #0]
			packetize_send_telemetry(TIME_TASK_ID, TIME_GROUND_ID, TIME_SERVICE, TIME_REPORT, time_report_count, 1, current_command);
   80e08:	4b40      	ldr	r3, [pc, #256]	; (80f0c <exec_commands+0x264>)
   80e0a:	781b      	ldrb	r3, [r3, #0]
   80e0c:	9300      	str	r3, [sp, #0]
   80e0e:	2301      	movs	r3, #1
   80e10:	9301      	str	r3, [sp, #4]
   80e12:	4b35      	ldr	r3, [pc, #212]	; (80ee8 <exec_commands+0x240>)
   80e14:	9302      	str	r3, [sp, #8]
   80e16:	2006      	movs	r0, #6
   80e18:	2111      	movs	r1, #17
   80e1a:	2209      	movs	r2, #9
   80e1c:	2302      	movs	r3, #2
   80e1e:	4c37      	ldr	r4, [pc, #220]	; (80efc <exec_commands+0x254>)
   80e20:	47a0      	blx	r4
		}
		if(current_command[9] == TASK_TO_OPR_TCV)
   80e22:	4b31      	ldr	r3, [pc, #196]	; (80ee8 <exec_commands+0x240>)
   80e24:	7a5b      	ldrb	r3, [r3, #9]
   80e26:	2bdd      	cmp	r3, #221	; 0xdd
   80e28:	d10d      	bne.n	80e46 <exec_commands+0x19e>
		send_tc_verification(packet_id, psc, current_command[8], current_command[7], 0, 2);
   80e2a:	4b31      	ldr	r3, [pc, #196]	; (80ef0 <exec_commands+0x248>)
   80e2c:	8818      	ldrh	r0, [r3, #0]
   80e2e:	4b31      	ldr	r3, [pc, #196]	; (80ef4 <exec_commands+0x24c>)
   80e30:	8819      	ldrh	r1, [r3, #0]
   80e32:	4b2d      	ldr	r3, [pc, #180]	; (80ee8 <exec_commands+0x240>)
   80e34:	7a1a      	ldrb	r2, [r3, #8]
   80e36:	4b2c      	ldr	r3, [pc, #176]	; (80ee8 <exec_commands+0x240>)
   80e38:	79db      	ldrb	r3, [r3, #7]
   80e3a:	2400      	movs	r4, #0
   80e3c:	9400      	str	r4, [sp, #0]
   80e3e:	2402      	movs	r4, #2
   80e40:	9401      	str	r4, [sp, #4]
   80e42:	4c30      	ldr	r4, [pc, #192]	; (80f04 <exec_commands+0x25c>)
   80e44:	47a0      	blx	r4
	}
	if(xQueueReceive(mem_to_obc_fifo, current_command, (TickType_t)1) == pdTRUE)
   80e46:	4b32      	ldr	r3, [pc, #200]	; (80f10 <exec_commands+0x268>)
   80e48:	681b      	ldr	r3, [r3, #0]
   80e4a:	4618      	mov	r0, r3
   80e4c:	4926      	ldr	r1, [pc, #152]	; (80ee8 <exec_commands+0x240>)
   80e4e:	2201      	movs	r2, #1
   80e50:	2300      	movs	r3, #0
   80e52:	4c26      	ldr	r4, [pc, #152]	; (80eec <exec_commands+0x244>)
   80e54:	47a0      	blx	r4
   80e56:	4603      	mov	r3, r0
   80e58:	2b01      	cmp	r3, #1
   80e5a:	d139      	bne.n	80ed0 <exec_commands+0x228>
	{
		packet_id = ((uint16_t)current_command[140]) << 8;
   80e5c:	4b22      	ldr	r3, [pc, #136]	; (80ee8 <exec_commands+0x240>)
   80e5e:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
   80e62:	021b      	lsls	r3, r3, #8
   80e64:	b29a      	uxth	r2, r3
   80e66:	4b22      	ldr	r3, [pc, #136]	; (80ef0 <exec_commands+0x248>)
   80e68:	801a      	strh	r2, [r3, #0]
		packet_id += (uint16_t)current_command[139];
   80e6a:	4b1f      	ldr	r3, [pc, #124]	; (80ee8 <exec_commands+0x240>)
   80e6c:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
   80e70:	461a      	mov	r2, r3
   80e72:	4b1f      	ldr	r3, [pc, #124]	; (80ef0 <exec_commands+0x248>)
   80e74:	881b      	ldrh	r3, [r3, #0]
   80e76:	4413      	add	r3, r2
   80e78:	b29a      	uxth	r2, r3
   80e7a:	4b1d      	ldr	r3, [pc, #116]	; (80ef0 <exec_commands+0x248>)
   80e7c:	801a      	strh	r2, [r3, #0]
		psc = ((uint16_t)current_command[138]) << 8;
   80e7e:	4b1a      	ldr	r3, [pc, #104]	; (80ee8 <exec_commands+0x240>)
   80e80:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
   80e84:	021b      	lsls	r3, r3, #8
   80e86:	b29a      	uxth	r2, r3
   80e88:	4b1a      	ldr	r3, [pc, #104]	; (80ef4 <exec_commands+0x24c>)
   80e8a:	801a      	strh	r2, [r3, #0]
		psc += (uint16_t)current_command[137];
   80e8c:	4b16      	ldr	r3, [pc, #88]	; (80ee8 <exec_commands+0x240>)
   80e8e:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
   80e92:	461a      	mov	r2, r3
   80e94:	4b17      	ldr	r3, [pc, #92]	; (80ef4 <exec_commands+0x24c>)
   80e96:	881b      	ldrh	r3, [r3, #0]
   80e98:	4413      	add	r3, r2
   80e9a:	b29a      	uxth	r2, r3
   80e9c:	4b15      	ldr	r3, [pc, #84]	; (80ef4 <exec_commands+0x24c>)
   80e9e:	801a      	strh	r2, [r3, #0]
		//}
		//if(current_command[146] == TASK_TO_OPR_EVENT)
		//{
			//send_event_packet(MEMORY_TASK_ID, current_command[145]);
		//}
		if(current_command[146] == DOWNLINKING_SCIENCE)
   80ea0:	4b11      	ldr	r3, [pc, #68]	; (80ee8 <exec_commands+0x240>)
   80ea2:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
   80ea6:	2bcc      	cmp	r3, #204	; 0xcc
   80ea8:	d112      	bne.n	80ed0 <exec_commands+0x228>
		{
			science_packet_count++;
   80eaa:	4b1a      	ldr	r3, [pc, #104]	; (80f14 <exec_commands+0x26c>)
   80eac:	781b      	ldrb	r3, [r3, #0]
   80eae:	3301      	adds	r3, #1
   80eb0:	b2da      	uxtb	r2, r3
   80eb2:	4b18      	ldr	r3, [pc, #96]	; (80f14 <exec_commands+0x26c>)
   80eb4:	701a      	strb	r2, [r3, #0]
			packetize_send_telemetry(MEMORY_TASK_ID, MEM_GROUND_ID, MEMORY_SERVICE, DOWNLINKING_SCIENCE, science_packet_count, 1, current_command);
   80eb6:	4b17      	ldr	r3, [pc, #92]	; (80f14 <exec_commands+0x26c>)
   80eb8:	781b      	ldrb	r3, [r3, #0]
   80eba:	9300      	str	r3, [sp, #0]
   80ebc:	2301      	movs	r3, #1
   80ebe:	9301      	str	r3, [sp, #4]
   80ec0:	4b09      	ldr	r3, [pc, #36]	; (80ee8 <exec_commands+0x240>)
   80ec2:	9302      	str	r3, [sp, #8]
   80ec4:	200e      	movs	r0, #14
   80ec6:	2112      	movs	r1, #18
   80ec8:	2206      	movs	r2, #6
   80eca:	23cc      	movs	r3, #204	; 0xcc
   80ecc:	4c0b      	ldr	r4, [pc, #44]	; (80efc <exec_commands+0x254>)
   80ece:	47a0      	blx	r4
		//if(current_command[146] == TASK_TO_OPR_EVENT)
		//{
			//send_event_packet(EPS_TASK_ID, current_command[145]);
		//}
	//}
	return;
   80ed0:	bf00      	nop
}
   80ed2:	3704      	adds	r7, #4
   80ed4:	46bd      	mov	sp, r7
   80ed6:	bd90      	pop	{r4, r7, pc}
   80ed8:	200705a0 	.word	0x200705a0
   80edc:	200705a4 	.word	0x200705a4
   80ee0:	00081579 	.word	0x00081579
   80ee4:	2007b38c 	.word	0x2007b38c
   80ee8:	2007050c 	.word	0x2007050c
   80eec:	00086dc1 	.word	0x00086dc1
   80ef0:	2007045e 	.word	0x2007045e
   80ef4:	20070460 	.word	0x20070460
   80ef8:	20070463 	.word	0x20070463
   80efc:	00080f19 	.word	0x00080f19
   80f00:	20070464 	.word	0x20070464
   80f04:	000824d9 	.word	0x000824d9
   80f08:	2007b430 	.word	0x2007b430
   80f0c:	20070465 	.word	0x20070465
   80f10:	2007d57c 	.word	0x2007d57c
   80f14:	20070467 	.word	0x20070467

00080f18 <packetize_send_telemetry>:
/* and proceeds to send this packet to the COMS SSM so that it can be	*/
/* downlinked to the groundstation.										*/
/* @return: -1 == Failure, 36 == success.								*/
/************************************************************************/
static int packetize_send_telemetry(uint8_t sender, uint8_t dest, uint8_t service_type, uint8_t service_sub_type, uint8_t packet_sub_counter, uint16_t num_packets, uint8_t* data)
{
   80f18:	b580      	push	{r7, lr}
   80f1a:	b084      	sub	sp, #16
   80f1c:	af00      	add	r7, sp, #0
   80f1e:	71f8      	strb	r0, [r7, #7]
   80f20:	71b9      	strb	r1, [r7, #6]
   80f22:	717a      	strb	r2, [r7, #5]
   80f24:	713b      	strb	r3, [r7, #4]
	uint16_t i, j;
	type = 0;			// Distinguishes TC and TM packets, TM = 0
   80f26:	4b98      	ldr	r3, [pc, #608]	; (81188 <packetize_send_telemetry+0x270>)
   80f28:	2200      	movs	r2, #0
   80f2a:	701a      	strb	r2, [r3, #0]
	sequence_count = 0;
   80f2c:	4b97      	ldr	r3, [pc, #604]	; (8118c <packetize_send_telemetry+0x274>)
   80f2e:	2200      	movs	r2, #0
   80f30:	701a      	strb	r2, [r3, #0]
	packet_error_control = 0;
   80f32:	4b97      	ldr	r3, [pc, #604]	; (81190 <packetize_send_telemetry+0x278>)
   80f34:	2200      	movs	r2, #0
   80f36:	801a      	strh	r2, [r3, #0]
	abs_time = ((uint16_t)absolute_time_arr[0]) << 12;	// DAY
   80f38:	4b96      	ldr	r3, [pc, #600]	; (81194 <packetize_send_telemetry+0x27c>)
   80f3a:	781b      	ldrb	r3, [r3, #0]
   80f3c:	031b      	lsls	r3, r3, #12
   80f3e:	b29a      	uxth	r2, r3
   80f40:	4b95      	ldr	r3, [pc, #596]	; (81198 <packetize_send_telemetry+0x280>)
   80f42:	801a      	strh	r2, [r3, #0]
	abs_time = ((uint16_t)absolute_time_arr[1]) << 8;	// HOUR
   80f44:	4b93      	ldr	r3, [pc, #588]	; (81194 <packetize_send_telemetry+0x27c>)
   80f46:	785b      	ldrb	r3, [r3, #1]
   80f48:	021b      	lsls	r3, r3, #8
   80f4a:	b29a      	uxth	r2, r3
   80f4c:	4b92      	ldr	r3, [pc, #584]	; (81198 <packetize_send_telemetry+0x280>)
   80f4e:	801a      	strh	r2, [r3, #0]
	abs_time = ((uint16_t)absolute_time_arr[2]) << 4;	// MINUTE
   80f50:	4b90      	ldr	r3, [pc, #576]	; (81194 <packetize_send_telemetry+0x27c>)
   80f52:	789b      	ldrb	r3, [r3, #2]
   80f54:	011b      	lsls	r3, r3, #4
   80f56:	b29a      	uxth	r2, r3
   80f58:	4b8f      	ldr	r3, [pc, #572]	; (81198 <packetize_send_telemetry+0x280>)
   80f5a:	801a      	strh	r2, [r3, #0]
	abs_time = (uint16_t)absolute_time_arr[3];			// SECOND
   80f5c:	4b8d      	ldr	r3, [pc, #564]	; (81194 <packetize_send_telemetry+0x27c>)
   80f5e:	78db      	ldrb	r3, [r3, #3]
   80f60:	461a      	mov	r2, r3
   80f62:	4b8d      	ldr	r3, [pc, #564]	; (81198 <packetize_send_telemetry+0x280>)
   80f64:	801a      	strh	r2, [r3, #0]
	
	if(current_tm_fullf)		// Current_tm should not normally be full.
   80f66:	4b8d      	ldr	r3, [pc, #564]	; (8119c <packetize_send_telemetry+0x284>)
   80f68:	781b      	ldrb	r3, [r3, #0]
   80f6a:	2b00      	cmp	r3, #0
   80f6c:	d002      	beq.n	80f74 <packetize_send_telemetry+0x5c>
		return -1;
   80f6e:	f04f 33ff 	mov.w	r3, #4294967295
   80f72:	e12b      	b.n	811cc <packetize_send_telemetry+0x2b4>
	
	if(num_packets > 1)
   80f74:	8bbb      	ldrh	r3, [r7, #28]
   80f76:	2b01      	cmp	r3, #1
   80f78:	d903      	bls.n	80f82 <packetize_send_telemetry+0x6a>
		sequence_flags = 0x1;	// Indicates that this is the first packet in a series of packets.
   80f7a:	4b89      	ldr	r3, [pc, #548]	; (811a0 <packetize_send_telemetry+0x288>)
   80f7c:	2201      	movs	r2, #1
   80f7e:	701a      	strb	r2, [r3, #0]
   80f80:	e002      	b.n	80f88 <packetize_send_telemetry+0x70>
	else
		sequence_flags = 0x3;	// Indicates that this is a standalone packet.
   80f82:	4b87      	ldr	r3, [pc, #540]	; (811a0 <packetize_send_telemetry+0x288>)
   80f84:	2203      	movs	r2, #3
   80f86:	701a      	strb	r2, [r3, #0]
	// Packet Header
	version = 0;
   80f88:	4b86      	ldr	r3, [pc, #536]	; (811a4 <packetize_send_telemetry+0x28c>)
   80f8a:	2200      	movs	r2, #0
   80f8c:	701a      	strb	r2, [r3, #0]
	current_tm[151] = ((version & 0x07) << 5) | ((type & 0x01) << 4) | (0x08);
   80f8e:	4b85      	ldr	r3, [pc, #532]	; (811a4 <packetize_send_telemetry+0x28c>)
   80f90:	781b      	ldrb	r3, [r3, #0]
   80f92:	015b      	lsls	r3, r3, #5
   80f94:	b2da      	uxtb	r2, r3
   80f96:	4b7c      	ldr	r3, [pc, #496]	; (81188 <packetize_send_telemetry+0x270>)
   80f98:	781b      	ldrb	r3, [r3, #0]
   80f9a:	f003 0301 	and.w	r3, r3, #1
   80f9e:	011b      	lsls	r3, r3, #4
   80fa0:	b2db      	uxtb	r3, r3
   80fa2:	4313      	orrs	r3, r2
   80fa4:	b2db      	uxtb	r3, r3
   80fa6:	f043 0308 	orr.w	r3, r3, #8
   80faa:	b2db      	uxtb	r3, r3
   80fac:	b2da      	uxtb	r2, r3
   80fae:	4b7e      	ldr	r3, [pc, #504]	; (811a8 <packetize_send_telemetry+0x290>)
   80fb0:	f883 2097 	strb.w	r2, [r3, #151]	; 0x97
	current_tm[150] = sender;
   80fb4:	4b7c      	ldr	r3, [pc, #496]	; (811a8 <packetize_send_telemetry+0x290>)
   80fb6:	79fa      	ldrb	r2, [r7, #7]
   80fb8:	f883 2096 	strb.w	r2, [r3, #150]	; 0x96
	current_tm[149] = (sequence_flags & 0x03) << 6;
   80fbc:	4b78      	ldr	r3, [pc, #480]	; (811a0 <packetize_send_telemetry+0x288>)
   80fbe:	781b      	ldrb	r3, [r3, #0]
   80fc0:	019b      	lsls	r3, r3, #6
   80fc2:	b2da      	uxtb	r2, r3
   80fc4:	4b78      	ldr	r3, [pc, #480]	; (811a8 <packetize_send_telemetry+0x290>)
   80fc6:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
	current_tm[148] = sequence_count;
   80fca:	4b70      	ldr	r3, [pc, #448]	; (8118c <packetize_send_telemetry+0x274>)
   80fcc:	781a      	ldrb	r2, [r3, #0]
   80fce:	4b76      	ldr	r3, [pc, #472]	; (811a8 <packetize_send_telemetry+0x290>)
   80fd0:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
	current_tm[147] = 0x00;
   80fd4:	4b74      	ldr	r3, [pc, #464]	; (811a8 <packetize_send_telemetry+0x290>)
   80fd6:	2200      	movs	r2, #0
   80fd8:	f883 2093 	strb.w	r2, [r3, #147]	; 0x93
	current_tm[146]	= PACKET_LENGTH - 1;	// Represents the length of the data field - 1.
   80fdc:	4b72      	ldr	r3, [pc, #456]	; (811a8 <packetize_send_telemetry+0x290>)
   80fde:	2297      	movs	r2, #151	; 0x97
   80fe0:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
	version = 1;
   80fe4:	4b6f      	ldr	r3, [pc, #444]	; (811a4 <packetize_send_telemetry+0x28c>)
   80fe6:	2201      	movs	r2, #1
   80fe8:	701a      	strb	r2, [r3, #0]
	// Data Field Header
	current_tm[145] = (version & 0x07) << 4 | 0x80;
   80fea:	4b6e      	ldr	r3, [pc, #440]	; (811a4 <packetize_send_telemetry+0x28c>)
   80fec:	781b      	ldrb	r3, [r3, #0]
   80fee:	f003 0307 	and.w	r3, r3, #7
   80ff2:	011b      	lsls	r3, r3, #4
   80ff4:	b2db      	uxtb	r3, r3
   80ff6:	f063 037f 	orn	r3, r3, #127	; 0x7f
   80ffa:	b2db      	uxtb	r3, r3
   80ffc:	b2da      	uxtb	r2, r3
   80ffe:	4b6a      	ldr	r3, [pc, #424]	; (811a8 <packetize_send_telemetry+0x290>)
   81000:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
	current_tm[144] = service_type;
   81004:	4b68      	ldr	r3, [pc, #416]	; (811a8 <packetize_send_telemetry+0x290>)
   81006:	797a      	ldrb	r2, [r7, #5]
   81008:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
	current_tm[143] = service_sub_type;
   8100c:	4b66      	ldr	r3, [pc, #408]	; (811a8 <packetize_send_telemetry+0x290>)
   8100e:	793a      	ldrb	r2, [r7, #4]
   81010:	f883 208f 	strb.w	r2, [r3, #143]	; 0x8f
	current_tm[142] = packet_sub_counter;
   81014:	4b64      	ldr	r3, [pc, #400]	; (811a8 <packetize_send_telemetry+0x290>)
   81016:	7e3a      	ldrb	r2, [r7, #24]
   81018:	f883 208e 	strb.w	r2, [r3, #142]	; 0x8e
	current_tm[141] = dest;
   8101c:	4b62      	ldr	r3, [pc, #392]	; (811a8 <packetize_send_telemetry+0x290>)
   8101e:	79ba      	ldrb	r2, [r7, #6]
   81020:	f883 208d 	strb.w	r2, [r3, #141]	; 0x8d
	current_tm[140] = (uint8_t)((abs_time & 0xFF00) >> 8);
   81024:	4b5c      	ldr	r3, [pc, #368]	; (81198 <packetize_send_telemetry+0x280>)
   81026:	881b      	ldrh	r3, [r3, #0]
   81028:	0a1b      	lsrs	r3, r3, #8
   8102a:	b29b      	uxth	r3, r3
   8102c:	b2da      	uxtb	r2, r3
   8102e:	4b5e      	ldr	r3, [pc, #376]	; (811a8 <packetize_send_telemetry+0x290>)
   81030:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	current_tm[139] = (uint8_t)(abs_time & 0x00FF);
   81034:	4b58      	ldr	r3, [pc, #352]	; (81198 <packetize_send_telemetry+0x280>)
   81036:	881b      	ldrh	r3, [r3, #0]
   81038:	b2da      	uxtb	r2, r3
   8103a:	4b5b      	ldr	r3, [pc, #364]	; (811a8 <packetize_send_telemetry+0x290>)
   8103c:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
	// The Packet Error Control (PEC) is put at the end of the packet.
	pec = fletcher16(current_tm + 2, 150);
   81040:	485a      	ldr	r0, [pc, #360]	; (811ac <packetize_send_telemetry+0x294>)
   81042:	2196      	movs	r1, #150	; 0x96
   81044:	4b5a      	ldr	r3, [pc, #360]	; (811b0 <packetize_send_telemetry+0x298>)
   81046:	4798      	blx	r3
   81048:	4603      	mov	r3, r0
   8104a:	461a      	mov	r2, r3
   8104c:	4b59      	ldr	r3, [pc, #356]	; (811b4 <packetize_send_telemetry+0x29c>)
   8104e:	801a      	strh	r2, [r3, #0]
	current_tm[1] = (uint8_t)((pec & 0xFF00) >> 8);
   81050:	4b58      	ldr	r3, [pc, #352]	; (811b4 <packetize_send_telemetry+0x29c>)
   81052:	881b      	ldrh	r3, [r3, #0]
   81054:	0a1b      	lsrs	r3, r3, #8
   81056:	b29b      	uxth	r3, r3
   81058:	b2da      	uxtb	r2, r3
   8105a:	4b53      	ldr	r3, [pc, #332]	; (811a8 <packetize_send_telemetry+0x290>)
   8105c:	705a      	strb	r2, [r3, #1]
	current_tm[0] = (uint8_t)(pec & 0x00FF);
   8105e:	4b55      	ldr	r3, [pc, #340]	; (811b4 <packetize_send_telemetry+0x29c>)
   81060:	881b      	ldrh	r3, [r3, #0]
   81062:	b2da      	uxtb	r2, r3
   81064:	4b50      	ldr	r3, [pc, #320]	; (811a8 <packetize_send_telemetry+0x290>)
   81066:	701a      	strb	r2, [r3, #0]

	if(num_packets == 1)
   81068:	8bbb      	ldrh	r3, [r7, #28]
   8106a:	2b01      	cmp	r3, #1
   8106c:	d137      	bne.n	810de <packetize_send_telemetry+0x1c6>
	{
		sequence_count++;
   8106e:	4b47      	ldr	r3, [pc, #284]	; (8118c <packetize_send_telemetry+0x274>)
   81070:	781b      	ldrb	r3, [r3, #0]
   81072:	3301      	adds	r3, #1
   81074:	b2da      	uxtb	r2, r3
   81076:	4b45      	ldr	r3, [pc, #276]	; (8118c <packetize_send_telemetry+0x274>)
   81078:	701a      	strb	r2, [r3, #0]
		for(j = 2; j < 130; j++)
   8107a:	2302      	movs	r3, #2
   8107c:	81bb      	strh	r3, [r7, #12]
   8107e:	e00a      	b.n	81096 <packetize_send_telemetry+0x17e>
		{
			current_tm[j] = *(data + (j - 2));
   81080:	89bb      	ldrh	r3, [r7, #12]
   81082:	89ba      	ldrh	r2, [r7, #12]
   81084:	3a02      	subs	r2, #2
   81086:	6a39      	ldr	r1, [r7, #32]
   81088:	440a      	add	r2, r1
   8108a:	7811      	ldrb	r1, [r2, #0]
   8108c:	4a46      	ldr	r2, [pc, #280]	; (811a8 <packetize_send_telemetry+0x290>)
   8108e:	54d1      	strb	r1, [r2, r3]
	current_tm[0] = (uint8_t)(pec & 0x00FF);

	if(num_packets == 1)
	{
		sequence_count++;
		for(j = 2; j < 130; j++)
   81090:	89bb      	ldrh	r3, [r7, #12]
   81092:	3301      	adds	r3, #1
   81094:	81bb      	strh	r3, [r7, #12]
   81096:	89bb      	ldrh	r3, [r7, #12]
   81098:	2b81      	cmp	r3, #129	; 0x81
   8109a:	d9f1      	bls.n	81080 <packetize_send_telemetry+0x168>
		{
			current_tm[j] = *(data + (j - 2));
		}
		
		/* Run checksum on the PUS packet	*/
		packet_error_control = fletcher16(current_tm + 2, 150);
   8109c:	4843      	ldr	r0, [pc, #268]	; (811ac <packetize_send_telemetry+0x294>)
   8109e:	2196      	movs	r1, #150	; 0x96
   810a0:	4b43      	ldr	r3, [pc, #268]	; (811b0 <packetize_send_telemetry+0x298>)
   810a2:	4798      	blx	r3
   810a4:	4603      	mov	r3, r0
   810a6:	461a      	mov	r2, r3
   810a8:	4b39      	ldr	r3, [pc, #228]	; (81190 <packetize_send_telemetry+0x278>)
   810aa:	801a      	strh	r2, [r3, #0]
		current_tm[1] = (uint8_t)(packet_error_control >> 8);
   810ac:	4b38      	ldr	r3, [pc, #224]	; (81190 <packetize_send_telemetry+0x278>)
   810ae:	881b      	ldrh	r3, [r3, #0]
   810b0:	0a1b      	lsrs	r3, r3, #8
   810b2:	b29b      	uxth	r3, r3
   810b4:	b2da      	uxtb	r2, r3
   810b6:	4b3c      	ldr	r3, [pc, #240]	; (811a8 <packetize_send_telemetry+0x290>)
   810b8:	705a      	strb	r2, [r3, #1]
		current_tm[0] = (uint8_t)(packet_error_control & 0x00FF);
   810ba:	4b35      	ldr	r3, [pc, #212]	; (81190 <packetize_send_telemetry+0x278>)
   810bc:	881b      	ldrh	r3, [r3, #0]
   810be:	b2da      	uxtb	r2, r3
   810c0:	4b39      	ldr	r3, [pc, #228]	; (811a8 <packetize_send_telemetry+0x290>)
   810c2:	701a      	strb	r2, [r3, #0]
		current_tm_fullf = 1;
   810c4:	4b35      	ldr	r3, [pc, #212]	; (8119c <packetize_send_telemetry+0x284>)
   810c6:	2201      	movs	r2, #1
   810c8:	701a      	strb	r2, [r3, #0]
		
		if(store_current_tm() < 0)
   810ca:	4b3b      	ldr	r3, [pc, #236]	; (811b8 <packetize_send_telemetry+0x2a0>)
   810cc:	4798      	blx	r3
   810ce:	4603      	mov	r3, r0
   810d0:	2b00      	cmp	r3, #0
   810d2:	da02      	bge.n	810da <packetize_send_telemetry+0x1c2>
			return -1;
   810d4:	f04f 33ff 	mov.w	r3, #4294967295
   810d8:	e078      	b.n	811cc <packetize_send_telemetry+0x2b4>
		
		return 1;
   810da:	2301      	movs	r3, #1
   810dc:	e076      	b.n	811cc <packetize_send_telemetry+0x2b4>
	}
	
	for(i = 0; i < num_packets; i++)
   810de:	2300      	movs	r3, #0
   810e0:	81fb      	strh	r3, [r7, #14]
   810e2:	e06e      	b.n	811c2 <packetize_send_telemetry+0x2aa>
	{
		current_tm[148] = sequence_count;
   810e4:	4b29      	ldr	r3, [pc, #164]	; (8118c <packetize_send_telemetry+0x274>)
   810e6:	781a      	ldrb	r2, [r3, #0]
   810e8:	4b2f      	ldr	r3, [pc, #188]	; (811a8 <packetize_send_telemetry+0x290>)
   810ea:	f883 2094 	strb.w	r2, [r3, #148]	; 0x94
		sequence_count++;
   810ee:	4b27      	ldr	r3, [pc, #156]	; (8118c <packetize_send_telemetry+0x274>)
   810f0:	781b      	ldrb	r3, [r3, #0]
   810f2:	3301      	adds	r3, #1
   810f4:	b2da      	uxtb	r2, r3
   810f6:	4b25      	ldr	r3, [pc, #148]	; (8118c <packetize_send_telemetry+0x274>)
   810f8:	701a      	strb	r2, [r3, #0]
		
		if(i > 1)
   810fa:	89fb      	ldrh	r3, [r7, #14]
   810fc:	2b01      	cmp	r3, #1
   810fe:	d902      	bls.n	81106 <packetize_send_telemetry+0x1ee>
			sequence_flags = 0x0;			// Continuation packet
   81100:	4b27      	ldr	r3, [pc, #156]	; (811a0 <packetize_send_telemetry+0x288>)
   81102:	2200      	movs	r2, #0
   81104:	701a      	strb	r2, [r3, #0]
		if(i == (num_packets - 1))
   81106:	89fa      	ldrh	r2, [r7, #14]
   81108:	8bbb      	ldrh	r3, [r7, #28]
   8110a:	3b01      	subs	r3, #1
   8110c:	429a      	cmp	r2, r3
   8110e:	d102      	bne.n	81116 <packetize_send_telemetry+0x1fe>
			sequence_flags = 0x2;			// Last packet
   81110:	4b23      	ldr	r3, [pc, #140]	; (811a0 <packetize_send_telemetry+0x288>)
   81112:	2202      	movs	r2, #2
   81114:	701a      	strb	r2, [r3, #0]
		current_tm[149] = (sequence_flags & 0x03) << 6;
   81116:	4b22      	ldr	r3, [pc, #136]	; (811a0 <packetize_send_telemetry+0x288>)
   81118:	781b      	ldrb	r3, [r3, #0]
   8111a:	019b      	lsls	r3, r3, #6
   8111c:	b2da      	uxtb	r2, r3
   8111e:	4b22      	ldr	r3, [pc, #136]	; (811a8 <packetize_send_telemetry+0x290>)
   81120:	f883 2095 	strb.w	r2, [r3, #149]	; 0x95
		
		for(j = 2; j < (PACKET_LENGTH - 13); j++)
   81124:	2302      	movs	r3, #2
   81126:	81bb      	strh	r3, [r7, #12]
   81128:	e00d      	b.n	81146 <packetize_send_telemetry+0x22e>
		{
			current_tm[j] = *(data + (j - 2) + (i * 128));
   8112a:	89bb      	ldrh	r3, [r7, #12]
   8112c:	89b9      	ldrh	r1, [r7, #12]
   8112e:	89fa      	ldrh	r2, [r7, #14]
   81130:	01d2      	lsls	r2, r2, #7
   81132:	440a      	add	r2, r1
   81134:	3a02      	subs	r2, #2
   81136:	6a39      	ldr	r1, [r7, #32]
   81138:	440a      	add	r2, r1
   8113a:	7811      	ldrb	r1, [r2, #0]
   8113c:	4a1a      	ldr	r2, [pc, #104]	; (811a8 <packetize_send_telemetry+0x290>)
   8113e:	54d1      	strb	r1, [r2, r3]
			sequence_flags = 0x0;			// Continuation packet
		if(i == (num_packets - 1))
			sequence_flags = 0x2;			// Last packet
		current_tm[149] = (sequence_flags & 0x03) << 6;
		
		for(j = 2; j < (PACKET_LENGTH - 13); j++)
   81140:	89bb      	ldrh	r3, [r7, #12]
   81142:	3301      	adds	r3, #1
   81144:	81bb      	strh	r3, [r7, #12]
   81146:	89bb      	ldrh	r3, [r7, #12]
   81148:	2b8a      	cmp	r3, #138	; 0x8a
   8114a:	d9ee      	bls.n	8112a <packetize_send_telemetry+0x212>
		{
			current_tm[j] = *(data + (j - 2) + (i * 128));
		}
		
		/* Run checksum on the PUS packet	*/
		packet_error_control = fletcher16(current_tm + 2, 150);
   8114c:	4817      	ldr	r0, [pc, #92]	; (811ac <packetize_send_telemetry+0x294>)
   8114e:	2196      	movs	r1, #150	; 0x96
   81150:	4b17      	ldr	r3, [pc, #92]	; (811b0 <packetize_send_telemetry+0x298>)
   81152:	4798      	blx	r3
   81154:	4603      	mov	r3, r0
   81156:	461a      	mov	r2, r3
   81158:	4b0d      	ldr	r3, [pc, #52]	; (81190 <packetize_send_telemetry+0x278>)
   8115a:	801a      	strh	r2, [r3, #0]
		current_tm[1] = (uint8_t)(packet_error_control >> 8);
   8115c:	4b0c      	ldr	r3, [pc, #48]	; (81190 <packetize_send_telemetry+0x278>)
   8115e:	881b      	ldrh	r3, [r3, #0]
   81160:	0a1b      	lsrs	r3, r3, #8
   81162:	b29b      	uxth	r3, r3
   81164:	b2da      	uxtb	r2, r3
   81166:	4b10      	ldr	r3, [pc, #64]	; (811a8 <packetize_send_telemetry+0x290>)
   81168:	705a      	strb	r2, [r3, #1]
		current_tm[0] = (uint8_t)(packet_error_control & 0x00FF);
   8116a:	4b09      	ldr	r3, [pc, #36]	; (81190 <packetize_send_telemetry+0x278>)
   8116c:	881b      	ldrh	r3, [r3, #0]
   8116e:	b2da      	uxtb	r2, r3
   81170:	4b0d      	ldr	r3, [pc, #52]	; (811a8 <packetize_send_telemetry+0x290>)
   81172:	701a      	strb	r2, [r3, #0]
		current_tm_fullf = 1;
   81174:	4b09      	ldr	r3, [pc, #36]	; (8119c <packetize_send_telemetry+0x284>)
   81176:	2201      	movs	r2, #1
   81178:	701a      	strb	r2, [r3, #0]
		if(store_current_tm() < 0)
   8117a:	4b0f      	ldr	r3, [pc, #60]	; (811b8 <packetize_send_telemetry+0x2a0>)
   8117c:	4798      	blx	r3
   8117e:	4603      	mov	r3, r0
   81180:	2b00      	cmp	r3, #0
   81182:	da1b      	bge.n	811bc <packetize_send_telemetry+0x2a4>
			return i;
   81184:	89fb      	ldrh	r3, [r7, #14]
   81186:	e021      	b.n	811cc <packetize_send_telemetry+0x2b4>
   81188:	20070459 	.word	0x20070459
   8118c:	2007045c 	.word	0x2007045c
   81190:	200705ac 	.word	0x200705ac
   81194:	2007b104 	.word	0x2007b104
   81198:	200705a8 	.word	0x200705a8
   8119c:	2007b4ed 	.word	0x2007b4ed
   811a0:	2007045b 	.word	0x2007045b
   811a4:	20070458 	.word	0x20070458
   811a8:	20070680 	.word	0x20070680
   811ac:	20070682 	.word	0x20070682
   811b0:	00082aa5 	.word	0x00082aa5
   811b4:	200705aa 	.word	0x200705aa
   811b8:	000815f5 	.word	0x000815f5
			return -1;
		
		return 1;
	}
	
	for(i = 0; i < num_packets; i++)
   811bc:	89fb      	ldrh	r3, [r7, #14]
   811be:	3301      	adds	r3, #1
   811c0:	81fb      	strh	r3, [r7, #14]
   811c2:	89fa      	ldrh	r2, [r7, #14]
   811c4:	8bbb      	ldrh	r3, [r7, #28]
   811c6:	429a      	cmp	r2, r3
   811c8:	d38c      	bcc.n	810e4 <packetize_send_telemetry+0x1cc>
		current_tm_fullf = 1;
		if(store_current_tm() < 0)
			return i;
	}
	
	return num_packets;
   811ca:	8bbb      	ldrh	r3, [r7, #28]
}
   811cc:	4618      	mov	r0, r3
   811ce:	3710      	adds	r7, #16
   811d0:	46bd      	mov	sp, r7
   811d2:	bd80      	pop	{r7, pc}

000811d4 <receive_tc_msg>:
/* function is in charge of checking whether the sequence counter is	*/
/* okay and if it is, placing the 4 bytes in current_tc[]				*/
/* @return: -1 : something went wrong or the received sequence was wrong*/
/************************************************************************/
static int receive_tc_msg(void)
{
   811d4:	b580      	push	{r7, lr}
   811d6:	b082      	sub	sp, #8
   811d8:	af00      	add	r7, sp, #0
	uint8_t ssm_seq_count = (uint8_t)(new_tc_msg_high & 0x000000FF);
   811da:	4b47      	ldr	r3, [pc, #284]	; (812f8 <receive_tc_msg+0x124>)
   811dc:	681b      	ldr	r3, [r3, #0]
   811de:	71fb      	strb	r3, [r7, #7]
	low_received = 0;
   811e0:	4b46      	ldr	r3, [pc, #280]	; (812fc <receive_tc_msg+0x128>)
   811e2:	2200      	movs	r2, #0
   811e4:	601a      	str	r2, [r3, #0]
	high_received = 0;
   811e6:	4b46      	ldr	r3, [pc, #280]	; (81300 <receive_tc_msg+0x12c>)
   811e8:	2200      	movs	r2, #0
   811ea:	601a      	str	r2, [r3, #0]
	
	if(ssm_seq_count > (tc_sequence_count + 1))
   811ec:	79fa      	ldrb	r2, [r7, #7]
   811ee:	4b45      	ldr	r3, [pc, #276]	; (81304 <receive_tc_msg+0x130>)
   811f0:	781b      	ldrb	r3, [r3, #0]
   811f2:	3301      	adds	r3, #1
   811f4:	429a      	cmp	r2, r3
   811f6:	dd0d      	ble.n	81214 <receive_tc_msg+0x40>
	{
		send_tc_transaction_response(0xFF);
   811f8:	20ff      	movs	r0, #255	; 0xff
   811fa:	4b43      	ldr	r3, [pc, #268]	; (81308 <receive_tc_msg+0x134>)
   811fc:	4798      	blx	r3
		tc_sequence_count = 0;
   811fe:	4b41      	ldr	r3, [pc, #260]	; (81304 <receive_tc_msg+0x130>)
   81200:	2200      	movs	r2, #0
   81202:	701a      	strb	r2, [r3, #0]
		receiving_tcf = 0;
   81204:	4b41      	ldr	r3, [pc, #260]	; (8130c <receive_tc_msg+0x138>)
   81206:	2200      	movs	r2, #0
   81208:	701a      	strb	r2, [r3, #0]
		clear_current_tc();
   8120a:	4b41      	ldr	r3, [pc, #260]	; (81310 <receive_tc_msg+0x13c>)
   8120c:	4798      	blx	r3
		return -1;
   8120e:	f04f 33ff 	mov.w	r3, #4294967295
   81212:	e06d      	b.n	812f0 <receive_tc_msg+0x11c>
	}
	if(current_tc_fullf)
   81214:	4b3f      	ldr	r3, [pc, #252]	; (81314 <receive_tc_msg+0x140>)
   81216:	781b      	ldrb	r3, [r3, #0]
   81218:	2b00      	cmp	r3, #0
   8121a:	d00b      	beq.n	81234 <receive_tc_msg+0x60>
	{
		send_tc_transaction_response(0xFF);
   8121c:	20ff      	movs	r0, #255	; 0xff
   8121e:	4b3a      	ldr	r3, [pc, #232]	; (81308 <receive_tc_msg+0x134>)
   81220:	4798      	blx	r3
		tc_sequence_count = 0;
   81222:	4b38      	ldr	r3, [pc, #224]	; (81304 <receive_tc_msg+0x130>)
   81224:	2200      	movs	r2, #0
   81226:	701a      	strb	r2, [r3, #0]
		receiving_tcf = 0;
   81228:	4b38      	ldr	r3, [pc, #224]	; (8130c <receive_tc_msg+0x138>)
   8122a:	2200      	movs	r2, #0
   8122c:	701a      	strb	r2, [r3, #0]
		return -1;
   8122e:	f04f 33ff 	mov.w	r3, #4294967295
   81232:	e05d      	b.n	812f0 <receive_tc_msg+0x11c>
	}
	
	if((!ssm_seq_count && !tc_sequence_count) || (ssm_seq_count == (tc_sequence_count + 1)))
   81234:	79fb      	ldrb	r3, [r7, #7]
   81236:	2b00      	cmp	r3, #0
   81238:	d103      	bne.n	81242 <receive_tc_msg+0x6e>
   8123a:	4b32      	ldr	r3, [pc, #200]	; (81304 <receive_tc_msg+0x130>)
   8123c:	781b      	ldrb	r3, [r3, #0]
   8123e:	2b00      	cmp	r3, #0
   81240:	d005      	beq.n	8124e <receive_tc_msg+0x7a>
   81242:	79fa      	ldrb	r2, [r7, #7]
   81244:	4b2f      	ldr	r3, [pc, #188]	; (81304 <receive_tc_msg+0x130>)
   81246:	781b      	ldrb	r3, [r3, #0]
   81248:	3301      	adds	r3, #1
   8124a:	429a      	cmp	r2, r3
   8124c:	d143      	bne.n	812d6 <receive_tc_msg+0x102>
	{
		tc_sequence_count = ssm_seq_count;
   8124e:	4b2d      	ldr	r3, [pc, #180]	; (81304 <receive_tc_msg+0x130>)
   81250:	79fa      	ldrb	r2, [r7, #7]
   81252:	701a      	strb	r2, [r3, #0]
		receiving_tcf = 1;
   81254:	4b2d      	ldr	r3, [pc, #180]	; (8130c <receive_tc_msg+0x138>)
   81256:	2201      	movs	r2, #1
   81258:	701a      	strb	r2, [r3, #0]
		current_tc[(ssm_seq_count * 4)] = (uint8_t)((new_tc_msg_low & 0x000000FF));
   8125a:	79fb      	ldrb	r3, [r7, #7]
   8125c:	009b      	lsls	r3, r3, #2
   8125e:	4a2e      	ldr	r2, [pc, #184]	; (81318 <receive_tc_msg+0x144>)
   81260:	6812      	ldr	r2, [r2, #0]
   81262:	b2d1      	uxtb	r1, r2
   81264:	4a2d      	ldr	r2, [pc, #180]	; (8131c <receive_tc_msg+0x148>)
   81266:	54d1      	strb	r1, [r2, r3]
		current_tc[(ssm_seq_count * 4) + 1] = (uint8_t)((new_tc_msg_low & 0x0000FF00) >> 8);
   81268:	79fb      	ldrb	r3, [r7, #7]
   8126a:	009b      	lsls	r3, r3, #2
   8126c:	3301      	adds	r3, #1
   8126e:	4a2a      	ldr	r2, [pc, #168]	; (81318 <receive_tc_msg+0x144>)
   81270:	6812      	ldr	r2, [r2, #0]
   81272:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
   81276:	0a12      	lsrs	r2, r2, #8
   81278:	b2d1      	uxtb	r1, r2
   8127a:	4a28      	ldr	r2, [pc, #160]	; (8131c <receive_tc_msg+0x148>)
   8127c:	54d1      	strb	r1, [r2, r3]
		current_tc[(ssm_seq_count * 4) + 2] = (uint8_t)((new_tc_msg_low & 0x00FF0000) >> 16);
   8127e:	79fb      	ldrb	r3, [r7, #7]
   81280:	009b      	lsls	r3, r3, #2
   81282:	3302      	adds	r3, #2
   81284:	4a24      	ldr	r2, [pc, #144]	; (81318 <receive_tc_msg+0x144>)
   81286:	6812      	ldr	r2, [r2, #0]
   81288:	f402 027f 	and.w	r2, r2, #16711680	; 0xff0000
   8128c:	0c12      	lsrs	r2, r2, #16
   8128e:	b2d1      	uxtb	r1, r2
   81290:	4a22      	ldr	r2, [pc, #136]	; (8131c <receive_tc_msg+0x148>)
   81292:	54d1      	strb	r1, [r2, r3]
		current_tc[(ssm_seq_count * 4) + 3] = (uint8_t)((new_tc_msg_low & 0xFF000000) >> 24);
   81294:	79fb      	ldrb	r3, [r7, #7]
   81296:	009b      	lsls	r3, r3, #2
   81298:	3303      	adds	r3, #3
   8129a:	4a1f      	ldr	r2, [pc, #124]	; (81318 <receive_tc_msg+0x144>)
   8129c:	6812      	ldr	r2, [r2, #0]
   8129e:	0e12      	lsrs	r2, r2, #24
   812a0:	b2d1      	uxtb	r1, r2
   812a2:	4a1e      	ldr	r2, [pc, #120]	; (8131c <receive_tc_msg+0x148>)
   812a4:	54d1      	strb	r1, [r2, r3]
		if(ssm_seq_count == (PACKET_LENGTH / 4) - 1)
   812a6:	79fb      	ldrb	r3, [r7, #7]
   812a8:	2b25      	cmp	r3, #37	; 0x25
   812aa:	d112      	bne.n	812d2 <receive_tc_msg+0xfe>
		{
			tc_sequence_count = 0;
   812ac:	4b15      	ldr	r3, [pc, #84]	; (81304 <receive_tc_msg+0x130>)
   812ae:	2200      	movs	r2, #0
   812b0:	701a      	strb	r2, [r3, #0]
			receiving_tcf = 0;
   812b2:	4b16      	ldr	r3, [pc, #88]	; (8130c <receive_tc_msg+0x138>)
   812b4:	2200      	movs	r2, #0
   812b6:	701a      	strb	r2, [r3, #0]
			current_tc_fullf = 1;
   812b8:	4b16      	ldr	r3, [pc, #88]	; (81314 <receive_tc_msg+0x140>)
   812ba:	2201      	movs	r2, #1
   812bc:	701a      	strb	r2, [r3, #0]
			send_tc_transaction_response(ssm_seq_count);
   812be:	79fb      	ldrb	r3, [r7, #7]
   812c0:	4618      	mov	r0, r3
   812c2:	4b11      	ldr	r3, [pc, #68]	; (81308 <receive_tc_msg+0x134>)
   812c4:	4798      	blx	r3
			send_tc_transaction_response(ssm_seq_count);
   812c6:	79fb      	ldrb	r3, [r7, #7]
   812c8:	4618      	mov	r0, r3
   812ca:	4b0f      	ldr	r3, [pc, #60]	; (81308 <receive_tc_msg+0x134>)
   812cc:	4798      	blx	r3
			store_current_tc();
   812ce:	4b14      	ldr	r3, [pc, #80]	; (81320 <receive_tc_msg+0x14c>)
   812d0:	4798      	blx	r3
		}
		return ssm_seq_count;
   812d2:	79fb      	ldrb	r3, [r7, #7]
   812d4:	e00c      	b.n	812f0 <receive_tc_msg+0x11c>
	}
	else
	{
		send_tc_transaction_response(0xFF);
   812d6:	20ff      	movs	r0, #255	; 0xff
   812d8:	4b0b      	ldr	r3, [pc, #44]	; (81308 <receive_tc_msg+0x134>)
   812da:	4798      	blx	r3
		tc_sequence_count = 0;
   812dc:	4b09      	ldr	r3, [pc, #36]	; (81304 <receive_tc_msg+0x130>)
   812de:	2200      	movs	r2, #0
   812e0:	701a      	strb	r2, [r3, #0]
		receiving_tcf = 0;
   812e2:	4b0a      	ldr	r3, [pc, #40]	; (8130c <receive_tc_msg+0x138>)
   812e4:	2200      	movs	r2, #0
   812e6:	701a      	strb	r2, [r3, #0]
		clear_current_tc();
   812e8:	4b09      	ldr	r3, [pc, #36]	; (81310 <receive_tc_msg+0x13c>)
   812ea:	4798      	blx	r3
		return -1;
   812ec:	f04f 33ff 	mov.w	r3, #4294967295
	}
}
   812f0:	4618      	mov	r0, r3
   812f2:	3708      	adds	r7, #8
   812f4:	46bd      	mov	sp, r7
   812f6:	bd80      	pop	{r7, pc}
   812f8:	20070470 	.word	0x20070470
   812fc:	20070848 	.word	0x20070848
   81300:	2007084c 	.word	0x2007084c
   81304:	20070462 	.word	0x20070462
   81308:	000814e1 	.word	0x000814e1
   8130c:	2007adcc 	.word	0x2007adcc
   81310:	00081519 	.word	0x00081519
   81314:	2007ada9 	.word	0x2007ada9
   81318:	20070474 	.word	0x20070474
   8131c:	200705e8 	.word	0x200705e8
   81320:	000815a9 	.word	0x000815a9

00081324 <send_pus_packet_tm>:
/* @Note: It should also be obvious that this packet is being sent to	*/
/* the COMS SSM.														*/
/* @Note: DO NOT call this function from an ISR.						*/
/************************************************************************/
static int send_pus_packet_tm(uint8_t sender_id)
{
   81324:	b590      	push	{r4, r7, lr}
   81326:	b087      	sub	sp, #28
   81328:	af02      	add	r7, sp, #8
   8132a:	4603      	mov	r3, r0
   8132c:	71fb      	strb	r3, [r7, #7]
	uint32_t i;
	num_transfers = PACKET_LENGTH / 4;
   8132e:	4b5f      	ldr	r3, [pc, #380]	; (814ac <send_pus_packet_tm+0x188>)
   81330:	2226      	movs	r2, #38	; 0x26
   81332:	601a      	str	r2, [r3, #0]
	timeout = 500;
   81334:	4b5e      	ldr	r3, [pc, #376]	; (814b0 <send_pus_packet_tm+0x18c>)
   81336:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   8133a:	801a      	strh	r2, [r3, #0]
	xTimeToWait = 25;
   8133c:	4b5d      	ldr	r3, [pc, #372]	; (814b4 <send_pus_packet_tm+0x190>)
   8133e:	2219      	movs	r2, #25
   81340:	601a      	str	r2, [r3, #0]
	
	tm_transfer_completef = 0;
   81342:	4b5d      	ldr	r3, [pc, #372]	; (814b8 <send_pus_packet_tm+0x194>)
   81344:	2200      	movs	r2, #0
   81346:	701a      	strb	r2, [r3, #0]
	start_tm_transferf = 0;
   81348:	4b5c      	ldr	r3, [pc, #368]	; (814bc <send_pus_packet_tm+0x198>)
   8134a:	2200      	movs	r2, #0
   8134c:	701a      	strb	r2, [r3, #0]
	send_tc_can_command(0x00, 0x00, sender_id, COMS_ID, TM_PACKET_READY, COMMAND_PRIO);	// Let the SSM know that a TM packet is ready.
   8134e:	79fb      	ldrb	r3, [r7, #7]
   81350:	220f      	movs	r2, #15
   81352:	9200      	str	r2, [sp, #0]
   81354:	2219      	movs	r2, #25
   81356:	9201      	str	r2, [sp, #4]
   81358:	2000      	movs	r0, #0
   8135a:	2100      	movs	r1, #0
   8135c:	461a      	mov	r2, r3
   8135e:	2300      	movs	r3, #0
   81360:	4c57      	ldr	r4, [pc, #348]	; (814c0 <send_pus_packet_tm+0x19c>)
   81362:	47a0      	blx	r4
	while(!start_tm_transferf)					// Wait for ~25 ms, for the SSM to say that we're good to start/
   81364:	e017      	b.n	81396 <send_pus_packet_tm+0x72>
	{
		if(!timeout--)
   81366:	4b52      	ldr	r3, [pc, #328]	; (814b0 <send_pus_packet_tm+0x18c>)
   81368:	881b      	ldrh	r3, [r3, #0]
   8136a:	1e5a      	subs	r2, r3, #1
   8136c:	b291      	uxth	r1, r2
   8136e:	4a50      	ldr	r2, [pc, #320]	; (814b0 <send_pus_packet_tm+0x18c>)
   81370:	8011      	strh	r1, [r2, #0]
   81372:	2b00      	cmp	r3, #0
   81374:	d102      	bne.n	8137c <send_pus_packet_tm+0x58>
		{
			return -1;
   81376:	f04f 33ff 	mov.w	r3, #4294967295
   8137a:	e092      	b.n	814a2 <send_pus_packet_tm+0x17e>
		}
		send_tc_can_command(0x00, 0x00, sender_id, COMS_ID, TM_PACKET_READY, COMMAND_PRIO);	// Let the SSM know that a TM packet is ready.
   8137c:	79fb      	ldrb	r3, [r7, #7]
   8137e:	220f      	movs	r2, #15
   81380:	9200      	str	r2, [sp, #0]
   81382:	2219      	movs	r2, #25
   81384:	9201      	str	r2, [sp, #4]
   81386:	2000      	movs	r0, #0
   81388:	2100      	movs	r1, #0
   8138a:	461a      	mov	r2, r3
   8138c:	2300      	movs	r3, #0
   8138e:	4c4c      	ldr	r4, [pc, #304]	; (814c0 <send_pus_packet_tm+0x19c>)
   81390:	47a0      	blx	r4
		taskYIELD();
   81392:	4b4c      	ldr	r3, [pc, #304]	; (814c4 <send_pus_packet_tm+0x1a0>)
   81394:	4798      	blx	r3
	xTimeToWait = 25;
	
	tm_transfer_completef = 0;
	start_tm_transferf = 0;
	send_tc_can_command(0x00, 0x00, sender_id, COMS_ID, TM_PACKET_READY, COMMAND_PRIO);	// Let the SSM know that a TM packet is ready.
	while(!start_tm_transferf)					// Wait for ~25 ms, for the SSM to say that we're good to start/
   81396:	4b49      	ldr	r3, [pc, #292]	; (814bc <send_pus_packet_tm+0x198>)
   81398:	781b      	ldrb	r3, [r3, #0]
   8139a:	2b00      	cmp	r3, #0
   8139c:	d0e3      	beq.n	81366 <send_pus_packet_tm+0x42>
			return -1;
		}
		send_tc_can_command(0x00, 0x00, sender_id, COMS_ID, TM_PACKET_READY, COMMAND_PRIO);	// Let the SSM know that a TM packet is ready.
		taskYIELD();
	}
	start_tm_transferf = 0;
   8139e:	4b47      	ldr	r3, [pc, #284]	; (814bc <send_pus_packet_tm+0x198>)
   813a0:	2200      	movs	r2, #0
   813a2:	701a      	strb	r2, [r3, #0]
	
	for(i = 0; i < num_transfers; i++)
   813a4:	2300      	movs	r3, #0
   813a6:	60fb      	str	r3, [r7, #12]
   813a8:	e04e      	b.n	81448 <send_pus_packet_tm+0x124>
	{
		if(tm_transfer_completef == 0xFF)			// The transaction has failed.
   813aa:	4b43      	ldr	r3, [pc, #268]	; (814b8 <send_pus_packet_tm+0x194>)
   813ac:	781b      	ldrb	r3, [r3, #0]
   813ae:	2bff      	cmp	r3, #255	; 0xff
   813b0:	d102      	bne.n	813b8 <send_pus_packet_tm+0x94>
			return -1;
   813b2:	f04f 33ff 	mov.w	r3, #4294967295
   813b6:	e074      	b.n	814a2 <send_pus_packet_tm+0x17e>
		low =	(uint32_t)tm_to_downlink[(i * 4)];			// Place the data into the lower 4 bytes of the CAN message.
   813b8:	68fb      	ldr	r3, [r7, #12]
   813ba:	009b      	lsls	r3, r3, #2
   813bc:	4a42      	ldr	r2, [pc, #264]	; (814c8 <send_pus_packet_tm+0x1a4>)
   813be:	5cd3      	ldrb	r3, [r2, r3]
   813c0:	461a      	mov	r2, r3
   813c2:	4b42      	ldr	r3, [pc, #264]	; (814cc <send_pus_packet_tm+0x1a8>)
   813c4:	601a      	str	r2, [r3, #0]
		low += (uint32_t)(tm_to_downlink[(i * 4) + 1] << 8);
   813c6:	68fb      	ldr	r3, [r7, #12]
   813c8:	009b      	lsls	r3, r3, #2
   813ca:	3301      	adds	r3, #1
   813cc:	4a3e      	ldr	r2, [pc, #248]	; (814c8 <send_pus_packet_tm+0x1a4>)
   813ce:	5cd3      	ldrb	r3, [r2, r3]
   813d0:	021b      	lsls	r3, r3, #8
   813d2:	461a      	mov	r2, r3
   813d4:	4b3d      	ldr	r3, [pc, #244]	; (814cc <send_pus_packet_tm+0x1a8>)
   813d6:	681b      	ldr	r3, [r3, #0]
   813d8:	441a      	add	r2, r3
   813da:	4b3c      	ldr	r3, [pc, #240]	; (814cc <send_pus_packet_tm+0x1a8>)
   813dc:	601a      	str	r2, [r3, #0]
		low += (uint32_t)(tm_to_downlink[(i * 4) + 2] << 16);
   813de:	68fb      	ldr	r3, [r7, #12]
   813e0:	009b      	lsls	r3, r3, #2
   813e2:	3302      	adds	r3, #2
   813e4:	4a38      	ldr	r2, [pc, #224]	; (814c8 <send_pus_packet_tm+0x1a4>)
   813e6:	5cd3      	ldrb	r3, [r2, r3]
   813e8:	041b      	lsls	r3, r3, #16
   813ea:	461a      	mov	r2, r3
   813ec:	4b37      	ldr	r3, [pc, #220]	; (814cc <send_pus_packet_tm+0x1a8>)
   813ee:	681b      	ldr	r3, [r3, #0]
   813f0:	441a      	add	r2, r3
   813f2:	4b36      	ldr	r3, [pc, #216]	; (814cc <send_pus_packet_tm+0x1a8>)
   813f4:	601a      	str	r2, [r3, #0]
		low += (uint32_t)(tm_to_downlink[(i * 4) + 3] << 24);
   813f6:	68fb      	ldr	r3, [r7, #12]
   813f8:	009b      	lsls	r3, r3, #2
   813fa:	3303      	adds	r3, #3
   813fc:	4a32      	ldr	r2, [pc, #200]	; (814c8 <send_pus_packet_tm+0x1a4>)
   813fe:	5cd3      	ldrb	r3, [r2, r3]
   81400:	061b      	lsls	r3, r3, #24
   81402:	461a      	mov	r2, r3
   81404:	4b31      	ldr	r3, [pc, #196]	; (814cc <send_pus_packet_tm+0x1a8>)
   81406:	681b      	ldr	r3, [r3, #0]
   81408:	441a      	add	r2, r3
   8140a:	4b30      	ldr	r3, [pc, #192]	; (814cc <send_pus_packet_tm+0x1a8>)
   8140c:	601a      	str	r2, [r3, #0]
		send_tc_can_command(low, i, sender_id, COMS_ID, SEND_TM, COMMAND_PRIO);
   8140e:	4b2f      	ldr	r3, [pc, #188]	; (814cc <send_pus_packet_tm+0x1a8>)
   81410:	6819      	ldr	r1, [r3, #0]
   81412:	68fb      	ldr	r3, [r7, #12]
   81414:	b2da      	uxtb	r2, r3
   81416:	79fb      	ldrb	r3, [r7, #7]
   81418:	200d      	movs	r0, #13
   8141a:	9000      	str	r0, [sp, #0]
   8141c:	2019      	movs	r0, #25
   8141e:	9001      	str	r0, [sp, #4]
   81420:	4608      	mov	r0, r1
   81422:	4611      	mov	r1, r2
   81424:	461a      	mov	r2, r3
   81426:	2300      	movs	r3, #0
   81428:	4c25      	ldr	r4, [pc, #148]	; (814c0 <send_pus_packet_tm+0x19c>)
   8142a:	47a0      	blx	r4
		xLastWakeTime = xTaskGetTickCount();		// Causes a mandatory delay of at least 100ms (10 * 1ms)
   8142c:	4b28      	ldr	r3, [pc, #160]	; (814d0 <send_pus_packet_tm+0x1ac>)
   8142e:	4798      	blx	r3
   81430:	4602      	mov	r2, r0
   81432:	4b28      	ldr	r3, [pc, #160]	; (814d4 <send_pus_packet_tm+0x1b0>)
   81434:	601a      	str	r2, [r3, #0]
		vTaskDelayUntil(&xLastWakeTime, xTimeToWait);
   81436:	4b1f      	ldr	r3, [pc, #124]	; (814b4 <send_pus_packet_tm+0x190>)
   81438:	681b      	ldr	r3, [r3, #0]
   8143a:	4826      	ldr	r0, [pc, #152]	; (814d4 <send_pus_packet_tm+0x1b0>)
   8143c:	4619      	mov	r1, r3
   8143e:	4b26      	ldr	r3, [pc, #152]	; (814d8 <send_pus_packet_tm+0x1b4>)
   81440:	4798      	blx	r3
		send_tc_can_command(0x00, 0x00, sender_id, COMS_ID, TM_PACKET_READY, COMMAND_PRIO);	// Let the SSM know that a TM packet is ready.
		taskYIELD();
	}
	start_tm_transferf = 0;
	
	for(i = 0; i < num_transfers; i++)
   81442:	68fb      	ldr	r3, [r7, #12]
   81444:	3301      	adds	r3, #1
   81446:	60fb      	str	r3, [r7, #12]
   81448:	4b18      	ldr	r3, [pc, #96]	; (814ac <send_pus_packet_tm+0x188>)
   8144a:	681b      	ldr	r3, [r3, #0]
   8144c:	68fa      	ldr	r2, [r7, #12]
   8144e:	429a      	cmp	r2, r3
   81450:	d3ab      	bcc.n	813aa <send_pus_packet_tm+0x86>
		low += (uint32_t)(tm_to_downlink[(i * 4) + 3] << 24);
		send_tc_can_command(low, i, sender_id, COMS_ID, SEND_TM, COMMAND_PRIO);
		xLastWakeTime = xTaskGetTickCount();		// Causes a mandatory delay of at least 100ms (10 * 1ms)
		vTaskDelayUntil(&xLastWakeTime, xTimeToWait);
	}
	timeout = 500;
   81452:	4b17      	ldr	r3, [pc, #92]	; (814b0 <send_pus_packet_tm+0x18c>)
   81454:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
   81458:	801a      	strh	r2, [r3, #0]
	while(!tm_transfer_completef)					// Delay for ~100 ms for the SSM to let the OBC know that
   8145a:	e00c      	b.n	81476 <send_pus_packet_tm+0x152>
	{												// the transfer has completed.
		if(!timeout--)
   8145c:	4b14      	ldr	r3, [pc, #80]	; (814b0 <send_pus_packet_tm+0x18c>)
   8145e:	881b      	ldrh	r3, [r3, #0]
   81460:	1e5a      	subs	r2, r3, #1
   81462:	b291      	uxth	r1, r2
   81464:	4a12      	ldr	r2, [pc, #72]	; (814b0 <send_pus_packet_tm+0x18c>)
   81466:	8011      	strh	r1, [r2, #0]
   81468:	2b00      	cmp	r3, #0
   8146a:	d102      	bne.n	81472 <send_pus_packet_tm+0x14e>
		{
			return -1;			
   8146c:	f04f 33ff 	mov.w	r3, #4294967295
   81470:	e017      	b.n	814a2 <send_pus_packet_tm+0x17e>
		}
		taskYIELD();
   81472:	4b14      	ldr	r3, [pc, #80]	; (814c4 <send_pus_packet_tm+0x1a0>)
   81474:	4798      	blx	r3
		send_tc_can_command(low, i, sender_id, COMS_ID, SEND_TM, COMMAND_PRIO);
		xLastWakeTime = xTaskGetTickCount();		// Causes a mandatory delay of at least 100ms (10 * 1ms)
		vTaskDelayUntil(&xLastWakeTime, xTimeToWait);
	}
	timeout = 500;
	while(!tm_transfer_completef)					// Delay for ~100 ms for the SSM to let the OBC know that
   81476:	4b10      	ldr	r3, [pc, #64]	; (814b8 <send_pus_packet_tm+0x194>)
   81478:	781b      	ldrb	r3, [r3, #0]
   8147a:	2b00      	cmp	r3, #0
   8147c:	d0ee      	beq.n	8145c <send_pus_packet_tm+0x138>
			return -1;			
		}
		taskYIELD();
	}
	
	if(tm_transfer_completef != (PACKET_LENGTH / 4) - 1)
   8147e:	4b0e      	ldr	r3, [pc, #56]	; (814b8 <send_pus_packet_tm+0x194>)
   81480:	781b      	ldrb	r3, [r3, #0]
   81482:	2b25      	cmp	r3, #37	; 0x25
   81484:	d005      	beq.n	81492 <send_pus_packet_tm+0x16e>
	{
		tm_transfer_completef = 0;
   81486:	4b0c      	ldr	r3, [pc, #48]	; (814b8 <send_pus_packet_tm+0x194>)
   81488:	2200      	movs	r2, #0
   8148a:	701a      	strb	r2, [r3, #0]
		return -1;
   8148c:	f04f 33ff 	mov.w	r3, #4294967295
   81490:	e007      	b.n	814a2 <send_pus_packet_tm+0x17e>
	}
	else
	{
		tm_transfer_completef = 0;
   81492:	4b09      	ldr	r3, [pc, #36]	; (814b8 <send_pus_packet_tm+0x194>)
   81494:	2200      	movs	r2, #0
   81496:	701a      	strb	r2, [r3, #0]
		tm_down_fullf = 0;
   81498:	4b10      	ldr	r3, [pc, #64]	; (814dc <send_pus_packet_tm+0x1b8>)
   8149a:	2200      	movs	r2, #0
   8149c:	701a      	strb	r2, [r3, #0]
		return tm_transfer_completef;
   8149e:	4b06      	ldr	r3, [pc, #24]	; (814b8 <send_pus_packet_tm+0x194>)
   814a0:	781b      	ldrb	r3, [r3, #0]
	}
}
   814a2:	4618      	mov	r0, r3
   814a4:	3714      	adds	r7, #20
   814a6:	46bd      	mov	sp, r7
   814a8:	bd90      	pop	{r4, r7, pc}
   814aa:	bf00      	nop
   814ac:	200705b0 	.word	0x200705b0
   814b0:	200705b4 	.word	0x200705b4
   814b4:	200705bc 	.word	0x200705bc
   814b8:	2007b4e0 	.word	0x2007b4e0
   814bc:	2007aef1 	.word	0x2007aef1
   814c0:	00089285 	.word	0x00089285
   814c4:	0008645d 	.word	0x0008645d
   814c8:	200707b0 	.word	0x200707b0
   814cc:	200705a4 	.word	0x200705a4
   814d0:	00087771 	.word	0x00087771
   814d4:	200705b8 	.word	0x200705b8
   814d8:	000874b5 	.word	0x000874b5
   814dc:	2007b551 	.word	0x2007b551

000814e0 <send_tc_transaction_response>:
/* incoming TC chunk was okay, and then sends a CAN message to the SSM	*/
/* to let it know.														*/
/* @param: code: The status of the transac response.					*/
/************************************************************************/
static void send_tc_transaction_response(uint8_t code)
{
   814e0:	b590      	push	{r4, r7, lr}
   814e2:	b087      	sub	sp, #28
   814e4:	af02      	add	r7, sp, #8
   814e6:	4603      	mov	r3, r0
   814e8:	71fb      	strb	r3, [r7, #7]
	uint32_t low;
	low = (uint32_t)code;	
   814ea:	79fb      	ldrb	r3, [r7, #7]
   814ec:	60fb      	str	r3, [r7, #12]
	send_tc_can_command(low, CURRENT_MINUTE, OBC_PACKET_ROUTER_ID, COMS_ID, TC_TRANSACTION_RESP, COMMAND_PRIO);
   814ee:	4b08      	ldr	r3, [pc, #32]	; (81510 <send_tc_transaction_response+0x30>)
   814f0:	781b      	ldrb	r3, [r3, #0]
   814f2:	2214      	movs	r2, #20
   814f4:	9200      	str	r2, [sp, #0]
   814f6:	2219      	movs	r2, #25
   814f8:	9201      	str	r2, [sp, #4]
   814fa:	68f8      	ldr	r0, [r7, #12]
   814fc:	4619      	mov	r1, r3
   814fe:	220a      	movs	r2, #10
   81500:	2300      	movs	r3, #0
   81502:	4c04      	ldr	r4, [pc, #16]	; (81514 <send_tc_transaction_response+0x34>)
   81504:	47a0      	blx	r4
	return;
   81506:	bf00      	nop
}
   81508:	3714      	adds	r7, #20
   8150a:	46bd      	mov	sp, r7
   8150c:	bd90      	pop	{r4, r7, pc}
   8150e:	bf00      	nop
   81510:	2007b108 	.word	0x2007b108
   81514:	00089285 	.word	0x00089285

00081518 <clear_current_tc>:
/************************************************************************/
/* CLEAR_CURRENT_TC		                                                */
/* @Purpose: clears the array current_tc[]								*/
/************************************************************************/
static void clear_current_tc(void)
{
   81518:	b480      	push	{r7}
   8151a:	b083      	sub	sp, #12
   8151c:	af00      	add	r7, sp, #0
	uint8_t i;
	for(i = 0; i < PACKET_LENGTH; i++)
   8151e:	2300      	movs	r3, #0
   81520:	71fb      	strb	r3, [r7, #7]
   81522:	e006      	b.n	81532 <clear_current_tc+0x1a>
	{
		current_tc[i] = 0;
   81524:	79fb      	ldrb	r3, [r7, #7]
   81526:	4a07      	ldr	r2, [pc, #28]	; (81544 <clear_current_tc+0x2c>)
   81528:	2100      	movs	r1, #0
   8152a:	54d1      	strb	r1, [r2, r3]
/* @Purpose: clears the array current_tc[]								*/
/************************************************************************/
static void clear_current_tc(void)
{
	uint8_t i;
	for(i = 0; i < PACKET_LENGTH; i++)
   8152c:	79fb      	ldrb	r3, [r7, #7]
   8152e:	3301      	adds	r3, #1
   81530:	71fb      	strb	r3, [r7, #7]
   81532:	79fb      	ldrb	r3, [r7, #7]
   81534:	2b97      	cmp	r3, #151	; 0x97
   81536:	d9f5      	bls.n	81524 <clear_current_tc+0xc>
	{
		current_tc[i] = 0;
	}
	return;
   81538:	bf00      	nop
}
   8153a:	370c      	adds	r7, #12
   8153c:	46bd      	mov	sp, r7
   8153e:	f85d 7b04 	ldr.w	r7, [sp], #4
   81542:	4770      	bx	lr
   81544:	200705e8 	.word	0x200705e8

00081548 <clear_current_data>:
/************************************************************************/
/* CLEAR_CURRENT_DATA		                                            */
/* @Purpose: clears the array current_data[]							*/
/************************************************************************/
static void clear_current_data(void)
{
   81548:	b480      	push	{r7}
   8154a:	b083      	sub	sp, #12
   8154c:	af00      	add	r7, sp, #0
	uint8_t i;
	for(i = 0; i < DATA_LENGTH; i++)
   8154e:	2300      	movs	r3, #0
   81550:	71fb      	strb	r3, [r7, #7]
   81552:	e006      	b.n	81562 <clear_current_data+0x1a>
	{
		current_data[i] = 0;
   81554:	79fb      	ldrb	r3, [r7, #7]
   81556:	4a07      	ldr	r2, [pc, #28]	; (81574 <clear_current_data+0x2c>)
   81558:	2100      	movs	r1, #0
   8155a:	54d1      	strb	r1, [r2, r3]
/* @Purpose: clears the array current_data[]							*/
/************************************************************************/
static void clear_current_data(void)
{
	uint8_t i;
	for(i = 0; i < DATA_LENGTH; i++)
   8155c:	79fb      	ldrb	r3, [r7, #7]
   8155e:	3301      	adds	r3, #1
   81560:	71fb      	strb	r3, [r7, #7]
   81562:	79fb      	ldrb	r3, [r7, #7]
   81564:	2b88      	cmp	r3, #136	; 0x88
   81566:	d9f5      	bls.n	81554 <clear_current_data+0xc>
	{
		current_data[i] = 0;
	}
	return;
   81568:	bf00      	nop
}
   8156a:	370c      	adds	r7, #12
   8156c:	46bd      	mov	sp, r7
   8156e:	f85d 7b04 	ldr.w	r7, [sp], #4
   81572:	4770      	bx	lr
   81574:	20070480 	.word	0x20070480

00081578 <clear_current_command>:
/************************************************************************/
/* CLEAR_CURRENT_COMMAND	                                            */
/* @Purpose: clears the array current_command[]							*/
/************************************************************************/
static void clear_current_command(void)
{
   81578:	b480      	push	{r7}
   8157a:	b083      	sub	sp, #12
   8157c:	af00      	add	r7, sp, #0
	uint8_t i;
	for(i = 0; i < (DATA_LENGTH + 10); i++)
   8157e:	2300      	movs	r3, #0
   81580:	71fb      	strb	r3, [r7, #7]
   81582:	e006      	b.n	81592 <clear_current_command+0x1a>
	{
		current_command[i] = 0;
   81584:	79fb      	ldrb	r3, [r7, #7]
   81586:	4a07      	ldr	r2, [pc, #28]	; (815a4 <clear_current_command+0x2c>)
   81588:	2100      	movs	r1, #0
   8158a:	54d1      	strb	r1, [r2, r3]
/* @Purpose: clears the array current_command[]							*/
/************************************************************************/
static void clear_current_command(void)
{
	uint8_t i;
	for(i = 0; i < (DATA_LENGTH + 10); i++)
   8158c:	79fb      	ldrb	r3, [r7, #7]
   8158e:	3301      	adds	r3, #1
   81590:	71fb      	strb	r3, [r7, #7]
   81592:	79fb      	ldrb	r3, [r7, #7]
   81594:	2b92      	cmp	r3, #146	; 0x92
   81596:	d9f5      	bls.n	81584 <clear_current_command+0xc>
	{
		current_command[i] = 0;
	}
	return;
   81598:	bf00      	nop
}
   8159a:	370c      	adds	r7, #12
   8159c:	46bd      	mov	sp, r7
   8159e:	f85d 7b04 	ldr.w	r7, [sp], #4
   815a2:	4770      	bx	lr
   815a4:	2007050c 	.word	0x2007050c

000815a8 <store_current_tc>:
/************************************************************************/
/* STORE_CURRENT_TC			                                            */
/* @Purpose: copies the contents of current_tc[] into the tc_buffer		*/
/************************************************************************/
static int store_current_tc(void)
{
   815a8:	b598      	push	{r3, r4, r7, lr}
   815aa:	af00      	add	r7, sp, #0
//
	//CURRENT_TC_PACKET += 152;
	//if(CURRENT_TC_PACKET > (TC_BASE + 0x20000))
		//CURRENT_TC_PACKET = TC_BASE + 12;
	//spimem_write(TC_BASE + 8, &CURRENT_TC_PACKET, 4);
	if(xQueueSendToBack(tc_buffer, current_tc, (TickType_t)1) != pdPASS)
   815ac:	4b0c      	ldr	r3, [pc, #48]	; (815e0 <store_current_tc+0x38>)
   815ae:	681b      	ldr	r3, [r3, #0]
   815b0:	4618      	mov	r0, r3
   815b2:	490c      	ldr	r1, [pc, #48]	; (815e4 <store_current_tc+0x3c>)
   815b4:	2201      	movs	r2, #1
   815b6:	2300      	movs	r3, #0
   815b8:	4c0b      	ldr	r4, [pc, #44]	; (815e8 <store_current_tc+0x40>)
   815ba:	47a0      	blx	r4
   815bc:	4603      	mov	r3, r0
   815be:	2b01      	cmp	r3, #1
   815c0:	d008      	beq.n	815d4 <store_current_tc+0x2c>
	{
		send_event_report(1, TC_BUFFER_FULL, 0, 0);		// FAILURE_RECOVERY
   815c2:	2001      	movs	r0, #1
   815c4:	2127      	movs	r1, #39	; 0x27
   815c6:	2200      	movs	r2, #0
   815c8:	2300      	movs	r3, #0
   815ca:	4c08      	ldr	r4, [pc, #32]	; (815ec <store_current_tc+0x44>)
   815cc:	47a0      	blx	r4
		return -1;
   815ce:	f04f 33ff 	mov.w	r3, #4294967295
   815d2:	e003      	b.n	815dc <store_current_tc+0x34>
	}
	current_tc_fullf = 0;
   815d4:	4b06      	ldr	r3, [pc, #24]	; (815f0 <store_current_tc+0x48>)
   815d6:	2200      	movs	r2, #0
   815d8:	701a      	strb	r2, [r3, #0]
	return 1;
   815da:	2301      	movs	r3, #1
}
   815dc:	4618      	mov	r0, r3
   815de:	bd98      	pop	{r3, r4, r7, pc}
   815e0:	2007b4f8 	.word	0x2007b4f8
   815e4:	200705e8 	.word	0x200705e8
   815e8:	00086b01 	.word	0x00086b01
   815ec:	000826f1 	.word	0x000826f1
   815f0:	2007ada9 	.word	0x2007ada9

000815f4 <store_current_tm>:
/************************************************************************/
/* STORE_CURRENT_TM			                                            */
/* @Purpose: copies the contents of current_tc[] into the tc_buffer		*/
/************************************************************************/
static int store_current_tm(void)
{
   815f4:	b598      	push	{r3, r4, r7, lr}
   815f6:	af00      	add	r7, sp, #0
	//spimem_write(TM_BASE + 8, &CURRENT_TM_PACKET, 4);		// FAILURE_RECOVERY
//
	//if(spimem_write(CURRENT_TM_PACKET, current_tm, 152) < 0)					// FAILURE_RECOVERY
		//return -1;
	//current_tm_fullf = 0;
	if(xQueueSendToBack(tm_buffer, current_tm, (TickType_t)1) != pdPASS)
   815f8:	4b09      	ldr	r3, [pc, #36]	; (81620 <store_current_tm+0x2c>)
   815fa:	681b      	ldr	r3, [r3, #0]
   815fc:	4618      	mov	r0, r3
   815fe:	4909      	ldr	r1, [pc, #36]	; (81624 <store_current_tm+0x30>)
   81600:	2201      	movs	r2, #1
   81602:	2300      	movs	r3, #0
   81604:	4c08      	ldr	r4, [pc, #32]	; (81628 <store_current_tm+0x34>)
   81606:	47a0      	blx	r4
   81608:	4603      	mov	r3, r0
   8160a:	2b01      	cmp	r3, #1
   8160c:	d002      	beq.n	81614 <store_current_tm+0x20>
	{
		return -1;										// FAILURE_RECOVERY
   8160e:	f04f 33ff 	mov.w	r3, #4294967295
   81612:	e003      	b.n	8161c <store_current_tm+0x28>
	}
	current_tm_fullf = 0;
   81614:	4b05      	ldr	r3, [pc, #20]	; (8162c <store_current_tm+0x38>)
   81616:	2200      	movs	r2, #0
   81618:	701a      	strb	r2, [r3, #0]
	return 1;
   8161a:	2301      	movs	r3, #1
}
   8161c:	4618      	mov	r0, r3
   8161e:	bd98      	pop	{r3, r4, r7, pc}
   81620:	2007b500 	.word	0x2007b500
   81624:	20070680 	.word	0x20070680
   81628:	00086b01 	.word	0x00086b01
   8162c:	2007b4ed 	.word	0x2007b4ed

00081630 <decode_telecommand>:
/* route a message to a task or send a CAN message to an SSM			*/
/* @Note: This function assumes that the telecommand to decode is		*/
/* contained in tc_to_decode[]											*/
/************************************************************************/
static int decode_telecommand(void)
{
   81630:	b5f0      	push	{r4, r5, r6, r7, lr}
   81632:	b089      	sub	sp, #36	; 0x24
   81634:	af06      	add	r7, sp, #24
	uint8_t i; //, test = 0;
	int x, attempts;
	
	packet_id = (uint16_t)(tc_to_decode[151]);
   81636:	4b74      	ldr	r3, [pc, #464]	; (81808 <decode_telecommand+0x1d8>)
   81638:	f893 3097 	ldrb.w	r3, [r3, #151]	; 0x97
   8163c:	461a      	mov	r2, r3
   8163e:	4b73      	ldr	r3, [pc, #460]	; (8180c <decode_telecommand+0x1dc>)
   81640:	801a      	strh	r2, [r3, #0]
	packet_id = packet_id << 8;
   81642:	4b72      	ldr	r3, [pc, #456]	; (8180c <decode_telecommand+0x1dc>)
   81644:	881b      	ldrh	r3, [r3, #0]
   81646:	021b      	lsls	r3, r3, #8
   81648:	b29a      	uxth	r2, r3
   8164a:	4b70      	ldr	r3, [pc, #448]	; (8180c <decode_telecommand+0x1dc>)
   8164c:	801a      	strh	r2, [r3, #0]
	packet_id |= (uint16_t)(tc_to_decode[150]);
   8164e:	4b6e      	ldr	r3, [pc, #440]	; (81808 <decode_telecommand+0x1d8>)
   81650:	f893 3096 	ldrb.w	r3, [r3, #150]	; 0x96
   81654:	461a      	mov	r2, r3
   81656:	4b6d      	ldr	r3, [pc, #436]	; (8180c <decode_telecommand+0x1dc>)
   81658:	881b      	ldrh	r3, [r3, #0]
   8165a:	4313      	orrs	r3, r2
   8165c:	b29a      	uxth	r2, r3
   8165e:	4b6b      	ldr	r3, [pc, #428]	; (8180c <decode_telecommand+0x1dc>)
   81660:	801a      	strh	r2, [r3, #0]
	psc = (uint16_t)(tc_to_decode[149]);
   81662:	4b69      	ldr	r3, [pc, #420]	; (81808 <decode_telecommand+0x1d8>)
   81664:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
   81668:	461a      	mov	r2, r3
   8166a:	4b69      	ldr	r3, [pc, #420]	; (81810 <decode_telecommand+0x1e0>)
   8166c:	801a      	strh	r2, [r3, #0]
	psc = psc << 8;
   8166e:	4b68      	ldr	r3, [pc, #416]	; (81810 <decode_telecommand+0x1e0>)
   81670:	881b      	ldrh	r3, [r3, #0]
   81672:	021b      	lsls	r3, r3, #8
   81674:	b29a      	uxth	r2, r3
   81676:	4b66      	ldr	r3, [pc, #408]	; (81810 <decode_telecommand+0x1e0>)
   81678:	801a      	strh	r2, [r3, #0]
	psc |= (uint16_t)(tc_to_decode[148]);
   8167a:	4b63      	ldr	r3, [pc, #396]	; (81808 <decode_telecommand+0x1d8>)
   8167c:	f893 3094 	ldrb.w	r3, [r3, #148]	; 0x94
   81680:	461a      	mov	r2, r3
   81682:	4b63      	ldr	r3, [pc, #396]	; (81810 <decode_telecommand+0x1e0>)
   81684:	881b      	ldrh	r3, [r3, #0]
   81686:	4313      	orrs	r3, r2
   81688:	b29a      	uxth	r2, r3
   8168a:	4b61      	ldr	r3, [pc, #388]	; (81810 <decode_telecommand+0x1e0>)
   8168c:	801a      	strh	r2, [r3, #0]
	
	// PACKET HEADER
	version1			= (tc_to_decode[151] & 0xE0) >> 5;
   8168e:	4b5e      	ldr	r3, [pc, #376]	; (81808 <decode_telecommand+0x1d8>)
   81690:	f893 3097 	ldrb.w	r3, [r3, #151]	; 0x97
   81694:	095b      	lsrs	r3, r3, #5
   81696:	b2da      	uxtb	r2, r3
   81698:	4b5e      	ldr	r3, [pc, #376]	; (81814 <decode_telecommand+0x1e4>)
   8169a:	701a      	strb	r2, [r3, #0]
	type1				= (tc_to_decode[151] & 0x10) >> 4;
   8169c:	4b5a      	ldr	r3, [pc, #360]	; (81808 <decode_telecommand+0x1d8>)
   8169e:	f893 3097 	ldrb.w	r3, [r3, #151]	; 0x97
   816a2:	f003 0310 	and.w	r3, r3, #16
   816a6:	111b      	asrs	r3, r3, #4
   816a8:	b2da      	uxtb	r2, r3
   816aa:	4b5b      	ldr	r3, [pc, #364]	; (81818 <decode_telecommand+0x1e8>)
   816ac:	701a      	strb	r2, [r3, #0]
	data_field_headerf	= (tc_to_decode[151] & 0x08) >> 3;
   816ae:	4b56      	ldr	r3, [pc, #344]	; (81808 <decode_telecommand+0x1d8>)
   816b0:	f893 3097 	ldrb.w	r3, [r3, #151]	; 0x97
   816b4:	f003 0308 	and.w	r3, r3, #8
   816b8:	10db      	asrs	r3, r3, #3
   816ba:	b2da      	uxtb	r2, r3
   816bc:	4b57      	ldr	r3, [pc, #348]	; (8181c <decode_telecommand+0x1ec>)
   816be:	701a      	strb	r2, [r3, #0]
	apid				= tc_to_decode[150];
   816c0:	4b51      	ldr	r3, [pc, #324]	; (81808 <decode_telecommand+0x1d8>)
   816c2:	f893 2096 	ldrb.w	r2, [r3, #150]	; 0x96
   816c6:	4b56      	ldr	r3, [pc, #344]	; (81820 <decode_telecommand+0x1f0>)
   816c8:	701a      	strb	r2, [r3, #0]
	sequence_flags1		= (tc_to_decode[149] & 0xC0) >> 6;
   816ca:	4b4f      	ldr	r3, [pc, #316]	; (81808 <decode_telecommand+0x1d8>)
   816cc:	f893 3095 	ldrb.w	r3, [r3, #149]	; 0x95
   816d0:	099b      	lsrs	r3, r3, #6
   816d2:	b2da      	uxtb	r2, r3
   816d4:	4b53      	ldr	r3, [pc, #332]	; (81824 <decode_telecommand+0x1f4>)
   816d6:	701a      	strb	r2, [r3, #0]
	sequence_count1		= tc_to_decode[148];
   816d8:	4b4b      	ldr	r3, [pc, #300]	; (81808 <decode_telecommand+0x1d8>)
   816da:	f893 2094 	ldrb.w	r2, [r3, #148]	; 0x94
   816de:	4b52      	ldr	r3, [pc, #328]	; (81828 <decode_telecommand+0x1f8>)
   816e0:	701a      	strb	r2, [r3, #0]
	packet_length		= tc_to_decode[146] + 1;				// B137 = PACKET_LENGTH - 1
   816e2:	4b49      	ldr	r3, [pc, #292]	; (81808 <decode_telecommand+0x1d8>)
   816e4:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
   816e8:	3301      	adds	r3, #1
   816ea:	b2da      	uxtb	r2, r3
   816ec:	4b4f      	ldr	r3, [pc, #316]	; (8182c <decode_telecommand+0x1fc>)
   816ee:	701a      	strb	r2, [r3, #0]
	// DATA FIELD HEADER
	ccsds_flag			= (tc_to_decode[145] & 0X80) >> 7;
   816f0:	4b45      	ldr	r3, [pc, #276]	; (81808 <decode_telecommand+0x1d8>)
   816f2:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
   816f6:	09db      	lsrs	r3, r3, #7
   816f8:	b2da      	uxtb	r2, r3
   816fa:	4b4d      	ldr	r3, [pc, #308]	; (81830 <decode_telecommand+0x200>)
   816fc:	701a      	strb	r2, [r3, #0]
	packet_version		= (tc_to_decode[145] & 0X70) >> 4;
   816fe:	4b42      	ldr	r3, [pc, #264]	; (81808 <decode_telecommand+0x1d8>)
   81700:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
   81704:	f003 0370 	and.w	r3, r3, #112	; 0x70
   81708:	111b      	asrs	r3, r3, #4
   8170a:	b2da      	uxtb	r2, r3
   8170c:	4b49      	ldr	r3, [pc, #292]	; (81834 <decode_telecommand+0x204>)
   8170e:	701a      	strb	r2, [r3, #0]
	ack					= tc_to_decode[145] & 0X0F;
   81710:	4b3d      	ldr	r3, [pc, #244]	; (81808 <decode_telecommand+0x1d8>)
   81712:	f893 3091 	ldrb.w	r3, [r3, #145]	; 0x91
   81716:	f003 030f 	and.w	r3, r3, #15
   8171a:	b2da      	uxtb	r2, r3
   8171c:	4b46      	ldr	r3, [pc, #280]	; (81838 <decode_telecommand+0x208>)
   8171e:	701a      	strb	r2, [r3, #0]
	service_type		= tc_to_decode[144];
   81720:	4b39      	ldr	r3, [pc, #228]	; (81808 <decode_telecommand+0x1d8>)
   81722:	f893 2090 	ldrb.w	r2, [r3, #144]	; 0x90
   81726:	4b45      	ldr	r3, [pc, #276]	; (8183c <decode_telecommand+0x20c>)
   81728:	701a      	strb	r2, [r3, #0]
	service_sub_type	= tc_to_decode[143];
   8172a:	4b37      	ldr	r3, [pc, #220]	; (81808 <decode_telecommand+0x1d8>)
   8172c:	f893 208f 	ldrb.w	r2, [r3, #143]	; 0x8f
   81730:	4b43      	ldr	r3, [pc, #268]	; (81840 <decode_telecommand+0x210>)
   81732:	701a      	strb	r2, [r3, #0]
	source_id			= tc_to_decode[142];
   81734:	4b34      	ldr	r3, [pc, #208]	; (81808 <decode_telecommand+0x1d8>)
   81736:	f893 208e 	ldrb.w	r2, [r3, #142]	; 0x8e
   8173a:	4b42      	ldr	r3, [pc, #264]	; (81844 <decode_telecommand+0x214>)
   8173c:	701a      	strb	r2, [r3, #0]
	
	pec1 = (uint16_t)(tc_to_decode[1]);
   8173e:	4b32      	ldr	r3, [pc, #200]	; (81808 <decode_telecommand+0x1d8>)
   81740:	785b      	ldrb	r3, [r3, #1]
   81742:	461a      	mov	r2, r3
   81744:	4b40      	ldr	r3, [pc, #256]	; (81848 <decode_telecommand+0x218>)
   81746:	801a      	strh	r2, [r3, #0]
	pec1 = pec1 << 8;
   81748:	4b3f      	ldr	r3, [pc, #252]	; (81848 <decode_telecommand+0x218>)
   8174a:	881b      	ldrh	r3, [r3, #0]
   8174c:	021b      	lsls	r3, r3, #8
   8174e:	b29a      	uxth	r2, r3
   81750:	4b3d      	ldr	r3, [pc, #244]	; (81848 <decode_telecommand+0x218>)
   81752:	801a      	strh	r2, [r3, #0]
	pec1 += (uint16_t)(tc_to_decode[0]);
   81754:	4b2c      	ldr	r3, [pc, #176]	; (81808 <decode_telecommand+0x1d8>)
   81756:	781b      	ldrb	r3, [r3, #0]
   81758:	461a      	mov	r2, r3
   8175a:	4b3b      	ldr	r3, [pc, #236]	; (81848 <decode_telecommand+0x218>)
   8175c:	881b      	ldrh	r3, [r3, #0]
   8175e:	4413      	add	r3, r2
   81760:	b29a      	uxth	r2, r3
   81762:	4b39      	ldr	r3, [pc, #228]	; (81848 <decode_telecommand+0x218>)
   81764:	801a      	strh	r2, [r3, #0]
	//{
		//test = tc_to_decode[i];
	//}
	
	/* Check that the packet error control is correct		*/
	pec0 = fletcher16(tc_to_decode + 2, 150);
   81766:	4839      	ldr	r0, [pc, #228]	; (8184c <decode_telecommand+0x21c>)
   81768:	2196      	movs	r1, #150	; 0x96
   8176a:	4b39      	ldr	r3, [pc, #228]	; (81850 <decode_telecommand+0x220>)
   8176c:	4798      	blx	r3
   8176e:	4603      	mov	r3, r0
   81770:	461a      	mov	r2, r3
   81772:	4b38      	ldr	r3, [pc, #224]	; (81854 <decode_telecommand+0x224>)
   81774:	801a      	strh	r2, [r3, #0]
	/* Verify that the telecommand is ready to be decoded.	*/
	
	attempts = 0; x = -1;
   81776:	2300      	movs	r3, #0
   81778:	603b      	str	r3, [r7, #0]
   8177a:	f04f 33ff 	mov.w	r3, #4294967295
   8177e:	607b      	str	r3, [r7, #4]
	while (attempts<3 && x<0){
   81780:	e020      	b.n	817c4 <decode_telecommand+0x194>
		x = verify_telecommand(apid, packet_length, pec0, pec1, service_type, service_sub_type, version1, ccsds_flag, packet_version);		// FAILURE_RECOVERY required if x == -1.
   81782:	4b27      	ldr	r3, [pc, #156]	; (81820 <decode_telecommand+0x1f0>)
   81784:	7818      	ldrb	r0, [r3, #0]
   81786:	4b29      	ldr	r3, [pc, #164]	; (8182c <decode_telecommand+0x1fc>)
   81788:	7819      	ldrb	r1, [r3, #0]
   8178a:	4b32      	ldr	r3, [pc, #200]	; (81854 <decode_telecommand+0x224>)
   8178c:	881a      	ldrh	r2, [r3, #0]
   8178e:	4b2e      	ldr	r3, [pc, #184]	; (81848 <decode_telecommand+0x218>)
   81790:	881b      	ldrh	r3, [r3, #0]
   81792:	4c2a      	ldr	r4, [pc, #168]	; (8183c <decode_telecommand+0x20c>)
   81794:	f894 c000 	ldrb.w	ip, [r4]
   81798:	4c29      	ldr	r4, [pc, #164]	; (81840 <decode_telecommand+0x210>)
   8179a:	f894 e000 	ldrb.w	lr, [r4]
   8179e:	4c1d      	ldr	r4, [pc, #116]	; (81814 <decode_telecommand+0x1e4>)
   817a0:	7826      	ldrb	r6, [r4, #0]
   817a2:	4c23      	ldr	r4, [pc, #140]	; (81830 <decode_telecommand+0x200>)
   817a4:	7825      	ldrb	r5, [r4, #0]
   817a6:	4c23      	ldr	r4, [pc, #140]	; (81834 <decode_telecommand+0x204>)
   817a8:	7824      	ldrb	r4, [r4, #0]
   817aa:	f8cd c000 	str.w	ip, [sp]
   817ae:	f8cd e004 	str.w	lr, [sp, #4]
   817b2:	9602      	str	r6, [sp, #8]
   817b4:	9503      	str	r5, [sp, #12]
   817b6:	9404      	str	r4, [sp, #16]
   817b8:	4c27      	ldr	r4, [pc, #156]	; (81858 <decode_telecommand+0x228>)
   817ba:	47a0      	blx	r4
   817bc:	6078      	str	r0, [r7, #4]
		attempts++;
   817be:	683b      	ldr	r3, [r7, #0]
   817c0:	3301      	adds	r3, #1
   817c2:	603b      	str	r3, [r7, #0]
	/* Check that the packet error control is correct		*/
	pec0 = fletcher16(tc_to_decode + 2, 150);
	/* Verify that the telecommand is ready to be decoded.	*/
	
	attempts = 0; x = -1;
	while (attempts<3 && x<0){
   817c4:	683b      	ldr	r3, [r7, #0]
   817c6:	2b02      	cmp	r3, #2
   817c8:	dc02      	bgt.n	817d0 <decode_telecommand+0x1a0>
   817ca:	687b      	ldr	r3, [r7, #4]
   817cc:	2b00      	cmp	r3, #0
   817ce:	dbd8      	blt.n	81782 <decode_telecommand+0x152>
		x = verify_telecommand(apid, packet_length, pec0, pec1, service_type, service_sub_type, version1, ccsds_flag, packet_version);		// FAILURE_RECOVERY required if x == -1.
		attempts++;
	}
	if(x < 0)
   817d0:	687b      	ldr	r3, [r7, #4]
   817d2:	2b00      	cmp	r3, #0
   817d4:	da0a      	bge.n	817ec <decode_telecommand+0x1bc>
	{	
		errorREPORT(OBC_ID, service_type, OBC_TC_PACKET_ERROR, 0);
   817d6:	4b19      	ldr	r3, [pc, #100]	; (8183c <decode_telecommand+0x20c>)
   817d8:	781b      	ldrb	r3, [r3, #0]
   817da:	2003      	movs	r0, #3
   817dc:	4619      	mov	r1, r3
   817de:	221a      	movs	r2, #26
   817e0:	2300      	movs	r3, #0
   817e2:	4c1e      	ldr	r4, [pc, #120]	; (8185c <decode_telecommand+0x22c>)
   817e4:	47a0      	blx	r4
		return -1;
   817e6:	f04f 33ff 	mov.w	r3, #4294967295
   817ea:	e008      	b.n	817fe <decode_telecommand+0x1ce>
	}
	/* Decode the telecommand packet						*/		// To be updated on a rolling basis
	return decode_telecommand_h(service_type, service_sub_type);
   817ec:	4b13      	ldr	r3, [pc, #76]	; (8183c <decode_telecommand+0x20c>)
   817ee:	781a      	ldrb	r2, [r3, #0]
   817f0:	4b13      	ldr	r3, [pc, #76]	; (81840 <decode_telecommand+0x210>)
   817f2:	781b      	ldrb	r3, [r3, #0]
   817f4:	4610      	mov	r0, r2
   817f6:	4619      	mov	r1, r3
   817f8:	4b19      	ldr	r3, [pc, #100]	; (81860 <decode_telecommand+0x230>)
   817fa:	4798      	blx	r3
   817fc:	4603      	mov	r3, r0
}
   817fe:	4618      	mov	r0, r3
   81800:	370c      	adds	r7, #12
   81802:	46bd      	mov	sp, r7
   81804:	bdf0      	pop	{r4, r5, r6, r7, pc}
   81806:	bf00      	nop
   81808:	20070718 	.word	0x20070718
   8180c:	2007045e 	.word	0x2007045e
   81810:	20070460 	.word	0x20070460
   81814:	200705cc 	.word	0x200705cc
   81818:	200705cd 	.word	0x200705cd
   8181c:	200705c0 	.word	0x200705c0
   81820:	200705c1 	.word	0x200705c1
   81824:	200705ce 	.word	0x200705ce
   81828:	200705cf 	.word	0x200705cf
   8182c:	200705c2 	.word	0x200705c2
   81830:	200705d0 	.word	0x200705d0
   81834:	200705d1 	.word	0x200705d1
   81838:	200705c8 	.word	0x200705c8
   8183c:	200705c9 	.word	0x200705c9
   81840:	200705ca 	.word	0x200705ca
   81844:	200705cb 	.word	0x200705cb
   81848:	200705c4 	.word	0x200705c4
   8184c:	2007071a 	.word	0x2007071a
   81850:	00082aa5 	.word	0x00082aa5
   81854:	200705c6 	.word	0x200705c6
   81858:	00081f6d 	.word	0x00081f6d
   8185c:	00080895 	.word	0x00080895
   81860:	00081865 	.word	0x00081865

00081864 <decode_telecommand_h>:
/* executing of required actions.										*/
/* @param: service_type: ex: Housekeeping = 3.							*/
/* @param: service_sub_type: ex: TC Verification, success == 1			*/
/************************************************************************/
static int decode_telecommand_h(uint8_t service_type, uint8_t service_sub_type)
{	
   81864:	b590      	push	{r4, r7, lr}
   81866:	b08b      	sub	sp, #44	; 0x2c
   81868:	af04      	add	r7, sp, #16
   8186a:	4602      	mov	r2, r0
   8186c:	460b      	mov	r3, r1
   8186e:	71fa      	strb	r2, [r7, #7]
   81870:	71bb      	strb	r3, [r7, #6]
	sID = 0xFF;
   81872:	4ba0      	ldr	r3, [pc, #640]	; (81af4 <decode_telecommand_h+0x290>)
   81874:	22ff      	movs	r2, #255	; 0xff
   81876:	701a      	strb	r2, [r3, #0]
	collection_interval = 0;
   81878:	4b9f      	ldr	r3, [pc, #636]	; (81af8 <decode_telecommand_h+0x294>)
   8187a:	2200      	movs	r2, #0
   8187c:	701a      	strb	r2, [r3, #0]
	npar1 = 0;
   8187e:	4b9f      	ldr	r3, [pc, #636]	; (81afc <decode_telecommand_h+0x298>)
   81880:	2200      	movs	r2, #0
   81882:	701a      	strb	r2, [r3, #0]
	uint8_t i; //severity=0;
	uint32_t val = 0;
   81884:	2300      	movs	r3, #0
   81886:	613b      	str	r3, [r7, #16]
	uint32_t time = 0;
   81888:	2300      	movs	r3, #0
   8188a:	60fb      	str	r3, [r7, #12]
	int status = 0;
   8188c:	2300      	movs	r3, #0
   8188e:	60bb      	str	r3, [r7, #8]
	clear_current_command();
   81890:	4b9b      	ldr	r3, [pc, #620]	; (81b00 <decode_telecommand_h+0x29c>)
   81892:	4798      	blx	r3
	for(i = 0; i < DATA_LENGTH; i++)
   81894:	2300      	movs	r3, #0
   81896:	75fb      	strb	r3, [r7, #23]
   81898:	e009      	b.n	818ae <decode_telecommand_h+0x4a>
	{
		current_command[i] = tc_to_decode[i + 2];
   8189a:	7dfb      	ldrb	r3, [r7, #23]
   8189c:	7dfa      	ldrb	r2, [r7, #23]
   8189e:	3202      	adds	r2, #2
   818a0:	4998      	ldr	r1, [pc, #608]	; (81b04 <decode_telecommand_h+0x2a0>)
   818a2:	5c89      	ldrb	r1, [r1, r2]
   818a4:	4a98      	ldr	r2, [pc, #608]	; (81b08 <decode_telecommand_h+0x2a4>)
   818a6:	54d1      	strb	r1, [r2, r3]
	uint8_t i; //severity=0;
	uint32_t val = 0;
	uint32_t time = 0;
	int status = 0;
	clear_current_command();
	for(i = 0; i < DATA_LENGTH; i++)
   818a8:	7dfb      	ldrb	r3, [r7, #23]
   818aa:	3301      	adds	r3, #1
   818ac:	75fb      	strb	r3, [r7, #23]
   818ae:	7dfb      	ldrb	r3, [r7, #23]
   818b0:	2b88      	cmp	r3, #136	; 0x88
   818b2:	d9f2      	bls.n	8189a <decode_telecommand_h+0x36>
	{
		current_command[i] = tc_to_decode[i + 2];
	}
	
	current_command[140] = ((uint8_t)packet_id) >> 8;	// Place packet_id and psc inside command in case a TC verification is needed.
   818b4:	4b95      	ldr	r3, [pc, #596]	; (81b0c <decode_telecommand_h+0x2a8>)
   818b6:	881b      	ldrh	r3, [r3, #0]
   818b8:	b2db      	uxtb	r3, r3
   818ba:	121b      	asrs	r3, r3, #8
   818bc:	b2da      	uxtb	r2, r3
   818be:	4b92      	ldr	r3, [pc, #584]	; (81b08 <decode_telecommand_h+0x2a4>)
   818c0:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	current_command[139] = (uint8_t)packet_id;
   818c4:	4b91      	ldr	r3, [pc, #580]	; (81b0c <decode_telecommand_h+0x2a8>)
   818c6:	881b      	ldrh	r3, [r3, #0]
   818c8:	b2da      	uxtb	r2, r3
   818ca:	4b8f      	ldr	r3, [pc, #572]	; (81b08 <decode_telecommand_h+0x2a4>)
   818cc:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
	current_command[138] = ((uint8_t)psc) >> 8;
   818d0:	4b8f      	ldr	r3, [pc, #572]	; (81b10 <decode_telecommand_h+0x2ac>)
   818d2:	881b      	ldrh	r3, [r3, #0]
   818d4:	b2db      	uxtb	r3, r3
   818d6:	121b      	asrs	r3, r3, #8
   818d8:	b2da      	uxtb	r2, r3
   818da:	4b8b      	ldr	r3, [pc, #556]	; (81b08 <decode_telecommand_h+0x2a4>)
   818dc:	f883 208a 	strb.w	r2, [r3, #138]	; 0x8a
	current_command[137] = (uint8_t)psc;
   818e0:	4b8b      	ldr	r3, [pc, #556]	; (81b10 <decode_telecommand_h+0x2ac>)
   818e2:	881b      	ldrh	r3, [r3, #0]
   818e4:	b2da      	uxtb	r2, r3
   818e6:	4b88      	ldr	r3, [pc, #544]	; (81b08 <decode_telecommand_h+0x2a4>)
   818e8:	f883 2089 	strb.w	r2, [r3, #137]	; 0x89
	
	if(service_type == HK_SERVICE)
   818ec:	79fb      	ldrb	r3, [r7, #7]
   818ee:	2b03      	cmp	r3, #3
   818f0:	f040 812e 	bne.w	81b50 <decode_telecommand_h+0x2ec>
	{
		switch(service_sub_type)
   818f4:	79bb      	ldrb	r3, [r7, #6]
   818f6:	3b01      	subs	r3, #1
   818f8:	2b0a      	cmp	r3, #10
   818fa:	f200 8124 	bhi.w	81b46 <decode_telecommand_h+0x2e2>
   818fe:	a201      	add	r2, pc, #4	; (adr r2, 81904 <decode_telecommand_h+0xa0>)
   81900:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   81904:	00081931 	.word	0x00081931
   81908:	00081a6d 	.word	0x00081a6d
   8190c:	000819d1 	.word	0x000819d1
   81910:	00081a8f 	.word	0x00081a8f
   81914:	00081a1f 	.word	0x00081a1f
   81918:	00081a39 	.word	0x00081a39
   8191c:	00081ab1 	.word	0x00081ab1
   81920:	00081ad3 	.word	0x00081ad3
   81924:	00081a53 	.word	0x00081a53
   81928:	00081b47 	.word	0x00081b47
   8192c:	00081b25 	.word	0x00081b25
		{
			case	NEW_HK_DEFINITION:
				sID = current_command[136];			// Structure ID for this definition.
   81930:	4b75      	ldr	r3, [pc, #468]	; (81b08 <decode_telecommand_h+0x2a4>)
   81932:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
   81936:	4b6f      	ldr	r3, [pc, #444]	; (81af4 <decode_telecommand_h+0x290>)
   81938:	701a      	strb	r2, [r3, #0]
				if(sID != 1)
   8193a:	4b6e      	ldr	r3, [pc, #440]	; (81af4 <decode_telecommand_h+0x290>)
   8193c:	781b      	ldrb	r3, [r3, #0]
   8193e:	2b01      	cmp	r3, #1
   81940:	d010      	beq.n	81964 <decode_telecommand_h+0x100>
				{
					send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);				// Only sID of 1 is allowed.
   81942:	4b72      	ldr	r3, [pc, #456]	; (81b0c <decode_telecommand_h+0x2a8>)
   81944:	881a      	ldrh	r2, [r3, #0]
   81946:	4b72      	ldr	r3, [pc, #456]	; (81b10 <decode_telecommand_h+0x2ac>)
   81948:	881b      	ldrh	r3, [r3, #0]
   8194a:	2100      	movs	r1, #0
   8194c:	9100      	str	r1, [sp, #0]
   8194e:	2101      	movs	r1, #1
   81950:	9101      	str	r1, [sp, #4]
   81952:	4610      	mov	r0, r2
   81954:	4619      	mov	r1, r3
   81956:	22ff      	movs	r2, #255	; 0xff
   81958:	2305      	movs	r3, #5
   8195a:	4c6e      	ldr	r4, [pc, #440]	; (81b14 <decode_telecommand_h+0x2b0>)
   8195c:	47a0      	blx	r4
					return -1;
   8195e:	f04f 33ff 	mov.w	r3, #4294967295
   81962:	e2e1      	b.n	81f28 <decode_telecommand_h+0x6c4>
				}
				collection_interval = (uint32_t)current_command[135];	
   81964:	4b68      	ldr	r3, [pc, #416]	; (81b08 <decode_telecommand_h+0x2a4>)
   81966:	f893 2087 	ldrb.w	r2, [r3, #135]	; 0x87
   8196a:	4b63      	ldr	r3, [pc, #396]	; (81af8 <decode_telecommand_h+0x294>)
   8196c:	701a      	strb	r2, [r3, #0]
				npar1 = current_command[134];
   8196e:	4b66      	ldr	r3, [pc, #408]	; (81b08 <decode_telecommand_h+0x2a4>)
   81970:	f893 2086 	ldrb.w	r2, [r3, #134]	; 0x86
   81974:	4b61      	ldr	r3, [pc, #388]	; (81afc <decode_telecommand_h+0x298>)
   81976:	701a      	strb	r2, [r3, #0]
				if(npar1 > 64)
   81978:	4b60      	ldr	r3, [pc, #384]	; (81afc <decode_telecommand_h+0x298>)
   8197a:	781b      	ldrb	r3, [r3, #0]
   8197c:	2b40      	cmp	r3, #64	; 0x40
   8197e:	d910      	bls.n	819a2 <decode_telecommand_h+0x13e>
				{
					send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);				// Npar1 must be <= 64
   81980:	4b62      	ldr	r3, [pc, #392]	; (81b0c <decode_telecommand_h+0x2a8>)
   81982:	881a      	ldrh	r2, [r3, #0]
   81984:	4b62      	ldr	r3, [pc, #392]	; (81b10 <decode_telecommand_h+0x2ac>)
   81986:	881b      	ldrh	r3, [r3, #0]
   81988:	2100      	movs	r1, #0
   8198a:	9100      	str	r1, [sp, #0]
   8198c:	2101      	movs	r1, #1
   8198e:	9101      	str	r1, [sp, #4]
   81990:	4610      	mov	r0, r2
   81992:	4619      	mov	r1, r3
   81994:	22ff      	movs	r2, #255	; 0xff
   81996:	2305      	movs	r3, #5
   81998:	4c5e      	ldr	r4, [pc, #376]	; (81b14 <decode_telecommand_h+0x2b0>)
   8199a:	47a0      	blx	r4
					return -1;
   8199c:	f04f 33ff 	mov.w	r3, #4294967295
   819a0:	e2c2      	b.n	81f28 <decode_telecommand_h+0x6c4>
				}
				current_command[146] = NEW_HK_DEFINITION;
   819a2:	4b59      	ldr	r3, [pc, #356]	; (81b08 <decode_telecommand_h+0x2a4>)
   819a4:	2201      	movs	r2, #1
   819a6:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				current_command[145] = collection_interval;
   819aa:	4b53      	ldr	r3, [pc, #332]	; (81af8 <decode_telecommand_h+0x294>)
   819ac:	781a      	ldrb	r2, [r3, #0]
   819ae:	4b56      	ldr	r3, [pc, #344]	; (81b08 <decode_telecommand_h+0x2a4>)
   819b0:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
				current_command[144] = npar1;
   819b4:	4b51      	ldr	r3, [pc, #324]	; (81afc <decode_telecommand_h+0x298>)
   819b6:	781a      	ldrb	r2, [r3, #0]
   819b8:	4b53      	ldr	r3, [pc, #332]	; (81b08 <decode_telecommand_h+0x2a4>)
   819ba:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
				xQueueSendToBack(obc_to_hk_fifo, current_command, (TickType_t)1);		// FAILURE_RECOVERY if this doesn't return pdTrue.
   819be:	4b56      	ldr	r3, [pc, #344]	; (81b18 <decode_telecommand_h+0x2b4>)
   819c0:	681b      	ldr	r3, [r3, #0]
   819c2:	4618      	mov	r0, r3
   819c4:	4950      	ldr	r1, [pc, #320]	; (81b08 <decode_telecommand_h+0x2a4>)
   819c6:	2201      	movs	r2, #1
   819c8:	2300      	movs	r3, #0
   819ca:	4c54      	ldr	r4, [pc, #336]	; (81b1c <decode_telecommand_h+0x2b8>)
   819cc:	47a0      	blx	r4
				break;
   819ce:	e0bd      	b.n	81b4c <decode_telecommand_h+0x2e8>
			case	CLEAR_HK_DEFINITION:
				sID = current_command[136];
   819d0:	4b4d      	ldr	r3, [pc, #308]	; (81b08 <decode_telecommand_h+0x2a4>)
   819d2:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
   819d6:	4b47      	ldr	r3, [pc, #284]	; (81af4 <decode_telecommand_h+0x290>)
   819d8:	701a      	strb	r2, [r3, #0]
				if(sID != 1)
   819da:	4b46      	ldr	r3, [pc, #280]	; (81af4 <decode_telecommand_h+0x290>)
   819dc:	781b      	ldrb	r3, [r3, #0]
   819de:	2b01      	cmp	r3, #1
   819e0:	d010      	beq.n	81a04 <decode_telecommand_h+0x1a0>
				{
					send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);				// Usage error.
   819e2:	4b4a      	ldr	r3, [pc, #296]	; (81b0c <decode_telecommand_h+0x2a8>)
   819e4:	881a      	ldrh	r2, [r3, #0]
   819e6:	4b4a      	ldr	r3, [pc, #296]	; (81b10 <decode_telecommand_h+0x2ac>)
   819e8:	881b      	ldrh	r3, [r3, #0]
   819ea:	2100      	movs	r1, #0
   819ec:	9100      	str	r1, [sp, #0]
   819ee:	2101      	movs	r1, #1
   819f0:	9101      	str	r1, [sp, #4]
   819f2:	4610      	mov	r0, r2
   819f4:	4619      	mov	r1, r3
   819f6:	22ff      	movs	r2, #255	; 0xff
   819f8:	2305      	movs	r3, #5
   819fa:	4c46      	ldr	r4, [pc, #280]	; (81b14 <decode_telecommand_h+0x2b0>)
   819fc:	47a0      	blx	r4
					return -1;
   819fe:	f04f 33ff 	mov.w	r3, #4294967295
   81a02:	e291      	b.n	81f28 <decode_telecommand_h+0x6c4>
				}
				current_command[146] = CLEAR_HK_DEFINITION;
   81a04:	4b40      	ldr	r3, [pc, #256]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a06:	2203      	movs	r2, #3
   81a08:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				xQueueSendToBack(obc_to_hk_fifo, current_command, (TickType_t)1);
   81a0c:	4b42      	ldr	r3, [pc, #264]	; (81b18 <decode_telecommand_h+0x2b4>)
   81a0e:	681b      	ldr	r3, [r3, #0]
   81a10:	4618      	mov	r0, r3
   81a12:	493d      	ldr	r1, [pc, #244]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a14:	2201      	movs	r2, #1
   81a16:	2300      	movs	r3, #0
   81a18:	4c40      	ldr	r4, [pc, #256]	; (81b1c <decode_telecommand_h+0x2b8>)
   81a1a:	47a0      	blx	r4
				break;
   81a1c:	e096      	b.n	81b4c <decode_telecommand_h+0x2e8>
			case	ENABLE_PARAM_REPORT:
				current_command[146] = ENABLE_PARAM_REPORT;
   81a1e:	4b3a      	ldr	r3, [pc, #232]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a20:	2205      	movs	r2, #5
   81a22:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				xQueueSendToBack(obc_to_hk_fifo, current_command, (TickType_t)1);
   81a26:	4b3c      	ldr	r3, [pc, #240]	; (81b18 <decode_telecommand_h+0x2b4>)
   81a28:	681b      	ldr	r3, [r3, #0]
   81a2a:	4618      	mov	r0, r3
   81a2c:	4936      	ldr	r1, [pc, #216]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a2e:	2201      	movs	r2, #1
   81a30:	2300      	movs	r3, #0
   81a32:	4c3a      	ldr	r4, [pc, #232]	; (81b1c <decode_telecommand_h+0x2b8>)
   81a34:	47a0      	blx	r4
				break;
   81a36:	e089      	b.n	81b4c <decode_telecommand_h+0x2e8>
			case	DISABLE_PARAM_REPORT:
				current_command[146] = DISABLE_PARAM_REPORT;
   81a38:	4b33      	ldr	r3, [pc, #204]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a3a:	2206      	movs	r2, #6
   81a3c:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				xQueueSendToBack(obc_to_hk_fifo, current_command, (TickType_t)1);
   81a40:	4b35      	ldr	r3, [pc, #212]	; (81b18 <decode_telecommand_h+0x2b4>)
   81a42:	681b      	ldr	r3, [r3, #0]
   81a44:	4618      	mov	r0, r3
   81a46:	4930      	ldr	r1, [pc, #192]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a48:	2201      	movs	r2, #1
   81a4a:	2300      	movs	r3, #0
   81a4c:	4c33      	ldr	r4, [pc, #204]	; (81b1c <decode_telecommand_h+0x2b8>)
   81a4e:	47a0      	blx	r4
				break;
   81a50:	e07c      	b.n	81b4c <decode_telecommand_h+0x2e8>
			case	REPORT_HK_DEFINITIONS:
				current_command[146] = REPORT_HK_DEFINITIONS;
   81a52:	4b2d      	ldr	r3, [pc, #180]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a54:	2209      	movs	r2, #9
   81a56:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				xQueueSendToBack(obc_to_hk_fifo, current_command, (TickType_t)1);
   81a5a:	4b2f      	ldr	r3, [pc, #188]	; (81b18 <decode_telecommand_h+0x2b4>)
   81a5c:	681b      	ldr	r3, [r3, #0]
   81a5e:	4618      	mov	r0, r3
   81a60:	4929      	ldr	r1, [pc, #164]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a62:	2201      	movs	r2, #1
   81a64:	2300      	movs	r3, #0
   81a66:	4c2d      	ldr	r4, [pc, #180]	; (81b1c <decode_telecommand_h+0x2b8>)
   81a68:	47a0      	blx	r4
				break;
   81a6a:	e06f      	b.n	81b4c <decode_telecommand_h+0x2e8>
				
			// William: Put more diagnostics stuff here. This time I want the service_type in current_command[146] and
			// The service_sub_type placed in current_command[145]
			case	NEW_DIAG_DEFINITION:
				current_command[146] = HK_SERVICE;
   81a6c:	4b26      	ldr	r3, [pc, #152]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a6e:	2203      	movs	r2, #3
   81a70:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				current_command[145] = NEW_DIAG_DEFINITION;
   81a74:	4b24      	ldr	r3, [pc, #144]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a76:	2202      	movs	r2, #2
   81a78:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
				xQueueSendToBack(obc_to_fdir_fifo, current_command, (TickType_t)1);
   81a7c:	4b28      	ldr	r3, [pc, #160]	; (81b20 <decode_telecommand_h+0x2bc>)
   81a7e:	681b      	ldr	r3, [r3, #0]
   81a80:	4618      	mov	r0, r3
   81a82:	4921      	ldr	r1, [pc, #132]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a84:	2201      	movs	r2, #1
   81a86:	2300      	movs	r3, #0
   81a88:	4c24      	ldr	r4, [pc, #144]	; (81b1c <decode_telecommand_h+0x2b8>)
   81a8a:	47a0      	blx	r4
				break;
   81a8c:	e05e      	b.n	81b4c <decode_telecommand_h+0x2e8>
			
			case	CLEAR_DIAG_DEFINITION:
				current_command[146] = HK_SERVICE;
   81a8e:	4b1e      	ldr	r3, [pc, #120]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a90:	2203      	movs	r2, #3
   81a92:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				current_command[145] = CLEAR_DIAG_DEFINITION;
   81a96:	4b1c      	ldr	r3, [pc, #112]	; (81b08 <decode_telecommand_h+0x2a4>)
   81a98:	2204      	movs	r2, #4
   81a9a:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
				xQueueSendToBack(obc_to_fdir_fifo, current_command, (TickType_t)1);
   81a9e:	4b20      	ldr	r3, [pc, #128]	; (81b20 <decode_telecommand_h+0x2bc>)
   81aa0:	681b      	ldr	r3, [r3, #0]
   81aa2:	4618      	mov	r0, r3
   81aa4:	4918      	ldr	r1, [pc, #96]	; (81b08 <decode_telecommand_h+0x2a4>)
   81aa6:	2201      	movs	r2, #1
   81aa8:	2300      	movs	r3, #0
   81aaa:	4c1c      	ldr	r4, [pc, #112]	; (81b1c <decode_telecommand_h+0x2b8>)
   81aac:	47a0      	blx	r4
				break;
   81aae:	e04d      	b.n	81b4c <decode_telecommand_h+0x2e8>
			
			case	ENABLE_D_PARAM_REPORT:
				current_command[146] = HK_SERVICE;
   81ab0:	4b15      	ldr	r3, [pc, #84]	; (81b08 <decode_telecommand_h+0x2a4>)
   81ab2:	2203      	movs	r2, #3
   81ab4:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				current_command[145] = ENABLE_D_PARAM_REPORT;
   81ab8:	4b13      	ldr	r3, [pc, #76]	; (81b08 <decode_telecommand_h+0x2a4>)
   81aba:	2207      	movs	r2, #7
   81abc:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
				xQueueSendToBack(obc_to_fdir_fifo, current_command, (TickType_t)1);
   81ac0:	4b17      	ldr	r3, [pc, #92]	; (81b20 <decode_telecommand_h+0x2bc>)
   81ac2:	681b      	ldr	r3, [r3, #0]
   81ac4:	4618      	mov	r0, r3
   81ac6:	4910      	ldr	r1, [pc, #64]	; (81b08 <decode_telecommand_h+0x2a4>)
   81ac8:	2201      	movs	r2, #1
   81aca:	2300      	movs	r3, #0
   81acc:	4c13      	ldr	r4, [pc, #76]	; (81b1c <decode_telecommand_h+0x2b8>)
   81ace:	47a0      	blx	r4
				break;
   81ad0:	e03c      	b.n	81b4c <decode_telecommand_h+0x2e8>
			case	DISABLE_D_PARAM_REPORT:
				current_command[146] = HK_SERVICE;
   81ad2:	4b0d      	ldr	r3, [pc, #52]	; (81b08 <decode_telecommand_h+0x2a4>)
   81ad4:	2203      	movs	r2, #3
   81ad6:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				current_command[145] = DISABLE_D_PARAM_REPORT;
   81ada:	4b0b      	ldr	r3, [pc, #44]	; (81b08 <decode_telecommand_h+0x2a4>)
   81adc:	2208      	movs	r2, #8
   81ade:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
				xQueueSendToBack(obc_to_fdir_fifo, current_command, (TickType_t)1);
   81ae2:	4b0f      	ldr	r3, [pc, #60]	; (81b20 <decode_telecommand_h+0x2bc>)
   81ae4:	681b      	ldr	r3, [r3, #0]
   81ae6:	4618      	mov	r0, r3
   81ae8:	4907      	ldr	r1, [pc, #28]	; (81b08 <decode_telecommand_h+0x2a4>)
   81aea:	2201      	movs	r2, #1
   81aec:	2300      	movs	r3, #0
   81aee:	4c0b      	ldr	r4, [pc, #44]	; (81b1c <decode_telecommand_h+0x2b8>)
   81af0:	47a0      	blx	r4
				break;
   81af2:	e02b      	b.n	81b4c <decode_telecommand_h+0x2e8>
   81af4:	200705d2 	.word	0x200705d2
   81af8:	200705d4 	.word	0x200705d4
   81afc:	200705d5 	.word	0x200705d5
   81b00:	00081579 	.word	0x00081579
   81b04:	20070718 	.word	0x20070718
   81b08:	2007050c 	.word	0x2007050c
   81b0c:	2007045e 	.word	0x2007045e
   81b10:	20070460 	.word	0x20070460
   81b14:	000824d9 	.word	0x000824d9
   81b18:	2007adc4 	.word	0x2007adc4
   81b1c:	00086b01 	.word	0x00086b01
   81b20:	2007adc8 	.word	0x2007adc8
			case	REPORT_DIAG_DEFINITIONS:
				current_command[146] = HK_SERVICE;
   81b24:	4b8d      	ldr	r3, [pc, #564]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b26:	2203      	movs	r2, #3
   81b28:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
				current_command[145] = REPORT_DIAG_DEFINITIONS;
   81b2c:	4b8b      	ldr	r3, [pc, #556]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b2e:	220b      	movs	r2, #11
   81b30:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
				xQueueSendToBack(obc_to_fdir_fifo, current_command, (TickType_t)1);
   81b34:	4b8a      	ldr	r3, [pc, #552]	; (81d60 <decode_telecommand_h+0x4fc>)
   81b36:	681b      	ldr	r3, [r3, #0]
   81b38:	4618      	mov	r0, r3
   81b3a:	4988      	ldr	r1, [pc, #544]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b3c:	2201      	movs	r2, #1
   81b3e:	2300      	movs	r3, #0
   81b40:	4c88      	ldr	r4, [pc, #544]	; (81d64 <decode_telecommand_h+0x500>)
   81b42:	47a0      	blx	r4
				break;
   81b44:	e002      	b.n	81b4c <decode_telecommand_h+0x2e8>
			default:
				return -1;
   81b46:	f04f 33ff 	mov.w	r3, #4294967295
   81b4a:	e1ed      	b.n	81f28 <decode_telecommand_h+0x6c4>
		}
		return 1;
   81b4c:	2301      	movs	r3, #1
   81b4e:	e1eb      	b.n	81f28 <decode_telecommand_h+0x6c4>
	}
	if(service_type == TIME_SERVICE)
   81b50:	79fb      	ldrb	r3, [r7, #7]
   81b52:	2b09      	cmp	r3, #9
   81b54:	d128      	bne.n	81ba8 <decode_telecommand_h+0x344>
	{
		current_command[9] = UPDATE_REPORT_FREQ;
   81b56:	4b81      	ldr	r3, [pc, #516]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b58:	2201      	movs	r2, #1
   81b5a:	725a      	strb	r2, [r3, #9]
		current_command[8] = ((uint8_t)packet_id) >> 8;	// Place packet_id and psc inside command in case a TC verification is needed.
   81b5c:	4b82      	ldr	r3, [pc, #520]	; (81d68 <decode_telecommand_h+0x504>)
   81b5e:	881b      	ldrh	r3, [r3, #0]
   81b60:	b2db      	uxtb	r3, r3
   81b62:	121b      	asrs	r3, r3, #8
   81b64:	b2da      	uxtb	r2, r3
   81b66:	4b7d      	ldr	r3, [pc, #500]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b68:	721a      	strb	r2, [r3, #8]
		current_command[7] = (uint8_t)packet_id;
   81b6a:	4b7f      	ldr	r3, [pc, #508]	; (81d68 <decode_telecommand_h+0x504>)
   81b6c:	881b      	ldrh	r3, [r3, #0]
   81b6e:	b2da      	uxtb	r2, r3
   81b70:	4b7a      	ldr	r3, [pc, #488]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b72:	71da      	strb	r2, [r3, #7]
		current_command[6] = ((uint8_t)psc) >> 8;
   81b74:	4b7d      	ldr	r3, [pc, #500]	; (81d6c <decode_telecommand_h+0x508>)
   81b76:	881b      	ldrh	r3, [r3, #0]
   81b78:	b2db      	uxtb	r3, r3
   81b7a:	121b      	asrs	r3, r3, #8
   81b7c:	b2da      	uxtb	r2, r3
   81b7e:	4b77      	ldr	r3, [pc, #476]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b80:	719a      	strb	r2, [r3, #6]
		current_command[5] = (uint8_t)psc;
   81b82:	4b7a      	ldr	r3, [pc, #488]	; (81d6c <decode_telecommand_h+0x508>)
   81b84:	881b      	ldrh	r3, [r3, #0]
   81b86:	b2da      	uxtb	r2, r3
   81b88:	4b74      	ldr	r3, [pc, #464]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b8a:	715a      	strb	r2, [r3, #5]
		current_command[0] = current_command[0];			// Report Freq.
   81b8c:	4b73      	ldr	r3, [pc, #460]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b8e:	781a      	ldrb	r2, [r3, #0]
   81b90:	4b72      	ldr	r3, [pc, #456]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b92:	701a      	strb	r2, [r3, #0]
		xQueueSendToBack(obc_to_time_fifo, current_command, (TickType_t)1);
   81b94:	4b76      	ldr	r3, [pc, #472]	; (81d70 <decode_telecommand_h+0x50c>)
   81b96:	681b      	ldr	r3, [r3, #0]
   81b98:	4618      	mov	r0, r3
   81b9a:	4970      	ldr	r1, [pc, #448]	; (81d5c <decode_telecommand_h+0x4f8>)
   81b9c:	2201      	movs	r2, #1
   81b9e:	2300      	movs	r3, #0
   81ba0:	4c70      	ldr	r4, [pc, #448]	; (81d64 <decode_telecommand_h+0x500>)
   81ba2:	47a0      	blx	r4
		return 1;
   81ba4:	2301      	movs	r3, #1
   81ba6:	e1bf      	b.n	81f28 <decode_telecommand_h+0x6c4>
	}
	if(service_type == MEMORY_SERVICE)
   81ba8:	79fb      	ldrb	r3, [r7, #7]
   81baa:	2b06      	cmp	r3, #6
   81bac:	d139      	bne.n	81c22 <decode_telecommand_h+0x3be>
	{
		current_command[146] = service_sub_type;
   81bae:	4b6b      	ldr	r3, [pc, #428]	; (81d5c <decode_telecommand_h+0x4f8>)
   81bb0:	79ba      	ldrb	r2, [r7, #6]
   81bb2:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
		current_command[140] = (uint8_t)(packet_id >> 8);
   81bb6:	4b6c      	ldr	r3, [pc, #432]	; (81d68 <decode_telecommand_h+0x504>)
   81bb8:	881b      	ldrh	r3, [r3, #0]
   81bba:	0a1b      	lsrs	r3, r3, #8
   81bbc:	b29b      	uxth	r3, r3
   81bbe:	b2da      	uxtb	r2, r3
   81bc0:	4b66      	ldr	r3, [pc, #408]	; (81d5c <decode_telecommand_h+0x4f8>)
   81bc2:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
		current_command[139] = (uint8_t)(packet_id & 0x00FF);
   81bc6:	4b68      	ldr	r3, [pc, #416]	; (81d68 <decode_telecommand_h+0x504>)
   81bc8:	881b      	ldrh	r3, [r3, #0]
   81bca:	b2da      	uxtb	r2, r3
   81bcc:	4b63      	ldr	r3, [pc, #396]	; (81d5c <decode_telecommand_h+0x4f8>)
   81bce:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
		current_command[138] = (uint8_t)(psc >> 8);
   81bd2:	4b66      	ldr	r3, [pc, #408]	; (81d6c <decode_telecommand_h+0x508>)
   81bd4:	881b      	ldrh	r3, [r3, #0]
   81bd6:	0a1b      	lsrs	r3, r3, #8
   81bd8:	b29b      	uxth	r3, r3
   81bda:	b2da      	uxtb	r2, r3
   81bdc:	4b5f      	ldr	r3, [pc, #380]	; (81d5c <decode_telecommand_h+0x4f8>)
   81bde:	f883 208a 	strb.w	r2, [r3, #138]	; 0x8a
		current_command[137] = (uint8_t)(psc & 0x00FF);
   81be2:	4b62      	ldr	r3, [pc, #392]	; (81d6c <decode_telecommand_h+0x508>)
   81be4:	881b      	ldrh	r3, [r3, #0]
   81be6:	b2da      	uxtb	r2, r3
   81be8:	4b5c      	ldr	r3, [pc, #368]	; (81d5c <decode_telecommand_h+0x4f8>)
   81bea:	f883 2089 	strb.w	r2, [r3, #137]	; 0x89
		if(!SAFE_MODE)
   81bee:	4b61      	ldr	r3, [pc, #388]	; (81d74 <decode_telecommand_h+0x510>)
   81bf0:	681b      	ldr	r3, [r3, #0]
   81bf2:	2b00      	cmp	r3, #0
   81bf4:	d107      	bne.n	81c06 <decode_telecommand_h+0x3a2>
			xQueueSendToBack(obc_to_mem_fifo, current_command, (TickType_t)1);
   81bf6:	4b60      	ldr	r3, [pc, #384]	; (81d78 <decode_telecommand_h+0x514>)
   81bf8:	681b      	ldr	r3, [r3, #0]
   81bfa:	4618      	mov	r0, r3
   81bfc:	4957      	ldr	r1, [pc, #348]	; (81d5c <decode_telecommand_h+0x4f8>)
   81bfe:	2201      	movs	r2, #1
   81c00:	2300      	movs	r3, #0
   81c02:	4c58      	ldr	r4, [pc, #352]	; (81d64 <decode_telecommand_h+0x500>)
   81c04:	47a0      	blx	r4
		if(SAFE_MODE)
   81c06:	4b5b      	ldr	r3, [pc, #364]	; (81d74 <decode_telecommand_h+0x510>)
   81c08:	681b      	ldr	r3, [r3, #0]
   81c0a:	2b00      	cmp	r3, #0
   81c0c:	d007      	beq.n	81c1e <decode_telecommand_h+0x3ba>
			xQueueSendToBack(obc_to_fdir_fifo, current_command, (TickType_t)1);
   81c0e:	4b54      	ldr	r3, [pc, #336]	; (81d60 <decode_telecommand_h+0x4fc>)
   81c10:	681b      	ldr	r3, [r3, #0]
   81c12:	4618      	mov	r0, r3
   81c14:	4951      	ldr	r1, [pc, #324]	; (81d5c <decode_telecommand_h+0x4f8>)
   81c16:	2201      	movs	r2, #1
   81c18:	2300      	movs	r3, #0
   81c1a:	4c52      	ldr	r4, [pc, #328]	; (81d64 <decode_telecommand_h+0x500>)
   81c1c:	47a0      	blx	r4
		return 1;
   81c1e:	2301      	movs	r3, #1
   81c20:	e182      	b.n	81f28 <decode_telecommand_h+0x6c4>
	}
	if(service_type == K_SERVICE)
   81c22:	79fb      	ldrb	r3, [r7, #7]
   81c24:	2b45      	cmp	r3, #69	; 0x45
   81c26:	f040 8156 	bne.w	81ed6 <decode_telecommand_h+0x672>
	{
		if(service_sub_type == ADD_SCHEDULE)
   81c2a:	79bb      	ldrb	r3, [r7, #6]
   81c2c:	2b01      	cmp	r3, #1
   81c2e:	d124      	bne.n	81c7a <decode_telecommand_h+0x416>
		{
			//severity = current_command[129];
			time = ((uint32_t)current_command[135]) << 24;
   81c30:	4b4a      	ldr	r3, [pc, #296]	; (81d5c <decode_telecommand_h+0x4f8>)
   81c32:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
   81c36:	061b      	lsls	r3, r3, #24
   81c38:	60fb      	str	r3, [r7, #12]
			time += ((uint32_t)current_command[134]) << 16;
   81c3a:	4b48      	ldr	r3, [pc, #288]	; (81d5c <decode_telecommand_h+0x4f8>)
   81c3c:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
   81c40:	041b      	lsls	r3, r3, #16
   81c42:	68fa      	ldr	r2, [r7, #12]
   81c44:	4413      	add	r3, r2
   81c46:	60fb      	str	r3, [r7, #12]
			time += ((uint32_t)current_command[133]) << 8;
   81c48:	4b44      	ldr	r3, [pc, #272]	; (81d5c <decode_telecommand_h+0x4f8>)
   81c4a:	f893 3085 	ldrb.w	r3, [r3, #133]	; 0x85
   81c4e:	021b      	lsls	r3, r3, #8
   81c50:	68fa      	ldr	r2, [r7, #12]
   81c52:	4413      	add	r3, r2
   81c54:	60fb      	str	r3, [r7, #12]
			time += (uint32_t)current_command[132];
   81c56:	4b41      	ldr	r3, [pc, #260]	; (81d5c <decode_telecommand_h+0x4f8>)
   81c58:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
   81c5c:	68fa      	ldr	r2, [r7, #12]
   81c5e:	4413      	add	r3, r2
   81c60:	60fb      	str	r3, [r7, #12]
			current_command[146] = service_sub_type;
   81c62:	4b3e      	ldr	r3, [pc, #248]	; (81d5c <decode_telecommand_h+0x4f8>)
   81c64:	79ba      	ldrb	r2, [r7, #6]
   81c66:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
			xQueueSendToBack(obc_to_sched_fifo, current_command, (TickType_t)1);	// All scheduled commands should be sent to scheduling.		
   81c6a:	4b44      	ldr	r3, [pc, #272]	; (81d7c <decode_telecommand_h+0x518>)
   81c6c:	681b      	ldr	r3, [r3, #0]
   81c6e:	4618      	mov	r0, r3
   81c70:	493a      	ldr	r1, [pc, #232]	; (81d5c <decode_telecommand_h+0x4f8>)
   81c72:	2201      	movs	r2, #1
   81c74:	2300      	movs	r3, #0
   81c76:	4c3b      	ldr	r4, [pc, #236]	; (81d64 <decode_telecommand_h+0x500>)
   81c78:	47a0      	blx	r4
		}
		if(service_sub_type == START_EXPERIMENT_ARM)
   81c7a:	79bb      	ldrb	r3, [r7, #6]
   81c7c:	2b08      	cmp	r3, #8
   81c7e:	d110      	bne.n	81ca2 <decode_telecommand_h+0x43e>
		{
			experiment_armed = 1;
   81c80:	4b3f      	ldr	r3, [pc, #252]	; (81d80 <decode_telecommand_h+0x51c>)
   81c82:	2201      	movs	r2, #1
   81c84:	701a      	strb	r2, [r3, #0]
			send_tc_verification(packet_id, psc, 0, OBC_PACKET_ROUTER_ID, 0, 2);	// Successful command execution report.
   81c86:	4b38      	ldr	r3, [pc, #224]	; (81d68 <decode_telecommand_h+0x504>)
   81c88:	881a      	ldrh	r2, [r3, #0]
   81c8a:	4b38      	ldr	r3, [pc, #224]	; (81d6c <decode_telecommand_h+0x508>)
   81c8c:	881b      	ldrh	r3, [r3, #0]
   81c8e:	2100      	movs	r1, #0
   81c90:	9100      	str	r1, [sp, #0]
   81c92:	2102      	movs	r1, #2
   81c94:	9101      	str	r1, [sp, #4]
   81c96:	4610      	mov	r0, r2
   81c98:	4619      	mov	r1, r3
   81c9a:	2200      	movs	r2, #0
   81c9c:	230a      	movs	r3, #10
   81c9e:	4c39      	ldr	r4, [pc, #228]	; (81d84 <decode_telecommand_h+0x520>)
   81ca0:	47a0      	blx	r4
		}
		if(service_sub_type == START_EXPERIMENT_FIRE)
   81ca2:	79bb      	ldrb	r3, [r7, #6]
   81ca4:	2b09      	cmp	r3, #9
   81ca6:	d123      	bne.n	81cf0 <decode_telecommand_h+0x48c>
		{
			if(experiment_armed)
   81ca8:	4b35      	ldr	r3, [pc, #212]	; (81d80 <decode_telecommand_h+0x51c>)
   81caa:	781b      	ldrb	r3, [r3, #0]
   81cac:	2b00      	cmp	r3, #0
   81cae:	d011      	beq.n	81cd4 <decode_telecommand_h+0x470>
			{
				experiment_started = 1;
   81cb0:	4b35      	ldr	r3, [pc, #212]	; (81d88 <decode_telecommand_h+0x524>)
   81cb2:	2201      	movs	r2, #1
   81cb4:	701a      	strb	r2, [r3, #0]
				send_tc_verification(packet_id, psc, 0, OBC_PACKET_ROUTER_ID, 0, 2);	// Successful command execution report.
   81cb6:	4b2c      	ldr	r3, [pc, #176]	; (81d68 <decode_telecommand_h+0x504>)
   81cb8:	881a      	ldrh	r2, [r3, #0]
   81cba:	4b2c      	ldr	r3, [pc, #176]	; (81d6c <decode_telecommand_h+0x508>)
   81cbc:	881b      	ldrh	r3, [r3, #0]
   81cbe:	2100      	movs	r1, #0
   81cc0:	9100      	str	r1, [sp, #0]
   81cc2:	2102      	movs	r1, #2
   81cc4:	9101      	str	r1, [sp, #4]
   81cc6:	4610      	mov	r0, r2
   81cc8:	4619      	mov	r1, r3
   81cca:	2200      	movs	r2, #0
   81ccc:	230a      	movs	r3, #10
   81cce:	4c2d      	ldr	r4, [pc, #180]	; (81d84 <decode_telecommand_h+0x520>)
   81cd0:	47a0      	blx	r4
   81cd2:	e00d      	b.n	81cf0 <decode_telecommand_h+0x48c>
			}
			else
				send_tc_verification(packet_id, psc, 0xFF, 5, 0, 1);				// Failed telecommand acceptance report (usage error due to experiment_armed = 0)
   81cd4:	4b24      	ldr	r3, [pc, #144]	; (81d68 <decode_telecommand_h+0x504>)
   81cd6:	881a      	ldrh	r2, [r3, #0]
   81cd8:	4b24      	ldr	r3, [pc, #144]	; (81d6c <decode_telecommand_h+0x508>)
   81cda:	881b      	ldrh	r3, [r3, #0]
   81cdc:	2100      	movs	r1, #0
   81cde:	9100      	str	r1, [sp, #0]
   81ce0:	2101      	movs	r1, #1
   81ce2:	9101      	str	r1, [sp, #4]
   81ce4:	4610      	mov	r0, r2
   81ce6:	4619      	mov	r1, r3
   81ce8:	22ff      	movs	r2, #255	; 0xff
   81cea:	2305      	movs	r3, #5
   81cec:	4c25      	ldr	r4, [pc, #148]	; (81d84 <decode_telecommand_h+0x520>)
   81cee:	47a0      	blx	r4
		}
		if(service_sub_type == SET_VARIABLE)
   81cf0:	79bb      	ldrb	r3, [r7, #6]
   81cf2:	2b0a      	cmp	r3, #10
   81cf4:	d165      	bne.n	81dc2 <decode_telecommand_h+0x55e>
		{
			ssmID = get_ssm_id(current_command[136]);
   81cf6:	4b19      	ldr	r3, [pc, #100]	; (81d5c <decode_telecommand_h+0x4f8>)
   81cf8:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   81cfc:	4618      	mov	r0, r3
   81cfe:	4b23      	ldr	r3, [pc, #140]	; (81d8c <decode_telecommand_h+0x528>)
   81d00:	4798      	blx	r3
   81d02:	4603      	mov	r3, r0
   81d04:	461a      	mov	r2, r3
   81d06:	4b22      	ldr	r3, [pc, #136]	; (81d90 <decode_telecommand_h+0x52c>)
   81d08:	701a      	strb	r2, [r3, #0]
			val = (uint32_t)current_command[132];
   81d0a:	4b14      	ldr	r3, [pc, #80]	; (81d5c <decode_telecommand_h+0x4f8>)
   81d0c:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
   81d10:	613b      	str	r3, [r7, #16]
			val += ((uint32_t)current_command[133]) << 8;
   81d12:	4b12      	ldr	r3, [pc, #72]	; (81d5c <decode_telecommand_h+0x4f8>)
   81d14:	f893 3085 	ldrb.w	r3, [r3, #133]	; 0x85
   81d18:	021b      	lsls	r3, r3, #8
   81d1a:	693a      	ldr	r2, [r7, #16]
   81d1c:	4413      	add	r3, r2
   81d1e:	613b      	str	r3, [r7, #16]
			val += ((uint32_t)current_command[134]) << 16;
   81d20:	4b0e      	ldr	r3, [pc, #56]	; (81d5c <decode_telecommand_h+0x4f8>)
   81d22:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
   81d26:	041b      	lsls	r3, r3, #16
   81d28:	693a      	ldr	r2, [r7, #16]
   81d2a:	4413      	add	r3, r2
   81d2c:	613b      	str	r3, [r7, #16]
			val += ((uint32_t)current_command[135]) << 24;			
   81d2e:	4b0b      	ldr	r3, [pc, #44]	; (81d5c <decode_telecommand_h+0x4f8>)
   81d30:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
   81d34:	061b      	lsls	r3, r3, #24
   81d36:	693a      	ldr	r2, [r7, #16]
   81d38:	4413      	add	r3, r2
   81d3a:	613b      	str	r3, [r7, #16]
			if(ssmID < 3)
   81d3c:	4b14      	ldr	r3, [pc, #80]	; (81d90 <decode_telecommand_h+0x52c>)
   81d3e:	781b      	ldrb	r3, [r3, #0]
   81d40:	2b02      	cmp	r3, #2
   81d42:	d829      	bhi.n	81d98 <decode_telecommand_h+0x534>
				set_variable(OBC_PACKET_ROUTER_ID, ssmID, current_command[136], (uint16_t)val);
   81d44:	4b12      	ldr	r3, [pc, #72]	; (81d90 <decode_telecommand_h+0x52c>)
   81d46:	7819      	ldrb	r1, [r3, #0]
   81d48:	4b04      	ldr	r3, [pc, #16]	; (81d5c <decode_telecommand_h+0x4f8>)
   81d4a:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
   81d4e:	693b      	ldr	r3, [r7, #16]
   81d50:	b29b      	uxth	r3, r3
   81d52:	200a      	movs	r0, #10
   81d54:	4c0f      	ldr	r4, [pc, #60]	; (81d94 <decode_telecommand_h+0x530>)
   81d56:	47a0      	blx	r4
   81d58:	e025      	b.n	81da6 <decode_telecommand_h+0x542>
   81d5a:	bf00      	nop
   81d5c:	2007050c 	.word	0x2007050c
   81d60:	2007adc8 	.word	0x2007adc8
   81d64:	00086b01 	.word	0x00086b01
   81d68:	2007045e 	.word	0x2007045e
   81d6c:	20070460 	.word	0x20070460
   81d70:	2007d580 	.word	0x2007d580
   81d74:	2007b438 	.word	0x2007b438
   81d78:	2007b534 	.word	0x2007b534
   81d7c:	2007b110 	.word	0x2007b110
   81d80:	2007ada8 	.word	0x2007ada8
   81d84:	000824d9 	.word	0x000824d9
   81d88:	2007b164 	.word	0x2007b164
   81d8c:	000831f1 	.word	0x000831f1
   81d90:	200705d3 	.word	0x200705d3
   81d94:	00089d2d 	.word	0x00089d2d
			else
				set_obc_variable(current_command[136], val);
   81d98:	4b65      	ldr	r3, [pc, #404]	; (81f30 <decode_telecommand_h+0x6cc>)
   81d9a:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   81d9e:	4618      	mov	r0, r3
   81da0:	6939      	ldr	r1, [r7, #16]
   81da2:	4b64      	ldr	r3, [pc, #400]	; (81f34 <decode_telecommand_h+0x6d0>)
   81da4:	4798      	blx	r3
			send_tc_verification(packet_id, psc, 0, OBC_PACKET_ROUTER_ID, 0, 2);
   81da6:	4b64      	ldr	r3, [pc, #400]	; (81f38 <decode_telecommand_h+0x6d4>)
   81da8:	881a      	ldrh	r2, [r3, #0]
   81daa:	4b64      	ldr	r3, [pc, #400]	; (81f3c <decode_telecommand_h+0x6d8>)
   81dac:	881b      	ldrh	r3, [r3, #0]
   81dae:	2100      	movs	r1, #0
   81db0:	9100      	str	r1, [sp, #0]
   81db2:	2102      	movs	r1, #2
   81db4:	9101      	str	r1, [sp, #4]
   81db6:	4610      	mov	r0, r2
   81db8:	4619      	mov	r1, r3
   81dba:	2200      	movs	r2, #0
   81dbc:	230a      	movs	r3, #10
   81dbe:	4c60      	ldr	r4, [pc, #384]	; (81f40 <decode_telecommand_h+0x6dc>)
   81dc0:	47a0      	blx	r4
		}
		if(service_sub_type == GET_PARAMETER)
   81dc2:	79bb      	ldrb	r3, [r7, #6]
   81dc4:	2b0b      	cmp	r3, #11
   81dc6:	d17a      	bne.n	81ebe <decode_telecommand_h+0x65a>
		{
			ssmID = get_ssm_id(current_command[136]);
   81dc8:	4b59      	ldr	r3, [pc, #356]	; (81f30 <decode_telecommand_h+0x6cc>)
   81dca:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   81dce:	4618      	mov	r0, r3
   81dd0:	4b5c      	ldr	r3, [pc, #368]	; (81f44 <decode_telecommand_h+0x6e0>)
   81dd2:	4798      	blx	r3
   81dd4:	4603      	mov	r3, r0
   81dd6:	461a      	mov	r2, r3
   81dd8:	4b5b      	ldr	r3, [pc, #364]	; (81f48 <decode_telecommand_h+0x6e4>)
   81dda:	701a      	strb	r2, [r3, #0]
			val = (uint32_t)current_command[132];
   81ddc:	4b54      	ldr	r3, [pc, #336]	; (81f30 <decode_telecommand_h+0x6cc>)
   81dde:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
   81de2:	613b      	str	r3, [r7, #16]
			val += ((uint32_t)current_command[133]) << 8;
   81de4:	4b52      	ldr	r3, [pc, #328]	; (81f30 <decode_telecommand_h+0x6cc>)
   81de6:	f893 3085 	ldrb.w	r3, [r3, #133]	; 0x85
   81dea:	021b      	lsls	r3, r3, #8
   81dec:	693a      	ldr	r2, [r7, #16]
   81dee:	4413      	add	r3, r2
   81df0:	613b      	str	r3, [r7, #16]
			val += ((uint32_t)current_command[134]) << 16;
   81df2:	4b4f      	ldr	r3, [pc, #316]	; (81f30 <decode_telecommand_h+0x6cc>)
   81df4:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
   81df8:	041b      	lsls	r3, r3, #16
   81dfa:	693a      	ldr	r2, [r7, #16]
   81dfc:	4413      	add	r3, r2
   81dfe:	613b      	str	r3, [r7, #16]
			val += ((uint32_t)current_command[135]) << 24;
   81e00:	4b4b      	ldr	r3, [pc, #300]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e02:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
   81e06:	061b      	lsls	r3, r3, #24
   81e08:	693a      	ldr	r2, [r7, #16]
   81e0a:	4413      	add	r3, r2
   81e0c:	613b      	str	r3, [r7, #16]
			if(ssmID < 3)
   81e0e:	4b4e      	ldr	r3, [pc, #312]	; (81f48 <decode_telecommand_h+0x6e4>)
   81e10:	781b      	ldrb	r3, [r3, #0]
   81e12:	2b02      	cmp	r3, #2
   81e14:	d80b      	bhi.n	81e2e <decode_telecommand_h+0x5ca>
				val = request_sensor_data(OBC_PACKET_ROUTER_ID, ssmID, current_command[136], &status);
   81e16:	4b4c      	ldr	r3, [pc, #304]	; (81f48 <decode_telecommand_h+0x6e4>)
   81e18:	7819      	ldrb	r1, [r3, #0]
   81e1a:	4b45      	ldr	r3, [pc, #276]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e1c:	f893 2088 	ldrb.w	r2, [r3, #136]	; 0x88
   81e20:	f107 0308 	add.w	r3, r7, #8
   81e24:	200a      	movs	r0, #10
   81e26:	4c49      	ldr	r4, [pc, #292]	; (81f4c <decode_telecommand_h+0x6e8>)
   81e28:	47a0      	blx	r4
   81e2a:	6138      	str	r0, [r7, #16]
   81e2c:	e006      	b.n	81e3c <decode_telecommand_h+0x5d8>
			else
				val = get_obc_variable(current_command[136]);
   81e2e:	4b40      	ldr	r3, [pc, #256]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e30:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   81e34:	4618      	mov	r0, r3
   81e36:	4b46      	ldr	r3, [pc, #280]	; (81f50 <decode_telecommand_h+0x6ec>)
   81e38:	4798      	blx	r3
   81e3a:	6138      	str	r0, [r7, #16]
			send_tc_verification(packet_id, psc, 0, OBC_PACKET_ROUTER_ID, 0, 2);
   81e3c:	4b3e      	ldr	r3, [pc, #248]	; (81f38 <decode_telecommand_h+0x6d4>)
   81e3e:	881a      	ldrh	r2, [r3, #0]
   81e40:	4b3e      	ldr	r3, [pc, #248]	; (81f3c <decode_telecommand_h+0x6d8>)
   81e42:	881b      	ldrh	r3, [r3, #0]
   81e44:	2100      	movs	r1, #0
   81e46:	9100      	str	r1, [sp, #0]
   81e48:	2102      	movs	r1, #2
   81e4a:	9101      	str	r1, [sp, #4]
   81e4c:	4610      	mov	r0, r2
   81e4e:	4619      	mov	r1, r3
   81e50:	2200      	movs	r2, #0
   81e52:	230a      	movs	r3, #10
   81e54:	4c3a      	ldr	r4, [pc, #232]	; (81f40 <decode_telecommand_h+0x6dc>)
   81e56:	47a0      	blx	r4
			i = current_command[136];
   81e58:	4b35      	ldr	r3, [pc, #212]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e5a:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   81e5e:	75fb      	strb	r3, [r7, #23]
			clear_current_command();
   81e60:	4b3c      	ldr	r3, [pc, #240]	; (81f54 <decode_telecommand_h+0x6f0>)
   81e62:	4798      	blx	r3
			current_command[136] = i;
   81e64:	4b32      	ldr	r3, [pc, #200]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e66:	7dfa      	ldrb	r2, [r7, #23]
   81e68:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
			current_command[132] = (uint8_t)val;
   81e6c:	693b      	ldr	r3, [r7, #16]
   81e6e:	b2da      	uxtb	r2, r3
   81e70:	4b2f      	ldr	r3, [pc, #188]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e72:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
			current_command[133] = (uint8_t)(val >> 8);
   81e76:	693b      	ldr	r3, [r7, #16]
   81e78:	0a1b      	lsrs	r3, r3, #8
   81e7a:	b2da      	uxtb	r2, r3
   81e7c:	4b2c      	ldr	r3, [pc, #176]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e7e:	f883 2085 	strb.w	r2, [r3, #133]	; 0x85
			current_command[134] = (uint8_t)(val >> 16);
   81e82:	693b      	ldr	r3, [r7, #16]
   81e84:	0c1b      	lsrs	r3, r3, #16
   81e86:	b2da      	uxtb	r2, r3
   81e88:	4b29      	ldr	r3, [pc, #164]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e8a:	f883 2086 	strb.w	r2, [r3, #134]	; 0x86
			current_command[135] = (uint8_t)(val >> 24);			
   81e8e:	693b      	ldr	r3, [r7, #16]
   81e90:	0e1b      	lsrs	r3, r3, #24
   81e92:	b2da      	uxtb	r2, r3
   81e94:	4b26      	ldr	r3, [pc, #152]	; (81f30 <decode_telecommand_h+0x6cc>)
   81e96:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
			packetize_send_telemetry(OBC_PACKET_ROUTER_ID, GROUND_PACKET_ROUTER_ID, K_SERVICE, SINGLE_PARAMETER_REPORT, sin_par_rep_count++, 1, current_command);
   81e9a:	4b2f      	ldr	r3, [pc, #188]	; (81f58 <decode_telecommand_h+0x6f4>)
   81e9c:	781b      	ldrb	r3, [r3, #0]
   81e9e:	1c5a      	adds	r2, r3, #1
   81ea0:	b2d1      	uxtb	r1, r2
   81ea2:	4a2d      	ldr	r2, [pc, #180]	; (81f58 <decode_telecommand_h+0x6f4>)
   81ea4:	7011      	strb	r1, [r2, #0]
   81ea6:	9300      	str	r3, [sp, #0]
   81ea8:	2301      	movs	r3, #1
   81eaa:	9301      	str	r3, [sp, #4]
   81eac:	4b20      	ldr	r3, [pc, #128]	; (81f30 <decode_telecommand_h+0x6cc>)
   81eae:	9302      	str	r3, [sp, #8]
   81eb0:	200a      	movs	r0, #10
   81eb2:	2113      	movs	r1, #19
   81eb4:	2245      	movs	r2, #69	; 0x45
   81eb6:	230c      	movs	r3, #12
   81eb8:	4c28      	ldr	r4, [pc, #160]	; (81f5c <decode_telecommand_h+0x6f8>)
   81eba:	47a0      	blx	r4
   81ebc:	e00b      	b.n	81ed6 <decode_telecommand_h+0x672>
		}
		else
		{
			/* Everything else should be sent to the scheduling task. */
			current_command[146] = service_sub_type;
   81ebe:	4b1c      	ldr	r3, [pc, #112]	; (81f30 <decode_telecommand_h+0x6cc>)
   81ec0:	79ba      	ldrb	r2, [r7, #6]
   81ec2:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
			xQueueSendToBack(obc_to_sched_fifo, current_command, (TickType_t)1);			
   81ec6:	4b26      	ldr	r3, [pc, #152]	; (81f60 <decode_telecommand_h+0x6fc>)
   81ec8:	681b      	ldr	r3, [r3, #0]
   81eca:	4618      	mov	r0, r3
   81ecc:	4918      	ldr	r1, [pc, #96]	; (81f30 <decode_telecommand_h+0x6cc>)
   81ece:	2201      	movs	r2, #1
   81ed0:	2300      	movs	r3, #0
   81ed2:	4c24      	ldr	r4, [pc, #144]	; (81f64 <decode_telecommand_h+0x700>)
   81ed4:	47a0      	blx	r4
		}
	}
	if(service_type == FDIR_SERVICE)
   81ed6:	79fb      	ldrb	r3, [r7, #7]
   81ed8:	2b46      	cmp	r3, #70	; 0x46
   81eda:	d124      	bne.n	81f26 <decode_telecommand_h+0x6c2>
	{
		current_command[146] = service_type;
   81edc:	4b14      	ldr	r3, [pc, #80]	; (81f30 <decode_telecommand_h+0x6cc>)
   81ede:	79fa      	ldrb	r2, [r7, #7]
   81ee0:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
		current_command[145] = service_sub_type;
   81ee4:	4b12      	ldr	r3, [pc, #72]	; (81f30 <decode_telecommand_h+0x6cc>)
   81ee6:	79ba      	ldrb	r2, [r7, #6]
   81ee8:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
		if((service_sub_type == PAUSE_SSM_OPERATIONS) || (service_sub_type == RESUME_SSM_OPERATIONS) || (service_sub_type == RESET_SSM) 
   81eec:	79bb      	ldrb	r3, [r7, #6]
   81eee:	2b07      	cmp	r3, #7
   81ef0:	d00b      	beq.n	81f0a <decode_telecommand_h+0x6a6>
   81ef2:	79bb      	ldrb	r3, [r7, #6]
   81ef4:	2b08      	cmp	r3, #8
   81ef6:	d008      	beq.n	81f0a <decode_telecommand_h+0x6a6>
   81ef8:	79bb      	ldrb	r3, [r7, #6]
   81efa:	2b0a      	cmp	r3, #10
   81efc:	d005      	beq.n	81f0a <decode_telecommand_h+0x6a6>
					|| (service_sub_type == REPROGRAM_SSM) || (service_sub_type == RESET_TASK))
   81efe:	79bb      	ldrb	r3, [r7, #6]
   81f00:	2b09      	cmp	r3, #9
   81f02:	d002      	beq.n	81f0a <decode_telecommand_h+0x6a6>
   81f04:	79bb      	ldrb	r3, [r7, #6]
   81f06:	2b0b      	cmp	r3, #11
   81f08:	d105      	bne.n	81f16 <decode_telecommand_h+0x6b2>
			current_command[144] = current_command[129];
   81f0a:	4b09      	ldr	r3, [pc, #36]	; (81f30 <decode_telecommand_h+0x6cc>)
   81f0c:	f893 2081 	ldrb.w	r2, [r3, #129]	; 0x81
   81f10:	4b07      	ldr	r3, [pc, #28]	; (81f30 <decode_telecommand_h+0x6cc>)
   81f12:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
		xQueueSendToBack(obc_to_fdir_fifo, current_command, (TickType_t)1);
   81f16:	4b14      	ldr	r3, [pc, #80]	; (81f68 <decode_telecommand_h+0x704>)
   81f18:	681b      	ldr	r3, [r3, #0]
   81f1a:	4618      	mov	r0, r3
   81f1c:	4904      	ldr	r1, [pc, #16]	; (81f30 <decode_telecommand_h+0x6cc>)
   81f1e:	2201      	movs	r2, #1
   81f20:	2300      	movs	r3, #0
   81f22:	4c10      	ldr	r4, [pc, #64]	; (81f64 <decode_telecommand_h+0x700>)
   81f24:	47a0      	blx	r4
	}
	
	return 1;
   81f26:	2301      	movs	r3, #1
}
   81f28:	4618      	mov	r0, r3
   81f2a:	371c      	adds	r7, #28
   81f2c:	46bd      	mov	sp, r7
   81f2e:	bd90      	pop	{r4, r7, pc}
   81f30:	2007050c 	.word	0x2007050c
   81f34:	00082771 	.word	0x00082771
   81f38:	2007045e 	.word	0x2007045e
   81f3c:	20070460 	.word	0x20070460
   81f40:	000824d9 	.word	0x000824d9
   81f44:	000831f1 	.word	0x000831f1
   81f48:	200705d3 	.word	0x200705d3
   81f4c:	00089c9d 	.word	0x00089c9d
   81f50:	00082881 	.word	0x00082881
   81f54:	00081579 	.word	0x00081579
   81f58:	2007046a 	.word	0x2007046a
   81f5c:	00080f19 	.word	0x00080f19
   81f60:	2007b110 	.word	0x2007b110
   81f64:	00086b01 	.word	0x00086b01
   81f68:	2007adc8 	.word	0x2007adc8

00081f6c <verify_telecommand>:
/* @param: ccsds_flag: does packet contain a PUS standard data header?	*/
/* @param: packet_version: PUS version within the data header.			*/
/* @return: -1: TC packet failed inspection, 1 == Good to decode		*/
/************************************************************************/
static int verify_telecommand(uint8_t apid, uint8_t packet_length, uint16_t pec0, uint16_t pec1, uint8_t service_type, uint8_t service_sub_type, uint8_t version, uint8_t ccsds_flag, uint8_t packet_version)
{
   81f6c:	b590      	push	{r4, r7, lr}
   81f6e:	b087      	sub	sp, #28
   81f70:	af02      	add	r7, sp, #8
   81f72:	71f8      	strb	r0, [r7, #7]
   81f74:	71b9      	strb	r1, [r7, #6]
   81f76:	80ba      	strh	r2, [r7, #4]
   81f78:	807b      	strh	r3, [r7, #2]
	address = 0;
   81f7a:	4b67      	ldr	r3, [pc, #412]	; (82118 <verify_telecommand+0x1ac>)
   81f7c:	2200      	movs	r2, #0
   81f7e:	601a      	str	r2, [r3, #0]
	length = 0;
   81f80:	4b66      	ldr	r3, [pc, #408]	; (8211c <verify_telecommand+0x1b0>)
   81f82:	2200      	movs	r2, #0
   81f84:	601a      	str	r2, [r3, #0]
	uint8_t i;
	new_time = 0;
   81f86:	4b66      	ldr	r3, [pc, #408]	; (82120 <verify_telecommand+0x1b4>)
   81f88:	2200      	movs	r2, #0
   81f8a:	601a      	str	r2, [r3, #0]
	last_time = 0;
   81f8c:	4b65      	ldr	r3, [pc, #404]	; (82124 <verify_telecommand+0x1b8>)
   81f8e:	2200      	movs	r2, #0
   81f90:	601a      	str	r2, [r3, #0]
	if(packet_length != PACKET_LENGTH)
   81f92:	79bb      	ldrb	r3, [r7, #6]
   81f94:	2b98      	cmp	r3, #152	; 0x98
   81f96:	d010      	beq.n	81fba <verify_telecommand+0x4e>
	{
		send_tc_verification(packet_id, psc, 0xFF, 1, (uint32_t)packet_length, 1);		// TC verify acceptance report, failure, 1 == invalid packet length
   81f98:	4b63      	ldr	r3, [pc, #396]	; (82128 <verify_telecommand+0x1bc>)
   81f9a:	881a      	ldrh	r2, [r3, #0]
   81f9c:	4b63      	ldr	r3, [pc, #396]	; (8212c <verify_telecommand+0x1c0>)
   81f9e:	881b      	ldrh	r3, [r3, #0]
   81fa0:	79b9      	ldrb	r1, [r7, #6]
   81fa2:	9100      	str	r1, [sp, #0]
   81fa4:	2101      	movs	r1, #1
   81fa6:	9101      	str	r1, [sp, #4]
   81fa8:	4610      	mov	r0, r2
   81faa:	4619      	mov	r1, r3
   81fac:	22ff      	movs	r2, #255	; 0xff
   81fae:	2301      	movs	r3, #1
   81fb0:	4c5f      	ldr	r4, [pc, #380]	; (82130 <verify_telecommand+0x1c4>)
   81fb2:	47a0      	blx	r4
		return -1;
   81fb4:	f04f 33ff 	mov.w	r3, #4294967295
   81fb8:	e27c      	b.n	824b4 <verify_telecommand+0x548>
	}
	
	if(pec0 != pec1)
   81fba:	88ba      	ldrh	r2, [r7, #4]
   81fbc:	887b      	ldrh	r3, [r7, #2]
   81fbe:	429a      	cmp	r2, r3
   81fc0:	d010      	beq.n	81fe4 <verify_telecommand+0x78>
	{
		send_tc_verification(packet_id, psc, 0xFF, 2, (uint32_t)pec1, 1);				// TC verify acceptance report, failure, 2 == invalid PEC (checksum)
   81fc2:	4b59      	ldr	r3, [pc, #356]	; (82128 <verify_telecommand+0x1bc>)
   81fc4:	881a      	ldrh	r2, [r3, #0]
   81fc6:	4b59      	ldr	r3, [pc, #356]	; (8212c <verify_telecommand+0x1c0>)
   81fc8:	881b      	ldrh	r3, [r3, #0]
   81fca:	8879      	ldrh	r1, [r7, #2]
   81fcc:	9100      	str	r1, [sp, #0]
   81fce:	2101      	movs	r1, #1
   81fd0:	9101      	str	r1, [sp, #4]
   81fd2:	4610      	mov	r0, r2
   81fd4:	4619      	mov	r1, r3
   81fd6:	22ff      	movs	r2, #255	; 0xff
   81fd8:	2302      	movs	r3, #2
   81fda:	4c55      	ldr	r4, [pc, #340]	; (82130 <verify_telecommand+0x1c4>)
   81fdc:	47a0      	blx	r4
		return -1;
   81fde:	f04f 33ff 	mov.w	r3, #4294967295
   81fe2:	e267      	b.n	824b4 <verify_telecommand+0x548>
	}
	
	if((service_type != 3) && (service_type != 6) && (service_type != 9) && (service_type != 69))
   81fe4:	f897 3020 	ldrb.w	r3, [r7, #32]
   81fe8:	2b03      	cmp	r3, #3
   81fea:	d01d      	beq.n	82028 <verify_telecommand+0xbc>
   81fec:	f897 3020 	ldrb.w	r3, [r7, #32]
   81ff0:	2b06      	cmp	r3, #6
   81ff2:	d019      	beq.n	82028 <verify_telecommand+0xbc>
   81ff4:	f897 3020 	ldrb.w	r3, [r7, #32]
   81ff8:	2b09      	cmp	r3, #9
   81ffa:	d015      	beq.n	82028 <verify_telecommand+0xbc>
   81ffc:	f897 3020 	ldrb.w	r3, [r7, #32]
   82000:	2b45      	cmp	r3, #69	; 0x45
   82002:	d011      	beq.n	82028 <verify_telecommand+0xbc>
	{
		send_tc_verification(packet_id, psc, 0xFF, 3, (uint32_t)service_type, 1);		// TC verify acceptance report, failure, 3 == invalid service type
   82004:	4b48      	ldr	r3, [pc, #288]	; (82128 <verify_telecommand+0x1bc>)
   82006:	881a      	ldrh	r2, [r3, #0]
   82008:	4b48      	ldr	r3, [pc, #288]	; (8212c <verify_telecommand+0x1c0>)
   8200a:	881b      	ldrh	r3, [r3, #0]
   8200c:	f897 1020 	ldrb.w	r1, [r7, #32]
   82010:	9100      	str	r1, [sp, #0]
   82012:	2101      	movs	r1, #1
   82014:	9101      	str	r1, [sp, #4]
   82016:	4610      	mov	r0, r2
   82018:	4619      	mov	r1, r3
   8201a:	22ff      	movs	r2, #255	; 0xff
   8201c:	2303      	movs	r3, #3
   8201e:	4c44      	ldr	r4, [pc, #272]	; (82130 <verify_telecommand+0x1c4>)
   82020:	47a0      	blx	r4
		return -1;
   82022:	f04f 33ff 	mov.w	r3, #4294967295
   82026:	e245      	b.n	824b4 <verify_telecommand+0x548>
	}
	
	if(service_type == HK_SERVICE)
   82028:	f897 3020 	ldrb.w	r3, [r7, #32]
   8202c:	2b03      	cmp	r3, #3
   8202e:	d13b      	bne.n	820a8 <verify_telecommand+0x13c>
	{
		if((service_sub_type != 1) && (service_sub_type != 2) && (service_sub_type != 3) && (service_sub_type != 4) && (service_sub_type != 5) && (service_sub_type != 6)
   82030:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82034:	2b01      	cmp	r3, #1
   82036:	d02e      	beq.n	82096 <verify_telecommand+0x12a>
   82038:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8203c:	2b02      	cmp	r3, #2
   8203e:	d02a      	beq.n	82096 <verify_telecommand+0x12a>
   82040:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82044:	2b03      	cmp	r3, #3
   82046:	d026      	beq.n	82096 <verify_telecommand+0x12a>
   82048:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8204c:	2b04      	cmp	r3, #4
   8204e:	d022      	beq.n	82096 <verify_telecommand+0x12a>
   82050:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82054:	2b05      	cmp	r3, #5
   82056:	d01e      	beq.n	82096 <verify_telecommand+0x12a>
   82058:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8205c:	2b06      	cmp	r3, #6
   8205e:	d01a      	beq.n	82096 <verify_telecommand+0x12a>
		&& (service_sub_type != 7) && (service_sub_type != 8) && (service_sub_type != 9) && (service_sub_type != 11) && (service_sub_type != 17) && (service_sub_type != 18))
   82060:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82064:	2b07      	cmp	r3, #7
   82066:	d016      	beq.n	82096 <verify_telecommand+0x12a>
   82068:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8206c:	2b08      	cmp	r3, #8
   8206e:	d012      	beq.n	82096 <verify_telecommand+0x12a>
   82070:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82074:	2b09      	cmp	r3, #9
   82076:	d00e      	beq.n	82096 <verify_telecommand+0x12a>
   82078:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8207c:	2b0b      	cmp	r3, #11
   8207e:	d00a      	beq.n	82096 <verify_telecommand+0x12a>
   82080:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82084:	2b11      	cmp	r3, #17
   82086:	d006      	beq.n	82096 <verify_telecommand+0x12a>
   82088:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8208c:	2b12      	cmp	r3, #18
   8208e:	d002      	beq.n	82096 <verify_telecommand+0x12a>
		{
			//send_tc_verification(packet_id, psc, 0xFF, 4, (uint32_t)service_sub_type, 1);	// TC verify acceptance report, failure, 4 == invalid service subtype.
			return -1;
   82090:	f04f 33ff 	mov.w	r3, #4294967295
   82094:	e20e      	b.n	824b4 <verify_telecommand+0x548>
		}
		
		if((apid != HK_TASK_ID) && (apid != FDIR_TASK_ID))
   82096:	79fb      	ldrb	r3, [r7, #7]
   82098:	2b04      	cmp	r3, #4
   8209a:	d005      	beq.n	820a8 <verify_telecommand+0x13c>
   8209c:	79fb      	ldrb	r3, [r7, #7]
   8209e:	2b0c      	cmp	r3, #12
   820a0:	d002      	beq.n	820a8 <verify_telecommand+0x13c>
		{
			//send_tc_verification(packet_id, psc, 0xFF, 0, (uint32_t)apid, 1);				// TC verify acceptance report, failure, 0 == invalid apid
			return -1;
   820a2:	f04f 33ff 	mov.w	r3, #4294967295
   820a6:	e205      	b.n	824b4 <verify_telecommand+0x548>
		}
	}
	
	if(service_type == MEMORY_SERVICE)
   820a8:	f897 3020 	ldrb.w	r3, [r7, #32]
   820ac:	2b06      	cmp	r3, #6
   820ae:	f040 80a9 	bne.w	82204 <verify_telecommand+0x298>
	{
		if((service_sub_type != 2) && (service_sub_type != 5) && (service_sub_type != 9))
   820b2:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   820b6:	2b02      	cmp	r3, #2
   820b8:	d019      	beq.n	820ee <verify_telecommand+0x182>
   820ba:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   820be:	2b05      	cmp	r3, #5
   820c0:	d015      	beq.n	820ee <verify_telecommand+0x182>
   820c2:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   820c6:	2b09      	cmp	r3, #9
   820c8:	d011      	beq.n	820ee <verify_telecommand+0x182>
		{
			send_tc_verification(packet_id, psc, 0xFF, 4, (uint32_t)service_sub_type, 1);	// TC verify acceptance report, failure, 4 == invalid service subtype
   820ca:	4b17      	ldr	r3, [pc, #92]	; (82128 <verify_telecommand+0x1bc>)
   820cc:	881a      	ldrh	r2, [r3, #0]
   820ce:	4b17      	ldr	r3, [pc, #92]	; (8212c <verify_telecommand+0x1c0>)
   820d0:	881b      	ldrh	r3, [r3, #0]
   820d2:	f897 1024 	ldrb.w	r1, [r7, #36]	; 0x24
   820d6:	9100      	str	r1, [sp, #0]
   820d8:	2101      	movs	r1, #1
   820da:	9101      	str	r1, [sp, #4]
   820dc:	4610      	mov	r0, r2
   820de:	4619      	mov	r1, r3
   820e0:	22ff      	movs	r2, #255	; 0xff
   820e2:	2304      	movs	r3, #4
   820e4:	4c12      	ldr	r4, [pc, #72]	; (82130 <verify_telecommand+0x1c4>)
   820e6:	47a0      	blx	r4
			return -1;
   820e8:	f04f 33ff 	mov.w	r3, #4294967295
   820ec:	e1e2      	b.n	824b4 <verify_telecommand+0x548>
		}
		if(apid != MEMORY_TASK_ID)
   820ee:	79fb      	ldrb	r3, [r7, #7]
   820f0:	2b0e      	cmp	r3, #14
   820f2:	d01f      	beq.n	82134 <verify_telecommand+0x1c8>
		{
			send_tc_verification(packet_id, psc, 0xFF, 0, (uint32_t)apid, 1);				// TC verify acceptance report, failure, 0 == invalid apid
   820f4:	4b0c      	ldr	r3, [pc, #48]	; (82128 <verify_telecommand+0x1bc>)
   820f6:	881a      	ldrh	r2, [r3, #0]
   820f8:	4b0c      	ldr	r3, [pc, #48]	; (8212c <verify_telecommand+0x1c0>)
   820fa:	881b      	ldrh	r3, [r3, #0]
   820fc:	79f9      	ldrb	r1, [r7, #7]
   820fe:	9100      	str	r1, [sp, #0]
   82100:	2101      	movs	r1, #1
   82102:	9101      	str	r1, [sp, #4]
   82104:	4610      	mov	r0, r2
   82106:	4619      	mov	r1, r3
   82108:	22ff      	movs	r2, #255	; 0xff
   8210a:	2300      	movs	r3, #0
   8210c:	4c08      	ldr	r4, [pc, #32]	; (82130 <verify_telecommand+0x1c4>)
   8210e:	47a0      	blx	r4
			return -1;
   82110:	f04f 33ff 	mov.w	r3, #4294967295
   82114:	e1ce      	b.n	824b4 <verify_telecommand+0x548>
   82116:	bf00      	nop
   82118:	200705d8 	.word	0x200705d8
   8211c:	200705dc 	.word	0x200705dc
   82120:	200705e0 	.word	0x200705e0
   82124:	200705e4 	.word	0x200705e4
   82128:	2007045e 	.word	0x2007045e
   8212c:	20070460 	.word	0x20070460
   82130:	000824d9 	.word	0x000824d9
		}
		address =  ((uint32_t)tc_to_decode[137]) << 24;
   82134:	4b7d      	ldr	r3, [pc, #500]	; (8232c <verify_telecommand+0x3c0>)
   82136:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
   8213a:	061a      	lsls	r2, r3, #24
   8213c:	4b7c      	ldr	r3, [pc, #496]	; (82330 <verify_telecommand+0x3c4>)
   8213e:	601a      	str	r2, [r3, #0]
		address += ((uint32_t)tc_to_decode[136]) << 16;
   82140:	4b7a      	ldr	r3, [pc, #488]	; (8232c <verify_telecommand+0x3c0>)
   82142:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   82146:	041a      	lsls	r2, r3, #16
   82148:	4b79      	ldr	r3, [pc, #484]	; (82330 <verify_telecommand+0x3c4>)
   8214a:	681b      	ldr	r3, [r3, #0]
   8214c:	441a      	add	r2, r3
   8214e:	4b78      	ldr	r3, [pc, #480]	; (82330 <verify_telecommand+0x3c4>)
   82150:	601a      	str	r2, [r3, #0]
		address += ((uint32_t)tc_to_decode[135]) << 8;
   82152:	4b76      	ldr	r3, [pc, #472]	; (8232c <verify_telecommand+0x3c0>)
   82154:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
   82158:	021a      	lsls	r2, r3, #8
   8215a:	4b75      	ldr	r3, [pc, #468]	; (82330 <verify_telecommand+0x3c4>)
   8215c:	681b      	ldr	r3, [r3, #0]
   8215e:	441a      	add	r2, r3
   82160:	4b73      	ldr	r3, [pc, #460]	; (82330 <verify_telecommand+0x3c4>)
   82162:	601a      	str	r2, [r3, #0]
		address += (uint32_t)tc_to_decode[134];
   82164:	4b71      	ldr	r3, [pc, #452]	; (8232c <verify_telecommand+0x3c0>)
   82166:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
   8216a:	461a      	mov	r2, r3
   8216c:	4b70      	ldr	r3, [pc, #448]	; (82330 <verify_telecommand+0x3c4>)
   8216e:	681b      	ldr	r3, [r3, #0]
   82170:	441a      	add	r2, r3
   82172:	4b6f      	ldr	r3, [pc, #444]	; (82330 <verify_telecommand+0x3c4>)
   82174:	601a      	str	r2, [r3, #0]
		
		if(tc_to_decode[138] > 1)											// Invalid memory ID.
   82176:	4b6d      	ldr	r3, [pc, #436]	; (8232c <verify_telecommand+0x3c0>)
   82178:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
   8217c:	2b01      	cmp	r3, #1
   8217e:	d90d      	bls.n	8219c <verify_telecommand+0x230>
			send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);
   82180:	4b6c      	ldr	r3, [pc, #432]	; (82334 <verify_telecommand+0x3c8>)
   82182:	881a      	ldrh	r2, [r3, #0]
   82184:	4b6c      	ldr	r3, [pc, #432]	; (82338 <verify_telecommand+0x3cc>)
   82186:	881b      	ldrh	r3, [r3, #0]
   82188:	2100      	movs	r1, #0
   8218a:	9100      	str	r1, [sp, #0]
   8218c:	2101      	movs	r1, #1
   8218e:	9101      	str	r1, [sp, #4]
   82190:	4610      	mov	r0, r2
   82192:	4619      	mov	r1, r3
   82194:	22ff      	movs	r2, #255	; 0xff
   82196:	2305      	movs	r3, #5
   82198:	4c68      	ldr	r4, [pc, #416]	; (8233c <verify_telecommand+0x3d0>)
   8219a:	47a0      	blx	r4
		if((tc_to_decode[138] == 1) && (address > 0xFFFFF))				// Invalid memory address (too high)
   8219c:	4b63      	ldr	r3, [pc, #396]	; (8232c <verify_telecommand+0x3c0>)
   8219e:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
   821a2:	2b01      	cmp	r3, #1
   821a4:	d112      	bne.n	821cc <verify_telecommand+0x260>
   821a6:	4b62      	ldr	r3, [pc, #392]	; (82330 <verify_telecommand+0x3c4>)
   821a8:	681b      	ldr	r3, [r3, #0]
   821aa:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
   821ae:	d30d      	bcc.n	821cc <verify_telecommand+0x260>
			send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);
   821b0:	4b60      	ldr	r3, [pc, #384]	; (82334 <verify_telecommand+0x3c8>)
   821b2:	881a      	ldrh	r2, [r3, #0]
   821b4:	4b60      	ldr	r3, [pc, #384]	; (82338 <verify_telecommand+0x3cc>)
   821b6:	881b      	ldrh	r3, [r3, #0]
   821b8:	2100      	movs	r1, #0
   821ba:	9100      	str	r1, [sp, #0]
   821bc:	2101      	movs	r1, #1
   821be:	9101      	str	r1, [sp, #4]
   821c0:	4610      	mov	r0, r2
   821c2:	4619      	mov	r1, r3
   821c4:	22ff      	movs	r2, #255	; 0xff
   821c6:	2305      	movs	r3, #5
   821c8:	4c5c      	ldr	r4, [pc, #368]	; (8233c <verify_telecommand+0x3d0>)
   821ca:	47a0      	blx	r4
		if((tc_to_decode[138] == 1) && INTERNAL_MEMORY_FALLBACK_MODE && (address > 0x0FFF))		// Invalid memory address (too high for INT MEM FALLBACK MODE)
   821cc:	4b57      	ldr	r3, [pc, #348]	; (8232c <verify_telecommand+0x3c0>)
   821ce:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
   821d2:	2b01      	cmp	r3, #1
   821d4:	d116      	bne.n	82204 <verify_telecommand+0x298>
   821d6:	4b5a      	ldr	r3, [pc, #360]	; (82340 <verify_telecommand+0x3d4>)
   821d8:	681b      	ldr	r3, [r3, #0]
   821da:	2b00      	cmp	r3, #0
   821dc:	d012      	beq.n	82204 <verify_telecommand+0x298>
   821de:	4b54      	ldr	r3, [pc, #336]	; (82330 <verify_telecommand+0x3c4>)
   821e0:	681b      	ldr	r3, [r3, #0]
   821e2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   821e6:	d30d      	bcc.n	82204 <verify_telecommand+0x298>
			send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);			
   821e8:	4b52      	ldr	r3, [pc, #328]	; (82334 <verify_telecommand+0x3c8>)
   821ea:	881a      	ldrh	r2, [r3, #0]
   821ec:	4b52      	ldr	r3, [pc, #328]	; (82338 <verify_telecommand+0x3cc>)
   821ee:	881b      	ldrh	r3, [r3, #0]
   821f0:	2100      	movs	r1, #0
   821f2:	9100      	str	r1, [sp, #0]
   821f4:	2101      	movs	r1, #1
   821f6:	9101      	str	r1, [sp, #4]
   821f8:	4610      	mov	r0, r2
   821fa:	4619      	mov	r1, r3
   821fc:	22ff      	movs	r2, #255	; 0xff
   821fe:	2305      	movs	r3, #5
   82200:	4c4e      	ldr	r4, [pc, #312]	; (8233c <verify_telecommand+0x3d0>)
   82202:	47a0      	blx	r4
	}
	
	if(service_type == TIME_SERVICE)
   82204:	f897 3020 	ldrb.w	r3, [r7, #32]
   82208:	2b09      	cmp	r3, #9
   8220a:	d129      	bne.n	82260 <verify_telecommand+0x2f4>
	{
		if(service_sub_type != UPDATE_REPORT_FREQ)
   8220c:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82210:	2b01      	cmp	r3, #1
   82212:	d011      	beq.n	82238 <verify_telecommand+0x2cc>
		{
			send_tc_verification(packet_id, psc, 0xFF, 4, (uint32_t)service_sub_type, 1);		// TC verify acceptance report, failure, 4 == invalid service subtype
   82214:	4b47      	ldr	r3, [pc, #284]	; (82334 <verify_telecommand+0x3c8>)
   82216:	881a      	ldrh	r2, [r3, #0]
   82218:	4b47      	ldr	r3, [pc, #284]	; (82338 <verify_telecommand+0x3cc>)
   8221a:	881b      	ldrh	r3, [r3, #0]
   8221c:	f897 1024 	ldrb.w	r1, [r7, #36]	; 0x24
   82220:	9100      	str	r1, [sp, #0]
   82222:	2101      	movs	r1, #1
   82224:	9101      	str	r1, [sp, #4]
   82226:	4610      	mov	r0, r2
   82228:	4619      	mov	r1, r3
   8222a:	22ff      	movs	r2, #255	; 0xff
   8222c:	2304      	movs	r3, #4
   8222e:	4c43      	ldr	r4, [pc, #268]	; (8233c <verify_telecommand+0x3d0>)
   82230:	47a0      	blx	r4
			return -1;			
   82232:	f04f 33ff 	mov.w	r3, #4294967295
   82236:	e13d      	b.n	824b4 <verify_telecommand+0x548>
		}
		if(apid != TIME_TASK_ID)
   82238:	79fb      	ldrb	r3, [r7, #7]
   8223a:	2b06      	cmp	r3, #6
   8223c:	d010      	beq.n	82260 <verify_telecommand+0x2f4>
		{
			send_tc_verification(packet_id, psc, 0xFF, 0, (uint32_t)apid, 1);				// TC verify acceptance report, failure, 0 == invalid apid
   8223e:	4b3d      	ldr	r3, [pc, #244]	; (82334 <verify_telecommand+0x3c8>)
   82240:	881a      	ldrh	r2, [r3, #0]
   82242:	4b3d      	ldr	r3, [pc, #244]	; (82338 <verify_telecommand+0x3cc>)
   82244:	881b      	ldrh	r3, [r3, #0]
   82246:	79f9      	ldrb	r1, [r7, #7]
   82248:	9100      	str	r1, [sp, #0]
   8224a:	2101      	movs	r1, #1
   8224c:	9101      	str	r1, [sp, #4]
   8224e:	4610      	mov	r0, r2
   82250:	4619      	mov	r1, r3
   82252:	22ff      	movs	r2, #255	; 0xff
   82254:	2300      	movs	r3, #0
   82256:	4c39      	ldr	r4, [pc, #228]	; (8233c <verify_telecommand+0x3d0>)
   82258:	47a0      	blx	r4
			return -1;
   8225a:	f04f 33ff 	mov.w	r3, #4294967295
   8225e:	e129      	b.n	824b4 <verify_telecommand+0x548>
		}
	}
	
	if(service_type == K_SERVICE)
   82260:	f897 3020 	ldrb.w	r3, [r7, #32]
   82264:	2b45      	cmp	r3, #69	; 0x45
   82266:	f040 80c7 	bne.w	823f8 <verify_telecommand+0x48c>
	{
		length = tc_to_decode[136];
   8226a:	4b30      	ldr	r3, [pc, #192]	; (8232c <verify_telecommand+0x3c0>)
   8226c:	f893 3088 	ldrb.w	r3, [r3, #136]	; 0x88
   82270:	461a      	mov	r2, r3
   82272:	4b34      	ldr	r3, [pc, #208]	; (82344 <verify_telecommand+0x3d8>)
   82274:	601a      	str	r2, [r3, #0]
		
		if((service_sub_type > 11) || !service_sub_type)
   82276:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8227a:	2b0b      	cmp	r3, #11
   8227c:	d803      	bhi.n	82286 <verify_telecommand+0x31a>
   8227e:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82282:	2b00      	cmp	r3, #0
   82284:	d111      	bne.n	822aa <verify_telecommand+0x33e>
		{
			send_tc_verification(packet_id, psc, 0xFF, 4, (uint32_t)service_sub_type, 1);
   82286:	4b2b      	ldr	r3, [pc, #172]	; (82334 <verify_telecommand+0x3c8>)
   82288:	881a      	ldrh	r2, [r3, #0]
   8228a:	4b2b      	ldr	r3, [pc, #172]	; (82338 <verify_telecommand+0x3cc>)
   8228c:	881b      	ldrh	r3, [r3, #0]
   8228e:	f897 1024 	ldrb.w	r1, [r7, #36]	; 0x24
   82292:	9100      	str	r1, [sp, #0]
   82294:	2101      	movs	r1, #1
   82296:	9101      	str	r1, [sp, #4]
   82298:	4610      	mov	r0, r2
   8229a:	4619      	mov	r1, r3
   8229c:	22ff      	movs	r2, #255	; 0xff
   8229e:	2304      	movs	r3, #4
   822a0:	4c26      	ldr	r4, [pc, #152]	; (8233c <verify_telecommand+0x3d0>)
   822a2:	47a0      	blx	r4
			return -1;
   822a4:	f04f 33ff 	mov.w	r3, #4294967295
   822a8:	e104      	b.n	824b4 <verify_telecommand+0x548>
		}
		if((tc_to_decode[135] || tc_to_decode[134] || tc_to_decode[133] || tc_to_decode[132]) && (service_sub_type != 1))	// Time should be zero for immediate commands
   822aa:	4b20      	ldr	r3, [pc, #128]	; (8232c <verify_telecommand+0x3c0>)
   822ac:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
   822b0:	2b00      	cmp	r3, #0
   822b2:	d10e      	bne.n	822d2 <verify_telecommand+0x366>
   822b4:	4b1d      	ldr	r3, [pc, #116]	; (8232c <verify_telecommand+0x3c0>)
   822b6:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
   822ba:	2b00      	cmp	r3, #0
   822bc:	d109      	bne.n	822d2 <verify_telecommand+0x366>
   822be:	4b1b      	ldr	r3, [pc, #108]	; (8232c <verify_telecommand+0x3c0>)
   822c0:	f893 3085 	ldrb.w	r3, [r3, #133]	; 0x85
   822c4:	2b00      	cmp	r3, #0
   822c6:	d104      	bne.n	822d2 <verify_telecommand+0x366>
   822c8:	4b18      	ldr	r3, [pc, #96]	; (8232c <verify_telecommand+0x3c0>)
   822ca:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
   822ce:	2b00      	cmp	r3, #0
   822d0:	d014      	beq.n	822fc <verify_telecommand+0x390>
   822d2:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   822d6:	2b01      	cmp	r3, #1
   822d8:	d010      	beq.n	822fc <verify_telecommand+0x390>
		{
			send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);					// Usage error.
   822da:	4b16      	ldr	r3, [pc, #88]	; (82334 <verify_telecommand+0x3c8>)
   822dc:	881a      	ldrh	r2, [r3, #0]
   822de:	4b16      	ldr	r3, [pc, #88]	; (82338 <verify_telecommand+0x3cc>)
   822e0:	881b      	ldrh	r3, [r3, #0]
   822e2:	2100      	movs	r1, #0
   822e4:	9100      	str	r1, [sp, #0]
   822e6:	2101      	movs	r1, #1
   822e8:	9101      	str	r1, [sp, #4]
   822ea:	4610      	mov	r0, r2
   822ec:	4619      	mov	r1, r3
   822ee:	22ff      	movs	r2, #255	; 0xff
   822f0:	2305      	movs	r3, #5
   822f2:	4c12      	ldr	r4, [pc, #72]	; (8233c <verify_telecommand+0x3d0>)
   822f4:	47a0      	blx	r4
			return -1;
   822f6:	f04f 33ff 	mov.w	r3, #4294967295
   822fa:	e0db      	b.n	824b4 <verify_telecommand+0x548>
		}
		if(tc_to_decode[135] || tc_to_decode[134] || tc_to_decode[133] || tc_to_decode[132])
   822fc:	4b0b      	ldr	r3, [pc, #44]	; (8232c <verify_telecommand+0x3c0>)
   822fe:	f893 3087 	ldrb.w	r3, [r3, #135]	; 0x87
   82302:	2b00      	cmp	r3, #0
   82304:	d10e      	bne.n	82324 <verify_telecommand+0x3b8>
   82306:	4b09      	ldr	r3, [pc, #36]	; (8232c <verify_telecommand+0x3c0>)
   82308:	f893 3086 	ldrb.w	r3, [r3, #134]	; 0x86
   8230c:	2b00      	cmp	r3, #0
   8230e:	d109      	bne.n	82324 <verify_telecommand+0x3b8>
   82310:	4b06      	ldr	r3, [pc, #24]	; (8232c <verify_telecommand+0x3c0>)
   82312:	f893 3085 	ldrb.w	r3, [r3, #133]	; 0x85
   82316:	2b00      	cmp	r3, #0
   82318:	d104      	bne.n	82324 <verify_telecommand+0x3b8>
   8231a:	4b04      	ldr	r3, [pc, #16]	; (8232c <verify_telecommand+0x3c0>)
   8231c:	f893 3084 	ldrb.w	r3, [r3, #132]	; 0x84
   82320:	2b00      	cmp	r3, #0
   82322:	d069      	beq.n	823f8 <verify_telecommand+0x48c>
		{
			for(i = 0; i < length; i++)
   82324:	2300      	movs	r3, #0
   82326:	73fb      	strb	r3, [r7, #15]
   82328:	e061      	b.n	823ee <verify_telecommand+0x482>
   8232a:	bf00      	nop
   8232c:	20070718 	.word	0x20070718
   82330:	200705d8 	.word	0x200705d8
   82334:	2007045e 	.word	0x2007045e
   82338:	20070460 	.word	0x20070460
   8233c:	000824d9 	.word	0x000824d9
   82340:	2007b3f8 	.word	0x2007b3f8
   82344:	200705dc 	.word	0x200705dc
			{
				new_time = ((uint32_t)tc_to_decode[135 - (i * 8)]) << 24;
   82348:	7bfa      	ldrb	r2, [r7, #15]
   8234a:	4613      	mov	r3, r2
   8234c:	075b      	lsls	r3, r3, #29
   8234e:	1a9b      	subs	r3, r3, r2
   82350:	00db      	lsls	r3, r3, #3
   82352:	3387      	adds	r3, #135	; 0x87
   82354:	4a59      	ldr	r2, [pc, #356]	; (824bc <verify_telecommand+0x550>)
   82356:	5cd3      	ldrb	r3, [r2, r3]
   82358:	061a      	lsls	r2, r3, #24
   8235a:	4b59      	ldr	r3, [pc, #356]	; (824c0 <verify_telecommand+0x554>)
   8235c:	601a      	str	r2, [r3, #0]
				new_time += ((uint32_t)tc_to_decode[134 - (i * 8)]) << 16;
   8235e:	7bfa      	ldrb	r2, [r7, #15]
   82360:	4613      	mov	r3, r2
   82362:	075b      	lsls	r3, r3, #29
   82364:	1a9b      	subs	r3, r3, r2
   82366:	00db      	lsls	r3, r3, #3
   82368:	3386      	adds	r3, #134	; 0x86
   8236a:	4a54      	ldr	r2, [pc, #336]	; (824bc <verify_telecommand+0x550>)
   8236c:	5cd3      	ldrb	r3, [r2, r3]
   8236e:	041a      	lsls	r2, r3, #16
   82370:	4b53      	ldr	r3, [pc, #332]	; (824c0 <verify_telecommand+0x554>)
   82372:	681b      	ldr	r3, [r3, #0]
   82374:	441a      	add	r2, r3
   82376:	4b52      	ldr	r3, [pc, #328]	; (824c0 <verify_telecommand+0x554>)
   82378:	601a      	str	r2, [r3, #0]
				new_time += ((uint32_t)tc_to_decode[133 - (i * 8)]) << 8;
   8237a:	7bfa      	ldrb	r2, [r7, #15]
   8237c:	4613      	mov	r3, r2
   8237e:	075b      	lsls	r3, r3, #29
   82380:	1a9b      	subs	r3, r3, r2
   82382:	00db      	lsls	r3, r3, #3
   82384:	3385      	adds	r3, #133	; 0x85
   82386:	4a4d      	ldr	r2, [pc, #308]	; (824bc <verify_telecommand+0x550>)
   82388:	5cd3      	ldrb	r3, [r2, r3]
   8238a:	021a      	lsls	r2, r3, #8
   8238c:	4b4c      	ldr	r3, [pc, #304]	; (824c0 <verify_telecommand+0x554>)
   8238e:	681b      	ldr	r3, [r3, #0]
   82390:	441a      	add	r2, r3
   82392:	4b4b      	ldr	r3, [pc, #300]	; (824c0 <verify_telecommand+0x554>)
   82394:	601a      	str	r2, [r3, #0]
				new_time += (uint32_t)tc_to_decode[132 - (i * 8)];
   82396:	7bfa      	ldrb	r2, [r7, #15]
   82398:	4613      	mov	r3, r2
   8239a:	075b      	lsls	r3, r3, #29
   8239c:	1a9b      	subs	r3, r3, r2
   8239e:	00db      	lsls	r3, r3, #3
   823a0:	3384      	adds	r3, #132	; 0x84
   823a2:	4a46      	ldr	r2, [pc, #280]	; (824bc <verify_telecommand+0x550>)
   823a4:	5cd3      	ldrb	r3, [r2, r3]
   823a6:	461a      	mov	r2, r3
   823a8:	4b45      	ldr	r3, [pc, #276]	; (824c0 <verify_telecommand+0x554>)
   823aa:	681b      	ldr	r3, [r3, #0]
   823ac:	441a      	add	r2, r3
   823ae:	4b44      	ldr	r3, [pc, #272]	; (824c0 <verify_telecommand+0x554>)
   823b0:	601a      	str	r2, [r3, #0]
				if(new_time < last_time)												// Scheduled commands should be in chronological order
   823b2:	4b43      	ldr	r3, [pc, #268]	; (824c0 <verify_telecommand+0x554>)
   823b4:	681a      	ldr	r2, [r3, #0]
   823b6:	4b43      	ldr	r3, [pc, #268]	; (824c4 <verify_telecommand+0x558>)
   823b8:	681b      	ldr	r3, [r3, #0]
   823ba:	429a      	cmp	r2, r3
   823bc:	d210      	bcs.n	823e0 <verify_telecommand+0x474>
				{
					send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);			// Usage error.
   823be:	4b42      	ldr	r3, [pc, #264]	; (824c8 <verify_telecommand+0x55c>)
   823c0:	881a      	ldrh	r2, [r3, #0]
   823c2:	4b42      	ldr	r3, [pc, #264]	; (824cc <verify_telecommand+0x560>)
   823c4:	881b      	ldrh	r3, [r3, #0]
   823c6:	2100      	movs	r1, #0
   823c8:	9100      	str	r1, [sp, #0]
   823ca:	2101      	movs	r1, #1
   823cc:	9101      	str	r1, [sp, #4]
   823ce:	4610      	mov	r0, r2
   823d0:	4619      	mov	r1, r3
   823d2:	22ff      	movs	r2, #255	; 0xff
   823d4:	2305      	movs	r3, #5
   823d6:	4c3e      	ldr	r4, [pc, #248]	; (824d0 <verify_telecommand+0x564>)
   823d8:	47a0      	blx	r4
					return -1;
   823da:	f04f 33ff 	mov.w	r3, #4294967295
   823de:	e069      	b.n	824b4 <verify_telecommand+0x548>
				}
				last_time = new_time;
   823e0:	4b37      	ldr	r3, [pc, #220]	; (824c0 <verify_telecommand+0x554>)
   823e2:	681a      	ldr	r2, [r3, #0]
   823e4:	4b37      	ldr	r3, [pc, #220]	; (824c4 <verify_telecommand+0x558>)
   823e6:	601a      	str	r2, [r3, #0]
			send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);					// Usage error.
			return -1;
		}
		if(tc_to_decode[135] || tc_to_decode[134] || tc_to_decode[133] || tc_to_decode[132])
		{
			for(i = 0; i < length; i++)
   823e8:	7bfb      	ldrb	r3, [r7, #15]
   823ea:	3301      	adds	r3, #1
   823ec:	73fb      	strb	r3, [r7, #15]
   823ee:	7bfa      	ldrb	r2, [r7, #15]
   823f0:	4b38      	ldr	r3, [pc, #224]	; (824d4 <verify_telecommand+0x568>)
   823f2:	681b      	ldr	r3, [r3, #0]
   823f4:	429a      	cmp	r2, r3
   823f6:	d3a7      	bcc.n	82348 <verify_telecommand+0x3dc>
				}
				last_time = new_time;
			}
		}
	}
	if(service_type == FDIR_SERVICE)
   823f8:	f897 3020 	ldrb.w	r3, [r7, #32]
   823fc:	2b46      	cmp	r3, #70	; 0x46
   823fe:	d119      	bne.n	82434 <verify_telecommand+0x4c8>
	{
		if((service_sub_type > 12) || !service_sub_type)
   82400:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   82404:	2b0c      	cmp	r3, #12
   82406:	d803      	bhi.n	82410 <verify_telecommand+0x4a4>
   82408:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   8240c:	2b00      	cmp	r3, #0
   8240e:	d111      	bne.n	82434 <verify_telecommand+0x4c8>
		{
			send_tc_verification(packet_id, psc, 0xFF, 4, (uint32_t)service_sub_type, 1);
   82410:	4b2d      	ldr	r3, [pc, #180]	; (824c8 <verify_telecommand+0x55c>)
   82412:	881a      	ldrh	r2, [r3, #0]
   82414:	4b2d      	ldr	r3, [pc, #180]	; (824cc <verify_telecommand+0x560>)
   82416:	881b      	ldrh	r3, [r3, #0]
   82418:	f897 1024 	ldrb.w	r1, [r7, #36]	; 0x24
   8241c:	9100      	str	r1, [sp, #0]
   8241e:	2101      	movs	r1, #1
   82420:	9101      	str	r1, [sp, #4]
   82422:	4610      	mov	r0, r2
   82424:	4619      	mov	r1, r3
   82426:	22ff      	movs	r2, #255	; 0xff
   82428:	2304      	movs	r3, #4
   8242a:	4c29      	ldr	r4, [pc, #164]	; (824d0 <verify_telecommand+0x564>)
   8242c:	47a0      	blx	r4
			return -1;
   8242e:	f04f 33ff 	mov.w	r3, #4294967295
   82432:	e03f      	b.n	824b4 <verify_telecommand+0x548>
		}
	}
	
	if(version != 0)
   82434:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   82438:	2b00      	cmp	r3, #0
   8243a:	d010      	beq.n	8245e <verify_telecommand+0x4f2>
	{
		send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);							// TC verify acceptance repoort, failure, 5 == usage error
   8243c:	4b22      	ldr	r3, [pc, #136]	; (824c8 <verify_telecommand+0x55c>)
   8243e:	881a      	ldrh	r2, [r3, #0]
   82440:	4b22      	ldr	r3, [pc, #136]	; (824cc <verify_telecommand+0x560>)
   82442:	881b      	ldrh	r3, [r3, #0]
   82444:	2100      	movs	r1, #0
   82446:	9100      	str	r1, [sp, #0]
   82448:	2101      	movs	r1, #1
   8244a:	9101      	str	r1, [sp, #4]
   8244c:	4610      	mov	r0, r2
   8244e:	4619      	mov	r1, r3
   82450:	22ff      	movs	r2, #255	; 0xff
   82452:	2305      	movs	r3, #5
   82454:	4c1e      	ldr	r4, [pc, #120]	; (824d0 <verify_telecommand+0x564>)
   82456:	47a0      	blx	r4
		return -1;
   82458:	f04f 33ff 	mov.w	r3, #4294967295
   8245c:	e02a      	b.n	824b4 <verify_telecommand+0x548>
	}
	
	if(ccsds_flag != 1)
   8245e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   82462:	2b01      	cmp	r3, #1
   82464:	d010      	beq.n	82488 <verify_telecommand+0x51c>
	{
		send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);							// TC verify acceptance report, failure, 5 == usage error
   82466:	4b18      	ldr	r3, [pc, #96]	; (824c8 <verify_telecommand+0x55c>)
   82468:	881a      	ldrh	r2, [r3, #0]
   8246a:	4b18      	ldr	r3, [pc, #96]	; (824cc <verify_telecommand+0x560>)
   8246c:	881b      	ldrh	r3, [r3, #0]
   8246e:	2100      	movs	r1, #0
   82470:	9100      	str	r1, [sp, #0]
   82472:	2101      	movs	r1, #1
   82474:	9101      	str	r1, [sp, #4]
   82476:	4610      	mov	r0, r2
   82478:	4619      	mov	r1, r3
   8247a:	22ff      	movs	r2, #255	; 0xff
   8247c:	2305      	movs	r3, #5
   8247e:	4c14      	ldr	r4, [pc, #80]	; (824d0 <verify_telecommand+0x564>)
   82480:	47a0      	blx	r4
		return -1;
   82482:	f04f 33ff 	mov.w	r3, #4294967295
   82486:	e015      	b.n	824b4 <verify_telecommand+0x548>
	}
	
	if(packet_version != 1)
   82488:	f897 3030 	ldrb.w	r3, [r7, #48]	; 0x30
   8248c:	2b01      	cmp	r3, #1
   8248e:	d010      	beq.n	824b2 <verify_telecommand+0x546>
	{
		send_tc_verification(packet_id, psc, 0xFF, 5, 0x00, 1);							// TC verify acceptance report, failure, 5 == usage error
   82490:	4b0d      	ldr	r3, [pc, #52]	; (824c8 <verify_telecommand+0x55c>)
   82492:	881a      	ldrh	r2, [r3, #0]
   82494:	4b0d      	ldr	r3, [pc, #52]	; (824cc <verify_telecommand+0x560>)
   82496:	881b      	ldrh	r3, [r3, #0]
   82498:	2100      	movs	r1, #0
   8249a:	9100      	str	r1, [sp, #0]
   8249c:	2101      	movs	r1, #1
   8249e:	9101      	str	r1, [sp, #4]
   824a0:	4610      	mov	r0, r2
   824a2:	4619      	mov	r1, r3
   824a4:	22ff      	movs	r2, #255	; 0xff
   824a6:	2305      	movs	r3, #5
   824a8:	4c09      	ldr	r4, [pc, #36]	; (824d0 <verify_telecommand+0x564>)
   824aa:	47a0      	blx	r4
		return -1;
   824ac:	f04f 33ff 	mov.w	r3, #4294967295
   824b0:	e000      	b.n	824b4 <verify_telecommand+0x548>
	}
	
	/* The telecommand packet is good to be decoded further!		*/
	//send_tc_verification(packet_id, psc, 0, 0, 0, 1);										// TC verify acceptance report, success.
	return 1;
   824b2:	2301      	movs	r3, #1
}
   824b4:	4618      	mov	r0, r3
   824b6:	3714      	adds	r7, #20
   824b8:	46bd      	mov	sp, r7
   824ba:	bd90      	pop	{r4, r7, pc}
   824bc:	20070718 	.word	0x20070718
   824c0:	200705e0 	.word	0x200705e0
   824c4:	200705e4 	.word	0x200705e4
   824c8:	2007045e 	.word	0x2007045e
   824cc:	20070460 	.word	0x20070460
   824d0:	000824d9 	.word	0x000824d9
   824d4:	200705dc 	.word	0x200705dc

000824d8 <send_tc_verification>:
/* @param: parameter: something informational to send to ground.		*/
/* @param: 1 == acceptance verification, 2 == execution verification	*/
/* @return: -1 = function failed, 1 = function succeeded.				*/
/************************************************************************/
static int send_tc_verification(uint16_t packet_id, uint16_t sequence_control, uint8_t status, uint8_t code, uint32_t parameter, uint8_t tc_type)
{
   824d8:	b590      	push	{r4, r7, lr}
   824da:	b089      	sub	sp, #36	; 0x24
   824dc:	af04      	add	r7, sp, #16
   824de:	80f8      	strh	r0, [r7, #6]
   824e0:	80b9      	strh	r1, [r7, #4]
   824e2:	70fa      	strb	r2, [r7, #3]
   824e4:	70bb      	strb	r3, [r7, #2]
	int resp = -1;
   824e6:	f04f 33ff 	mov.w	r3, #4294967295
   824ea:	60fb      	str	r3, [r7, #12]
	clear_current_data();	
   824ec:	4b66      	ldr	r3, [pc, #408]	; (82688 <send_tc_verification+0x1b0>)
   824ee:	4798      	blx	r3
	if(tc_type == 1)
   824f0:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   824f4:	2b01      	cmp	r3, #1
   824f6:	d173      	bne.n	825e0 <send_tc_verification+0x108>
	{
		if (code > 5)
   824f8:	78bb      	ldrb	r3, [r7, #2]
   824fa:	2b05      	cmp	r3, #5
   824fc:	d902      	bls.n	82504 <send_tc_verification+0x2c>
			return -1;				// Invalid code inputted.
   824fe:	f04f 33ff 	mov.w	r3, #4294967295
   82502:	e0bd      	b.n	82680 <send_tc_verification+0x1a8>
		if(!status)					// Telecommand Acceptance Report - Success (1,1)
   82504:	78fb      	ldrb	r3, [r7, #3]
   82506:	2b00      	cmp	r3, #0
   82508:	d128      	bne.n	8255c <send_tc_verification+0x84>
		{
			tc_verify_success_count++;
   8250a:	4b60      	ldr	r3, [pc, #384]	; (8268c <send_tc_verification+0x1b4>)
   8250c:	781b      	ldrb	r3, [r3, #0]
   8250e:	3301      	adds	r3, #1
   82510:	b2da      	uxtb	r2, r3
   82512:	4b5e      	ldr	r3, [pc, #376]	; (8268c <send_tc_verification+0x1b4>)
   82514:	701a      	strb	r2, [r3, #0]
			current_data[0] = (uint8_t)(sequence_control & 0x00FF);
   82516:	88bb      	ldrh	r3, [r7, #4]
   82518:	b2da      	uxtb	r2, r3
   8251a:	4b5d      	ldr	r3, [pc, #372]	; (82690 <send_tc_verification+0x1b8>)
   8251c:	701a      	strb	r2, [r3, #0]
			current_data[1] = (uint8_t)((sequence_control & 0xFF00) >> 8);
   8251e:	88bb      	ldrh	r3, [r7, #4]
   82520:	0a1b      	lsrs	r3, r3, #8
   82522:	b29b      	uxth	r3, r3
   82524:	b2da      	uxtb	r2, r3
   82526:	4b5a      	ldr	r3, [pc, #360]	; (82690 <send_tc_verification+0x1b8>)
   82528:	705a      	strb	r2, [r3, #1]
			current_data[2] = (uint8_t)(packet_id & 0x00FF);
   8252a:	88fb      	ldrh	r3, [r7, #6]
   8252c:	b2da      	uxtb	r2, r3
   8252e:	4b58      	ldr	r3, [pc, #352]	; (82690 <send_tc_verification+0x1b8>)
   82530:	709a      	strb	r2, [r3, #2]
			current_data[3] = (uint8_t)((packet_id & 0xFF00) >> 8);
   82532:	88fb      	ldrh	r3, [r7, #6]
   82534:	0a1b      	lsrs	r3, r3, #8
   82536:	b29b      	uxth	r3, r3
   82538:	b2da      	uxtb	r2, r3
   8253a:	4b55      	ldr	r3, [pc, #340]	; (82690 <send_tc_verification+0x1b8>)
   8253c:	70da      	strb	r2, [r3, #3]
			resp = packetize_send_telemetry(OBC_PACKET_ROUTER_ID, GROUND_PACKET_ROUTER_ID, 1, 1, tc_verify_success_count, 1, current_data);
   8253e:	4b53      	ldr	r3, [pc, #332]	; (8268c <send_tc_verification+0x1b4>)
   82540:	781b      	ldrb	r3, [r3, #0]
   82542:	9300      	str	r3, [sp, #0]
   82544:	2301      	movs	r3, #1
   82546:	9301      	str	r3, [sp, #4]
   82548:	4b51      	ldr	r3, [pc, #324]	; (82690 <send_tc_verification+0x1b8>)
   8254a:	9302      	str	r3, [sp, #8]
   8254c:	200a      	movs	r0, #10
   8254e:	2113      	movs	r1, #19
   82550:	2201      	movs	r2, #1
   82552:	2301      	movs	r3, #1
   82554:	4c4f      	ldr	r4, [pc, #316]	; (82694 <send_tc_verification+0x1bc>)
   82556:	47a0      	blx	r4
   82558:	60f8      	str	r0, [r7, #12]
   8255a:	e041      	b.n	825e0 <send_tc_verification+0x108>
		}
		else						// Telecommand Acceptance Report - Failure (1,2)
		{
			tc_verify_fail_count++;
   8255c:	4b4e      	ldr	r3, [pc, #312]	; (82698 <send_tc_verification+0x1c0>)
   8255e:	781b      	ldrb	r3, [r3, #0]
   82560:	3301      	adds	r3, #1
   82562:	b2da      	uxtb	r2, r3
   82564:	4b4c      	ldr	r3, [pc, #304]	; (82698 <send_tc_verification+0x1c0>)
   82566:	701a      	strb	r2, [r3, #0]
			current_data[0] = (uint8_t)((parameter & 0x000000FF));
   82568:	6a3b      	ldr	r3, [r7, #32]
   8256a:	b2da      	uxtb	r2, r3
   8256c:	4b48      	ldr	r3, [pc, #288]	; (82690 <send_tc_verification+0x1b8>)
   8256e:	701a      	strb	r2, [r3, #0]
			current_data[1] = (uint8_t)((parameter & 0x0000FF00) >> 8);
   82570:	6a3b      	ldr	r3, [r7, #32]
   82572:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   82576:	0a1b      	lsrs	r3, r3, #8
   82578:	b2da      	uxtb	r2, r3
   8257a:	4b45      	ldr	r3, [pc, #276]	; (82690 <send_tc_verification+0x1b8>)
   8257c:	705a      	strb	r2, [r3, #1]
			current_data[2] = (uint8_t)((parameter & 0x00FF0000) >> 16);
   8257e:	6a3b      	ldr	r3, [r7, #32]
   82580:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   82584:	0c1b      	lsrs	r3, r3, #16
   82586:	b2da      	uxtb	r2, r3
   82588:	4b41      	ldr	r3, [pc, #260]	; (82690 <send_tc_verification+0x1b8>)
   8258a:	709a      	strb	r2, [r3, #2]
			current_data[3] = (uint8_t)((parameter & 0xFF000000) >> 24);
   8258c:	6a3b      	ldr	r3, [r7, #32]
   8258e:	0e1b      	lsrs	r3, r3, #24
   82590:	b2da      	uxtb	r2, r3
   82592:	4b3f      	ldr	r3, [pc, #252]	; (82690 <send_tc_verification+0x1b8>)
   82594:	70da      	strb	r2, [r3, #3]
			current_data[4] = code;
   82596:	4b3e      	ldr	r3, [pc, #248]	; (82690 <send_tc_verification+0x1b8>)
   82598:	78ba      	ldrb	r2, [r7, #2]
   8259a:	711a      	strb	r2, [r3, #4]
			current_data[5] = (uint8_t)(sequence_control & 0x00FF);
   8259c:	88bb      	ldrh	r3, [r7, #4]
   8259e:	b2da      	uxtb	r2, r3
   825a0:	4b3b      	ldr	r3, [pc, #236]	; (82690 <send_tc_verification+0x1b8>)
   825a2:	715a      	strb	r2, [r3, #5]
			current_data[6] = (uint8_t)((sequence_control & 0xFF00) >> 8);
   825a4:	88bb      	ldrh	r3, [r7, #4]
   825a6:	0a1b      	lsrs	r3, r3, #8
   825a8:	b29b      	uxth	r3, r3
   825aa:	b2da      	uxtb	r2, r3
   825ac:	4b38      	ldr	r3, [pc, #224]	; (82690 <send_tc_verification+0x1b8>)
   825ae:	719a      	strb	r2, [r3, #6]
			current_data[7] = (uint8_t)(packet_id & 0x00FF);
   825b0:	88fb      	ldrh	r3, [r7, #6]
   825b2:	b2da      	uxtb	r2, r3
   825b4:	4b36      	ldr	r3, [pc, #216]	; (82690 <send_tc_verification+0x1b8>)
   825b6:	71da      	strb	r2, [r3, #7]
			current_data[8] = (uint8_t)((packet_id & 0xFF00) >> 8);
   825b8:	88fb      	ldrh	r3, [r7, #6]
   825ba:	0a1b      	lsrs	r3, r3, #8
   825bc:	b29b      	uxth	r3, r3
   825be:	b2da      	uxtb	r2, r3
   825c0:	4b33      	ldr	r3, [pc, #204]	; (82690 <send_tc_verification+0x1b8>)
   825c2:	721a      	strb	r2, [r3, #8]
			resp = packetize_send_telemetry(OBC_PACKET_ROUTER_ID, GROUND_PACKET_ROUTER_ID, 1, 2, tc_verify_success_count, 1, current_data);
   825c4:	4b31      	ldr	r3, [pc, #196]	; (8268c <send_tc_verification+0x1b4>)
   825c6:	781b      	ldrb	r3, [r3, #0]
   825c8:	9300      	str	r3, [sp, #0]
   825ca:	2301      	movs	r3, #1
   825cc:	9301      	str	r3, [sp, #4]
   825ce:	4b30      	ldr	r3, [pc, #192]	; (82690 <send_tc_verification+0x1b8>)
   825d0:	9302      	str	r3, [sp, #8]
   825d2:	200a      	movs	r0, #10
   825d4:	2113      	movs	r1, #19
   825d6:	2201      	movs	r2, #1
   825d8:	2302      	movs	r3, #2
   825da:	4c2e      	ldr	r4, [pc, #184]	; (82694 <send_tc_verification+0x1bc>)
   825dc:	47a0      	blx	r4
   825de:	60f8      	str	r0, [r7, #12]
		}		
	}
	if(tc_type == 2)
   825e0:	f897 3024 	ldrb.w	r3, [r7, #36]	; 0x24
   825e4:	2b02      	cmp	r3, #2
   825e6:	d143      	bne.n	82670 <send_tc_verification+0x198>
	{
		current_data[0] = (uint8_t)(sequence_control & 0x00FF);
   825e8:	88bb      	ldrh	r3, [r7, #4]
   825ea:	b2da      	uxtb	r2, r3
   825ec:	4b28      	ldr	r3, [pc, #160]	; (82690 <send_tc_verification+0x1b8>)
   825ee:	701a      	strb	r2, [r3, #0]
		current_data[1] = (uint8_t)((sequence_control & 0xFF00) >> 8);
   825f0:	88bb      	ldrh	r3, [r7, #4]
   825f2:	0a1b      	lsrs	r3, r3, #8
   825f4:	b29b      	uxth	r3, r3
   825f6:	b2da      	uxtb	r2, r3
   825f8:	4b25      	ldr	r3, [pc, #148]	; (82690 <send_tc_verification+0x1b8>)
   825fa:	705a      	strb	r2, [r3, #1]
		current_data[2] = (uint8_t)(packet_id & 0x00FF);
   825fc:	88fb      	ldrh	r3, [r7, #6]
   825fe:	b2da      	uxtb	r2, r3
   82600:	4b23      	ldr	r3, [pc, #140]	; (82690 <send_tc_verification+0x1b8>)
   82602:	709a      	strb	r2, [r3, #2]
		current_data[3] = (uint8_t)((packet_id & 0xFF00) >> 8);
   82604:	88fb      	ldrh	r3, [r7, #6]
   82606:	0a1b      	lsrs	r3, r3, #8
   82608:	b29b      	uxth	r3, r3
   8260a:	b2da      	uxtb	r2, r3
   8260c:	4b20      	ldr	r3, [pc, #128]	; (82690 <send_tc_verification+0x1b8>)
   8260e:	70da      	strb	r2, [r3, #3]
		if(status == 0xFF)
   82610:	78fb      	ldrb	r3, [r7, #3]
   82612:	2bff      	cmp	r3, #255	; 0xff
   82614:	d114      	bne.n	82640 <send_tc_verification+0x168>
		{
			tc_exec_fail_count++;
   82616:	4b21      	ldr	r3, [pc, #132]	; (8269c <send_tc_verification+0x1c4>)
   82618:	781b      	ldrb	r3, [r3, #0]
   8261a:	3301      	adds	r3, #1
   8261c:	b2da      	uxtb	r2, r3
   8261e:	4b1f      	ldr	r3, [pc, #124]	; (8269c <send_tc_verification+0x1c4>)
   82620:	701a      	strb	r2, [r3, #0]
			resp = packetize_send_telemetry(code, GROUND_PACKET_ROUTER_ID, 1, 8, tc_exec_fail_count, 1, current_data);
   82622:	4b1e      	ldr	r3, [pc, #120]	; (8269c <send_tc_verification+0x1c4>)
   82624:	781a      	ldrb	r2, [r3, #0]
   82626:	78bb      	ldrb	r3, [r7, #2]
   82628:	9200      	str	r2, [sp, #0]
   8262a:	2201      	movs	r2, #1
   8262c:	9201      	str	r2, [sp, #4]
   8262e:	4a18      	ldr	r2, [pc, #96]	; (82690 <send_tc_verification+0x1b8>)
   82630:	9202      	str	r2, [sp, #8]
   82632:	4618      	mov	r0, r3
   82634:	2113      	movs	r1, #19
   82636:	2201      	movs	r2, #1
   82638:	2308      	movs	r3, #8
   8263a:	4c16      	ldr	r4, [pc, #88]	; (82694 <send_tc_verification+0x1bc>)
   8263c:	47a0      	blx	r4
   8263e:	60f8      	str	r0, [r7, #12]
		}
		if(status == 1)
   82640:	78fb      	ldrb	r3, [r7, #3]
   82642:	2b01      	cmp	r3, #1
   82644:	d114      	bne.n	82670 <send_tc_verification+0x198>
		{
			tc_exec_success_count++;
   82646:	4b16      	ldr	r3, [pc, #88]	; (826a0 <send_tc_verification+0x1c8>)
   82648:	781b      	ldrb	r3, [r3, #0]
   8264a:	3301      	adds	r3, #1
   8264c:	b2da      	uxtb	r2, r3
   8264e:	4b14      	ldr	r3, [pc, #80]	; (826a0 <send_tc_verification+0x1c8>)
   82650:	701a      	strb	r2, [r3, #0]
			resp = packetize_send_telemetry(code, GROUND_PACKET_ROUTER_ID, 1, 7, tc_exec_success_count, 1, current_data);
   82652:	4b13      	ldr	r3, [pc, #76]	; (826a0 <send_tc_verification+0x1c8>)
   82654:	781a      	ldrb	r2, [r3, #0]
   82656:	78bb      	ldrb	r3, [r7, #2]
   82658:	9200      	str	r2, [sp, #0]
   8265a:	2201      	movs	r2, #1
   8265c:	9201      	str	r2, [sp, #4]
   8265e:	4a0c      	ldr	r2, [pc, #48]	; (82690 <send_tc_verification+0x1b8>)
   82660:	9202      	str	r2, [sp, #8]
   82662:	4618      	mov	r0, r3
   82664:	2113      	movs	r1, #19
   82666:	2201      	movs	r2, #1
   82668:	2307      	movs	r3, #7
   8266a:	4c0a      	ldr	r4, [pc, #40]	; (82694 <send_tc_verification+0x1bc>)
   8266c:	47a0      	blx	r4
   8266e:	60f8      	str	r0, [r7, #12]
		}
	}
	if(resp == -1)
   82670:	68fb      	ldr	r3, [r7, #12]
   82672:	f1b3 3fff 	cmp.w	r3, #4294967295
   82676:	d102      	bne.n	8267e <send_tc_verification+0x1a6>
		return -1;
   82678:	f04f 33ff 	mov.w	r3, #4294967295
   8267c:	e000      	b.n	82680 <send_tc_verification+0x1a8>
	else
		return 1;
   8267e:	2301      	movs	r3, #1
}
   82680:	4618      	mov	r0, r3
   82682:	3714      	adds	r7, #20
   82684:	46bd      	mov	sp, r7
   82686:	bd90      	pop	{r4, r7, pc}
   82688:	00081549 	.word	0x00081549
   8268c:	20070478 	.word	0x20070478
   82690:	20070480 	.word	0x20070480
   82694:	00080f19 	.word	0x00080f19
   82698:	20070479 	.word	0x20070479
   8269c:	2007046c 	.word	0x2007046c
   826a0:	2007046b 	.word	0x2007046b

000826a4 <send_event_packet>:
/* @Note: The task event report function is now responsible for setting */
/* up the data portion of the packet, and hence this function assumes	*/
/* that the array current_data[] has the data necessary for this report	*/
/************************************************************************/
static void send_event_packet(uint8_t sender, uint8_t severity)
{
   826a4:	b590      	push	{r4, r7, lr}
   826a6:	b087      	sub	sp, #28
   826a8:	af04      	add	r7, sp, #16
   826aa:	4602      	mov	r2, r0
   826ac:	460b      	mov	r3, r1
   826ae:	71fa      	strb	r2, [r7, #7]
   826b0:	71bb      	strb	r3, [r7, #6]
	event_report_count++;
   826b2:	4b0c      	ldr	r3, [pc, #48]	; (826e4 <send_event_packet+0x40>)
   826b4:	781b      	ldrb	r3, [r3, #0]
   826b6:	3301      	adds	r3, #1
   826b8:	b2da      	uxtb	r2, r3
   826ba:	4b0a      	ldr	r3, [pc, #40]	; (826e4 <send_event_packet+0x40>)
   826bc:	701a      	strb	r2, [r3, #0]
	packetize_send_telemetry(sender, GROUND_PACKET_ROUTER_ID, 5, severity, event_report_count, 1, current_data);	// FAILURE_RECOVERY
   826be:	4b09      	ldr	r3, [pc, #36]	; (826e4 <send_event_packet+0x40>)
   826c0:	7819      	ldrb	r1, [r3, #0]
   826c2:	79fa      	ldrb	r2, [r7, #7]
   826c4:	79bb      	ldrb	r3, [r7, #6]
   826c6:	9100      	str	r1, [sp, #0]
   826c8:	2101      	movs	r1, #1
   826ca:	9101      	str	r1, [sp, #4]
   826cc:	4906      	ldr	r1, [pc, #24]	; (826e8 <send_event_packet+0x44>)
   826ce:	9102      	str	r1, [sp, #8]
   826d0:	4610      	mov	r0, r2
   826d2:	2113      	movs	r1, #19
   826d4:	2205      	movs	r2, #5
   826d6:	4c05      	ldr	r4, [pc, #20]	; (826ec <send_event_packet+0x48>)
   826d8:	47a0      	blx	r4
	return;
   826da:	bf00      	nop
}
   826dc:	370c      	adds	r7, #12
   826de:	46bd      	mov	sp, r7
   826e0:	bd90      	pop	{r4, r7, pc}
   826e2:	bf00      	nop
   826e4:	2007047a 	.word	0x2007047a
   826e8:	20070480 	.word	0x20070480
   826ec:	00080f19 	.word	0x00080f19

000826f0 <send_event_report>:
/* @param: severity: 1 = Normal.										*/
/* @param: report_id: Unique to the event report, ex: BIT_FLIP_DETECTED */
/* @param: param1,0 extra information that can be sent to ground.		*/
/************************************************************************/
static void send_event_report(uint8_t severity, uint8_t report_id, uint8_t param1, uint8_t param0)
{
   826f0:	b580      	push	{r7, lr}
   826f2:	b082      	sub	sp, #8
   826f4:	af00      	add	r7, sp, #0
   826f6:	71f8      	strb	r0, [r7, #7]
   826f8:	71b9      	strb	r1, [r7, #6]
   826fa:	717a      	strb	r2, [r7, #5]
   826fc:	713b      	strb	r3, [r7, #4]
	clear_current_command();
   826fe:	4b19      	ldr	r3, [pc, #100]	; (82764 <send_event_report+0x74>)
   82700:	4798      	blx	r3
	current_command[136] = report_id;
   82702:	4b19      	ldr	r3, [pc, #100]	; (82768 <send_event_report+0x78>)
   82704:	79ba      	ldrb	r2, [r7, #6]
   82706:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
	current_command[135] = 2;
   8270a:	4b17      	ldr	r3, [pc, #92]	; (82768 <send_event_report+0x78>)
   8270c:	2202      	movs	r2, #2
   8270e:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
	current_command[134] = 0x00;
   82712:	4b15      	ldr	r3, [pc, #84]	; (82768 <send_event_report+0x78>)
   82714:	2200      	movs	r2, #0
   82716:	f883 2086 	strb.w	r2, [r3, #134]	; 0x86
	current_command[133] = 0x00;
   8271a:	4b13      	ldr	r3, [pc, #76]	; (82768 <send_event_report+0x78>)
   8271c:	2200      	movs	r2, #0
   8271e:	f883 2085 	strb.w	r2, [r3, #133]	; 0x85
	current_command[132] = 0x00;
   82722:	4b11      	ldr	r3, [pc, #68]	; (82768 <send_event_report+0x78>)
   82724:	2200      	movs	r2, #0
   82726:	f883 2084 	strb.w	r2, [r3, #132]	; 0x84
	current_command[131] = param0;
   8272a:	4b0f      	ldr	r3, [pc, #60]	; (82768 <send_event_report+0x78>)
   8272c:	793a      	ldrb	r2, [r7, #4]
   8272e:	f883 2083 	strb.w	r2, [r3, #131]	; 0x83
	current_command[130] = 0x00;
   82732:	4b0d      	ldr	r3, [pc, #52]	; (82768 <send_event_report+0x78>)
   82734:	2200      	movs	r2, #0
   82736:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
	current_command[129] = 0x00;
   8273a:	4b0b      	ldr	r3, [pc, #44]	; (82768 <send_event_report+0x78>)
   8273c:	2200      	movs	r2, #0
   8273e:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
	current_command[128] = 0x00;
   82742:	4b09      	ldr	r3, [pc, #36]	; (82768 <send_event_report+0x78>)
   82744:	2200      	movs	r2, #0
   82746:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	current_command[127] = param1;
   8274a:	4b07      	ldr	r3, [pc, #28]	; (82768 <send_event_report+0x78>)
   8274c:	797a      	ldrb	r2, [r7, #5]
   8274e:	f883 207f 	strb.w	r2, [r3, #127]	; 0x7f
	send_event_packet(OBC_PACKET_ROUTER_ID, severity);
   82752:	79fb      	ldrb	r3, [r7, #7]
   82754:	200a      	movs	r0, #10
   82756:	4619      	mov	r1, r3
   82758:	4b04      	ldr	r3, [pc, #16]	; (8276c <send_event_report+0x7c>)
   8275a:	4798      	blx	r3
	return;
   8275c:	bf00      	nop
}
   8275e:	3708      	adds	r7, #8
   82760:	46bd      	mov	sp, r7
   82762:	bd80      	pop	{r7, pc}
   82764:	00081579 	.word	0x00081579
   82768:	2007050c 	.word	0x2007050c
   8276c:	000826a5 	.word	0x000826a5

00082770 <set_obc_variable>:
		vTaskDelete(NULL);
	return;
}

void set_obc_variable(uint8_t parameter, uint32_t val)
{
   82770:	b480      	push	{r7}
   82772:	b083      	sub	sp, #12
   82774:	af00      	add	r7, sp, #0
   82776:	4603      	mov	r3, r0
   82778:	6039      	str	r1, [r7, #0]
   8277a:	71fb      	strb	r3, [r7, #7]
	switch(parameter)
   8277c:	79fb      	ldrb	r3, [r7, #7]
   8277e:	3be4      	subs	r3, #228	; 0xe4
   82780:	2b14      	cmp	r3, #20
   82782:	d85c      	bhi.n	8283e <set_obc_variable+0xce>
   82784:	a201      	add	r2, pc, #4	; (adr r2, 8278c <set_obc_variable+0x1c>)
   82786:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8278a:	bf00      	nop
   8278c:	00082837 	.word	0x00082837
   82790:	00082831 	.word	0x00082831
   82794:	0008282b 	.word	0x0008282b
   82798:	00082825 	.word	0x00082825
   8279c:	0008283f 	.word	0x0008283f
   827a0:	0008283f 	.word	0x0008283f
   827a4:	0008283f 	.word	0x0008283f
   827a8:	0008283f 	.word	0x0008283f
   827ac:	0008281f 	.word	0x0008281f
   827b0:	00082819 	.word	0x00082819
   827b4:	0008283f 	.word	0x0008283f
   827b8:	0008283f 	.word	0x0008283f
   827bc:	0008283f 	.word	0x0008283f
   827c0:	0008283f 	.word	0x0008283f
   827c4:	00082811 	.word	0x00082811
   827c8:	00082809 	.word	0x00082809
   827cc:	00082801 	.word	0x00082801
   827d0:	000827f9 	.word	0x000827f9
   827d4:	000827f1 	.word	0x000827f1
   827d8:	000827e9 	.word	0x000827e9
   827dc:	000827e1 	.word	0x000827e1
	{
		case ABS_TIME_D:
			ABSOLUTE_DAY = (uint8_t)val;
   827e0:	683b      	ldr	r3, [r7, #0]
   827e2:	b2da      	uxtb	r2, r3
   827e4:	4b19      	ldr	r3, [pc, #100]	; (8284c <set_obc_variable+0xdc>)
   827e6:	701a      	strb	r2, [r3, #0]
		case ABS_TIME_H:
			CURRENT_HOUR = (uint8_t)val;
   827e8:	683b      	ldr	r3, [r7, #0]
   827ea:	b2da      	uxtb	r2, r3
   827ec:	4b18      	ldr	r3, [pc, #96]	; (82850 <set_obc_variable+0xe0>)
   827ee:	701a      	strb	r2, [r3, #0]
		case ABS_TIME_M:
			CURRENT_MINUTE = (uint8_t)val;
   827f0:	683b      	ldr	r3, [r7, #0]
   827f2:	b2da      	uxtb	r2, r3
   827f4:	4b17      	ldr	r3, [pc, #92]	; (82854 <set_obc_variable+0xe4>)
   827f6:	701a      	strb	r2, [r3, #0]
		case ABS_TIME_S:
			CURRENT_SECOND = (uint8_t)val;
   827f8:	683b      	ldr	r3, [r7, #0]
   827fa:	b2da      	uxtb	r2, r3
   827fc:	4b16      	ldr	r3, [pc, #88]	; (82858 <set_obc_variable+0xe8>)
   827fe:	701a      	strb	r2, [r3, #0]
		case SPI_CHIP_1:
			SPI_HEALTH1 = (uint8_t)val;
   82800:	683b      	ldr	r3, [r7, #0]
   82802:	b2da      	uxtb	r2, r3
   82804:	4b15      	ldr	r3, [pc, #84]	; (8285c <set_obc_variable+0xec>)
   82806:	701a      	strb	r2, [r3, #0]
		case SPI_CHIP_2:
			SPI_HEALTH2 = (uint8_t)val;
   82808:	683b      	ldr	r3, [r7, #0]
   8280a:	b2da      	uxtb	r2, r3
   8280c:	4b14      	ldr	r3, [pc, #80]	; (82860 <set_obc_variable+0xf0>)
   8280e:	701a      	strb	r2, [r3, #0]
		case SPI_CHIP_3:
			SPI_HEALTH3 = (uint8_t)val;
   82810:	683b      	ldr	r3, [r7, #0]
   82812:	b2da      	uxtb	r2, r3
   82814:	4b13      	ldr	r3, [pc, #76]	; (82864 <set_obc_variable+0xf4>)
   82816:	701a      	strb	r2, [r3, #0]
		case OBC_CTT:
			obc_consec_trans_timeout = val;
   82818:	4b13      	ldr	r3, [pc, #76]	; (82868 <set_obc_variable+0xf8>)
   8281a:	683a      	ldr	r2, [r7, #0]
   8281c:	601a      	str	r2, [r3, #0]
		case OBC_OGT:
			obc_ok_go_timeout = val;
   8281e:	4b13      	ldr	r3, [pc, #76]	; (8286c <set_obc_variable+0xfc>)
   82820:	683a      	ldr	r2, [r7, #0]
   82822:	601a      	str	r2, [r3, #0]
		case EPS_BAL_INTV:
			eps_balance_interval = val;
   82824:	4b12      	ldr	r3, [pc, #72]	; (82870 <set_obc_variable+0x100>)
   82826:	683a      	ldr	r2, [r7, #0]
   82828:	601a      	str	r2, [r3, #0]
		case EPS_HEAT_INTV:
			eps_heater_interval = val;
   8282a:	4b12      	ldr	r3, [pc, #72]	; (82874 <set_obc_variable+0x104>)
   8282c:	683a      	ldr	r2, [r7, #0]
   8282e:	601a      	str	r2, [r3, #0]
		case EPS_TRGT_TMP:
			eps_target_temp = val;
   82830:	4b11      	ldr	r3, [pc, #68]	; (82878 <set_obc_variable+0x108>)
   82832:	683a      	ldr	r2, [r7, #0]
   82834:	601a      	str	r2, [r3, #0]
		case EPS_TEMP_INTV:
			eps_temp_interval = val;
   82836:	4b11      	ldr	r3, [pc, #68]	; (8287c <set_obc_variable+0x10c>)
   82838:	683a      	ldr	r2, [r7, #0]
   8283a:	601a      	str	r2, [r3, #0]
		default:
			return;
   8283c:	bf00      	nop
   8283e:	bf00      	nop
	}
	return;
}
   82840:	370c      	adds	r7, #12
   82842:	46bd      	mov	sp, r7
   82844:	f85d 7b04 	ldr.w	r7, [sp], #4
   82848:	4770      	bx	lr
   8284a:	bf00      	nop
   8284c:	2007b4ec 	.word	0x2007b4ec
   82850:	2007d584 	.word	0x2007d584
   82854:	2007b108 	.word	0x2007b108
   82858:	2007b118 	.word	0x2007b118
   8285c:	2007b3fe 	.word	0x2007b3fe
   82860:	2007ade5 	.word	0x2007ade5
   82864:	2007b574 	.word	0x2007b574
   82868:	2007b168 	.word	0x2007b168
   8286c:	2007adac 	.word	0x2007adac
   82870:	2007b3e4 	.word	0x2007b3e4
   82874:	2007b124 	.word	0x2007b124
   82878:	2007b4f4 	.word	0x2007b4f4
   8287c:	2007b4e4 	.word	0x2007b4e4

00082880 <get_obc_variable>:

uint32_t get_obc_variable(uint8_t parameter)
{
   82880:	b480      	push	{r7}
   82882:	b083      	sub	sp, #12
   82884:	af00      	add	r7, sp, #0
   82886:	4603      	mov	r3, r0
   82888:	71fb      	strb	r3, [r7, #7]
	switch(parameter)
   8288a:	79fb      	ldrb	r3, [r7, #7]
   8288c:	3be4      	subs	r3, #228	; 0xe4
   8288e:	2b14      	cmp	r3, #20
   82890:	d853      	bhi.n	8293a <get_obc_variable+0xba>
   82892:	a201      	add	r2, pc, #4	; (adr r2, 82898 <get_obc_variable+0x18>)
   82894:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   82898:	00082935 	.word	0x00082935
   8289c:	0008292f 	.word	0x0008292f
   828a0:	00082929 	.word	0x00082929
   828a4:	00082923 	.word	0x00082923
   828a8:	0008293b 	.word	0x0008293b
   828ac:	0008293b 	.word	0x0008293b
   828b0:	0008293b 	.word	0x0008293b
   828b4:	0008293b 	.word	0x0008293b
   828b8:	0008291d 	.word	0x0008291d
   828bc:	00082917 	.word	0x00082917
   828c0:	0008293b 	.word	0x0008293b
   828c4:	0008293b 	.word	0x0008293b
   828c8:	0008293b 	.word	0x0008293b
   828cc:	0008293b 	.word	0x0008293b
   828d0:	00082911 	.word	0x00082911
   828d4:	0008290b 	.word	0x0008290b
   828d8:	00082905 	.word	0x00082905
   828dc:	000828ff 	.word	0x000828ff
   828e0:	000828f9 	.word	0x000828f9
   828e4:	000828f3 	.word	0x000828f3
   828e8:	000828ed 	.word	0x000828ed
	{
		case ABS_TIME_D:
			return (uint32_t)ABSOLUTE_DAY;
   828ec:	4b16      	ldr	r3, [pc, #88]	; (82948 <get_obc_variable+0xc8>)
   828ee:	781b      	ldrb	r3, [r3, #0]
   828f0:	e024      	b.n	8293c <get_obc_variable+0xbc>
		case ABS_TIME_H:
			return (uint32_t)CURRENT_HOUR;
   828f2:	4b16      	ldr	r3, [pc, #88]	; (8294c <get_obc_variable+0xcc>)
   828f4:	781b      	ldrb	r3, [r3, #0]
   828f6:	e021      	b.n	8293c <get_obc_variable+0xbc>
		case ABS_TIME_M:
			return (uint32_t)CURRENT_MINUTE;
   828f8:	4b15      	ldr	r3, [pc, #84]	; (82950 <get_obc_variable+0xd0>)
   828fa:	781b      	ldrb	r3, [r3, #0]
   828fc:	e01e      	b.n	8293c <get_obc_variable+0xbc>
		case ABS_TIME_S:
			return (uint32_t)CURRENT_SECOND;
   828fe:	4b15      	ldr	r3, [pc, #84]	; (82954 <get_obc_variable+0xd4>)
   82900:	781b      	ldrb	r3, [r3, #0]
   82902:	e01b      	b.n	8293c <get_obc_variable+0xbc>
		case SPI_CHIP_1:
			return (uint32_t)SPI_HEALTH1;
   82904:	4b14      	ldr	r3, [pc, #80]	; (82958 <get_obc_variable+0xd8>)
   82906:	781b      	ldrb	r3, [r3, #0]
   82908:	e018      	b.n	8293c <get_obc_variable+0xbc>
		case SPI_CHIP_2:
			return (uint32_t)SPI_HEALTH2;
   8290a:	4b14      	ldr	r3, [pc, #80]	; (8295c <get_obc_variable+0xdc>)
   8290c:	781b      	ldrb	r3, [r3, #0]
   8290e:	e015      	b.n	8293c <get_obc_variable+0xbc>
		case SPI_CHIP_3:
			return (uint32_t)SPI_HEALTH3;
   82910:	4b13      	ldr	r3, [pc, #76]	; (82960 <get_obc_variable+0xe0>)
   82912:	781b      	ldrb	r3, [r3, #0]
   82914:	e012      	b.n	8293c <get_obc_variable+0xbc>
		case OBC_CTT:
			return obc_consec_trans_timeout;
   82916:	4b13      	ldr	r3, [pc, #76]	; (82964 <get_obc_variable+0xe4>)
   82918:	681b      	ldr	r3, [r3, #0]
   8291a:	e00f      	b.n	8293c <get_obc_variable+0xbc>
		case OBC_OGT:
			return obc_ok_go_timeout;
   8291c:	4b12      	ldr	r3, [pc, #72]	; (82968 <get_obc_variable+0xe8>)
   8291e:	681b      	ldr	r3, [r3, #0]
   82920:	e00c      	b.n	8293c <get_obc_variable+0xbc>
		case EPS_BAL_INTV:
			return eps_balance_interval;
   82922:	4b12      	ldr	r3, [pc, #72]	; (8296c <get_obc_variable+0xec>)
   82924:	681b      	ldr	r3, [r3, #0]
   82926:	e009      	b.n	8293c <get_obc_variable+0xbc>
		case EPS_HEAT_INTV:
			return eps_heater_interval;
   82928:	4b11      	ldr	r3, [pc, #68]	; (82970 <get_obc_variable+0xf0>)
   8292a:	681b      	ldr	r3, [r3, #0]
   8292c:	e006      	b.n	8293c <get_obc_variable+0xbc>
		case EPS_TRGT_TMP:
			return eps_target_temp;
   8292e:	4b11      	ldr	r3, [pc, #68]	; (82974 <get_obc_variable+0xf4>)
   82930:	681b      	ldr	r3, [r3, #0]
   82932:	e003      	b.n	8293c <get_obc_variable+0xbc>
		case EPS_TEMP_INTV:
			return eps_temp_interval;
   82934:	4b10      	ldr	r3, [pc, #64]	; (82978 <get_obc_variable+0xf8>)
   82936:	681b      	ldr	r3, [r3, #0]
   82938:	e000      	b.n	8293c <get_obc_variable+0xbc>
		default:
			return 0;
   8293a:	2300      	movs	r3, #0
	}
	return 0;
}
   8293c:	4618      	mov	r0, r3
   8293e:	370c      	adds	r7, #12
   82940:	46bd      	mov	sp, r7
   82942:	f85d 7b04 	ldr.w	r7, [sp], #4
   82946:	4770      	bx	lr
   82948:	2007b4ec 	.word	0x2007b4ec
   8294c:	2007d584 	.word	0x2007d584
   82950:	2007b108 	.word	0x2007b108
   82954:	2007b118 	.word	0x2007b118
   82958:	2007b3fe 	.word	0x2007b3fe
   8295c:	2007ade5 	.word	0x2007ade5
   82960:	2007b574 	.word	0x2007b574
   82964:	2007b168 	.word	0x2007b168
   82968:	2007adac 	.word	0x2007adac
   8296c:	2007b3e4 	.word	0x2007b3e4
   82970:	2007b124 	.word	0x2007b124
   82974:	2007b4f4 	.word	0x2007b4f4
   82978:	2007b4e4 	.word	0x2007b4e4

0008297c <wdt_reset>:
void wdt_reset_kill(uint8_t killer);

/*-------------------------------------------------------------*/

TaskHandle_t wdt_reset(void)
{
   8297c:	b590      	push	{r4, r7, lr}
   8297e:	b087      	sub	sp, #28
   82980:	af04      	add	r7, sp, #16
	/*Start the watchdog timer reset task as described in comments */
	TaskHandle_t temp_HANDLE = 0;
   82982:	2300      	movs	r3, #0
   82984:	607b      	str	r3, [r7, #4]
	xTaskCreate( wdtResetTask,			/* The function that implements the task. */
   82986:	2301      	movs	r3, #1
   82988:	9300      	str	r3, [sp, #0]
   8298a:	1d3b      	adds	r3, r7, #4
   8298c:	9301      	str	r3, [sp, #4]
   8298e:	2300      	movs	r3, #0
   82990:	9302      	str	r3, [sp, #8]
   82992:	2300      	movs	r3, #0
   82994:	9303      	str	r3, [sp, #12]
   82996:	4806      	ldr	r0, [pc, #24]	; (829b0 <wdt_reset+0x34>)
   82998:	4906      	ldr	r1, [pc, #24]	; (829b4 <wdt_reset+0x38>)
   8299a:	2282      	movs	r2, #130	; 0x82
   8299c:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   829a0:	4c05      	ldr	r4, [pc, #20]	; (829b8 <wdt_reset+0x3c>)
   829a2:	47a0      	blx	r4
	/* If all is well, the scheduler will now be running, and the following
	line will never be reached.  If the following line does execute, then
	there was insufficient FreeRTOS heap memory available for the idle and/or
	timer tasks	to be created.  See the memory management section on the
	FreeRTOS web site for more details. */
	return temp_HANDLE;
   829a4:	687b      	ldr	r3, [r7, #4]
	
	//What happens if it does return? //death and destruction of course.
}
   829a6:	4618      	mov	r0, r3
   829a8:	370c      	adds	r7, #12
   829aa:	46bd      	mov	sp, r7
   829ac:	bd90      	pop	{r4, r7, pc}
   829ae:	bf00      	nop
   829b0:	000829bd 	.word	0x000829bd
   829b4:	0008b030 	.word	0x0008b030
   829b8:	00087335 	.word	0x00087335

000829bc <wdtResetTask>:
/*	The purpose of this task is to reset the watchdog timer every  	*/
/*	time interval (defined by WDT_Reset_Delay)						*/
/************************************************************************/

static void wdtResetTask(void *pvParameters)
{
   829bc:	b580      	push	{r7, lr}
   829be:	b084      	sub	sp, #16
   829c0:	af00      	add	r7, sp, #0
   829c2:	6078      	str	r0, [r7, #4]
	//What is this?
	configASSERT( ( ( unsigned long ) pvParameters ) == WDT_PARAMETER );
   829c4:	687a      	ldr	r2, [r7, #4]
   829c6:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   829ca:	429a      	cmp	r2, r3
   829cc:	d002      	beq.n	829d4 <wdtResetTask+0x18>
   829ce:	4b09      	ldr	r3, [pc, #36]	; (829f4 <wdtResetTask+0x38>)
   829d0:	4798      	blx	r3
   829d2:	e7fe      	b.n	829d2 <wdtResetTask+0x16>
	
	TickType_t xLastWakeTime;
	
	//is this okay?
	const TickType_t xTimeToWait = WDT_Reset_Delay;
   829d4:	2364      	movs	r3, #100	; 0x64
   829d6:	60fb      	str	r3, [r7, #12]
	
	/* @non-terminating@ */	
	
	for ( ;; )
	{
		wdt_restart(WDT);
   829d8:	4807      	ldr	r0, [pc, #28]	; (829f8 <wdtResetTask+0x3c>)
   829da:	4b08      	ldr	r3, [pc, #32]	; (829fc <wdtResetTask+0x40>)
   829dc:	4798      	blx	r3
		
		xLastWakeTime = xTaskGetTickCount();
   829de:	4b08      	ldr	r3, [pc, #32]	; (82a00 <wdtResetTask+0x44>)
   829e0:	4798      	blx	r3
   829e2:	4603      	mov	r3, r0
   829e4:	60bb      	str	r3, [r7, #8]
		vTaskDelayUntil(&xLastWakeTime, xTimeToWait);	
   829e6:	f107 0308 	add.w	r3, r7, #8
   829ea:	4618      	mov	r0, r3
   829ec:	68f9      	ldr	r1, [r7, #12]
   829ee:	4b05      	ldr	r3, [pc, #20]	; (82a04 <wdtResetTask+0x48>)
   829f0:	4798      	blx	r3
	}
   829f2:	e7f1      	b.n	829d8 <wdtResetTask+0x1c>
   829f4:	000864f9 	.word	0x000864f9
   829f8:	400e1a50 	.word	0x400e1a50
   829fc:	00085e79 	.word	0x00085e79
   82a00:	00087771 	.word	0x00087771
   82a04:	000874b5 	.word	0x000874b5

00082a08 <fletcher32>:
/* hashing.																*/
/* @param: words: how many WORDS in memory, you would like to hash		*/
/* @return: the 32-bit checksum value.									*/
/************************************************************************/
uint32_t fletcher32(uint32_t *data, size_t words )
{
   82a08:	b480      	push	{r7}
   82a0a:	b087      	sub	sp, #28
   82a0c:	af00      	add	r7, sp, #0
   82a0e:	6078      	str	r0, [r7, #4]
   82a10:	6039      	str	r1, [r7, #0]
	/* sum1 and sum2 should never be 0 */
	uint32_t sum1 = 0xffff;
   82a12:	f64f 73ff 	movw	r3, #65535	; 0xffff
   82a16:	617b      	str	r3, [r7, #20]
	uint32_t sum2 = 0xffff;
   82a18:	f64f 73ff 	movw	r3, #65535	; 0xffff
   82a1c:	613b      	str	r3, [r7, #16]
	
	while (words)
   82a1e:	e028      	b.n	82a72 <fletcher32+0x6a>
	{
		/* 359 is the largest n such that ( n(n+1) / 2 ) will not cause an overflow in sum2 */
		unsigned len = words > 359 ? 359 : words;
   82a20:	683a      	ldr	r2, [r7, #0]
   82a22:	f240 1367 	movw	r3, #359	; 0x167
   82a26:	429a      	cmp	r2, r3
   82a28:	bf38      	it	cc
   82a2a:	4613      	movcc	r3, r2
   82a2c:	60fb      	str	r3, [r7, #12]
		words -= len;
   82a2e:	683a      	ldr	r2, [r7, #0]
   82a30:	68fb      	ldr	r3, [r7, #12]
   82a32:	1ad3      	subs	r3, r2, r3
   82a34:	603b      	str	r3, [r7, #0]

		while(--len)
   82a36:	e00a      	b.n	82a4e <fletcher32+0x46>
		{
			sum2 += sum1 += *(data++);
   82a38:	687b      	ldr	r3, [r7, #4]
   82a3a:	1d1a      	adds	r2, r3, #4
   82a3c:	607a      	str	r2, [r7, #4]
   82a3e:	681b      	ldr	r3, [r3, #0]
   82a40:	697a      	ldr	r2, [r7, #20]
   82a42:	4413      	add	r3, r2
   82a44:	617b      	str	r3, [r7, #20]
   82a46:	693a      	ldr	r2, [r7, #16]
   82a48:	697b      	ldr	r3, [r7, #20]
   82a4a:	4413      	add	r3, r2
   82a4c:	613b      	str	r3, [r7, #16]
	{
		/* 359 is the largest n such that ( n(n+1) / 2 ) will not cause an overflow in sum2 */
		unsigned len = words > 359 ? 359 : words;
		words -= len;

		while(--len)
   82a4e:	68fb      	ldr	r3, [r7, #12]
   82a50:	3b01      	subs	r3, #1
   82a52:	60fb      	str	r3, [r7, #12]
   82a54:	68fb      	ldr	r3, [r7, #12]
   82a56:	2b00      	cmp	r3, #0
   82a58:	d1ee      	bne.n	82a38 <fletcher32+0x30>
		{
			sum2 += sum1 += *(data++);
		}
		
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
   82a5a:	697b      	ldr	r3, [r7, #20]
   82a5c:	b29a      	uxth	r2, r3
   82a5e:	697b      	ldr	r3, [r7, #20]
   82a60:	0c1b      	lsrs	r3, r3, #16
   82a62:	4413      	add	r3, r2
   82a64:	617b      	str	r3, [r7, #20]
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);
   82a66:	693b      	ldr	r3, [r7, #16]
   82a68:	b29a      	uxth	r2, r3
   82a6a:	693b      	ldr	r3, [r7, #16]
   82a6c:	0c1b      	lsrs	r3, r3, #16
   82a6e:	4413      	add	r3, r2
   82a70:	613b      	str	r3, [r7, #16]
{
	/* sum1 and sum2 should never be 0 */
	uint32_t sum1 = 0xffff;
	uint32_t sum2 = 0xffff;
	
	while (words)
   82a72:	683b      	ldr	r3, [r7, #0]
   82a74:	2b00      	cmp	r3, #0
   82a76:	d1d3      	bne.n	82a20 <fletcher32+0x18>
		
		sum1 = (sum1 & 0xffff) + (sum1 >> 16);
		sum2 = (sum2 & 0xffff) + (sum2 >> 16);
	}
	/* Second reduction step to reduce sums to 16 bits to yield a final uint32_t */
	sum1 = (sum1 & 0xffff) + (sum1 >> 16);
   82a78:	697b      	ldr	r3, [r7, #20]
   82a7a:	b29a      	uxth	r2, r3
   82a7c:	697b      	ldr	r3, [r7, #20]
   82a7e:	0c1b      	lsrs	r3, r3, #16
   82a80:	4413      	add	r3, r2
   82a82:	617b      	str	r3, [r7, #20]
	sum2 = (sum2 & 0xffff) + (sum2 >> 16);
   82a84:	693b      	ldr	r3, [r7, #16]
   82a86:	b29a      	uxth	r2, r3
   82a88:	693b      	ldr	r3, [r7, #16]
   82a8a:	0c1b      	lsrs	r3, r3, #16
   82a8c:	4413      	add	r3, r2
   82a8e:	613b      	str	r3, [r7, #16]
	
	return sum2 << 16 | sum1;
   82a90:	693b      	ldr	r3, [r7, #16]
   82a92:	041a      	lsls	r2, r3, #16
   82a94:	697b      	ldr	r3, [r7, #20]
   82a96:	4313      	orrs	r3, r2
}
   82a98:	4618      	mov	r0, r3
   82a9a:	371c      	adds	r7, #28
   82a9c:	46bd      	mov	sp, r7
   82a9e:	f85d 7b04 	ldr.w	r7, [sp], #4
   82aa2:	4770      	bx	lr

00082aa4 <fletcher16>:
/* hashing.																*/
/* @param: count: how many BYTES in memory, you would like to hash		*/
/* @return: the 16-bit checksum value.									*/
/************************************************************************/
uint16_t fletcher16(uint8_t* data, int count)
{
   82aa4:	b480      	push	{r7}
   82aa6:	b085      	sub	sp, #20
   82aa8:	af00      	add	r7, sp, #0
   82aaa:	6078      	str	r0, [r7, #4]
   82aac:	6039      	str	r1, [r7, #0]
	uint16_t sum1 = 0;
   82aae:	2300      	movs	r3, #0
   82ab0:	81fb      	strh	r3, [r7, #14]
	uint16_t sum2 = 0;
   82ab2:	2300      	movs	r3, #0
   82ab4:	81bb      	strh	r3, [r7, #12]
	int i;
	
	for(i = 0; i < count; i++)
   82ab6:	2300      	movs	r3, #0
   82ab8:	60bb      	str	r3, [r7, #8]
   82aba:	e025      	b.n	82b08 <fletcher16+0x64>
	{
		sum1 = (sum1 + data[i]) % 255;
   82abc:	89fa      	ldrh	r2, [r7, #14]
   82abe:	68bb      	ldr	r3, [r7, #8]
   82ac0:	6879      	ldr	r1, [r7, #4]
   82ac2:	440b      	add	r3, r1
   82ac4:	781b      	ldrb	r3, [r3, #0]
   82ac6:	18d1      	adds	r1, r2, r3
   82ac8:	4b18      	ldr	r3, [pc, #96]	; (82b2c <fletcher16+0x88>)
   82aca:	fb81 2303 	smull	r2, r3, r1, r3
   82ace:	440b      	add	r3, r1
   82ad0:	11da      	asrs	r2, r3, #7
   82ad2:	17cb      	asrs	r3, r1, #31
   82ad4:	1ad2      	subs	r2, r2, r3
   82ad6:	4613      	mov	r3, r2
   82ad8:	021b      	lsls	r3, r3, #8
   82ada:	1a9b      	subs	r3, r3, r2
   82adc:	1aca      	subs	r2, r1, r3
   82ade:	4613      	mov	r3, r2
   82ae0:	81fb      	strh	r3, [r7, #14]
		sum2 = (sum2 + sum1) % 255;
   82ae2:	89ba      	ldrh	r2, [r7, #12]
   82ae4:	89fb      	ldrh	r3, [r7, #14]
   82ae6:	18d1      	adds	r1, r2, r3
   82ae8:	4b10      	ldr	r3, [pc, #64]	; (82b2c <fletcher16+0x88>)
   82aea:	fb81 2303 	smull	r2, r3, r1, r3
   82aee:	440b      	add	r3, r1
   82af0:	11da      	asrs	r2, r3, #7
   82af2:	17cb      	asrs	r3, r1, #31
   82af4:	1ad2      	subs	r2, r2, r3
   82af6:	4613      	mov	r3, r2
   82af8:	021b      	lsls	r3, r3, #8
   82afa:	1a9b      	subs	r3, r3, r2
   82afc:	1aca      	subs	r2, r1, r3
   82afe:	4613      	mov	r3, r2
   82b00:	81bb      	strh	r3, [r7, #12]
{
	uint16_t sum1 = 0;
	uint16_t sum2 = 0;
	int i;
	
	for(i = 0; i < count; i++)
   82b02:	68bb      	ldr	r3, [r7, #8]
   82b04:	3301      	adds	r3, #1
   82b06:	60bb      	str	r3, [r7, #8]
   82b08:	68ba      	ldr	r2, [r7, #8]
   82b0a:	683b      	ldr	r3, [r7, #0]
   82b0c:	429a      	cmp	r2, r3
   82b0e:	dbd5      	blt.n	82abc <fletcher16+0x18>
	{
		sum1 = (sum1 + data[i]) % 255;
		sum2 = (sum2 + sum1) % 255;
	}
	
	return (sum2 << 8) | sum1;
   82b10:	89bb      	ldrh	r3, [r7, #12]
   82b12:	021b      	lsls	r3, r3, #8
   82b14:	b29a      	uxth	r2, r3
   82b16:	89fb      	ldrh	r3, [r7, #14]
   82b18:	4313      	orrs	r3, r2
   82b1a:	b29b      	uxth	r3, r3
   82b1c:	b29b      	uxth	r3, r3
}
   82b1e:	4618      	mov	r0, r3
   82b20:	3714      	adds	r7, #20
   82b22:	46bd      	mov	sp, r7
   82b24:	f85d 7b04 	ldr.w	r7, [sp], #4
   82b28:	4770      	bx	lr
   82b2a:	bf00      	nop
   82b2c:	80808081 	.word	0x80808081

00082b30 <housekeep>:
/************************************************************************/
/* HOUSEKEEPING (Function) 												*/
/* @Purpose: This function is used to create the housekeeping task.		*/
/************************************************************************/
TaskHandle_t housekeep( void )
{
   82b30:	b590      	push	{r4, r7, lr}
   82b32:	b087      	sub	sp, #28
   82b34:	af04      	add	r7, sp, #16
		/* Start the two tasks as described in the comments at the top of this
		file. */
		TaskHandle_t temp_HANDLE = 0;
   82b36:	2300      	movs	r3, #0
   82b38:	607b      	str	r3, [r7, #4]
		xTaskCreate( prvHouseKeepTask,					/* The function that implements the task. */
   82b3a:	2301      	movs	r3, #1
   82b3c:	9300      	str	r3, [sp, #0]
   82b3e:	1d3b      	adds	r3, r7, #4
   82b40:	9301      	str	r3, [sp, #4]
   82b42:	2300      	movs	r3, #0
   82b44:	9302      	str	r3, [sp, #8]
   82b46:	2300      	movs	r3, #0
   82b48:	9303      	str	r3, [sp, #12]
   82b4a:	4806      	ldr	r0, [pc, #24]	; (82b64 <housekeep+0x34>)
   82b4c:	4906      	ldr	r1, [pc, #24]	; (82b68 <housekeep+0x38>)
   82b4e:	2282      	movs	r2, #130	; 0x82
   82b50:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   82b54:	4c05      	ldr	r4, [pc, #20]	; (82b6c <housekeep+0x3c>)
   82b56:	47a0      	blx	r4
	/* If all is well, the scheduler will now be running, and the following
	line will never be reached.  If the following line does execute, then
	there was insufficient FreeRTOS heap memory available for the idle and/or
	timer tasks	to be created.  See the memory management section on the
	FreeRTOS web site for more details. */
	return temp_HANDLE;
   82b58:	687b      	ldr	r3, [r7, #4]
}
   82b5a:	4618      	mov	r0, r3
   82b5c:	370c      	adds	r7, #12
   82b5e:	46bd      	mov	sp, r7
   82b60:	bd90      	pop	{r4, r7, pc}
   82b62:	bf00      	nop
   82b64:	00082b71 	.word	0x00082b71
   82b68:	0008b034 	.word	0x0008b034
   82b6c:	00087335 	.word	0x00087335

00082b70 <prvHouseKeepTask>:
/*				HOUSEKEEPING TASK		                                */
/* This task is used to periodically gather housekeeping information	*/
/* and store it in external memory until it is ready to be downlinked.  */
/************************************************************************/
static void prvHouseKeepTask(void *pvParameters )
{
   82b70:	b580      	push	{r7, lr}
   82b72:	b084      	sub	sp, #16
   82b74:	af00      	add	r7, sp, #0
   82b76:	6078      	str	r0, [r7, #4]
	configASSERT( ( ( unsigned long ) pvParameters ) == HK_PARAMETER );
   82b78:	687a      	ldr	r2, [r7, #4]
   82b7a:	f64a 33cd 	movw	r3, #43981	; 0xabcd
   82b7e:	429a      	cmp	r2, r3
   82b80:	d002      	beq.n	82b88 <prvHouseKeepTask+0x18>
   82b82:	4b24      	ldr	r3, [pc, #144]	; (82c14 <prvHouseKeepTask+0xa4>)
   82b84:	4798      	blx	r3
   82b86:	e7fe      	b.n	82b86 <prvHouseKeepTask+0x16>
	/* As SysTick will be approx. 1kHz, Num = 1000 * 60 * 60 = 1 hour.*/
	new_hk_msg_high = 0;
   82b88:	4b23      	ldr	r3, [pc, #140]	; (82c18 <prvHouseKeepTask+0xa8>)
   82b8a:	2200      	movs	r2, #0
   82b8c:	601a      	str	r2, [r3, #0]
	new_hk_msg_low = 0;
   82b8e:	4b23      	ldr	r3, [pc, #140]	; (82c1c <prvHouseKeepTask+0xac>)
   82b90:	2200      	movs	r2, #0
   82b92:	601a      	str	r2, [r3, #0]
	current_hk_fullf = 0;
   82b94:	4b22      	ldr	r3, [pc, #136]	; (82c20 <prvHouseKeepTask+0xb0>)
   82b96:	2200      	movs	r2, #0
   82b98:	701a      	strb	r2, [r3, #0]
	current_hk_definitionf = 0;		// Default definition
   82b9a:	4b22      	ldr	r3, [pc, #136]	; (82c24 <prvHouseKeepTask+0xb4>)
   82b9c:	2200      	movs	r2, #0
   82b9e:	701a      	strb	r2, [r3, #0]
	param_report_requiredf = 0;
   82ba0:	4b21      	ldr	r3, [pc, #132]	; (82c28 <prvHouseKeepTask+0xb8>)
   82ba2:	2200      	movs	r2, #0
   82ba4:	701a      	strb	r2, [r3, #0]
	collection_interval0 = 30;
   82ba6:	4b21      	ldr	r3, [pc, #132]	; (82c2c <prvHouseKeepTask+0xbc>)
   82ba8:	221e      	movs	r2, #30
   82baa:	701a      	strb	r2, [r3, #0]
	collection_interval1 = 30;
   82bac:	4b20      	ldr	r3, [pc, #128]	; (82c30 <prvHouseKeepTask+0xc0>)
   82bae:	221e      	movs	r2, #30
   82bb0:	701a      	strb	r2, [r3, #0]
	xTimeToWait = 10;
   82bb2:	4b20      	ldr	r3, [pc, #128]	; (82c34 <prvHouseKeepTask+0xc4>)
   82bb4:	220a      	movs	r2, #10
   82bb6:	601a      	str	r2, [r3, #0]
	TickType_t last_tick_count = xTaskGetTickCount();
   82bb8:	4b1f      	ldr	r3, [pc, #124]	; (82c38 <prvHouseKeepTask+0xc8>)
   82bba:	4798      	blx	r3
   82bbc:	60f8      	str	r0, [r7, #12]

	clear_current_hk();
   82bbe:	4b1f      	ldr	r3, [pc, #124]	; (82c3c <prvHouseKeepTask+0xcc>)
   82bc0:	4798      	blx	r3
	clear_current_command();
   82bc2:	4b1f      	ldr	r3, [pc, #124]	; (82c40 <prvHouseKeepTask+0xd0>)
   82bc4:	4798      	blx	r3
	setup_default_definition();
   82bc6:	4b1f      	ldr	r3, [pc, #124]	; (82c44 <prvHouseKeepTask+0xd4>)
   82bc8:	4798      	blx	r3
	set_definition(DEFAULT);
   82bca:	2000      	movs	r0, #0
   82bcc:	4b1e      	ldr	r3, [pc, #120]	; (82c48 <prvHouseKeepTask+0xd8>)
   82bce:	4798      	blx	r3
	clear_alternate_hk_definition();
   82bd0:	4b1e      	ldr	r3, [pc, #120]	; (82c4c <prvHouseKeepTask+0xdc>)
   82bd2:	4798      	blx	r3
	//set_hk_mem_offset();
		
	/* @non-terminating@ */	
	for( ;; )
	{
		if(xTaskGetTickCount() - last_tick_count > HK_LOOP_TIMEOUT)
   82bd4:	4b18      	ldr	r3, [pc, #96]	; (82c38 <prvHouseKeepTask+0xc8>)
   82bd6:	4798      	blx	r3
   82bd8:	4602      	mov	r2, r0
   82bda:	68fb      	ldr	r3, [r7, #12]
   82bdc:	1ad2      	subs	r2, r2, r3
   82bde:	f643 2398 	movw	r3, #15000	; 0x3a98
   82be2:	429a      	cmp	r2, r3
   82be4:	d90b      	bls.n	82bfe <prvHouseKeepTask+0x8e>
		{
			if(request_housekeeping_all())
   82be6:	4b1a      	ldr	r3, [pc, #104]	; (82c50 <prvHouseKeepTask+0xe0>)
   82be8:	4798      	blx	r3
   82bea:	4603      	mov	r3, r0
   82bec:	2b00      	cmp	r3, #0
   82bee:	d006      	beq.n	82bfe <prvHouseKeepTask+0x8e>
			{
				store_housekeeping();
   82bf0:	4b18      	ldr	r3, [pc, #96]	; (82c54 <prvHouseKeepTask+0xe4>)
   82bf2:	4798      	blx	r3
				send_hk_as_tm();
   82bf4:	4b18      	ldr	r3, [pc, #96]	; (82c58 <prvHouseKeepTask+0xe8>)
   82bf6:	4798      	blx	r3
				last_tick_count = xTaskGetTickCount();
   82bf8:	4b0f      	ldr	r3, [pc, #60]	; (82c38 <prvHouseKeepTask+0xc8>)
   82bfa:	4798      	blx	r3
   82bfc:	60f8      	str	r0, [r7, #12]
			}
		}
		exec_commands();
   82bfe:	4b17      	ldr	r3, [pc, #92]	; (82c5c <prvHouseKeepTask+0xec>)
   82c00:	4798      	blx	r3
		if(param_report_requiredf)
   82c02:	4b09      	ldr	r3, [pc, #36]	; (82c28 <prvHouseKeepTask+0xb8>)
   82c04:	781b      	ldrb	r3, [r3, #0]
   82c06:	2b00      	cmp	r3, #0
   82c08:	d002      	beq.n	82c10 <prvHouseKeepTask+0xa0>
			send_param_report();
   82c0a:	4b15      	ldr	r3, [pc, #84]	; (82c60 <prvHouseKeepTask+0xf0>)
   82c0c:	4798      	blx	r3
	}
   82c0e:	e7e1      	b.n	82bd4 <prvHouseKeepTask+0x64>
   82c10:	e7e0      	b.n	82bd4 <prvHouseKeepTask+0x64>
   82c12:	bf00      	nop
   82c14:	000864f9 	.word	0x000864f9
   82c18:	20070ba4 	.word	0x20070ba4
   82c1c:	20070ba8 	.word	0x20070ba8
   82c20:	20070bac 	.word	0x20070bac
   82c24:	20070ba0 	.word	0x20070ba0
   82c28:	20070bad 	.word	0x20070bad
   82c2c:	20070bae 	.word	0x20070bae
   82c30:	20070baf 	.word	0x20070baf
   82c34:	20070bb0 	.word	0x20070bb0
   82c38:	00087771 	.word	0x00087771
   82c3c:	00082e79 	.word	0x00082e79
   82c40:	00082ec5 	.word	0x00082ec5
   82c44:	0008332d 	.word	0x0008332d
   82c48:	00083519 	.word	0x00083519
   82c4c:	00082f01 	.word	0x00082f01
   82c50:	00082f3d 	.word	0x00082f3d
   82c54:	00082f81 	.word	0x00082f81
   82c58:	000835e5 	.word	0x000835e5
   82c5c:	00082c65 	.word	0x00082c65
   82c60:	0008364d 	.word	0x0008364d

00082c64 <exec_commands>:
/* EXEC_COMMANDS														*/
/* @Purpose: Attempts to receive from obc_to_hk_fifo, executes			*/
/* different commands depending on what was received.					*/
/************************************************************************/
static void exec_commands(void)
{
   82c64:	b580      	push	{r7, lr}
   82c66:	af00      	add	r7, sp, #0
	//uint8_t exec_com_success = (uint8_t)
	exec_commands_H(); 	//exec_com_success is 1 if successful, current_commands if there is a FIFO error
   82c68:	4b01      	ldr	r3, [pc, #4]	; (82c70 <exec_commands+0xc>)
   82c6a:	4798      	blx	r3
	//}
	//if (exec_com_success != 1) {
		//errorREPORT(HK_TASK_ID,0,HK_FIFO_RW_ERROR, &exec_com_success);
	//}
	/******************/
	return;
   82c6c:	bf00      	nop
}
   82c6e:	bd80      	pop	{r7, pc}
   82c70:	00082c75 	.word	0x00082c75

00082c74 <exec_commands_H>:

// Will return 1 if successful, current_command if there is a FIFO error/

static int exec_commands_H(void)
{
   82c74:	b598      	push	{r3, r4, r7, lr}
   82c76:	af00      	add	r7, sp, #0
	clear_current_command();
   82c78:	4b11      	ldr	r3, [pc, #68]	; (82cc0 <exec_commands_H+0x4c>)
   82c7a:	4798      	blx	r3
	if(xQueueReceive(obc_to_hk_fifo, current_command, (TickType_t)1) == pdTRUE)
   82c7c:	4b11      	ldr	r3, [pc, #68]	; (82cc4 <exec_commands_H+0x50>)
   82c7e:	681b      	ldr	r3, [r3, #0]
   82c80:	4618      	mov	r0, r3
   82c82:	4911      	ldr	r1, [pc, #68]	; (82cc8 <exec_commands_H+0x54>)
   82c84:	2201      	movs	r2, #1
   82c86:	2300      	movs	r3, #0
   82c88:	4c10      	ldr	r4, [pc, #64]	; (82ccc <exec_commands_H+0x58>)
   82c8a:	47a0      	blx	r4
   82c8c:	4603      	mov	r3, r0
   82c8e:	2b01      	cmp	r3, #1
   82c90:	d103      	bne.n	82c9a <exec_commands_H+0x26>
		return exec_commands_H2();
   82c92:	4b0f      	ldr	r3, [pc, #60]	; (82cd0 <exec_commands_H+0x5c>)
   82c94:	4798      	blx	r3
   82c96:	4603      	mov	r3, r0
   82c98:	e00f      	b.n	82cba <exec_commands_H+0x46>
	else if(xQueueReceive(sched_to_hk_fifo, current_command, (TickType_t)1))
   82c9a:	4b0e      	ldr	r3, [pc, #56]	; (82cd4 <exec_commands_H+0x60>)
   82c9c:	681b      	ldr	r3, [r3, #0]
   82c9e:	4618      	mov	r0, r3
   82ca0:	4909      	ldr	r1, [pc, #36]	; (82cc8 <exec_commands_H+0x54>)
   82ca2:	2201      	movs	r2, #1
   82ca4:	2300      	movs	r3, #0
   82ca6:	4c09      	ldr	r4, [pc, #36]	; (82ccc <exec_commands_H+0x58>)
   82ca8:	47a0      	blx	r4
   82caa:	4603      	mov	r3, r0
   82cac:	2b00      	cmp	r3, #0
   82cae:	d003      	beq.n	82cb8 <exec_commands_H+0x44>
		return exec_commands_H2();
   82cb0:	4b07      	ldr	r3, [pc, #28]	; (82cd0 <exec_commands_H+0x5c>)
   82cb2:	4798      	blx	r3
   82cb4:	4603      	mov	r3, r0
   82cb6:	e000      	b.n	82cba <exec_commands_H+0x46>
	else										//Failure Recovery					
		return 0;
   82cb8:	2300      	movs	r3, #0
}
   82cba:	4618      	mov	r0, r3
   82cbc:	bd98      	pop	{r3, r4, r7, pc}
   82cbe:	bf00      	nop
   82cc0:	00082ec5 	.word	0x00082ec5
   82cc4:	2007adc4 	.word	0x2007adc4
   82cc8:	200708dc 	.word	0x200708dc
   82ccc:	00086dc1 	.word	0x00086dc1
   82cd0:	00082cd9 	.word	0x00082cd9
   82cd4:	2007b0fc 	.word	0x2007b0fc

00082cd8 <exec_commands_H2>:

static int exec_commands_H2(void)
{
   82cd8:	b580      	push	{r7, lr}
   82cda:	b082      	sub	sp, #8
   82cdc:	af00      	add	r7, sp, #0
	uint8_t command;
	packet_id = ((uint16_t)current_command[140]) << 8;
   82cde:	4b5d      	ldr	r3, [pc, #372]	; (82e54 <exec_commands_H2+0x17c>)
   82ce0:	f893 308c 	ldrb.w	r3, [r3, #140]	; 0x8c
   82ce4:	021b      	lsls	r3, r3, #8
   82ce6:	b29a      	uxth	r2, r3
   82ce8:	4b5b      	ldr	r3, [pc, #364]	; (82e58 <exec_commands_H2+0x180>)
   82cea:	801a      	strh	r2, [r3, #0]
	packet_id += (uint16_t)current_command[139];
   82cec:	4b59      	ldr	r3, [pc, #356]	; (82e54 <exec_commands_H2+0x17c>)
   82cee:	f893 308b 	ldrb.w	r3, [r3, #139]	; 0x8b
   82cf2:	461a      	mov	r2, r3
   82cf4:	4b58      	ldr	r3, [pc, #352]	; (82e58 <exec_commands_H2+0x180>)
   82cf6:	881b      	ldrh	r3, [r3, #0]
   82cf8:	4413      	add	r3, r2
   82cfa:	b29a      	uxth	r2, r3
   82cfc:	4b56      	ldr	r3, [pc, #344]	; (82e58 <exec_commands_H2+0x180>)
   82cfe:	801a      	strh	r2, [r3, #0]
	psc = ((uint16_t)current_command[138]) << 8;
   82d00:	4b54      	ldr	r3, [pc, #336]	; (82e54 <exec_commands_H2+0x17c>)
   82d02:	f893 308a 	ldrb.w	r3, [r3, #138]	; 0x8a
   82d06:	021b      	lsls	r3, r3, #8
   82d08:	b29a      	uxth	r2, r3
   82d0a:	4b54      	ldr	r3, [pc, #336]	; (82e5c <exec_commands_H2+0x184>)
   82d0c:	801a      	strh	r2, [r3, #0]
	psc += (uint16_t)current_command[137];
   82d0e:	4b51      	ldr	r3, [pc, #324]	; (82e54 <exec_commands_H2+0x17c>)
   82d10:	f893 3089 	ldrb.w	r3, [r3, #137]	; 0x89
   82d14:	461a      	mov	r2, r3
   82d16:	4b51      	ldr	r3, [pc, #324]	; (82e5c <exec_commands_H2+0x184>)
   82d18:	881b      	ldrh	r3, [r3, #0]
   82d1a:	4413      	add	r3, r2
   82d1c:	b29a      	uxth	r2, r3
   82d1e:	4b4f      	ldr	r3, [pc, #316]	; (82e5c <exec_commands_H2+0x184>)
   82d20:	801a      	strh	r2, [r3, #0]
	command = current_command[146];
   82d22:	4b4c      	ldr	r3, [pc, #304]	; (82e54 <exec_commands_H2+0x17c>)
   82d24:	f893 3092 	ldrb.w	r3, [r3, #146]	; 0x92
   82d28:	71fb      	strb	r3, [r7, #7]
	switch(command)
   82d2a:	79fb      	ldrb	r3, [r7, #7]
   82d2c:	3b01      	subs	r3, #1
   82d2e:	2b08      	cmp	r3, #8
   82d30:	f200 8089 	bhi.w	82e46 <exec_commands_H2+0x16e>
   82d34:	a201      	add	r2, pc, #4	; (adr r2, 82d3c <exec_commands_H2+0x64>)
   82d36:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   82d3a:	bf00      	nop
   82d3c:	00082d61 	.word	0x00082d61
   82d40:	00082e47 	.word	0x00082e47
   82d44:	00082dcd 	.word	0x00082dcd
   82d48:	00082e47 	.word	0x00082e47
   82d4c:	00082e11 	.word	0x00082e11
   82d50:	00082e29 	.word	0x00082e29
   82d54:	00082e47 	.word	0x00082e47
   82d58:	00082e47 	.word	0x00082e47
   82d5c:	00082e41 	.word	0x00082e41
	{
		case	NEW_HK_DEFINITION:
			collection_interval1 = current_command[145];
   82d60:	4b3c      	ldr	r3, [pc, #240]	; (82e54 <exec_commands_H2+0x17c>)
   82d62:	f893 2091 	ldrb.w	r2, [r3, #145]	; 0x91
   82d66:	4b3e      	ldr	r3, [pc, #248]	; (82e60 <exec_commands_H2+0x188>)
   82d68:	701a      	strb	r2, [r3, #0]
			for(i = 0; i < DATA_LENGTH; i++)
   82d6a:	4b3e      	ldr	r3, [pc, #248]	; (82e64 <exec_commands_H2+0x18c>)
   82d6c:	2200      	movs	r2, #0
   82d6e:	701a      	strb	r2, [r3, #0]
   82d70:	e00d      	b.n	82d8e <exec_commands_H2+0xb6>
			{
				hk_definition1[i] = current_command[i];
   82d72:	4b3c      	ldr	r3, [pc, #240]	; (82e64 <exec_commands_H2+0x18c>)
   82d74:	781b      	ldrb	r3, [r3, #0]
   82d76:	4a3b      	ldr	r2, [pc, #236]	; (82e64 <exec_commands_H2+0x18c>)
   82d78:	7812      	ldrb	r2, [r2, #0]
   82d7a:	4936      	ldr	r1, [pc, #216]	; (82e54 <exec_commands_H2+0x17c>)
   82d7c:	5c89      	ldrb	r1, [r1, r2]
   82d7e:	4a3a      	ldr	r2, [pc, #232]	; (82e68 <exec_commands_H2+0x190>)
   82d80:	54d1      	strb	r1, [r2, r3]
	command = current_command[146];
	switch(command)
	{
		case	NEW_HK_DEFINITION:
			collection_interval1 = current_command[145];
			for(i = 0; i < DATA_LENGTH; i++)
   82d82:	4b38      	ldr	r3, [pc, #224]	; (82e64 <exec_commands_H2+0x18c>)
   82d84:	781b      	ldrb	r3, [r3, #0]
   82d86:	3301      	adds	r3, #1
   82d88:	b2da      	uxtb	r2, r3
   82d8a:	4b36      	ldr	r3, [pc, #216]	; (82e64 <exec_commands_H2+0x18c>)
   82d8c:	701a      	strb	r2, [r3, #0]
   82d8e:	4b35      	ldr	r3, [pc, #212]	; (82e64 <exec_commands_H2+0x18c>)
   82d90:	781b      	ldrb	r3, [r3, #0]
   82d92:	2b88      	cmp	r3, #136	; 0x88
   82d94:	d9ed      	bls.n	82d72 <exec_commands_H2+0x9a>
			{
				hk_definition1[i] = current_command[i];
			}
			hk_definition1[136] = 1;		//sID = 1
   82d96:	4b34      	ldr	r3, [pc, #208]	; (82e68 <exec_commands_H2+0x190>)
   82d98:	2201      	movs	r2, #1
   82d9a:	f883 2088 	strb.w	r2, [r3, #136]	; 0x88
			hk_definition1[135] = collection_interval1;
   82d9e:	4b30      	ldr	r3, [pc, #192]	; (82e60 <exec_commands_H2+0x188>)
   82da0:	781a      	ldrb	r2, [r3, #0]
   82da2:	4b31      	ldr	r3, [pc, #196]	; (82e68 <exec_commands_H2+0x190>)
   82da4:	f883 2087 	strb.w	r2, [r3, #135]	; 0x87
			hk_definition1[134] = current_command[146];
   82da8:	4b2a      	ldr	r3, [pc, #168]	; (82e54 <exec_commands_H2+0x17c>)
   82daa:	f893 2092 	ldrb.w	r2, [r3, #146]	; 0x92
   82dae:	4b2e      	ldr	r3, [pc, #184]	; (82e68 <exec_commands_H2+0x190>)
   82db0:	f883 2086 	strb.w	r2, [r3, #134]	; 0x86
			set_definition(ALTERNATE);
   82db4:	2001      	movs	r0, #1
   82db6:	4b2d      	ldr	r3, [pc, #180]	; (82e6c <exec_commands_H2+0x194>)
   82db8:	4798      	blx	r3
			send_tc_execution_verify(1, packet_id, psc);		// Send TC Execution Verification (Success)
   82dba:	4b27      	ldr	r3, [pc, #156]	; (82e58 <exec_commands_H2+0x180>)
   82dbc:	881a      	ldrh	r2, [r3, #0]
   82dbe:	4b27      	ldr	r3, [pc, #156]	; (82e5c <exec_commands_H2+0x184>)
   82dc0:	881b      	ldrh	r3, [r3, #0]
   82dc2:	2001      	movs	r0, #1
   82dc4:	4611      	mov	r1, r2
   82dc6:	461a      	mov	r2, r3
   82dc8:	4b29      	ldr	r3, [pc, #164]	; (82e70 <exec_commands_H2+0x198>)
   82dca:	4798      	blx	r3
		case	CLEAR_HK_DEFINITION:
			collection_interval1 = 30;
   82dcc:	4b24      	ldr	r3, [pc, #144]	; (82e60 <exec_commands_H2+0x188>)
   82dce:	221e      	movs	r2, #30
   82dd0:	701a      	strb	r2, [r3, #0]
			for(i = 0; i < DATA_LENGTH; i++)
   82dd2:	4b24      	ldr	r3, [pc, #144]	; (82e64 <exec_commands_H2+0x18c>)
   82dd4:	2200      	movs	r2, #0
   82dd6:	701a      	strb	r2, [r3, #0]
   82dd8:	e00a      	b.n	82df0 <exec_commands_H2+0x118>
			{
				hk_definition1[i] = 0;
   82dda:	4b22      	ldr	r3, [pc, #136]	; (82e64 <exec_commands_H2+0x18c>)
   82ddc:	781b      	ldrb	r3, [r3, #0]
   82dde:	4a22      	ldr	r2, [pc, #136]	; (82e68 <exec_commands_H2+0x190>)
   82de0:	2100      	movs	r1, #0
   82de2:	54d1      	strb	r1, [r2, r3]
			hk_definition1[134] = current_command[146];
			set_definition(ALTERNATE);
			send_tc_execution_verify(1, packet_id, psc);		// Send TC Execution Verification (Success)
		case	CLEAR_HK_DEFINITION:
			collection_interval1 = 30;
			for(i = 0; i < DATA_LENGTH; i++)
   82de4:	4b1f      	ldr	r3, [pc, #124]	; (82e64 <exec_commands_H2+0x18c>)
   82de6:	781b      	ldrb	r3, [r3, #0]
   82de8:	3301      	adds	r3, #1
   82dea:	b2da      	uxtb	r2, r3
   82dec:	4b1d      	ldr	r3, [pc, #116]	; (82e64 <exec_commands_H2+0x18c>)
   82dee:	701a      	strb	r2, [r3, #0]
   82df0:	4b1c      	ldr	r3, [pc, #112]	; (82e64 <exec_commands_H2+0x18c>)
   82df2:	781b      	ldrb	r3, [r3, #0]
   82df4:	2b88      	cmp	r3, #136	; 0x88
   82df6:	d9f0      	bls.n	82dda <exec_commands_H2+0x102>
			{
				hk_definition1[i] = 0;
			}
			set_definition(DEFAULT);
   82df8:	2000      	movs	r0, #0
   82dfa:	4b1c      	ldr	r3, [pc, #112]	; (82e6c <exec_commands_H2+0x194>)
   82dfc:	4798      	blx	r3
			send_tc_execution_verify(1, packet_id, psc);
   82dfe:	4b16      	ldr	r3, [pc, #88]	; (82e58 <exec_commands_H2+0x180>)
   82e00:	881a      	ldrh	r2, [r3, #0]
   82e02:	4b16      	ldr	r3, [pc, #88]	; (82e5c <exec_commands_H2+0x184>)
   82e04:	881b      	ldrh	r3, [r3, #0]
   82e06:	2001      	movs	r0, #1
   82e08:	4611      	mov	r1, r2
   82e0a:	461a      	mov	r2, r3
   82e0c:	4b18      	ldr	r3, [pc, #96]	; (82e70 <exec_commands_H2+0x198>)
   82e0e:	4798      	blx	r3
		case	ENABLE_PARAM_REPORT:
			param_report_requiredf = 1;
   82e10:	4b18      	ldr	r3, [pc, #96]	; (82e74 <exec_commands_H2+0x19c>)
   82e12:	2201      	movs	r2, #1
   82e14:	701a      	strb	r2, [r3, #0]
			send_tc_execution_verify(1, packet_id, psc);
   82e16:	4b10      	ldr	r3, [pc, #64]	; (82e58 <exec_commands_H2+0x180>)
   82e18:	881a      	ldrh	r2, [r3, #0]
   82e1a:	4b10      	ldr	r3, [pc, #64]	; (82e5c <exec_commands_H2+0x184>)
   82e1c:	881b      	ldrh	r3, [r3, #0]
   82e1e:	2001      	movs	r0, #1
   82e20:	4611      	mov	r1, r2
   82e22:	461a      	mov	r2, r3
   82e24:	4b12      	ldr	r3, [pc, #72]	; (82e70 <exec_commands_H2+0x198>)
   82e26:	4798      	blx	r3
		case	DISABLE_PARAM_REPORT:
			param_report_requiredf = 0;
   82e28:	4b12      	ldr	r3, [pc, #72]	; (82e74 <exec_commands_H2+0x19c>)
   82e2a:	2200      	movs	r2, #0
   82e2c:	701a      	strb	r2, [r3, #0]
			send_tc_execution_verify(1, packet_id, psc);
   82e2e:	4b0a      	ldr	r3, [pc, #40]	; (82e58 <exec_commands_H2+0x180>)
   82e30:	881a      	ldrh	r2, [r3, #0]
   82e32:	4b0a      	ldr	r3, [pc, #40]	; (82e5c <exec_commands_H2+0x184>)
   82e34:	881b      	ldrh	r3, [r3, #0]
   82e36:	2001      	movs	r0, #1
   82e38:	4611      	mov	r1, r2
   82e3a:	461a      	mov	r2, r3
   82e3c:	4b0c      	ldr	r3, [pc, #48]	; (82e70 <exec_commands_H2+0x198>)
   82e3e:	4798      	blx	r3
		case	REPORT_HK_DEFINITIONS:
			param_report_requiredf = 1;
   82e40:	4b0c      	ldr	r3, [pc, #48]	; (82e74 <exec_commands_H2+0x19c>)
   82e42:	2201      	movs	r2, #1
   82e44:	701a      	strb	r2, [r3, #0]
			//send_tc_execution_verify(1, packet_id, psc);
		default:
			return -1;
   82e46:	f04f 33ff 	mov.w	r3, #4294967295
	}
	return 1;
}
   82e4a:	4618      	mov	r0, r3
   82e4c:	3708      	adds	r7, #8
   82e4e:	46bd      	mov	sp, r7
   82e50:	bd80      	pop	{r7, pc}
   82e52:	bf00      	nop
   82e54:	200708dc 	.word	0x200708dc
   82e58:	20070bba 	.word	0x20070bba
   82e5c:	20070bbc 	.word	0x20070bbc
   82e60:	20070baf 	.word	0x20070baf
   82e64:	20070bb8 	.word	0x20070bb8
   82e68:	200709fc 	.word	0x200709fc
   82e6c:	00083519 	.word	0x00083519
   82e70:	000836c1 	.word	0x000836c1
   82e74:	20070bad 	.word	0x20070bad

00082e78 <clear_current_hk>:
/************************************************************************/
/* CLEAR_CURRENT_HK														*/
/* @Purpose: clears the array current_hk[]								*/
/************************************************************************/
static void clear_current_hk(void)
{
   82e78:	b480      	push	{r7}
   82e7a:	af00      	add	r7, sp, #0
	for(i = 0; i < DATA_LENGTH; i++)
   82e7c:	4b0e      	ldr	r3, [pc, #56]	; (82eb8 <clear_current_hk+0x40>)
   82e7e:	2200      	movs	r2, #0
   82e80:	701a      	strb	r2, [r3, #0]
   82e82:	e00f      	b.n	82ea4 <clear_current_hk+0x2c>
	{
		current_hk[i] = 0;
   82e84:	4b0c      	ldr	r3, [pc, #48]	; (82eb8 <clear_current_hk+0x40>)
   82e86:	781b      	ldrb	r3, [r3, #0]
   82e88:	4a0c      	ldr	r2, [pc, #48]	; (82ebc <clear_current_hk+0x44>)
   82e8a:	2100      	movs	r1, #0
   82e8c:	54d1      	strb	r1, [r2, r3]
		hk_updated[i] = 0;
   82e8e:	4b0a      	ldr	r3, [pc, #40]	; (82eb8 <clear_current_hk+0x40>)
   82e90:	781b      	ldrb	r3, [r3, #0]
   82e92:	4a0b      	ldr	r2, [pc, #44]	; (82ec0 <clear_current_hk+0x48>)
   82e94:	2100      	movs	r1, #0
   82e96:	54d1      	strb	r1, [r2, r3]
/* CLEAR_CURRENT_HK														*/
/* @Purpose: clears the array current_hk[]								*/
/************************************************************************/
static void clear_current_hk(void)
{
	for(i = 0; i < DATA_LENGTH; i++)
   82e98:	4b07      	ldr	r3, [pc, #28]	; (82eb8 <clear_current_hk+0x40>)
   82e9a:	781b      	ldrb	r3, [r3, #0]
   82e9c:	3301      	adds	r3, #1
   82e9e:	b2da      	uxtb	r2, r3
   82ea0:	4b05      	ldr	r3, [pc, #20]	; (82eb8 <clear_current_hk+0x40>)
   82ea2:	701a      	strb	r2, [r3, #0]
   82ea4:	4b04      	ldr	r3, [pc, #16]	; (82eb8 <clear_current_hk+0x40>)
   82ea6:	781b      	ldrb	r3, [r3, #0]
   82ea8:	2b88      	cmp	r3, #136	; 0x88
   82eaa:	d9eb      	bls.n	82e84 <clear_current_hk+0xc>
	{
		current_hk[i] = 0;
		hk_updated[i] = 0;
	}
	return;
   82eac:	bf00      	nop
}
   82eae:	46bd      	mov	sp, r7
   82eb0:	f85d 7b04 	ldr.w	r7, [sp], #4
   82eb4:	4770      	bx	lr
   82eb6:	bf00      	nop
   82eb8:	20070bb8 	.word	0x20070bb8
   82ebc:	20070850 	.word	0x20070850
   82ec0:	20070a88 	.word	0x20070a88

00082ec4 <clear_current_command>:
/************************************************************************/
/* CLEAR_CURRENT_COMMAND												*/
/* @Purpose: clears the array current_command[]							*/
/************************************************************************/
static void clear_current_command(void)
{
   82ec4:	b480      	push	{r7}
   82ec6:	af00      	add	r7, sp, #0
	for(i = 0; i < (DATA_LENGTH + 10); i++)
   82ec8:	4b0b      	ldr	r3, [pc, #44]	; (82ef8 <clear_current_command+0x34>)
   82eca:	2200      	movs	r2, #0
   82ecc:	701a      	strb	r2, [r3, #0]
   82ece:	e00a      	b.n	82ee6 <clear_current_command+0x22>
	{
		current_command[i] = 0;
   82ed0:	4b09      	ldr	r3, [pc, #36]	; (82ef8 <clear_current_command+0x34>)
   82ed2:	781b      	ldrb	r3, [r3, #0]
   82ed4:	4a09      	ldr	r2, [pc, #36]	; (82efc <clear_current_command+0x38>)
   82ed6:	2100      	movs	r1, #0
   82ed8:	54d1      	strb	r1, [r2, r3]
/* CLEAR_CURRENT_COMMAND												*/
/* @Purpose: clears the array current_command[]							*/
/************************************************************************/
static void clear_current_command(void)
{
	for(i = 0; i < (DATA_LENGTH + 10); i++)
   82eda:	4b07      	ldr	r3, [pc, #28]	; (82ef8 <clear_current_command+0x34>)
   82edc:	781b      	ldrb	r3, [r3, #0]
   82ede:	3301      	adds	r3, #1
   82ee0:	b2da      	uxtb	r2, r3
   82ee2:	4b05      	ldr	r3, [pc, #20]	; (82ef8 <clear_current_command+0x34>)
   82ee4:	701a      	strb	r2, [r3, #0]
   82ee6:	4b04      	ldr	r3, [pc, #16]	; (82ef8 <clear_current_command+0x34>)
   82ee8:	781b      	ldrb	r3, [r3, #0]
   82eea:	2b92      	cmp	r3, #146	; 0x92
   82eec:	d9f0      	bls.n	82ed0 <clear_current_command+0xc>
	{
		current_command[i] = 0;
	}
	return;
   82eee:	bf00      	nop
}
   82ef0:	46bd      	mov	sp, r7
   82ef2:	f85d 7b04 	ldr.w	r7, [sp], #4
   82ef6:	4770      	bx	lr
   82ef8:	20070bb8 	.word	0x20070bb8
   82efc:	200708dc 	.word	0x200708dc

00082f00 <clear_alternate_hk_definition>:
/************************************************************************/
/* CLEAR_ALTERNATE_HK_DEFINITION										*/
/* @Purpose: clears the array current_hk_definition						*/
/************************************************************************/
static void clear_alternate_hk_definition(void)
{
   82f00:	b480      	push	{r7}
   82f02:	af00      	add	r7, sp, #0
	for(i = 0; i < DATA_LENGTH; i++)
   82f04:	4b0b      	ldr	r3, [pc, #44]	; (82f34 <clear_alternate_hk_definition+0x34>)
   82f06:	2200      	movs	r2, #0
   82f08:	701a      	strb	r2, [r3, #0]
   82f0a:	e00a      	b.n	82f22 <clear_alternate_hk_definition+0x22>
	{
		hk_definition1[i] = 0;
   82f0c:	4b09      	ldr	r3, [pc, #36]	; (82f34 <clear_alternate_hk_definition+0x34>)
   82f0e:	781b      	ldrb	r3, [r3, #0]
   82f10:	4a09      	ldr	r2, [pc, #36]	; (82f38 <clear_alternate_hk_definition+0x38>)
   82f12:	2100      	movs	r1, #0
   82f14:	54d1      	strb	r1, [r2, r3]
/* CLEAR_ALTERNATE_HK_DEFINITION										*/
/* @Purpose: clears the array current_hk_definition						*/
/************************************************************************/
static void clear_alternate_hk_definition(void)
{
	for(i = 0; i < DATA_LENGTH; i++)
   82f16:	4b07      	ldr	r3, [pc, #28]	; (82f34 <clear_alternate_hk_definition+0x34>)
   82f18:	781b      	ldrb	r3, [r3, #0]
   82f1a:	3301      	adds	r3, #1
   82f1c:	b2da      	uxtb	r2, r3
   82f1e:	4b05      	ldr	r3, [pc, #20]	; (82f34 <clear_alternate_hk_definition+0x34>)
   82f20:	701a      	strb	r2, [r3, #0]
   82f22:	4b04      	ldr	r3, [pc, #16]	; (82f34 <clear_alternate_hk_definition+0x34>)
   82f24:	781b      	ldrb	r3, [r3, #0]
   82f26:	2b88      	cmp	r3, #136	; 0x88
   82f28:	d9f0      	bls.n	82f0c <clear_alternate_hk_definition+0xc>
	{
		hk_definition1[i] = 0;
	}
	return;
   82f2a:	bf00      	nop
}
   82f2c:	46bd      	mov	sp, r7
   82f2e:	f85d 7b04 	ldr.w	r7, [sp], #4
   82f32:	4770      	bx	lr
   82f34:	20070bb8 	.word	0x20070bb8
   82f38:	200709fc 	.word	0x200709fc

00082f3c <request_housekeeping_all>:
/* REQUEST_HOUSEKEEPING_ALL												*/
/* @Purpose: Requests for housekeeping from each SSM.					*/
/* @return: 1 = action succeeded, -1 = something bad happened.			*/
/************************************************************************/
static int request_housekeeping_all(void)
{			
   82f3c:	b580      	push	{r7, lr}
   82f3e:	af00      	add	r7, sp, #0
	if(request_housekeeping(EPS_ID) > 1)							// Request housekeeping from COMS.
   82f40:	2001      	movs	r0, #1
   82f42:	4b0e      	ldr	r3, [pc, #56]	; (82f7c <request_housekeeping_all+0x40>)
   82f44:	4798      	blx	r3
   82f46:	4603      	mov	r3, r0
   82f48:	2b01      	cmp	r3, #1
   82f4a:	d902      	bls.n	82f52 <request_housekeeping_all+0x16>
		return -1;
   82f4c:	f04f 33ff 	mov.w	r3, #4294967295
   82f50:	e012      	b.n	82f78 <request_housekeeping_all+0x3c>
	if(request_housekeeping(COMS_ID) > 1)							// Request housekeeping from EPS.
   82f52:	2000      	movs	r0, #0
   82f54:	4b09      	ldr	r3, [pc, #36]	; (82f7c <request_housekeeping_all+0x40>)
   82f56:	4798      	blx	r3
   82f58:	4603      	mov	r3, r0
   82f5a:	2b01      	cmp	r3, #1
   82f5c:	d902      	bls.n	82f64 <request_housekeeping_all+0x28>
		return -1;
   82f5e:	f04f 33ff 	mov.w	r3, #4294967295
   82f62:	e009      	b.n	82f78 <request_housekeeping_all+0x3c>
	if(request_housekeeping(PAY_ID) > 1)							// Request housekeeping from PAY.
   82f64:	2002      	movs	r0, #2
   82f66:	4b05      	ldr	r3, [pc, #20]	; (82f7c <request_housekeeping_all+0x40>)
   82f68:	4798      	blx	r3
   82f6a:	4603      	mov	r3, r0
   82f6c:	2b01      	cmp	r3, #1
   82f6e:	d902      	bls.n	82f76 <request_housekeeping_all+0x3a>
		return -1;
   82f70:	f04f 33ff 	mov.w	r3, #4294967295
   82f74:	e000      	b.n	82f78 <request_housekeeping_all+0x3c>
	return 1;
   82f76:	2301      	movs	r3, #1
}
   82f78:	4618      	mov	r0, r3
   82f7a:	bd80      	pop	{r7, pc}
   82f7c:	000894f1 	.word	0x000894f1

00082f80 <store_housekeeping>:
/* @Note: This function erases old values but also keeps track of values*/
/* were not updated, and subsequently sends an event report to ground	*/
/* if one was updated as well as a message to the FDIR task.			*/
/************************************************************************/
static int store_housekeeping(void)
{
   82f80:	b590      	push	{r4, r7, lr}
   82f82:	b085      	sub	sp, #20
   82f84:	af00      	add	r7, sp, #0
	num_parameters = current_hk_definition[129];	// ALTERED FOR CSDC 134 --> 129
   82f86:	4b89      	ldr	r3, [pc, #548]	; (831ac <store_housekeeping+0x22c>)
   82f88:	f893 2081 	ldrb.w	r2, [r3, #129]	; 0x81
   82f8c:	4b88      	ldr	r3, [pc, #544]	; (831b0 <store_housekeeping+0x230>)
   82f8e:	701a      	strb	r2, [r3, #0]
	parameter_name = 0;
   82f90:	4b88      	ldr	r3, [pc, #544]	; (831b4 <store_housekeeping+0x234>)
   82f92:	2200      	movs	r2, #0
   82f94:	701a      	strb	r2, [r3, #0]
	//int attempts = 1;
	int* status = 0; // this might be wrong
   82f96:	2300      	movs	r3, #0
   82f98:	607b      	str	r3, [r7, #4]
	req_data_result = 0;
   82f9a:	4b87      	ldr	r3, [pc, #540]	; (831b8 <store_housekeeping+0x238>)
   82f9c:	2200      	movs	r2, #0
   82f9e:	601a      	str	r2, [r3, #0]
	if(current_hk_fullf)
   82fa0:	4b86      	ldr	r3, [pc, #536]	; (831bc <store_housekeeping+0x23c>)
   82fa2:	781b      	ldrb	r3, [r3, #0]
   82fa4:	2b00      	cmp	r3, #0
   82fa6:	d002      	beq.n	82fae <store_housekeeping+0x2e>
		return -1;
   82fa8:	f04f 33ff 	mov.w	r3, #4294967295
   82fac:	e0f9      	b.n	831a2 <store_housekeeping+0x222>
	for(i = 0; i < PACKET_LENGTH; i++)
   82fae:	4b84      	ldr	r3, [pc, #528]	; (831c0 <store_housekeeping+0x240>)
   82fb0:	2200      	movs	r2, #0
   82fb2:	701a      	strb	r2, [r3, #0]
   82fb4:	e00a      	b.n	82fcc <store_housekeeping+0x4c>
	{
		hk_updated[i] = 0;
   82fb6:	4b82      	ldr	r3, [pc, #520]	; (831c0 <store_housekeeping+0x240>)
   82fb8:	781b      	ldrb	r3, [r3, #0]
   82fba:	4a82      	ldr	r2, [pc, #520]	; (831c4 <store_housekeeping+0x244>)
   82fbc:	2100      	movs	r1, #0
   82fbe:	54d1      	strb	r1, [r2, r3]
	//int attempts = 1;
	int* status = 0; // this might be wrong
	req_data_result = 0;
	if(current_hk_fullf)
		return -1;
	for(i = 0; i < PACKET_LENGTH; i++)
   82fc0:	4b7f      	ldr	r3, [pc, #508]	; (831c0 <store_housekeeping+0x240>)
   82fc2:	781b      	ldrb	r3, [r3, #0]
   82fc4:	3301      	adds	r3, #1
   82fc6:	b2da      	uxtb	r2, r3
   82fc8:	4b7d      	ldr	r3, [pc, #500]	; (831c0 <store_housekeeping+0x240>)
   82fca:	701a      	strb	r2, [r3, #0]
   82fcc:	4b7c      	ldr	r3, [pc, #496]	; (831c0 <store_housekeeping+0x240>)
   82fce:	781b      	ldrb	r3, [r3, #0]
   82fd0:	2b97      	cmp	r3, #151	; 0x97
   82fd2:	d9f0      	bls.n	82fb6 <store_housekeeping+0x36>
	{
		hk_updated[i] = 0;
	}
	uint8_t parameter_count = num_parameters;
   82fd4:	4b76      	ldr	r3, [pc, #472]	; (831b0 <store_housekeeping+0x230>)
   82fd6:	781b      	ldrb	r3, [r3, #0]
   82fd8:	73fb      	strb	r3, [r7, #15]
	uint32_t timeout = 5000;
   82fda:	f241 3388 	movw	r3, #5000	; 0x1388
   82fde:	60bb      	str	r3, [r7, #8]
	//clear_current_hk();									// Commented out for CSDC
	
	// CSDC ONLY  // (Filling in OBC values for housekeeping)
	current_hk[94] = 0x55;
   82fe0:	4b79      	ldr	r3, [pc, #484]	; (831c8 <store_housekeeping+0x248>)
   82fe2:	2255      	movs	r2, #85	; 0x55
   82fe4:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
	current_hk[93] = 0x55;
   82fe8:	4b77      	ldr	r3, [pc, #476]	; (831c8 <store_housekeeping+0x248>)
   82fea:	2255      	movs	r2, #85	; 0x55
   82fec:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
	current_hk[83] = ABSOLUTE_DAY;
   82ff0:	4b76      	ldr	r3, [pc, #472]	; (831cc <store_housekeeping+0x24c>)
   82ff2:	781a      	ldrb	r2, [r3, #0]
   82ff4:	4b74      	ldr	r3, [pc, #464]	; (831c8 <store_housekeeping+0x248>)
   82ff6:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	current_hk[81] = CURRENT_HOUR;
   82ffa:	4b75      	ldr	r3, [pc, #468]	; (831d0 <store_housekeeping+0x250>)
   82ffc:	781a      	ldrb	r2, [r3, #0]
   82ffe:	4b72      	ldr	r3, [pc, #456]	; (831c8 <store_housekeeping+0x248>)
   83000:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	current_hk[79] = CURRENT_MINUTE;
   83004:	4b73      	ldr	r3, [pc, #460]	; (831d4 <store_housekeeping+0x254>)
   83006:	781a      	ldrb	r2, [r3, #0]
   83008:	4b6f      	ldr	r3, [pc, #444]	; (831c8 <store_housekeeping+0x248>)
   8300a:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	hk_updated[94] = 1;
   8300e:	4b6d      	ldr	r3, [pc, #436]	; (831c4 <store_housekeeping+0x244>)
   83010:	2201      	movs	r2, #1
   83012:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
	hk_updated[93] = 1;
   83016:	4b6b      	ldr	r3, [pc, #428]	; (831c4 <store_housekeeping+0x244>)
   83018:	2201      	movs	r2, #1
   8301a:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
	hk_updated[84] = 1;
   8301e:	4b69      	ldr	r3, [pc, #420]	; (831c4 <store_housekeeping+0x244>)
   83020:	2201      	movs	r2, #1
   83022:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	hk_updated[83] = 1;
   83026:	4b67      	ldr	r3, [pc, #412]	; (831c4 <store_housekeeping+0x244>)
   83028:	2201      	movs	r2, #1
   8302a:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	hk_updated[82] = 1;
   8302e:	4b65      	ldr	r3, [pc, #404]	; (831c4 <store_housekeeping+0x244>)
   83030:	2201      	movs	r2, #1
   83032:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	hk_updated[81] = 1;
   83036:	4b63      	ldr	r3, [pc, #396]	; (831c4 <store_housekeeping+0x244>)
   83038:	2201      	movs	r2, #1
   8303a:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	hk_updated[80] = 1;
   8303e:	4b61      	ldr	r3, [pc, #388]	; (831c4 <store_housekeeping+0x244>)
   83040:	2201      	movs	r2, #1
   83042:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	hk_updated[79] = 1;
   83046:	4b5f      	ldr	r3, [pc, #380]	; (831c4 <store_housekeeping+0x244>)
   83048:	2201      	movs	r2, #1
   8304a:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	
	while(parameter_count && timeout--)
   8304e:	e04a      	b.n	830e6 <store_housekeeping+0x166>
	{
		if(read_can_hk(&new_hk_msg_high, &new_hk_msg_low, 1234) == 1)
   83050:	4861      	ldr	r0, [pc, #388]	; (831d8 <store_housekeeping+0x258>)
   83052:	4962      	ldr	r1, [pc, #392]	; (831dc <store_housekeeping+0x25c>)
   83054:	f240 42d2 	movw	r2, #1234	; 0x4d2
   83058:	4b61      	ldr	r3, [pc, #388]	; (831e0 <store_housekeeping+0x260>)
   8305a:	4798      	blx	r3
   8305c:	4603      	mov	r3, r0
   8305e:	2b01      	cmp	r3, #1
   83060:	d13f      	bne.n	830e2 <store_housekeeping+0x162>
		{
			parameter_count--;
   83062:	7bfb      	ldrb	r3, [r7, #15]
   83064:	3b01      	subs	r3, #1
   83066:	73fb      	strb	r3, [r7, #15]
			parameter_name = (new_hk_msg_high & 0x00000FF);	// Name of the parameter for housekeeping (either sensor or variable).
   83068:	4b5b      	ldr	r3, [pc, #364]	; (831d8 <store_housekeeping+0x258>)
   8306a:	681b      	ldr	r3, [r3, #0]
   8306c:	b2da      	uxtb	r2, r3
   8306e:	4b51      	ldr	r3, [pc, #324]	; (831b4 <store_housekeeping+0x234>)
   83070:	701a      	strb	r2, [r3, #0]
			for(i = 79; i < 79 + num_parameters * 2; i+=2)					// ALTERED FOR CSDC (i = 0 before)
   83072:	4b53      	ldr	r3, [pc, #332]	; (831c0 <store_housekeeping+0x240>)
   83074:	224f      	movs	r2, #79	; 0x4f
   83076:	701a      	strb	r2, [r3, #0]
   83078:	e02a      	b.n	830d0 <store_housekeeping+0x150>
			{
				if(current_hk_definition[i] == parameter_name)
   8307a:	4b51      	ldr	r3, [pc, #324]	; (831c0 <store_housekeeping+0x240>)
   8307c:	781b      	ldrb	r3, [r3, #0]
   8307e:	4a4b      	ldr	r2, [pc, #300]	; (831ac <store_housekeeping+0x22c>)
   83080:	5cd2      	ldrb	r2, [r2, r3]
   83082:	4b4c      	ldr	r3, [pc, #304]	; (831b4 <store_housekeeping+0x234>)
   83084:	781b      	ldrb	r3, [r3, #0]
   83086:	429a      	cmp	r2, r3
   83088:	d11c      	bne.n	830c4 <store_housekeeping+0x144>
				{
					current_hk[i] = (uint8_t)(new_hk_msg_low & 0x000000FF);
   8308a:	4b4d      	ldr	r3, [pc, #308]	; (831c0 <store_housekeeping+0x240>)
   8308c:	781b      	ldrb	r3, [r3, #0]
   8308e:	4a53      	ldr	r2, [pc, #332]	; (831dc <store_housekeeping+0x25c>)
   83090:	6812      	ldr	r2, [r2, #0]
   83092:	b2d1      	uxtb	r1, r2
   83094:	4a4c      	ldr	r2, [pc, #304]	; (831c8 <store_housekeeping+0x248>)
   83096:	54d1      	strb	r1, [r2, r3]
					current_hk[i + 1] = (uint8_t)((new_hk_msg_low & 0x0000FF00) >> 8);
   83098:	4b49      	ldr	r3, [pc, #292]	; (831c0 <store_housekeeping+0x240>)
   8309a:	781b      	ldrb	r3, [r3, #0]
   8309c:	3301      	adds	r3, #1
   8309e:	4a4f      	ldr	r2, [pc, #316]	; (831dc <store_housekeeping+0x25c>)
   830a0:	6812      	ldr	r2, [r2, #0]
   830a2:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
   830a6:	0a12      	lsrs	r2, r2, #8
   830a8:	b2d1      	uxtb	r1, r2
   830aa:	4a47      	ldr	r2, [pc, #284]	; (831c8 <store_housekeeping+0x248>)
   830ac:	54d1      	strb	r1, [r2, r3]
					hk_updated[i] = 1;
   830ae:	4b44      	ldr	r3, [pc, #272]	; (831c0 <store_housekeeping+0x240>)
   830b0:	781b      	ldrb	r3, [r3, #0]
   830b2:	4a44      	ldr	r2, [pc, #272]	; (831c4 <store_housekeeping+0x244>)
   830b4:	2101      	movs	r1, #1
   830b6:	54d1      	strb	r1, [r2, r3]
					hk_updated[i + 1] = 1;
   830b8:	4b41      	ldr	r3, [pc, #260]	; (831c0 <store_housekeeping+0x240>)
   830ba:	781b      	ldrb	r3, [r3, #0]
   830bc:	3301      	adds	r3, #1
   830be:	4a41      	ldr	r2, [pc, #260]	; (831c4 <store_housekeeping+0x244>)
   830c0:	2101      	movs	r1, #1
   830c2:	54d1      	strb	r1, [r2, r3]
	{
		if(read_can_hk(&new_hk_msg_high, &new_hk_msg_low, 1234) == 1)
		{
			parameter_count--;
			parameter_name = (new_hk_msg_high & 0x00000FF);	// Name of the parameter for housekeeping (either sensor or variable).
			for(i = 79; i < 79 + num_parameters * 2; i+=2)					// ALTERED FOR CSDC (i = 0 before)
   830c4:	4b3e      	ldr	r3, [pc, #248]	; (831c0 <store_housekeeping+0x240>)
   830c6:	781b      	ldrb	r3, [r3, #0]
   830c8:	3302      	adds	r3, #2
   830ca:	b2da      	uxtb	r2, r3
   830cc:	4b3c      	ldr	r3, [pc, #240]	; (831c0 <store_housekeeping+0x240>)
   830ce:	701a      	strb	r2, [r3, #0]
   830d0:	4b3b      	ldr	r3, [pc, #236]	; (831c0 <store_housekeeping+0x240>)
   830d2:	781b      	ldrb	r3, [r3, #0]
   830d4:	461a      	mov	r2, r3
   830d6:	4b36      	ldr	r3, [pc, #216]	; (831b0 <store_housekeeping+0x230>)
   830d8:	781b      	ldrb	r3, [r3, #0]
   830da:	005b      	lsls	r3, r3, #1
   830dc:	334f      	adds	r3, #79	; 0x4f
   830de:	429a      	cmp	r2, r3
   830e0:	dbcb      	blt.n	8307a <store_housekeeping+0xfa>
					hk_updated[i] = 1;
					hk_updated[i + 1] = 1;
				}
			}			
		}
		taskYIELD();		// Allows for more messages to come in.
   830e2:	4b40      	ldr	r3, [pc, #256]	; (831e4 <store_housekeeping+0x264>)
   830e4:	4798      	blx	r3
	hk_updated[82] = 1;
	hk_updated[81] = 1;
	hk_updated[80] = 1;
	hk_updated[79] = 1;
	
	while(parameter_count && timeout--)
   830e6:	7bfb      	ldrb	r3, [r7, #15]
   830e8:	2b00      	cmp	r3, #0
   830ea:	d004      	beq.n	830f6 <store_housekeeping+0x176>
   830ec:	68bb      	ldr	r3, [r7, #8]
   830ee:	1e5a      	subs	r2, r3, #1
   830f0:	60ba      	str	r2, [r7, #8]
   830f2:	2b00      	cmp	r3, #0
   830f4:	d1ac      	bne.n	83050 <store_housekeeping+0xd0>
			}			
		}
		taskYIELD();		// Allows for more messages to come in.
	}
	
	for(i = 79; i < 79 + num_parameters * 2; i+=2)							// ALTERED FOR CSDC (i = 0 before)
   830f6:	4b32      	ldr	r3, [pc, #200]	; (831c0 <store_housekeeping+0x240>)
   830f8:	224f      	movs	r2, #79	; 0x4f
   830fa:	701a      	strb	r2, [r3, #0]
   830fc:	e044      	b.n	83188 <store_housekeeping+0x208>
	{
		if(!hk_updated[i])
   830fe:	4b30      	ldr	r3, [pc, #192]	; (831c0 <store_housekeeping+0x240>)
   83100:	781b      	ldrb	r3, [r3, #0]
   83102:	4a30      	ldr	r2, [pc, #192]	; (831c4 <store_housekeeping+0x244>)
   83104:	5cd3      	ldrb	r3, [r2, r3]
   83106:	2b00      	cmp	r3, #0
   83108:	d138      	bne.n	8317c <store_housekeeping+0x1fc>
		{//failed updates are requested 3 times. If they fail, error is reported
			
			req_data_result = (int)request_sensor_data(HK_TASK_ID,get_ssm_id(current_hk_definition[i]),current_hk_definition[i],status);
   8310a:	4b2d      	ldr	r3, [pc, #180]	; (831c0 <store_housekeeping+0x240>)
   8310c:	781b      	ldrb	r3, [r3, #0]
   8310e:	4a27      	ldr	r2, [pc, #156]	; (831ac <store_housekeeping+0x22c>)
   83110:	5cd3      	ldrb	r3, [r2, r3]
   83112:	4618      	mov	r0, r3
   83114:	4b34      	ldr	r3, [pc, #208]	; (831e8 <store_housekeeping+0x268>)
   83116:	4798      	blx	r3
   83118:	4603      	mov	r3, r0
   8311a:	461a      	mov	r2, r3
   8311c:	4b28      	ldr	r3, [pc, #160]	; (831c0 <store_housekeeping+0x240>)
   8311e:	781b      	ldrb	r3, [r3, #0]
   83120:	4922      	ldr	r1, [pc, #136]	; (831ac <store_housekeeping+0x22c>)
   83122:	5ccb      	ldrb	r3, [r1, r3]
   83124:	2004      	movs	r0, #4
   83126:	4611      	mov	r1, r2
   83128:	461a      	mov	r2, r3
   8312a:	687b      	ldr	r3, [r7, #4]
   8312c:	4c2f      	ldr	r4, [pc, #188]	; (831ec <store_housekeeping+0x26c>)
   8312e:	47a0      	blx	r4
   83130:	4603      	mov	r3, r0
   83132:	461a      	mov	r2, r3
   83134:	4b20      	ldr	r3, [pc, #128]	; (831b8 <store_housekeeping+0x238>)
   83136:	601a      	str	r2, [r3, #0]
			//while (attempts < 3 && req_data_result == -1){
				//attempts++;
				//req_data_result = (int)request_sensor_data(HK_TASK_ID,get_ssm_id(current_hk_definition[i]),current_hk_definition[i],status);
			//}
			
			if (*status == -1)
   83138:	687b      	ldr	r3, [r7, #4]
   8313a:	681b      	ldr	r3, [r3, #0]
   8313c:	f1b3 3fff 	cmp.w	r3, #4294967295
   83140:	d01c      	beq.n	8317c <store_housekeeping+0x1fc>
			{
				//errorREPORT(HK_TASK_ID,0,HK_COLLECT_ERROR, current_hk_definition[i]); 				//malfunctioning sensor is sent to erorREPORT
			}
			else {
				current_hk[i] = (uint8_t)(req_data_result & 0x000000FF);
   83142:	4b1f      	ldr	r3, [pc, #124]	; (831c0 <store_housekeeping+0x240>)
   83144:	781b      	ldrb	r3, [r3, #0]
   83146:	4a1c      	ldr	r2, [pc, #112]	; (831b8 <store_housekeeping+0x238>)
   83148:	6812      	ldr	r2, [r2, #0]
   8314a:	b2d1      	uxtb	r1, r2
   8314c:	4a1e      	ldr	r2, [pc, #120]	; (831c8 <store_housekeeping+0x248>)
   8314e:	54d1      	strb	r1, [r2, r3]
				current_hk[i + 1] = (uint8_t)((req_data_result & 0x0000FF00) >> 8);
   83150:	4b1b      	ldr	r3, [pc, #108]	; (831c0 <store_housekeeping+0x240>)
   83152:	781b      	ldrb	r3, [r3, #0]
   83154:	3301      	adds	r3, #1
   83156:	4a18      	ldr	r2, [pc, #96]	; (831b8 <store_housekeeping+0x238>)
   83158:	6812      	ldr	r2, [r2, #0]
   8315a:	f402 427f 	and.w	r2, r2, #65280	; 0xff00
   8315e:	1212      	asrs	r2, r2, #8
   83160:	b2d1      	uxtb	r1, r2
   83162:	4a19      	ldr	r2, [pc, #100]	; (831c8 <store_housekeeping+0x248>)
   83164:	54d1      	strb	r1, [r2, r3]
				hk_updated[i] = 1;
   83166:	4b16      	ldr	r3, [pc, #88]	; (831c0 <store_housekeeping+0x240>)
   83168:	781b      	ldrb	r3, [r3, #0]
   8316a:	4a16      	ldr	r2, [pc, #88]	; (831c4 <store_housekeeping+0x244>)
   8316c:	2101      	movs	r1, #1
   8316e:	54d1      	strb	r1, [r2, r3]
				hk_updated[i + 1] = 1;
   83170:	4b13      	ldr	r3, [pc, #76]	; (831c0 <store_housekeeping+0x240>)
   83172:	781b      	ldrb	r3, [r3, #0]
   83174:	3301      	adds	r3, #1
   83176:	4a13      	ldr	r2, [pc, #76]	; (831c4 <store_housekeeping+0x244>)
   83178:	2101      	movs	r1, #1
   8317a:	54d1      	strb	r1, [r2, r3]
			}			
		}
		taskYIELD();		// Allows for more messages to come in.
	}
	
	for(i = 79; i < 79 + num_parameters * 2; i+=2)							// ALTERED FOR CSDC (i = 0 before)
   8317c:	4b10      	ldr	r3, [pc, #64]	; (831c0 <store_housekeeping+0x240>)
   8317e:	781b      	ldrb	r3, [r3, #0]
   83180:	3302      	adds	r3, #2
   83182:	b2da      	uxtb	r2, r3
   83184:	4b0e      	ldr	r3, [pc, #56]	; (831c0 <store_housekeeping+0x240>)
   83186:	701a      	strb	r2, [r3, #0]
   83188:	4b0d      	ldr	r3, [pc, #52]	; (831c0 <store_housekeeping+0x240>)
   8318a:	781b      	ldrb	r3, [r3, #0]
   8318c:	461a      	mov	r2, r3
   8318e:	4b08      	ldr	r3, [pc, #32]	; (831b0 <store_housekeeping+0x230>)
   83190:	781b      	ldrb	r3, [r3, #0]
   83192:	005b      	lsls	r3, r3, #1
   83194:	334f      	adds	r3, #79	; 0x4f
   83196:	429a      	cmp	r2, r3
   83198:	dbb1      	blt.n	830fe <store_housekeeping+0x17e>
		}
	}
	/* Store the new housekeeping in SPI memory */
	//store_hk_in_spimem();				// Removed for CSDC
	
	current_hk_fullf = 1;
   8319a:	4b08      	ldr	r3, [pc, #32]	; (831bc <store_housekeeping+0x23c>)
   8319c:	2201      	movs	r2, #1
   8319e:	701a      	strb	r2, [r3, #0]
	return 1;
   831a0:	2301      	movs	r3, #1
}
   831a2:	4618      	mov	r0, r3
   831a4:	3714      	adds	r7, #20
   831a6:	46bd      	mov	sp, r7
   831a8:	bd90      	pop	{r4, r7, pc}
   831aa:	bf00      	nop
   831ac:	20070b14 	.word	0x20070b14
   831b0:	20070bbe 	.word	0x20070bbe
   831b4:	20070bbf 	.word	0x20070bbf
   831b8:	20070bb4 	.word	0x20070bb4
   831bc:	20070bac 	.word	0x20070bac
   831c0:	20070bb8 	.word	0x20070bb8
   831c4:	20070a88 	.word	0x20070a88
   831c8:	20070850 	.word	0x20070850
   831cc:	2007b4ec 	.word	0x2007b4ec
   831d0:	2007d584 	.word	0x2007d584
   831d4:	2007b108 	.word	0x2007b108
   831d8:	20070ba4 	.word	0x20070ba4
   831dc:	20070ba8 	.word	0x20070ba8
   831e0:	00089489 	.word	0x00089489
   831e4:	0008645d 	.word	0x0008645d
   831e8:	000831f1 	.word	0x000831f1
   831ec:	00089c9d 	.word	0x00089c9d

000831f0 <get_ssm_id>:

//Returns the proper ssm_id for a given sensor/variable
uint8_t get_ssm_id(uint8_t sensor_name)
{
   831f0:	b480      	push	{r7}
   831f2:	b083      	sub	sp, #12
   831f4:	af00      	add	r7, sp, #0
   831f6:	4603      	mov	r3, r0
   831f8:	71fb      	strb	r3, [r7, #7]
	//for sensors://
	if ((sensor_name>=0x01 && sensor_name <=0x11)||(sensor_name == 0xFF) || (sensor_name == 0xFC) || (sensor_name == 0xFE))
   831fa:	79fb      	ldrb	r3, [r7, #7]
   831fc:	2b00      	cmp	r3, #0
   831fe:	d002      	beq.n	83206 <get_ssm_id+0x16>
   83200:	79fb      	ldrb	r3, [r7, #7]
   83202:	2b11      	cmp	r3, #17
   83204:	d908      	bls.n	83218 <get_ssm_id+0x28>
   83206:	79fb      	ldrb	r3, [r7, #7]
   83208:	2bff      	cmp	r3, #255	; 0xff
   8320a:	d005      	beq.n	83218 <get_ssm_id+0x28>
   8320c:	79fb      	ldrb	r3, [r7, #7]
   8320e:	2bfc      	cmp	r3, #252	; 0xfc
   83210:	d002      	beq.n	83218 <get_ssm_id+0x28>
   83212:	79fb      	ldrb	r3, [r7, #7]
   83214:	2bfe      	cmp	r3, #254	; 0xfe
   83216:	d101      	bne.n	8321c <get_ssm_id+0x2c>
		return EPS_ID;
   83218:	2301      	movs	r3, #1
   8321a:	e080      	b.n	8331e <get_ssm_id+0x12e>
	if ((sensor_name == 0x12) || (sensor_name == 0xFD))
   8321c:	79fb      	ldrb	r3, [r7, #7]
   8321e:	2b12      	cmp	r3, #18
   83220:	d002      	beq.n	83228 <get_ssm_id+0x38>
   83222:	79fb      	ldrb	r3, [r7, #7]
   83224:	2bfd      	cmp	r3, #253	; 0xfd
   83226:	d101      	bne.n	8322c <get_ssm_id+0x3c>
		return COMS_ID;
   83228:	2300      	movs	r3, #0
   8322a:	e078      	b.n	8331e <get_ssm_id+0x12e>
	if ((sensor_name == 0x13) || (sensor_name == 0xFA) || (sensor_name>=0xF2 && sensor_name <=0xF8))
   8322c:	79fb      	ldrb	r3, [r7, #7]
   8322e:	2b13      	cmp	r3, #19
   83230:	d008      	beq.n	83244 <get_ssm_id+0x54>
   83232:	79fb      	ldrb	r3, [r7, #7]
   83234:	2bfa      	cmp	r3, #250	; 0xfa
   83236:	d005      	beq.n	83244 <get_ssm_id+0x54>
   83238:	79fb      	ldrb	r3, [r7, #7]
   8323a:	2bf1      	cmp	r3, #241	; 0xf1
   8323c:	d904      	bls.n	83248 <get_ssm_id+0x58>
   8323e:	79fb      	ldrb	r3, [r7, #7]
   83240:	2bf8      	cmp	r3, #248	; 0xf8
   83242:	d801      	bhi.n	83248 <get_ssm_id+0x58>
		return OBC_ID; //not sure if this is right
   83244:	2303      	movs	r3, #3
   83246:	e06a      	b.n	8331e <get_ssm_id+0x12e>
	if ((sensor_name>0x13 && sensor_name <= 0x63) || (sensor_name == 0xFB) || (sensor_name == 0xF9))
   83248:	79fb      	ldrb	r3, [r7, #7]
   8324a:	2b13      	cmp	r3, #19
   8324c:	d902      	bls.n	83254 <get_ssm_id+0x64>
   8324e:	79fb      	ldrb	r3, [r7, #7]
   83250:	2b63      	cmp	r3, #99	; 0x63
   83252:	d905      	bls.n	83260 <get_ssm_id+0x70>
   83254:	79fb      	ldrb	r3, [r7, #7]
   83256:	2bfb      	cmp	r3, #251	; 0xfb
   83258:	d002      	beq.n	83260 <get_ssm_id+0x70>
   8325a:	79fb      	ldrb	r3, [r7, #7]
   8325c:	2bf9      	cmp	r3, #249	; 0xf9
   8325e:	d101      	bne.n	83264 <get_ssm_id+0x74>
		return PAY_ID;
   83260:	2302      	movs	r3, #2
   83262:	e05c      	b.n	8331e <get_ssm_id+0x12e>
	//for global variables:
	if ((sensor_name == MPPTX) || (sensor_name == MPPTY) || (sensor_name == EPS_MODE) || (sensor_name == EPS_FDIR_SIGNAL) || 
   83264:	79fb      	ldrb	r3, [r7, #7]
   83266:	2bff      	cmp	r3, #255	; 0xff
   83268:	d01d      	beq.n	832a6 <get_ssm_id+0xb6>
   8326a:	79fb      	ldrb	r3, [r7, #7]
   8326c:	2bfe      	cmp	r3, #254	; 0xfe
   8326e:	d01a      	beq.n	832a6 <get_ssm_id+0xb6>
   83270:	79fb      	ldrb	r3, [r7, #7]
   83272:	2bfc      	cmp	r3, #252	; 0xfc
   83274:	d017      	beq.n	832a6 <get_ssm_id+0xb6>
   83276:	79fb      	ldrb	r3, [r7, #7]
   83278:	2bea      	cmp	r3, #234	; 0xea
   8327a:	d014      	beq.n	832a6 <get_ssm_id+0xb6>
   8327c:	79fb      	ldrb	r3, [r7, #7]
   8327e:	2bf0      	cmp	r3, #240	; 0xf0
   83280:	d011      	beq.n	832a6 <get_ssm_id+0xb6>
		(sensor_name == BALANCE_H) || (sensor_name == BALANCE_L) || (sensor_name == BATT_HEAT) || (sensor_name == EPS_BAL_INTV)
   83282:	79fb      	ldrb	r3, [r7, #7]
   83284:	2bf1      	cmp	r3, #241	; 0xf1
   83286:	d00e      	beq.n	832a6 <get_ssm_id+0xb6>
   83288:	79fb      	ldrb	r3, [r7, #7]
   8328a:	2be8      	cmp	r3, #232	; 0xe8
   8328c:	d00b      	beq.n	832a6 <get_ssm_id+0xb6>
   8328e:	79fb      	ldrb	r3, [r7, #7]
   83290:	2be7      	cmp	r3, #231	; 0xe7
   83292:	d008      	beq.n	832a6 <get_ssm_id+0xb6>
		 || (sensor_name == EPS_HEAT_INTV) || (sensor_name == EPS_TRGT_TMP) || (sensor_name == EPS_TEMP_INTV))
   83294:	79fb      	ldrb	r3, [r7, #7]
   83296:	2be6      	cmp	r3, #230	; 0xe6
   83298:	d005      	beq.n	832a6 <get_ssm_id+0xb6>
   8329a:	79fb      	ldrb	r3, [r7, #7]
   8329c:	2be5      	cmp	r3, #229	; 0xe5
   8329e:	d002      	beq.n	832a6 <get_ssm_id+0xb6>
   832a0:	79fb      	ldrb	r3, [r7, #7]
   832a2:	2be4      	cmp	r3, #228	; 0xe4
   832a4:	d101      	bne.n	832aa <get_ssm_id+0xba>
		return EPS_ID;
   832a6:	2301      	movs	r3, #1
   832a8:	e039      	b.n	8331e <get_ssm_id+0x12e>
	if ((sensor_name == COMS_MODE) || (sensor_name == SSM_CTT) || (sensor_name == SSM_OGT) || (sensor_name == COMS_FDIR_SIGNAL))
   832aa:	79fb      	ldrb	r3, [r7, #7]
   832ac:	2bfd      	cmp	r3, #253	; 0xfd
   832ae:	d008      	beq.n	832c2 <get_ssm_id+0xd2>
   832b0:	79fb      	ldrb	r3, [r7, #7]
   832b2:	2bef      	cmp	r3, #239	; 0xef
   832b4:	d005      	beq.n	832c2 <get_ssm_id+0xd2>
   832b6:	79fb      	ldrb	r3, [r7, #7]
   832b8:	2bee      	cmp	r3, #238	; 0xee
   832ba:	d002      	beq.n	832c2 <get_ssm_id+0xd2>
   832bc:	79fb      	ldrb	r3, [r7, #7]
   832be:	2beb      	cmp	r3, #235	; 0xeb
   832c0:	d101      	bne.n	832c6 <get_ssm_id+0xd6>
		return COMS_ID;
   832c2:	2300      	movs	r3, #0
   832c4:	e02b      	b.n	8331e <get_ssm_id+0x12e>
	if ((sensor_name == PAY_MODE) || (sensor_name == PAY_STATE) || (sensor_name == PAY_FDIR_SIGNAL))
   832c6:	79fb      	ldrb	r3, [r7, #7]
   832c8:	2bfb      	cmp	r3, #251	; 0xfb
   832ca:	d005      	beq.n	832d8 <get_ssm_id+0xe8>
   832cc:	79fb      	ldrb	r3, [r7, #7]
   832ce:	2bf9      	cmp	r3, #249	; 0xf9
   832d0:	d002      	beq.n	832d8 <get_ssm_id+0xe8>
   832d2:	79fb      	ldrb	r3, [r7, #7]
   832d4:	2be9      	cmp	r3, #233	; 0xe9
   832d6:	d101      	bne.n	832dc <get_ssm_id+0xec>
		return PAY_ID;
   832d8:	2302      	movs	r3, #2
   832da:	e020      	b.n	8331e <get_ssm_id+0x12e>
	if ((sensor_name == OBC_MODE) || (sensor_name == ABS_TIME_D) || (sensor_name == ABS_TIME_H) || (sensor_name == ABS_TIME_M) || 
   832dc:	79fb      	ldrb	r3, [r7, #7]
   832de:	2bfa      	cmp	r3, #250	; 0xfa
   832e0:	d01a      	beq.n	83318 <get_ssm_id+0x128>
   832e2:	79fb      	ldrb	r3, [r7, #7]
   832e4:	2bf8      	cmp	r3, #248	; 0xf8
   832e6:	d017      	beq.n	83318 <get_ssm_id+0x128>
   832e8:	79fb      	ldrb	r3, [r7, #7]
   832ea:	2bf7      	cmp	r3, #247	; 0xf7
   832ec:	d014      	beq.n	83318 <get_ssm_id+0x128>
   832ee:	79fb      	ldrb	r3, [r7, #7]
   832f0:	2bf6      	cmp	r3, #246	; 0xf6
   832f2:	d011      	beq.n	83318 <get_ssm_id+0x128>
   832f4:	79fb      	ldrb	r3, [r7, #7]
   832f6:	2bf5      	cmp	r3, #245	; 0xf5
   832f8:	d00e      	beq.n	83318 <get_ssm_id+0x128>
		(sensor_name == ABS_TIME_S) || (sensor_name == SPI_CHIP_1) || (sensor_name == SPI_CHIP_2) || (sensor_name == SPI_CHIP_3) || 
   832fa:	79fb      	ldrb	r3, [r7, #7]
   832fc:	2bf4      	cmp	r3, #244	; 0xf4
   832fe:	d00b      	beq.n	83318 <get_ssm_id+0x128>
   83300:	79fb      	ldrb	r3, [r7, #7]
   83302:	2bf3      	cmp	r3, #243	; 0xf3
   83304:	d008      	beq.n	83318 <get_ssm_id+0x128>
   83306:	79fb      	ldrb	r3, [r7, #7]
   83308:	2bf2      	cmp	r3, #242	; 0xf2
   8330a:	d005      	beq.n	83318 <get_ssm_id+0x128>
   8330c:	79fb      	ldrb	r3, [r7, #7]
   8330e:	2bed      	cmp	r3, #237	; 0xed
   83310:	d002      	beq.n	83318 <get_ssm_id+0x128>
		(sensor_name == OBC_CTT) || (sensor_name == OBC_OGT))
   83312:	79fb      	ldrb	r3, [r7, #7]
   83314:	2bec      	cmp	r3, #236	; 0xec
   83316:	d101      	bne.n	8331c <get_ssm_id+0x12c>
		return OBC_ID;
   83318:	2303      	movs	r3, #3
   8331a:	e000      	b.n	8331e <get_ssm_id+0x12e>
	//assume the worst:
	return OBC_ID;
   8331c:	2303      	movs	r3, #3
	
}
   8331e:	4618      	mov	r0, r3
   83320:	370c      	adds	r7, #12
   83322:	46bd      	mov	sp, r7
   83324:	f85d 7b04 	ldr.w	r7, [sp], #4
   83328:	4770      	bx	lr
   8332a:	bf00      	nop

0008332c <setup_default_definition>:
/* SETUP_DEFAULT_DEFINITION												*/
/* @Purpose: This function will set the values stored in the default	*/
/* housekeeping definition and will also set it as the current hk def	*/
/************************************************************************/
static void setup_default_definition(void)
{
   8332c:	b480      	push	{r7}
   8332e:	af00      	add	r7, sp, #0
	for(i = 0; i < DATA_LENGTH; i++)
   83330:	4b76      	ldr	r3, [pc, #472]	; (8350c <setup_default_definition+0x1e0>)
   83332:	2200      	movs	r2, #0
   83334:	701a      	strb	r2, [r3, #0]
   83336:	e00a      	b.n	8334e <setup_default_definition+0x22>
	{
		hk_definition0[i] = 0;
   83338:	4b74      	ldr	r3, [pc, #464]	; (8350c <setup_default_definition+0x1e0>)
   8333a:	781b      	ldrb	r3, [r3, #0]
   8333c:	4a74      	ldr	r2, [pc, #464]	; (83510 <setup_default_definition+0x1e4>)
   8333e:	2100      	movs	r1, #0
   83340:	54d1      	strb	r1, [r2, r3]
/* @Purpose: This function will set the values stored in the default	*/
/* housekeeping definition and will also set it as the current hk def	*/
/************************************************************************/
static void setup_default_definition(void)
{
	for(i = 0; i < DATA_LENGTH; i++)
   83342:	4b72      	ldr	r3, [pc, #456]	; (8350c <setup_default_definition+0x1e0>)
   83344:	781b      	ldrb	r3, [r3, #0]
   83346:	3301      	adds	r3, #1
   83348:	b2da      	uxtb	r2, r3
   8334a:	4b70      	ldr	r3, [pc, #448]	; (8350c <setup_default_definition+0x1e0>)
   8334c:	701a      	strb	r2, [r3, #0]
   8334e:	4b6f      	ldr	r3, [pc, #444]	; (8350c <setup_default_definition+0x1e0>)
   83350:	781b      	ldrb	r3, [r3, #0]
   83352:	2b88      	cmp	r3, #136	; 0x88
   83354:	d9f0      	bls.n	83338 <setup_default_definition+0xc>
	//hk_definition0[1] = SPI_CHIP_3;
	//hk_definition0[0] = SPI_CHIP_3;
	
	/* The definition below is meant to be used in the CSDC environmental testing */
	
	hk_definition0[131] = 0;							// sID = 0
   83356:	4b6e      	ldr	r3, [pc, #440]	; (83510 <setup_default_definition+0x1e4>)
   83358:	2200      	movs	r2, #0
   8335a:	f883 2083 	strb.w	r2, [r3, #131]	; 0x83
	hk_definition0[130] = collection_interval0;			// Collection interval = 30 min
   8335e:	4b6d      	ldr	r3, [pc, #436]	; (83514 <setup_default_definition+0x1e8>)
   83360:	781a      	ldrb	r2, [r3, #0]
   83362:	4b6b      	ldr	r3, [pc, #428]	; (83510 <setup_default_definition+0x1e4>)
   83364:	f883 2082 	strb.w	r2, [r3, #130]	; 0x82
	hk_definition0[129] = 25;							// Number of parameters (2B each)
   83368:	4b69      	ldr	r3, [pc, #420]	; (83510 <setup_default_definition+0x1e4>)
   8336a:	2219      	movs	r2, #25
   8336c:	f883 2081 	strb.w	r2, [r3, #129]	; 0x81
	hk_definition0[128] = PANELX_V;
   83370:	4b67      	ldr	r3, [pc, #412]	; (83510 <setup_default_definition+0x1e4>)
   83372:	2201      	movs	r2, #1
   83374:	f883 2080 	strb.w	r2, [r3, #128]	; 0x80
	hk_definition0[127] = PANELX_V;
   83378:	4b65      	ldr	r3, [pc, #404]	; (83510 <setup_default_definition+0x1e4>)
   8337a:	2201      	movs	r2, #1
   8337c:	f883 207f 	strb.w	r2, [r3, #127]	; 0x7f
	hk_definition0[126] = PANELX_I;
   83380:	4b63      	ldr	r3, [pc, #396]	; (83510 <setup_default_definition+0x1e4>)
   83382:	2202      	movs	r2, #2
   83384:	f883 207e 	strb.w	r2, [r3, #126]	; 0x7e
	hk_definition0[125] = PANELX_I;
   83388:	4b61      	ldr	r3, [pc, #388]	; (83510 <setup_default_definition+0x1e4>)
   8338a:	2202      	movs	r2, #2
   8338c:	f883 207d 	strb.w	r2, [r3, #125]	; 0x7d
	hk_definition0[124] = PANELY_V;
   83390:	4b5f      	ldr	r3, [pc, #380]	; (83510 <setup_default_definition+0x1e4>)
   83392:	2203      	movs	r2, #3
   83394:	f883 207c 	strb.w	r2, [r3, #124]	; 0x7c
	hk_definition0[123] = PANELY_V;
   83398:	4b5d      	ldr	r3, [pc, #372]	; (83510 <setup_default_definition+0x1e4>)
   8339a:	2203      	movs	r2, #3
   8339c:	f883 207b 	strb.w	r2, [r3, #123]	; 0x7b
	hk_definition0[122] = PANELY_I;
   833a0:	4b5b      	ldr	r3, [pc, #364]	; (83510 <setup_default_definition+0x1e4>)
   833a2:	2204      	movs	r2, #4
   833a4:	f883 207a 	strb.w	r2, [r3, #122]	; 0x7a
	hk_definition0[121] = PANELY_I;
   833a8:	4b59      	ldr	r3, [pc, #356]	; (83510 <setup_default_definition+0x1e4>)
   833aa:	2204      	movs	r2, #4
   833ac:	f883 2079 	strb.w	r2, [r3, #121]	; 0x79
	hk_definition0[120] = BATTM_V;
   833b0:	4b57      	ldr	r3, [pc, #348]	; (83510 <setup_default_definition+0x1e4>)
   833b2:	2205      	movs	r2, #5
   833b4:	f883 2078 	strb.w	r2, [r3, #120]	; 0x78
	hk_definition0[119] = BATTM_V;
   833b8:	4b55      	ldr	r3, [pc, #340]	; (83510 <setup_default_definition+0x1e4>)
   833ba:	2205      	movs	r2, #5
   833bc:	f883 2077 	strb.w	r2, [r3, #119]	; 0x77
	hk_definition0[118] = BATT_V;
   833c0:	4b53      	ldr	r3, [pc, #332]	; (83510 <setup_default_definition+0x1e4>)
   833c2:	2206      	movs	r2, #6
   833c4:	f883 2076 	strb.w	r2, [r3, #118]	; 0x76
	hk_definition0[117] = BATT_V;
   833c8:	4b51      	ldr	r3, [pc, #324]	; (83510 <setup_default_definition+0x1e4>)
   833ca:	2206      	movs	r2, #6
   833cc:	f883 2075 	strb.w	r2, [r3, #117]	; 0x75
	hk_definition0[116] = BATTIN_I;
   833d0:	4b4f      	ldr	r3, [pc, #316]	; (83510 <setup_default_definition+0x1e4>)
   833d2:	2207      	movs	r2, #7
   833d4:	f883 2074 	strb.w	r2, [r3, #116]	; 0x74
	hk_definition0[115] = BATTIN_I;
   833d8:	4b4d      	ldr	r3, [pc, #308]	; (83510 <setup_default_definition+0x1e4>)
   833da:	2207      	movs	r2, #7
   833dc:	f883 2073 	strb.w	r2, [r3, #115]	; 0x73
	hk_definition0[114] = BATTOUT_I;
   833e0:	4b4b      	ldr	r3, [pc, #300]	; (83510 <setup_default_definition+0x1e4>)
   833e2:	2208      	movs	r2, #8
   833e4:	f883 2072 	strb.w	r2, [r3, #114]	; 0x72
	hk_definition0[113] = BATTOUT_I;
   833e8:	4b49      	ldr	r3, [pc, #292]	; (83510 <setup_default_definition+0x1e4>)
   833ea:	2208      	movs	r2, #8
   833ec:	f883 2071 	strb.w	r2, [r3, #113]	; 0x71
	hk_definition0[112] = BATT_TEMP;
   833f0:	4b47      	ldr	r3, [pc, #284]	; (83510 <setup_default_definition+0x1e4>)
   833f2:	2209      	movs	r2, #9
   833f4:	f883 2070 	strb.w	r2, [r3, #112]	; 0x70
	hk_definition0[111] = BATT_TEMP;	//
   833f8:	4b45      	ldr	r3, [pc, #276]	; (83510 <setup_default_definition+0x1e4>)
   833fa:	2209      	movs	r2, #9
   833fc:	f883 206f 	strb.w	r2, [r3, #111]	; 0x6f
	hk_definition0[110] = EPS_TEMP;
   83400:	4b43      	ldr	r3, [pc, #268]	; (83510 <setup_default_definition+0x1e4>)
   83402:	220a      	movs	r2, #10
   83404:	f883 206e 	strb.w	r2, [r3, #110]	; 0x6e
	hk_definition0[109] = EPS_TEMP;	//
   83408:	4b41      	ldr	r3, [pc, #260]	; (83510 <setup_default_definition+0x1e4>)
   8340a:	220a      	movs	r2, #10
   8340c:	f883 206d 	strb.w	r2, [r3, #109]	; 0x6d
	hk_definition0[108] = COMS_V;
   83410:	4b3f      	ldr	r3, [pc, #252]	; (83510 <setup_default_definition+0x1e4>)
   83412:	220b      	movs	r2, #11
   83414:	f883 206c 	strb.w	r2, [r3, #108]	; 0x6c
	hk_definition0[107] = COMS_V;
   83418:	4b3d      	ldr	r3, [pc, #244]	; (83510 <setup_default_definition+0x1e4>)
   8341a:	220b      	movs	r2, #11
   8341c:	f883 206b 	strb.w	r2, [r3, #107]	; 0x6b
	hk_definition0[106] = COMS_I;
   83420:	4b3b      	ldr	r3, [pc, #236]	; (83510 <setup_default_definition+0x1e4>)
   83422:	220c      	movs	r2, #12
   83424:	f883 206a 	strb.w	r2, [r3, #106]	; 0x6a
	hk_definition0[105] = COMS_I;
   83428:	4b39      	ldr	r3, [pc, #228]	; (83510 <setup_default_definition+0x1e4>)
   8342a:	220c      	movs	r2, #12
   8342c:	f883 2069 	strb.w	r2, [r3, #105]	; 0x69
	hk_definition0[104] = PAY_V;
   83430:	4b37      	ldr	r3, [pc, #220]	; (83510 <setup_default_definition+0x1e4>)
   83432:	220d      	movs	r2, #13
   83434:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
	hk_definition0[103] = PAY_V;
   83438:	4b35      	ldr	r3, [pc, #212]	; (83510 <setup_default_definition+0x1e4>)
   8343a:	220d      	movs	r2, #13
   8343c:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
	hk_definition0[102] = PAY_I;
   83440:	4b33      	ldr	r3, [pc, #204]	; (83510 <setup_default_definition+0x1e4>)
   83442:	220e      	movs	r2, #14
   83444:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
	hk_definition0[101] = PAY_I;
   83448:	4b31      	ldr	r3, [pc, #196]	; (83510 <setup_default_definition+0x1e4>)
   8344a:	220e      	movs	r2, #14
   8344c:	f883 2065 	strb.w	r2, [r3, #101]	; 0x65
	hk_definition0[100] = OBC_V;
   83450:	4b2f      	ldr	r3, [pc, #188]	; (83510 <setup_default_definition+0x1e4>)
   83452:	220f      	movs	r2, #15
   83454:	f883 2064 	strb.w	r2, [r3, #100]	; 0x64
	hk_definition0[99] = OBC_V;
   83458:	4b2d      	ldr	r3, [pc, #180]	; (83510 <setup_default_definition+0x1e4>)
   8345a:	220f      	movs	r2, #15
   8345c:	f883 2063 	strb.w	r2, [r3, #99]	; 0x63
	hk_definition0[98] = OBC_I;
   83460:	4b2b      	ldr	r3, [pc, #172]	; (83510 <setup_default_definition+0x1e4>)
   83462:	2210      	movs	r2, #16
   83464:	f883 2062 	strb.w	r2, [r3, #98]	; 0x62
	hk_definition0[97] = OBC_I;
   83468:	4b29      	ldr	r3, [pc, #164]	; (83510 <setup_default_definition+0x1e4>)
   8346a:	2210      	movs	r2, #16
   8346c:	f883 2061 	strb.w	r2, [r3, #97]	; 0x61
	hk_definition0[96] = COMS_TEMP;	//
   83470:	4b27      	ldr	r3, [pc, #156]	; (83510 <setup_default_definition+0x1e4>)
   83472:	2212      	movs	r2, #18
   83474:	f883 2060 	strb.w	r2, [r3, #96]	; 0x60
	hk_definition0[95] = COMS_TEMP;
   83478:	4b25      	ldr	r3, [pc, #148]	; (83510 <setup_default_definition+0x1e4>)
   8347a:	2212      	movs	r2, #18
   8347c:	f883 205f 	strb.w	r2, [r3, #95]	; 0x5f
	hk_definition0[94] = OBC_TEMP;	//
   83480:	4b23      	ldr	r3, [pc, #140]	; (83510 <setup_default_definition+0x1e4>)
   83482:	2213      	movs	r2, #19
   83484:	f883 205e 	strb.w	r2, [r3, #94]	; 0x5e
	hk_definition0[93] = OBC_TEMP;
   83488:	4b21      	ldr	r3, [pc, #132]	; (83510 <setup_default_definition+0x1e4>)
   8348a:	2213      	movs	r2, #19
   8348c:	f883 205d 	strb.w	r2, [r3, #93]	; 0x5d
	hk_definition0[92] = PAY_TEMP0;
   83490:	4b1f      	ldr	r3, [pc, #124]	; (83510 <setup_default_definition+0x1e4>)
   83492:	2214      	movs	r2, #20
   83494:	f883 205c 	strb.w	r2, [r3, #92]	; 0x5c
	hk_definition0[91] = PAY_TEMP0;
   83498:	4b1d      	ldr	r3, [pc, #116]	; (83510 <setup_default_definition+0x1e4>)
   8349a:	2214      	movs	r2, #20
   8349c:	f883 205b 	strb.w	r2, [r3, #91]	; 0x5b
	hk_definition0[90] = PAY_HUM;
   834a0:	4b1b      	ldr	r3, [pc, #108]	; (83510 <setup_default_definition+0x1e4>)
   834a2:	2219      	movs	r2, #25
   834a4:	f883 205a 	strb.w	r2, [r3, #90]	; 0x5a
	hk_definition0[89] = PAY_HUM;
   834a8:	4b19      	ldr	r3, [pc, #100]	; (83510 <setup_default_definition+0x1e4>)
   834aa:	2219      	movs	r2, #25
   834ac:	f883 2059 	strb.w	r2, [r3, #89]	; 0x59
	hk_definition0[88] = PAY_PRESS;
   834b0:	4b17      	ldr	r3, [pc, #92]	; (83510 <setup_default_definition+0x1e4>)
   834b2:	221a      	movs	r2, #26
   834b4:	f883 2058 	strb.w	r2, [r3, #88]	; 0x58
	hk_definition0[87] = PAY_PRESS;
   834b8:	4b15      	ldr	r3, [pc, #84]	; (83510 <setup_default_definition+0x1e4>)
   834ba:	221a      	movs	r2, #26
   834bc:	f883 2057 	strb.w	r2, [r3, #87]	; 0x57
	hk_definition0[86] = PAY_ACCEL;
   834c0:	4b13      	ldr	r3, [pc, #76]	; (83510 <setup_default_definition+0x1e4>)
   834c2:	221b      	movs	r2, #27
   834c4:	f883 2056 	strb.w	r2, [r3, #86]	; 0x56
	hk_definition0[85] = PAY_ACCEL;
   834c8:	4b11      	ldr	r3, [pc, #68]	; (83510 <setup_default_definition+0x1e4>)
   834ca:	221b      	movs	r2, #27
   834cc:	f883 2055 	strb.w	r2, [r3, #85]	; 0x55
	hk_definition0[84] = ABS_TIME_D;
   834d0:	4b0f      	ldr	r3, [pc, #60]	; (83510 <setup_default_definition+0x1e4>)
   834d2:	22f8      	movs	r2, #248	; 0xf8
   834d4:	f883 2054 	strb.w	r2, [r3, #84]	; 0x54
	hk_definition0[83] = ABS_TIME_D;
   834d8:	4b0d      	ldr	r3, [pc, #52]	; (83510 <setup_default_definition+0x1e4>)
   834da:	22f8      	movs	r2, #248	; 0xf8
   834dc:	f883 2053 	strb.w	r2, [r3, #83]	; 0x53
	hk_definition0[82] = ABS_TIME_H;
   834e0:	4b0b      	ldr	r3, [pc, #44]	; (83510 <setup_default_definition+0x1e4>)
   834e2:	22f7      	movs	r2, #247	; 0xf7
   834e4:	f883 2052 	strb.w	r2, [r3, #82]	; 0x52
	hk_definition0[81] = ABS_TIME_H;
   834e8:	4b09      	ldr	r3, [pc, #36]	; (83510 <setup_default_definition+0x1e4>)
   834ea:	22f7      	movs	r2, #247	; 0xf7
   834ec:	f883 2051 	strb.w	r2, [r3, #81]	; 0x51
	hk_definition0[80] = ABS_TIME_M;
   834f0:	4b07      	ldr	r3, [pc, #28]	; (83510 <setup_default_definition+0x1e4>)
   834f2:	22f6      	movs	r2, #246	; 0xf6
   834f4:	f883 2050 	strb.w	r2, [r3, #80]	; 0x50
	hk_definition0[79] = ABS_TIME_M;
   834f8:	4b05      	ldr	r3, [pc, #20]	; (83510 <setup_default_definition+0x1e4>)
   834fa:	22f6      	movs	r2, #246	; 0xf6
   834fc:	f883 204f 	strb.w	r2, [r3, #79]	; 0x4f
	return;
   83500:	bf00      	nop
}
   83502:	46bd      	mov	sp, r7
   83504:	f85d 7b04 	ldr.w	r7, [sp], #4
   83508:	4770      	bx	lr
   8350a:	bf00      	nop
   8350c:	20070bb8 	.word	0x20070bb8
   83510:	20070970 	.word	0x20070970
   83514:	20070bae 	.word	0x20070bae

00083518 <set_definition>:
/* @Purpose: This function will change which definition is being used	*/
/* for creating housekeeping reports.									*/
/* @param: sID: 0 == default, 1 = alternate.							*/
/************************************************************************/
static void set_definition(uint8_t sID)
{
   83518:	b480      	push	{r7}
   8351a:	b083      	sub	sp, #12
   8351c:	af00      	add	r7, sp, #0
   8351e:	4603      	mov	r3, r0
   83520:	71fb      	strb	r3, [r7, #7]
	if(!sID)								// DEFAULT
   83522:	79fb      	ldrb	r3, [r7, #7]
   83524:	2b00      	cmp	r3, #0
   83526:	d121      	bne.n	8356c <set_definition+0x54>
	{
		for(i = 0; i < DATA_LENGTH; i++)
   83528:	4b26      	ldr	r3, [pc, #152]	; (835c4 <set_definition+0xac>)
   8352a:	2200      	movs	r2, #0
   8352c:	701a      	strb	r2, [r3, #0]
   8352e:	e00d      	b.n	8354c <set_definition+0x34>
		{
			current_hk_definition[i] = hk_definition0[i];		
   83530:	4b24      	ldr	r3, [pc, #144]	; (835c4 <set_definition+0xac>)
   83532:	781b      	ldrb	r3, [r3, #0]
   83534:	4a23      	ldr	r2, [pc, #140]	; (835c4 <set_definition+0xac>)
   83536:	7812      	ldrb	r2, [r2, #0]
   83538:	4923      	ldr	r1, [pc, #140]	; (835c8 <set_definition+0xb0>)
   8353a:	5c89      	ldrb	r1, [r1, r2]
   8353c:	4a23      	ldr	r2, [pc, #140]	; (835cc <set_definition+0xb4>)
   8353e:	54d1      	strb	r1, [r2, r3]
/************************************************************************/
static void set_definition(uint8_t sID)
{
	if(!sID)								// DEFAULT
	{
		for(i = 0; i < DATA_LENGTH; i++)
   83540:	4b20      	ldr	r3, [pc, #128]	; (835c4 <set_definition+0xac>)
   83542:	781b      	ldrb	r3, [r3, #0]
   83544:	3301      	adds	r3, #1
   83546:	b2da      	uxtb	r2, r3
   83548:	4b1e      	ldr	r3, [pc, #120]	; (835c4 <set_definition+0xac>)
   8354a:	701a      	strb	r2, [r3, #0]
   8354c:	4b1d      	ldr	r3, [pc, #116]	; (835c4 <set_definition+0xac>)
   8354e:	781b      	ldrb	r3, [r3, #0]
   83550:	2b88      	cmp	r3, #136	; 0x88
   83552:	d9ed      	bls.n	83530 <set_definition+0x18>
		{
			current_hk_definition[i] = hk_definition0[i];		
		}
		current_hk_definitionf = 0;
   83554:	4b1e      	ldr	r3, [pc, #120]	; (835d0 <set_definition+0xb8>)
   83556:	2200      	movs	r2, #0
   83558:	701a      	strb	r2, [r3, #0]
		xTimeToWait = collection_interval0 * 1000 * 60;
   8355a:	4b1e      	ldr	r3, [pc, #120]	; (835d4 <set_definition+0xbc>)
   8355c:	781b      	ldrb	r3, [r3, #0]
   8355e:	f64e 2260 	movw	r2, #60000	; 0xea60
   83562:	fb02 f303 	mul.w	r3, r2, r3
   83566:	461a      	mov	r2, r3
   83568:	4b1b      	ldr	r3, [pc, #108]	; (835d8 <set_definition+0xc0>)
   8356a:	601a      	str	r2, [r3, #0]
	}
	if(sID == 1)							// ALTERNATE
   8356c:	79fb      	ldrb	r3, [r7, #7]
   8356e:	2b01      	cmp	r3, #1
   83570:	d121      	bne.n	835b6 <set_definition+0x9e>
	{
		for(i = 0; i < DATA_LENGTH; i++)
   83572:	4b14      	ldr	r3, [pc, #80]	; (835c4 <set_definition+0xac>)
   83574:	2200      	movs	r2, #0
   83576:	701a      	strb	r2, [r3, #0]
   83578:	e00d      	b.n	83596 <set_definition+0x7e>
		{
			current_hk_definition[i] = hk_definition1[i];
   8357a:	4b12      	ldr	r3, [pc, #72]	; (835c4 <set_definition+0xac>)
   8357c:	781b      	ldrb	r3, [r3, #0]
   8357e:	4a11      	ldr	r2, [pc, #68]	; (835c4 <set_definition+0xac>)
   83580:	7812      	ldrb	r2, [r2, #0]
   83582:	4916      	ldr	r1, [pc, #88]	; (835dc <set_definition+0xc4>)
   83584:	5c89      	ldrb	r1, [r1, r2]
   83586:	4a11      	ldr	r2, [pc, #68]	; (835cc <set_definition+0xb4>)
   83588:	54d1      	strb	r1, [r2, r3]
		current_hk_definitionf = 0;
		xTimeToWait = collection_interval0 * 1000 * 60;
	}
	if(sID == 1)							// ALTERNATE
	{
		for(i = 0; i < DATA_LENGTH; i++)
   8358a:	4b0e      	ldr	r3, [pc, #56]	; (835c4 <set_definition+0xac>)
   8358c:	781b      	ldrb	r3, [r3, #0]
   8358e:	3301      	adds	r3, #1
   83590:	b2da      	uxtb	r2, r3
   83592:	4b0c      	ldr	r3, [pc, #48]	; (835c4 <set_definition+0xac>)
   83594:	701a      	strb	r2, [r3, #0]
   83596:	4b0b      	ldr	r3, [pc, #44]	; (835c4 <set_definition+0xac>)
   83598:	781b      	ldrb	r3, [r3, #0]
   8359a:	2b88      	cmp	r3, #136	; 0x88
   8359c:	d9ed      	bls.n	8357a <set_definition+0x62>
		{
			current_hk_definition[i] = hk_definition1[i];
		}
		current_hk_definitionf = 1;
   8359e:	4b0c      	ldr	r3, [pc, #48]	; (835d0 <set_definition+0xb8>)
   835a0:	2201      	movs	r2, #1
   835a2:	701a      	strb	r2, [r3, #0]
		xTimeToWait = collection_interval1 * 1000 * 60;
   835a4:	4b0e      	ldr	r3, [pc, #56]	; (835e0 <set_definition+0xc8>)
   835a6:	781b      	ldrb	r3, [r3, #0]
   835a8:	f64e 2260 	movw	r2, #60000	; 0xea60
   835ac:	fb02 f303 	mul.w	r3, r2, r3
   835b0:	461a      	mov	r2, r3
   835b2:	4b09      	ldr	r3, [pc, #36]	; (835d8 <set_definition+0xc0>)
   835b4:	601a      	str	r2, [r3, #0]
	}
	return;
   835b6:	bf00      	nop
}
   835b8:	370c      	adds	r7, #12
   835ba:	46bd      	mov	sp, r7
   835bc:	f85d 7b04 	ldr.w	r7, [sp], #4
   835c0:	4770      	bx	lr
   835c2:	bf00      	nop
   835c4:	20070bb8 	.word	0x20070bb8
   835c8:	20070970 	.word	0x20070970
   835cc:	20070b14 	.word	0x20070b14
   835d0:	20070ba0 	.word	0x20070ba0
   835d4:	20070bae 	.word	0x20070bae
   835d8:	20070bb0 	.word	0x20070bb0
   835dc:	200709fc 	.word	0x200709fc
   835e0:	20070baf 	.word	0x20070baf

000835e4 <send_hk_as_tm>:
/* @Purpose: This function will downlink all housekeeping to ground		*/
/* by sending 128B chunks to the OBC_PACKET_ROUTER, which in turn will	*/
/* attempt to downlink the telemetry to ground.							*/
/************************************************************************/
static void send_hk_as_tm(void)
{
   835e4:	b598      	push	{r3, r4, r7, lr}
   835e6:	af00      	add	r7, sp, #0
	clear_current_command();
   835e8:	4b12      	ldr	r3, [pc, #72]	; (83634 <send_hk_as_tm+0x50>)
   835ea:	4798      	blx	r3
	current_command[146] = HK_REPORT;
   835ec:	4b12      	ldr	r3, [pc, #72]	; (83638 <send_hk_as_tm+0x54>)
   835ee:	2219      	movs	r2, #25
   835f0:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
	for(i = 0; i < DATA_LENGTH; i++)
   835f4:	4b11      	ldr	r3, [pc, #68]	; (8363c <send_hk_as_tm+0x58>)
   835f6:	2200      	movs	r2, #0
   835f8:	701a      	strb	r2, [r3, #0]
   835fa:	e00d      	b.n	83618 <send_hk_as_tm+0x34>
	{
		current_command[i] = current_hk[i];
   835fc:	4b0f      	ldr	r3, [pc, #60]	; (8363c <send_hk_as_tm+0x58>)
   835fe:	781b      	ldrb	r3, [r3, #0]
   83600:	4a0e      	ldr	r2, [pc, #56]	; (8363c <send_hk_as_tm+0x58>)
   83602:	7812      	ldrb	r2, [r2, #0]
   83604:	490e      	ldr	r1, [pc, #56]	; (83640 <send_hk_as_tm+0x5c>)
   83606:	5c89      	ldrb	r1, [r1, r2]
   83608:	4a0b      	ldr	r2, [pc, #44]	; (83638 <send_hk_as_tm+0x54>)
   8360a:	54d1      	strb	r1, [r2, r3]
/************************************************************************/
static void send_hk_as_tm(void)
{
	clear_current_command();
	current_command[146] = HK_REPORT;
	for(i = 0; i < DATA_LENGTH; i++)
   8360c:	4b0b      	ldr	r3, [pc, #44]	; (8363c <send_hk_as_tm+0x58>)
   8360e:	781b      	ldrb	r3, [r3, #0]
   83610:	3301      	adds	r3, #1
   83612:	b2da      	uxtb	r2, r3
   83614:	4b09      	ldr	r3, [pc, #36]	; (8363c <send_hk_as_tm+0x58>)
   83616:	701a      	strb	r2, [r3, #0]
   83618:	4b08      	ldr	r3, [pc, #32]	; (8363c <send_hk_as_tm+0x58>)
   8361a:	781b      	ldrb	r3, [r3, #0]
   8361c:	2b88      	cmp	r3, #136	; 0x88
   8361e:	d9ed      	bls.n	835fc <send_hk_as_tm+0x18>
	{
		current_command[i] = current_hk[i];
	}
	xQueueSendToBack(hk_to_obc_fifo, current_command, (TickType_t)1);
   83620:	4b08      	ldr	r3, [pc, #32]	; (83644 <send_hk_as_tm+0x60>)
   83622:	681b      	ldr	r3, [r3, #0]
   83624:	4618      	mov	r0, r3
   83626:	4904      	ldr	r1, [pc, #16]	; (83638 <send_hk_as_tm+0x54>)
   83628:	2201      	movs	r2, #1
   8362a:	2300      	movs	r3, #0
   8362c:	4c06      	ldr	r4, [pc, #24]	; (83648 <send_hk_as_tm+0x64>)
   8362e:	47a0      	blx	r4
	return;
   83630:	bf00      	nop
}
   83632:	bd98      	pop	{r3, r4, r7, pc}
   83634:	00082ec5 	.word	0x00082ec5
   83638:	200708dc 	.word	0x200708dc
   8363c:	20070bb8 	.word	0x20070bb8
   83640:	20070850 	.word	0x20070850
   83644:	2007b38c 	.word	0x2007b38c
   83648:	00086b01 	.word	0x00086b01

0008364c <send_param_report>:
/* @Purpose: This function will downlink the current hk definition being*/
/* used to produce housekeeping reports.								*/
/* It does this by sending current hk def to OBC_PACKET_ROUTER.			*/
/************************************************************************/
static void send_param_report(void)
{
   8364c:	b598      	push	{r3, r4, r7, lr}
   8364e:	af00      	add	r7, sp, #0
	param_report_requiredf = 0;
   83650:	4b14      	ldr	r3, [pc, #80]	; (836a4 <send_param_report+0x58>)
   83652:	2200      	movs	r2, #0
   83654:	701a      	strb	r2, [r3, #0]
	clear_current_command();
   83656:	4b14      	ldr	r3, [pc, #80]	; (836a8 <send_param_report+0x5c>)
   83658:	4798      	blx	r3
	current_command[146] = HK_DEFINITON_REPORT;
   8365a:	4b14      	ldr	r3, [pc, #80]	; (836ac <send_param_report+0x60>)
   8365c:	220a      	movs	r2, #10
   8365e:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
	for(i = 0; i < DATA_LENGTH; i++)
   83662:	4b13      	ldr	r3, [pc, #76]	; (836b0 <send_param_report+0x64>)
   83664:	2200      	movs	r2, #0
   83666:	701a      	strb	r2, [r3, #0]
   83668:	e00d      	b.n	83686 <send_param_report+0x3a>
	{
		current_command[i] = current_hk_definition[i];
   8366a:	4b11      	ldr	r3, [pc, #68]	; (836b0 <send_param_report+0x64>)
   8366c:	781b      	ldrb	r3, [r3, #0]
   8366e:	4a10      	ldr	r2, [pc, #64]	; (836b0 <send_param_report+0x64>)
   83670:	7812      	ldrb	r2, [r2, #0]
   83672:	4910      	ldr	r1, [pc, #64]	; (836b4 <send_param_report+0x68>)
   83674:	5c89      	ldrb	r1, [r1, r2]
   83676:	4a0d      	ldr	r2, [pc, #52]	; (836ac <send_param_report+0x60>)
   83678:	54d1      	strb	r1, [r2, r3]
static void send_param_report(void)
{
	param_report_requiredf = 0;
	clear_current_command();
	current_command[146] = HK_DEFINITON_REPORT;
	for(i = 0; i < DATA_LENGTH; i++)
   8367a:	4b0d      	ldr	r3, [pc, #52]	; (836b0 <send_param_report+0x64>)
   8367c:	781b      	ldrb	r3, [r3, #0]
   8367e:	3301      	adds	r3, #1
   83680:	b2da      	uxtb	r2, r3
   83682:	4b0b      	ldr	r3, [pc, #44]	; (836b0 <send_param_report+0x64>)
   83684:	701a      	strb	r2, [r3, #0]
   83686:	4b0a      	ldr	r3, [pc, #40]	; (836b0 <send_param_report+0x64>)
   83688:	781b      	ldrb	r3, [r3, #0]
   8368a:	2b88      	cmp	r3, #136	; 0x88
   8368c:	d9ed      	bls.n	8366a <send_param_report+0x1e>
	{
		current_command[i] = current_hk_definition[i];
	}
	xQueueSendToBack(hk_to_obc_fifo, current_command, (TickType_t)1);		// FAILURE_RECOVERY if this doesn't return pdPASS
   8368e:	4b0a      	ldr	r3, [pc, #40]	; (836b8 <send_param_report+0x6c>)
   83690:	681b      	ldr	r3, [r3, #0]
   83692:	4618      	mov	r0, r3
   83694:	4905      	ldr	r1, [pc, #20]	; (836ac <send_param_report+0x60>)
   83696:	2201      	movs	r2, #1
   83698:	2300      	movs	r3, #0
   8369a:	4c08      	ldr	r4, [pc, #32]	; (836bc <send_param_report+0x70>)
   8369c:	47a0      	blx	r4
	return;
   8369e:	bf00      	nop
}
   836a0:	bd98      	pop	{r3, r4, r7, pc}
   836a2:	bf00      	nop
   836a4:	20070bad 	.word	0x20070bad
   836a8:	00082ec5 	.word	0x00082ec5
   836ac:	200708dc 	.word	0x200708dc
   836b0:	20070bb8 	.word	0x20070bb8
   836b4:	20070b14 	.word	0x20070b14
   836b8:	2007b38c 	.word	0x2007b38c
   836bc:	00086b01 	.word	0x00086b01

000836c0 <send_tc_execution_verify>:
/* @param: status: 0x01 = Success, 0xFF = failure.						*/
/* @param: packet_id: The first 2B of the PUS packet.					*/
/* @param: psc: the next 2B of the PUS packet.							*/
/************************************************************************/
static void send_tc_execution_verify(uint8_t status, uint16_t packet_id, uint16_t psc)
{
   836c0:	b590      	push	{r4, r7, lr}
   836c2:	b085      	sub	sp, #20
   836c4:	af02      	add	r7, sp, #8
   836c6:	4613      	mov	r3, r2
   836c8:	4602      	mov	r2, r0
   836ca:	71fa      	strb	r2, [r7, #7]
   836cc:	460a      	mov	r2, r1
   836ce:	80ba      	strh	r2, [r7, #4]
   836d0:	807b      	strh	r3, [r7, #2]
	clear_current_command();
   836d2:	4b1a      	ldr	r3, [pc, #104]	; (8373c <send_tc_execution_verify+0x7c>)
   836d4:	4798      	blx	r3
	current_command[146] = TASK_TO_OPR_TCV;		// Request a TC verification
   836d6:	4b1a      	ldr	r3, [pc, #104]	; (83740 <send_tc_execution_verify+0x80>)
   836d8:	22dd      	movs	r2, #221	; 0xdd
   836da:	f883 2092 	strb.w	r2, [r3, #146]	; 0x92
	current_command[145] = status;
   836de:	4b18      	ldr	r3, [pc, #96]	; (83740 <send_tc_execution_verify+0x80>)
   836e0:	79fa      	ldrb	r2, [r7, #7]
   836e2:	f883 2091 	strb.w	r2, [r3, #145]	; 0x91
	current_command[144] = HK_TASK_ID;			// APID of this task
   836e6:	4b16      	ldr	r3, [pc, #88]	; (83740 <send_tc_execution_verify+0x80>)
   836e8:	2204      	movs	r2, #4
   836ea:	f883 2090 	strb.w	r2, [r3, #144]	; 0x90
	current_command[140] = ((uint8_t)packet_id) >> 8;
   836ee:	88bb      	ldrh	r3, [r7, #4]
   836f0:	b2db      	uxtb	r3, r3
   836f2:	121b      	asrs	r3, r3, #8
   836f4:	b2da      	uxtb	r2, r3
   836f6:	4b12      	ldr	r3, [pc, #72]	; (83740 <send_tc_execution_verify+0x80>)
   836f8:	f883 208c 	strb.w	r2, [r3, #140]	; 0x8c
	current_command[139] = (uint8_t)packet_id;
   836fc:	88bb      	ldrh	r3, [r7, #4]
   836fe:	b2da      	uxtb	r2, r3
   83700:	4b0f      	ldr	r3, [pc, #60]	; (83740 <send_tc_execution_verify+0x80>)
   83702:	f883 208b 	strb.w	r2, [r3, #139]	; 0x8b
	current_command[138] = ((uint8_t)psc) >> 8;
   83706:	887b      	ldrh	r3, [r7, #2]
   83708:	b2db      	uxtb	r3, r3
   8370a:	121b      	asrs	r3, r3, #8
   8370c:	b2da      	uxtb	r2, r3
   8370e:	4b0c      	ldr	r3, [pc, #48]	; (83740 <send_tc_execution_verify+0x80>)
   83710:	f883 208a 	strb.w	r2, [r3, #138]	; 0x8a
	current_command[137] = (uint8_t)psc;
   83714:	887b      	ldrh	r3, [r7, #2]
   83716:	b2da      	uxtb	r2, r3
   83718:	4b09      	ldr	r3, [pc, #36]	; (83740 <send_tc_execution_verify+0x80>)
   8371a:	f883 2089 	strb.w	r2, [r3, #137]	; 0x89
	xQueueSendToBackTask(HK_TASK_ID, 1, hk_to_obc_fifo, current_command, (TickType_t)1);		// FAILURE_RECOVERY if this doesn't return pdPASS
   8371e:	4b09      	ldr	r3, [pc, #36]	; (83744 <send_tc_execution_verify+0x84>)
   83720:	681b      	ldr	r3, [r3, #0]
   83722:	2201      	movs	r2, #1
   83724:	9200      	str	r2, [sp, #0]
   83726:	2004      	movs	r0, #4
   83728:	2101      	movs	r1, #1
   8372a:	461a      	mov	r2, r3
   8372c:	4b04      	ldr	r3, [pc, #16]	; (83740 <send_tc_execution_verify+0x80>)
   8372e:	4c06      	ldr	r4, [pc, #24]	; (83748 <send_tc_execution_verify+0x88>)
   83730:	47a0      	blx	r4
	return;
   83732:	bf00      	nop
}
   83734:	370c      	adds	r7, #12
   83736:	46bd      	mov	sp, r7
   83738:	bd90      	pop	{r4, r7, pc}
   8373a:	bf00      	nop
   8373c:	00082ec5 	.word	0x00082ec5
   83740:	200708dc 	.word	0x200708dc
   83744:	2007b38c 	.word	0x2007b38c
   83748:	00080995 	.word	0x00080995

0008374c <vParTestInitialise>:

/**
 * \brief Initializes the LEDs in the off state.
 */ 
void vParTestInitialise( void )
{
   8374c:	b580      	push	{r7, lr}
   8374e:	b082      	sub	sp, #8
   83750:	af00      	add	r7, sp, #0
	unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
   83752:	2300      	movs	r3, #0
   83754:	607b      	str	r3, [r7, #4]
   83756:	e00f      	b.n	83778 <vParTestInitialise+0x2c>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
   83758:	4b0a      	ldr	r3, [pc, #40]	; (83784 <vParTestInitialise+0x38>)
   8375a:	687a      	ldr	r2, [r7, #4]
   8375c:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   83760:	4618      	mov	r0, r3
   83762:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   83766:	4b08      	ldr	r3, [pc, #32]	; (83788 <vParTestInitialise+0x3c>)
   83768:	4798      	blx	r3
		vParTestSetLED( ul, pdFALSE );
   8376a:	6878      	ldr	r0, [r7, #4]
   8376c:	2100      	movs	r1, #0
   8376e:	4b07      	ldr	r3, [pc, #28]	; (8378c <vParTestInitialise+0x40>)
   83770:	4798      	blx	r3
 */ 
void vParTestInitialise( void )
{
	unsigned long ul;

	for( ul = 0; ul < partestNUM_LEDS; ul++ )
   83772:	687b      	ldr	r3, [r7, #4]
   83774:	3301      	adds	r3, #1
   83776:	607b      	str	r3, [r7, #4]
   83778:	687b      	ldr	r3, [r7, #4]
   8377a:	2b03      	cmp	r3, #3
   8377c:	d9ec      	bls.n	83758 <vParTestInitialise+0xc>
	{
		/* Configure the LED, before ensuring it starts in the off state. */
		gpio_configure_pin( ulLED[ ul ],  ( PIO_OUTPUT_1 | PIO_DEFAULT ) );
		vParTestSetLED( ul, pdFALSE );
	}
}
   8377e:	3708      	adds	r7, #8
   83780:	46bd      	mov	sp, r7
   83782:	bd80      	pop	{r7, pc}
   83784:	0008b038 	.word	0x0008b038
   83788:	0008559d 	.word	0x0008559d
   8378c:	00083791 	.word	0x00083791

00083790 <vParTestSetLED>:
 						will be inverted.
 * @param xValue:		Boolean value - true to turn LED on,
 *									  - false to turn LED off
 */
void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
   83790:	b580      	push	{r7, lr}
   83792:	b082      	sub	sp, #8
   83794:	af00      	add	r7, sp, #0
   83796:	6078      	str	r0, [r7, #4]
   83798:	6039      	str	r1, [r7, #0]
	if( uxLED < partestNUM_LEDS )
   8379a:	687b      	ldr	r3, [r7, #4]
   8379c:	2b03      	cmp	r3, #3
   8379e:	d823      	bhi.n	837e8 <vParTestSetLED+0x58>
	{
		if( uxLED == partstsINVERTED_LED )
   837a0:	687b      	ldr	r3, [r7, #4]
   837a2:	2b00      	cmp	r3, #0
   837a4:	d106      	bne.n	837b4 <vParTestSetLED+0x24>
		{
			xValue = !xValue;
   837a6:	683b      	ldr	r3, [r7, #0]
   837a8:	2b00      	cmp	r3, #0
   837aa:	bf14      	ite	ne
   837ac:	2300      	movne	r3, #0
   837ae:	2301      	moveq	r3, #1
   837b0:	b2db      	uxtb	r3, r3
   837b2:	603b      	str	r3, [r7, #0]
		}

		if( xValue != pdFALSE )
   837b4:	683b      	ldr	r3, [r7, #0]
   837b6:	2b00      	cmp	r3, #0
   837b8:	d00b      	beq.n	837d2 <vParTestSetLED+0x42>
		{
			/* Turn the LED on. */
			taskENTER_CRITICAL();
   837ba:	4b0d      	ldr	r3, [pc, #52]	; (837f0 <vParTestSetLED+0x60>)
   837bc:	4798      	blx	r3
			{
				gpio_set_pin_low( ulLED[ uxLED ]);
   837be:	4b0d      	ldr	r3, [pc, #52]	; (837f4 <vParTestSetLED+0x64>)
   837c0:	687a      	ldr	r2, [r7, #4]
   837c2:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   837c6:	4618      	mov	r0, r3
   837c8:	4b0b      	ldr	r3, [pc, #44]	; (837f8 <vParTestSetLED+0x68>)
   837ca:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
   837cc:	4b0b      	ldr	r3, [pc, #44]	; (837fc <vParTestSetLED+0x6c>)
   837ce:	4798      	blx	r3
   837d0:	e00a      	b.n	837e8 <vParTestSetLED+0x58>
		}
		else
		{
			/* Turn the LED off. */
			taskENTER_CRITICAL();
   837d2:	4b07      	ldr	r3, [pc, #28]	; (837f0 <vParTestSetLED+0x60>)
   837d4:	4798      	blx	r3
			{
				gpio_set_pin_high( ulLED[ uxLED ]);
   837d6:	4b07      	ldr	r3, [pc, #28]	; (837f4 <vParTestSetLED+0x64>)
   837d8:	687a      	ldr	r2, [r7, #4]
   837da:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
   837de:	4618      	mov	r0, r3
   837e0:	4b07      	ldr	r3, [pc, #28]	; (83800 <vParTestSetLED+0x70>)
   837e2:	4798      	blx	r3
			}
			taskEXIT_CRITICAL();
   837e4:	4b05      	ldr	r3, [pc, #20]	; (837fc <vParTestSetLED+0x6c>)
   837e6:	4798      	blx	r3
		}
	}
}
   837e8:	3708      	adds	r7, #8
   837ea:	46bd      	mov	sp, r7
   837ec:	bd80      	pop	{r7, pc}
   837ee:	bf00      	nop
   837f0:	0008647d 	.word	0x0008647d
   837f4:	0008b038 	.word	0x0008b038
   837f8:	00085509 	.word	0x00085509
   837fc:	000864c1 	.word	0x000864c1
   83800:	000854d5 	.word	0x000854d5

00083804 <dectobcd>:
/************************************************************************/
/* DECTOBCD			 		                                            */
/* @Purpose: Decimal to binary code decimal conversion					*/
/************************************************************************/
static uint8_t dectobcd(uint8_t val)
{
   83804:	b480      	push	{r7}
   83806:	b083      	sub	sp, #12
   83808:	af00      	add	r7, sp, #0
   8380a:	4603      	mov	r3, r0
   8380c:	71fb      	strb	r3, [r7, #7]
	return ((val / 10 * 16) + (val % 10));
   8380e:	79fa      	ldrb	r2, [r7, #7]
   83810:	4b0c      	ldr	r3, [pc, #48]	; (83844 <dectobcd+0x40>)
   83812:	fba3 1302 	umull	r1, r3, r3, r2
   83816:	08db      	lsrs	r3, r3, #3
   83818:	b2db      	uxtb	r3, r3
   8381a:	011b      	lsls	r3, r3, #4
   8381c:	b2d8      	uxtb	r0, r3
   8381e:	79fa      	ldrb	r2, [r7, #7]
   83820:	4b08      	ldr	r3, [pc, #32]	; (83844 <dectobcd+0x40>)
   83822:	fba3 1302 	umull	r1, r3, r3, r2
   83826:	08d9      	lsrs	r1, r3, #3
   83828:	460b      	mov	r3, r1
   8382a:	009b      	lsls	r3, r3, #2
   8382c:	440b      	add	r3, r1
   8382e:	005b      	lsls	r3, r3, #1
   83830:	1ad3      	subs	r3, r2, r3
   83832:	b2db      	uxtb	r3, r3
   83834:	4403      	add	r3, r0
   83836:	b2db      	uxtb	r3, r3
}
   83838:	4618      	mov	r0, r3
   8383a:	370c      	adds	r7, #12
   8383c:	46bd      	mov	sp, r7
   8383e:	f85d 7b04 	ldr.w	r7, [sp], #4
   83842:	4770      	bx	lr
   83844:	cccccccd 	.word	0xcccccccd

00083848 <rtc_init>:
/* @Purpose: Initializes the RTC by configuring the control register and*/
/* setting the time-date to 00:00:00 01/01/0000							*/
/* @param: crtl_reg_val: The byte to set the control register to.		*/
/************************************************************************/
void rtc_init(uint16_t ctrl_reg_val)
{	
   83848:	b580      	push	{r7, lr}
   8384a:	b084      	sub	sp, #16
   8384c:	af00      	add	r7, sp, #0
   8384e:	4603      	mov	r3, r0
   83850:	80fb      	strh	r3, [r7, #6]
	rtc_set_creg(ctrl_reg_val);
   83852:	88fb      	ldrh	r3, [r7, #6]
   83854:	4618      	mov	r0, r3
   83856:	4b18      	ldr	r3, [pc, #96]	; (838b8 <rtc_init+0x70>)
   83858:	4798      	blx	r3
	//if (x<0) {errorREPORT(TIME_TASK_ID, 0, RTC_SPIMEM_R_ERROR, &ctrl_reg_val);}
	
	
	
	// Get the absolute time which may be stored in memory.
	ABSOLUTE_DAY = absolute_time_arr[0];
   8385a:	4b18      	ldr	r3, [pc, #96]	; (838bc <rtc_init+0x74>)
   8385c:	781a      	ldrb	r2, [r3, #0]
   8385e:	4b18      	ldr	r3, [pc, #96]	; (838c0 <rtc_init+0x78>)
   83860:	701a      	strb	r2, [r3, #0]
	CURRENT_HOUR = absolute_time_arr[1];
   83862:	4b16      	ldr	r3, [pc, #88]	; (838bc <rtc_init+0x74>)
   83864:	785a      	ldrb	r2, [r3, #1]
   83866:	4b17      	ldr	r3, [pc, #92]	; (838c4 <rtc_init+0x7c>)
   83868:	701a      	strb	r2, [r3, #0]
	CURRENT_MINUTE = absolute_time_arr[2];
   8386a:	4b14      	ldr	r3, [pc, #80]	; (838bc <rtc_init+0x74>)
   8386c:	789a      	ldrb	r2, [r3, #2]
   8386e:	4b16      	ldr	r3, [pc, #88]	; (838c8 <rtc_init+0x80>)
   83870:	701a      	strb	r2, [r3, #0]
	CURRENT_SECOND = absolute_time_arr[3];
   83872:	4b12      	ldr	r3, [pc, #72]	; (838bc <rtc_init+0x74>)
   83874:	78da      	ldrb	r2, [r3, #3]
   83876:	4b15      	ldr	r3, [pc, #84]	; (838cc <rtc_init+0x84>)
   83878:	701a      	strb	r2, [r3, #0]
	// FAILURE_RECOVERY if this function returns -1.
	struct timestamp initial_time;

	initial_time.sec = CURRENT_SECOND;
   8387a:	4b14      	ldr	r3, [pc, #80]	; (838cc <rtc_init+0x84>)
   8387c:	781b      	ldrb	r3, [r3, #0]
   8387e:	723b      	strb	r3, [r7, #8]
	initial_time.minute = CURRENT_MINUTE;
   83880:	4b11      	ldr	r3, [pc, #68]	; (838c8 <rtc_init+0x80>)
   83882:	781b      	ldrb	r3, [r3, #0]
   83884:	727b      	strb	r3, [r7, #9]
	initial_time.hour = CURRENT_HOUR;
   83886:	4b0f      	ldr	r3, [pc, #60]	; (838c4 <rtc_init+0x7c>)
   83888:	781b      	ldrb	r3, [r3, #0]
   8388a:	72bb      	strb	r3, [r7, #10]
	initial_time.mday = 0x01;
   8388c:	2301      	movs	r3, #1
   8388e:	733b      	strb	r3, [r7, #12]
	initial_time.wday = 0x01;
   83890:	2301      	movs	r3, #1
   83892:	72fb      	strb	r3, [r7, #11]
	initial_time.mon = 0x01;
   83894:	2301      	movs	r3, #1
   83896:	737b      	strb	r3, [r7, #13]
	initial_time.year = 0x00;
   83898:	2300      	movs	r3, #0
   8389a:	81fb      	strh	r3, [r7, #14]
	
	rtc_set(initial_time);
   8389c:	f107 0308 	add.w	r3, r7, #8
   838a0:	e893 0003 	ldmia.w	r3, {r0, r1}
   838a4:	4b0a      	ldr	r3, [pc, #40]	; (838d0 <rtc_init+0x88>)
   838a6:	4798      	blx	r3
	
	rtc_set_a2();
   838a8:	4b0a      	ldr	r3, [pc, #40]	; (838d4 <rtc_init+0x8c>)
   838aa:	4798      	blx	r3
	rtc_clear_a2_flag();
   838ac:	4b0a      	ldr	r3, [pc, #40]	; (838d8 <rtc_init+0x90>)
   838ae:	4798      	blx	r3
	return;
   838b0:	bf00      	nop
}
   838b2:	3710      	adds	r7, #16
   838b4:	46bd      	mov	sp, r7
   838b6:	bd80      	pop	{r7, pc}
   838b8:	000839d9 	.word	0x000839d9
   838bc:	2007b104 	.word	0x2007b104
   838c0:	2007b4ec 	.word	0x2007b4ec
   838c4:	2007d584 	.word	0x2007d584
   838c8:	2007b108 	.word	0x2007b108
   838cc:	2007b118 	.word	0x2007b118
   838d0:	000838dd 	.word	0x000838dd
   838d4:	00083a39 	.word	0x00083a39
   838d8:	00083a85 	.word	0x00083a85

000838dc <rtc_set>:
/* RTC_SET																*/
/* @Purpose: Set the time and date of the RTC to a specified value.		*/
/* @param: t: the time struct containing the new time/date to update to	*/
/************************************************************************/
void rtc_set(struct timestamp t)
{
   838dc:	b580      	push	{r7, lr}
   838de:	b086      	sub	sp, #24
   838e0:	af00      	add	r7, sp, #0
   838e2:	463b      	mov	r3, r7
   838e4:	e883 0003 	stmia.w	r3, {r0, r1}
	uint8_t time_date[7] = { t.sec, t.minute, t.hour, t.wday, t.mday, t.mon, t.year };
   838e8:	783b      	ldrb	r3, [r7, #0]
   838ea:	743b      	strb	r3, [r7, #16]
   838ec:	787b      	ldrb	r3, [r7, #1]
   838ee:	747b      	strb	r3, [r7, #17]
   838f0:	78bb      	ldrb	r3, [r7, #2]
   838f2:	74bb      	strb	r3, [r7, #18]
   838f4:	78fb      	ldrb	r3, [r7, #3]
   838f6:	74fb      	strb	r3, [r7, #19]
   838f8:	793b      	ldrb	r3, [r7, #4]
   838fa:	753b      	strb	r3, [r7, #20]
   838fc:	797b      	ldrb	r3, [r7, #5]
   838fe:	757b      	strb	r3, [r7, #21]
   83900:	88fb      	ldrh	r3, [r7, #6]
   83902:	b2db      	uxtb	r3, r3
   83904:	75bb      	strb	r3, [r7, #22]
    uint8_t i;
	uint16_t volatile message, addr, data;

    for (i = 0; i < 7; i++) 
   83906:	2300      	movs	r3, #0
   83908:	75fb      	strb	r3, [r7, #23]
   8390a:	e024      	b.n	83956 <rtc_set+0x7a>
	{
		// Convert data and prepare message to send
		addr = i + 0x80;
   8390c:	7dfb      	ldrb	r3, [r7, #23]
   8390e:	b29b      	uxth	r3, r3
   83910:	3380      	adds	r3, #128	; 0x80
   83912:	b29b      	uxth	r3, r3
   83914:	81bb      	strh	r3, [r7, #12]
		data = dectobcd(time_date[i]);
   83916:	7dfb      	ldrb	r3, [r7, #23]
   83918:	f107 0218 	add.w	r2, r7, #24
   8391c:	4413      	add	r3, r2
   8391e:	f813 3c08 	ldrb.w	r3, [r3, #-8]
   83922:	4618      	mov	r0, r3
   83924:	4b0f      	ldr	r3, [pc, #60]	; (83964 <rtc_set+0x88>)
   83926:	4798      	blx	r3
   83928:	4603      	mov	r3, r0
   8392a:	817b      	strh	r3, [r7, #10]
		
		message = (addr << 8) | data;
   8392c:	89bb      	ldrh	r3, [r7, #12]
   8392e:	b29b      	uxth	r3, r3
   83930:	021b      	lsls	r3, r3, #8
   83932:	b29a      	uxth	r2, r3
   83934:	897b      	ldrh	r3, [r7, #10]
   83936:	b29b      	uxth	r3, r3
   83938:	b29b      	uxth	r3, r3
   8393a:	4313      	orrs	r3, r2
   8393c:	b29b      	uxth	r3, r3
   8393e:	b29b      	uxth	r3, r3
   83940:	81fb      	strh	r3, [r7, #14]
		spi_master_transfer(&message, 1, 1);	// Chip-Select 3.
   83942:	f107 030e 	add.w	r3, r7, #14
   83946:	4618      	mov	r0, r3
   83948:	2101      	movs	r1, #1
   8394a:	2201      	movs	r2, #1
   8394c:	4b06      	ldr	r3, [pc, #24]	; (83968 <rtc_set+0x8c>)
   8394e:	4798      	blx	r3
{
	uint8_t time_date[7] = { t.sec, t.minute, t.hour, t.wday, t.mday, t.mon, t.year };
    uint8_t i;
	uint16_t volatile message, addr, data;

    for (i = 0; i < 7; i++) 
   83950:	7dfb      	ldrb	r3, [r7, #23]
   83952:	3301      	adds	r3, #1
   83954:	75fb      	strb	r3, [r7, #23]
   83956:	7dfb      	ldrb	r3, [r7, #23]
   83958:	2b06      	cmp	r3, #6
   8395a:	d9d7      	bls.n	8390c <rtc_set+0x30>
		data = dectobcd(time_date[i]);
		
		message = (addr << 8) | data;
		spi_master_transfer(&message, 1, 1);	// Chip-Select 3.
    }
	return;
   8395c:	bf00      	nop
}
   8395e:	3718      	adds	r7, #24
   83960:	46bd      	mov	sp, r7
   83962:	bd80      	pop	{r7, pc}
   83964:	00083805 	.word	0x00083805
   83968:	000840c5 	.word	0x000840c5

0008396c <rtc_set_addr>:
/* @Purpose: Sets an RTC register to a specfied value.					*/
/* @param: addr: RTC register address									*/
/* @param: val: New register value.										*/
/************************************************************************/
void rtc_set_addr(uint16_t addr, uint16_t val)
{
   8396c:	b580      	push	{r7, lr}
   8396e:	b084      	sub	sp, #16
   83970:	af00      	add	r7, sp, #0
   83972:	4602      	mov	r2, r0
   83974:	460b      	mov	r3, r1
   83976:	80fa      	strh	r2, [r7, #6]
   83978:	80bb      	strh	r3, [r7, #4]
	uint16_t volatile message = (addr << 8) | val;
   8397a:	88fb      	ldrh	r3, [r7, #6]
   8397c:	021b      	lsls	r3, r3, #8
   8397e:	b29a      	uxth	r2, r3
   83980:	88bb      	ldrh	r3, [r7, #4]
   83982:	4313      	orrs	r3, r2
   83984:	b29b      	uxth	r3, r3
   83986:	b29b      	uxth	r3, r3
   83988:	81fb      	strh	r3, [r7, #14]
	spi_master_transfer(&message, 1, 1);	// Chip-Select 1.
   8398a:	f107 030e 	add.w	r3, r7, #14
   8398e:	4618      	mov	r0, r3
   83990:	2101      	movs	r1, #1
   83992:	2201      	movs	r2, #1
   83994:	4b02      	ldr	r3, [pc, #8]	; (839a0 <rtc_set_addr+0x34>)
   83996:	4798      	blx	r3
	return;
   83998:	bf00      	nop
}
   8399a:	3710      	adds	r7, #16
   8399c:	46bd      	mov	sp, r7
   8399e:	bd80      	pop	{r7, pc}
   839a0:	000840c5 	.word	0x000840c5

000839a4 <rtc_get_addr>:
/* RTC_GET_ADDR		 		                                            */
/* @Purpose: Gets the value from a register								*/
/* @return: val: value stored in specified register						*/
/************************************************************************/
uint8_t rtc_get_addr(uint16_t addr)
{
   839a4:	b580      	push	{r7, lr}
   839a6:	b084      	sub	sp, #16
   839a8:	af00      	add	r7, sp, #0
   839aa:	4603      	mov	r3, r0
   839ac:	80fb      	strh	r3, [r7, #6]
	uint8_t val;
	uint16_t volatile message = (uint16_t) addr << 8;
   839ae:	88fb      	ldrh	r3, [r7, #6]
   839b0:	021b      	lsls	r3, r3, #8
   839b2:	b29b      	uxth	r3, r3
   839b4:	81bb      	strh	r3, [r7, #12]
	
	spi_master_transfer(&message, 1, 1);	// Chip-Select 1.
   839b6:	f107 030c 	add.w	r3, r7, #12
   839ba:	4618      	mov	r0, r3
   839bc:	2101      	movs	r1, #1
   839be:	2201      	movs	r2, #1
   839c0:	4b04      	ldr	r3, [pc, #16]	; (839d4 <rtc_get_addr+0x30>)
   839c2:	4798      	blx	r3
	
	val = (uint8_t) message;	
   839c4:	89bb      	ldrh	r3, [r7, #12]
   839c6:	b29b      	uxth	r3, r3
   839c8:	73fb      	strb	r3, [r7, #15]
	return val;
   839ca:	7bfb      	ldrb	r3, [r7, #15]
}
   839cc:	4618      	mov	r0, r3
   839ce:	3710      	adds	r7, #16
   839d0:	46bd      	mov	sp, r7
   839d2:	bd80      	pop	{r7, pc}
   839d4:	000840c5 	.word	0x000840c5

000839d8 <rtc_set_creg>:
 * bit2 INTCN  Interrupt control (1 for use of the alarms and to disable square wave)
 * bit1 A2IE   Alarm1 interrupt enable (1 to enable)
 * bit0 A1IE   Alarm0 interrupt enable (1 to enable)
 */
void rtc_set_creg(uint16_t val)
{
   839d8:	b580      	push	{r7, lr}
   839da:	b082      	sub	sp, #8
   839dc:	af00      	add	r7, sp, #0
   839de:	4603      	mov	r3, r0
   839e0:	80fb      	strh	r3, [r7, #6]
    rtc_set_addr(DS3234_CREG_WRITE, val);
   839e2:	88fb      	ldrh	r3, [r7, #6]
   839e4:	208e      	movs	r0, #142	; 0x8e
   839e6:	4619      	mov	r1, r3
   839e8:	4b02      	ldr	r3, [pc, #8]	; (839f4 <rtc_set_creg+0x1c>)
   839ea:	4798      	blx	r3
	return;
   839ec:	bf00      	nop
}
   839ee:	3708      	adds	r7, #8
   839f0:	46bd      	mov	sp, r7
   839f2:	bd80      	pop	{r7, pc}
   839f4:	0008396d 	.word	0x0008396d

000839f8 <rtc_set_sreg>:
/* bit2 BSY      Busy with TCXO functions								*/
/* bit1 A2F      Alarm 1 Flag - (1 if alarm2 was triggered)				*/
/* bit0 A1F      Alarm 0 Flag - (1 if alarm1 was triggered)				*/
/************************************************************************/
void rtc_set_sreg(uint16_t val)
{
   839f8:	b580      	push	{r7, lr}
   839fa:	b082      	sub	sp, #8
   839fc:	af00      	add	r7, sp, #0
   839fe:	4603      	mov	r3, r0
   83a00:	80fb      	strh	r3, [r7, #6]
    rtc_set_addr(DS3234_SREG_WRITE, val);
   83a02:	88fb      	ldrh	r3, [r7, #6]
   83a04:	208f      	movs	r0, #143	; 0x8f
   83a06:	4619      	mov	r1, r3
   83a08:	4b02      	ldr	r3, [pc, #8]	; (83a14 <rtc_set_sreg+0x1c>)
   83a0a:	4798      	blx	r3
	return;
   83a0c:	bf00      	nop
}
   83a0e:	3708      	adds	r7, #8
   83a10:	46bd      	mov	sp, r7
   83a12:	bd80      	pop	{r7, pc}
   83a14:	0008396d 	.word	0x0008396d

00083a18 <rtc_get_sreg>:
/* RTC_GET_SREG		 		                                            */
/* @Purpose: Get the value of the RTC status register					*/
/* @return: ret_val: Value of the RTC status register					*/
/************************************************************************/
uint8_t rtc_get_sreg(void)
{
   83a18:	b580      	push	{r7, lr}
   83a1a:	b082      	sub	sp, #8
   83a1c:	af00      	add	r7, sp, #0
	uint8_t ret_val;
	ret_val = rtc_get_addr(DS3234_SREG_READ);
   83a1e:	200f      	movs	r0, #15
   83a20:	4b04      	ldr	r3, [pc, #16]	; (83a34 <rtc_get_sreg+0x1c>)
   83a22:	4798      	blx	r3
   83a24:	4603      	mov	r3, r0
   83a26:	71fb      	strb	r3, [r7, #7]
	return ret_val;
   83a28:	79fb      	ldrb	r3, [r7, #7]
}
   83a2a:	4618      	mov	r0, r3
   83a2c:	3708      	adds	r7, #8
   83a2e:	46bd      	mov	sp, r7
   83a30:	bd80      	pop	{r7, pc}
   83a32:	bf00      	nop
   83a34:	000839a5 	.word	0x000839a5

00083a38 <rtc_set_a2>:
/************************************************************************/
/* RTC_SET_A2		 		                                            */
/* @Purpose: Sets the RTC Alarm 2 to trigger every minute				*/
/************************************************************************/
void rtc_set_a2(void)
{
   83a38:	b580      	push	{r7, lr}
   83a3a:	b082      	sub	sp, #8
   83a3c:	af00      	add	r7, sp, #0
	uint8_t i;
	uint16_t volatile buffer, message;
	
	for (i = 0; i <= 2; i++) 
   83a3e:	2300      	movs	r3, #0
   83a40:	71fb      	strb	r3, [r7, #7]
   83a42:	e016      	b.n	83a72 <rtc_set_a2+0x3a>
	{
		buffer = i + 0x8B;
   83a44:	79fb      	ldrb	r3, [r7, #7]
   83a46:	b29b      	uxth	r3, r3
   83a48:	338b      	adds	r3, #139	; 0x8b
   83a4a:	b29b      	uxth	r3, r3
   83a4c:	80bb      	strh	r3, [r7, #4]

		message = (buffer << 8) | 0x80;
   83a4e:	88bb      	ldrh	r3, [r7, #4]
   83a50:	b29b      	uxth	r3, r3
   83a52:	021b      	lsls	r3, r3, #8
   83a54:	b29b      	uxth	r3, r3
   83a56:	f043 0380 	orr.w	r3, r3, #128	; 0x80
   83a5a:	b29b      	uxth	r3, r3
   83a5c:	b29b      	uxth	r3, r3
   83a5e:	807b      	strh	r3, [r7, #2]
		spi_master_transfer(&message, 1, 1);	// Chip-Select 1.
   83a60:	1cbb      	adds	r3, r7, #2
   83a62:	4618      	mov	r0, r3
   83a64:	2101      	movs	r1, #1
   83a66:	2201      	movs	r2, #1
   83a68:	4b05      	ldr	r3, [pc, #20]	; (83a80 <rtc_set_a2+0x48>)
   83a6a:	4798      	blx	r3
void rtc_set_a2(void)
{
	uint8_t i;
	uint16_t volatile buffer, message;
	
	for (i = 0; i <= 2; i++) 
   83a6c:	79fb      	ldrb	r3, [r7, #7]
   83a6e:	3301      	adds	r3, #1
   83a70:	71fb      	strb	r3, [r7, #7]
   83a72:	79fb      	ldrb	r3, [r7, #7]
   83a74:	2b02      	cmp	r3, #2
   83a76:	d9e5      	bls.n	83a44 <rtc_set_a2+0xc>
		buffer = i + 0x8B;

		message = (buffer << 8) | 0x80;
		spi_master_transfer(&message, 1, 1);	// Chip-Select 1.
	}
	return;
   83a78:	bf00      	nop
}
   83a7a:	3708      	adds	r7, #8
   83a7c:	46bd      	mov	sp, r7
   83a7e:	bd80      	pop	{r7, pc}
   83a80:	000840c5 	.word	0x000840c5

00083a84 <rtc_clear_a2_flag>:
/************************************************************************/
/* RTC_CLEAR_A2_FLAG 		                                            */
/* @Purpose: Clears the RTC Alarm 2 Flag								*/
/************************************************************************/
void rtc_clear_a2_flag(void)
{
   83a84:	b580      	push	{r7, lr}
   83a86:	b082      	sub	sp, #8
   83a88:	af00      	add	r7, sp, #0
	uint8_t reg_val;
	reg_val = rtc_get_sreg() & ~DS3234_A2F;
   83a8a:	4b07      	ldr	r3, [pc, #28]	; (83aa8 <rtc_clear_a2_flag+0x24>)
   83a8c:	4798      	blx	r3
   83a8e:	4603      	mov	r3, r0
   83a90:	f023 0302 	bic.w	r3, r3, #2
   83a94:	71fb      	strb	r3, [r7, #7]
	
	rtc_set_sreg(reg_val);
   83a96:	79fb      	ldrb	r3, [r7, #7]
   83a98:	b29b      	uxth	r3, r3
   83a9a:	4618      	mov	r0, r3
   83a9c:	4b03      	ldr	r3, [pc, #12]	; (83aac <rtc_clear_a2_flag+0x28>)
   83a9e:	4798      	blx	r3
	return;
   83aa0:	bf00      	nop
}
   83aa2:	3708      	adds	r7, #8
   83aa4:	46bd      	mov	sp, r7
   83aa6:	bd80      	pop	{r7, pc}
   83aa8:	00083a19 	.word	0x00083a19
   83aac:	000839f9 	.word	0x000839f9

00083ab0 <spimem_initialize>:
/* @return: None.														*/
/* @Note: The initialization procedure needs to be repeated for each	*/
/* SPI memory chip.														*/
/************************************************************************/
void spimem_initialize(void)
{
   83ab0:	b590      	push	{r4, r7, lr}
   83ab2:	b085      	sub	sp, #20
   83ab4:	af02      	add	r7, sp, #8
	uint16_t i;
	
	if(INTERNAL_MEMORY_FALLBACK_MODE)
   83ab6:	4b28      	ldr	r3, [pc, #160]	; (83b58 <spimem_initialize+0xa8>)
   83ab8:	681b      	ldr	r3, [r3, #0]
   83aba:	2b00      	cmp	r3, #0
   83abc:	d000      	beq.n	83ac0 <spimem_initialize+0x10>
		return;
   83abe:	e048      	b.n	83b52 <spimem_initialize+0xa2>
	
	gpio_set_pin_low(SPI0_MEM1_HOLD);	// Turn "holding" off for SPIMEM1
   83ac0:	2015      	movs	r0, #21
   83ac2:	4b26      	ldr	r3, [pc, #152]	; (83b5c <spimem_initialize+0xac>)
   83ac4:	4798      	blx	r3
	
	if (ready_for_command_h(2) != 1)
   83ac6:	2002      	movs	r0, #2
   83ac8:	4b25      	ldr	r3, [pc, #148]	; (83b60 <spimem_initialize+0xb0>)
   83aca:	4798      	blx	r3
   83acc:	4603      	mov	r3, r0
   83ace:	2b01      	cmp	r3, #1
   83ad0:	d007      	beq.n	83ae2 <spimem_initialize+0x32>
		errorASSERT(SPIMEM_SENDER_ID, 0, SPIMEM_BUSY_CHIP_ERROR, spi_mem_buff, 0);
   83ad2:	2300      	movs	r3, #0
   83ad4:	9300      	str	r3, [sp, #0]
   83ad6:	2016      	movs	r0, #22
   83ad8:	2100      	movs	r1, #0
   83ada:	220a      	movs	r2, #10
   83adc:	4b21      	ldr	r3, [pc, #132]	; (83b64 <spimem_initialize+0xb4>)
   83ade:	4c22      	ldr	r4, [pc, #136]	; (83b68 <spimem_initialize+0xb8>)
   83ae0:	47a0      	blx	r4

	if(ERASE_SPIMEM_ON_RESET)
	{	
		if(erase_spimem() < 0)
   83ae2:	4b22      	ldr	r3, [pc, #136]	; (83b6c <spimem_initialize+0xbc>)
   83ae4:	4798      	blx	r3
   83ae6:	4603      	mov	r3, r0
   83ae8:	2b00      	cmp	r3, #0
   83aea:	da07      	bge.n	83afc <spimem_initialize+0x4c>
			errorASSERT(SPIMEM_SENDER_ID, 0, SPIMEM_CHIP_ERASE_ERROR, spi_mem_buff, 0);
   83aec:	2300      	movs	r3, #0
   83aee:	9300      	str	r3, [sp, #0]
   83af0:	2016      	movs	r0, #22
   83af2:	2100      	movs	r1, #0
   83af4:	220b      	movs	r2, #11
   83af6:	4b1b      	ldr	r3, [pc, #108]	; (83b64 <spimem_initialize+0xb4>)
   83af8:	4c1b      	ldr	r4, [pc, #108]	; (83b68 <spimem_initialize+0xb8>)
   83afa:	47a0      	blx	r4
	}

	if (ready_for_command_h(2) != 1)
   83afc:	2002      	movs	r0, #2
   83afe:	4b18      	ldr	r3, [pc, #96]	; (83b60 <spimem_initialize+0xb0>)
   83b00:	4798      	blx	r3
   83b02:	4603      	mov	r3, r0
   83b04:	2b01      	cmp	r3, #1
   83b06:	d007      	beq.n	83b18 <spimem_initialize+0x68>
		errorASSERT(SPIMEM_SENDER_ID, 0, SPIMEM_BUSY_CHIP_ERROR, spi_mem_buff, 0);
   83b08:	2300      	movs	r3, #0
   83b0a:	9300      	str	r3, [sp, #0]
   83b0c:	2016      	movs	r0, #22
   83b0e:	2100      	movs	r1, #0
   83b10:	220a      	movs	r2, #10
   83b12:	4b14      	ldr	r3, [pc, #80]	; (83b64 <spimem_initialize+0xb4>)
   83b14:	4c14      	ldr	r4, [pc, #80]	; (83b68 <spimem_initialize+0xb8>)
   83b16:	47a0      	blx	r4
							
	for (i = 0; i < 128; i++)
   83b18:	2300      	movs	r3, #0
   83b1a:	80fb      	strh	r3, [r7, #6]
   83b1c:	e007      	b.n	83b2e <spimem_initialize+0x7e>
	{
		spi_bit_map[i] = 0;				// Initialize the bitmap
   83b1e:	88fa      	ldrh	r2, [r7, #6]
   83b20:	4b13      	ldr	r3, [pc, #76]	; (83b70 <spimem_initialize+0xc0>)
   83b22:	2100      	movs	r1, #0
   83b24:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	}

	if (ready_for_command_h(2) != 1)
		errorASSERT(SPIMEM_SENDER_ID, 0, SPIMEM_BUSY_CHIP_ERROR, spi_mem_buff, 0);
							
	for (i = 0; i < 128; i++)
   83b28:	88fb      	ldrh	r3, [r7, #6]
   83b2a:	3301      	adds	r3, #1
   83b2c:	80fb      	strh	r3, [r7, #6]
   83b2e:	88fb      	ldrh	r3, [r7, #6]
   83b30:	2b7f      	cmp	r3, #127	; 0x7f
   83b32:	d9f4      	bls.n	83b1e <spimem_initialize+0x6e>
	{
		spi_bit_map[i] = 0;				// Initialize the bitmap
	}

	for (i = 0; i < 4096; i++)
   83b34:	2300      	movs	r3, #0
   83b36:	80fb      	strh	r3, [r7, #6]
   83b38:	e006      	b.n	83b48 <spimem_initialize+0x98>
	{
		spi_mem_buff[i] = 0;			// Initialize the memory buffer.
   83b3a:	88fb      	ldrh	r3, [r7, #6]
   83b3c:	4a09      	ldr	r2, [pc, #36]	; (83b64 <spimem_initialize+0xb4>)
   83b3e:	2100      	movs	r1, #0
   83b40:	54d1      	strb	r1, [r2, r3]
	for (i = 0; i < 128; i++)
	{
		spi_bit_map[i] = 0;				// Initialize the bitmap
	}

	for (i = 0; i < 4096; i++)
   83b42:	88fb      	ldrh	r3, [r7, #6]
   83b44:	3301      	adds	r3, #1
   83b46:	80fb      	strh	r3, [r7, #6]
   83b48:	88fb      	ldrh	r3, [r7, #6]
   83b4a:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   83b4e:	d3f4      	bcc.n	83b3a <spimem_initialize+0x8a>
	{
		spi_mem_buff[i] = 0;			// Initialize the memory buffer.
	}
	return;
   83b50:	bf00      	nop
}
   83b52:	370c      	adds	r7, #12
   83b54:	46bd      	mov	sp, r7
   83b56:	bd90      	pop	{r4, r7, pc}
   83b58:	2007b3f8 	.word	0x2007b3f8
   83b5c:	00085509 	.word	0x00085509
   83b60:	00083cc1 	.word	0x00083cc1
   83b64:	2007b57c 	.word	0x2007b57c
   83b68:	00080565 	.word	0x00080565
   83b6c:	00083b75 	.word	0x00083b75
   83b70:	2007aef4 	.word	0x2007aef4

00083b74 <erase_spimem>:

int erase_spimem(void)
{
   83b74:	b580      	push	{r7, lr}
   83b76:	b084      	sub	sp, #16
   83b78:	af00      	add	r7, sp, #0
	uint16_t dumbuf[2], i;
	dumbuf[0] = CE;
   83b7a:	23c7      	movs	r3, #199	; 0xc7
   83b7c:	80bb      	strh	r3, [r7, #4]
	if(INTERNAL_MEMORY_FALLBACK_MODE)
   83b7e:	4b1e      	ldr	r3, [pc, #120]	; (83bf8 <erase_spimem+0x84>)
   83b80:	681b      	ldr	r3, [r3, #0]
   83b82:	2b00      	cmp	r3, #0
   83b84:	d00f      	beq.n	83ba6 <erase_spimem+0x32>
	{
		for (i = 0; i < 4096; i++)
   83b86:	2300      	movs	r3, #0
   83b88:	81fb      	strh	r3, [r7, #14]
   83b8a:	e006      	b.n	83b9a <erase_spimem+0x26>
		{
			spi_mem_buff[i] = 0;			// Initialize the memory buffer.
   83b8c:	89fb      	ldrh	r3, [r7, #14]
   83b8e:	4a1b      	ldr	r2, [pc, #108]	; (83bfc <erase_spimem+0x88>)
   83b90:	2100      	movs	r1, #0
   83b92:	54d1      	strb	r1, [r2, r3]
{
	uint16_t dumbuf[2], i;
	dumbuf[0] = CE;
	if(INTERNAL_MEMORY_FALLBACK_MODE)
	{
		for (i = 0; i < 4096; i++)
   83b94:	89fb      	ldrh	r3, [r7, #14]
   83b96:	3301      	adds	r3, #1
   83b98:	81fb      	strh	r3, [r7, #14]
   83b9a:	89fb      	ldrh	r3, [r7, #14]
   83b9c:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
   83ba0:	d3f4      	bcc.n	83b8c <erase_spimem+0x18>
		{
			spi_mem_buff[i] = 0;			// Initialize the memory buffer.
		}
		return 1;
   83ba2:	2301      	movs	r3, #1
   83ba4:	e024      	b.n	83bf0 <erase_spimem+0x7c>
	}
	uint32_t timeout = 1500;
   83ba6:	f240 53dc 	movw	r3, #1500	; 0x5dc
   83baa:	60bb      	str	r3, [r7, #8]
	spi_master_transfer(dumbuf, 1, 2);	// Chip-Erase (this operation can take up to 7s for each chip)
   83bac:	1d3b      	adds	r3, r7, #4
   83bae:	4618      	mov	r0, r3
   83bb0:	2101      	movs	r1, #1
   83bb2:	2202      	movs	r2, #2
   83bb4:	4b12      	ldr	r3, [pc, #72]	; (83c00 <erase_spimem+0x8c>)
   83bb6:	4798      	blx	r3
	while((check_if_wip(2) != 0) && timeout--){delay_ms(10);}
   83bb8:	e002      	b.n	83bc0 <erase_spimem+0x4c>
   83bba:	200a      	movs	r0, #10
   83bbc:	4b11      	ldr	r3, [pc, #68]	; (83c04 <erase_spimem+0x90>)
   83bbe:	4798      	blx	r3
   83bc0:	2002      	movs	r0, #2
   83bc2:	4b11      	ldr	r3, [pc, #68]	; (83c08 <erase_spimem+0x94>)
   83bc4:	4798      	blx	r3
   83bc6:	4603      	mov	r3, r0
   83bc8:	2b00      	cmp	r3, #0
   83bca:	d004      	beq.n	83bd6 <erase_spimem+0x62>
   83bcc:	68bb      	ldr	r3, [r7, #8]
   83bce:	1e5a      	subs	r2, r3, #1
   83bd0:	60ba      	str	r2, [r7, #8]
   83bd2:	2b00      	cmp	r3, #0
   83bd4:	d1f1      	bne.n	83bba <erase_spimem+0x46>
	if((check_if_wip(2) != 0) || !timeout)
   83bd6:	2002      	movs	r0, #2
   83bd8:	4b0b      	ldr	r3, [pc, #44]	; (83c08 <erase_spimem+0x94>)
   83bda:	4798      	blx	r3
   83bdc:	4603      	mov	r3, r0
   83bde:	2b00      	cmp	r3, #0
   83be0:	d102      	bne.n	83be8 <erase_spimem+0x74>
   83be2:	68bb      	ldr	r3, [r7, #8]
   83be4:	2b00      	cmp	r3, #0
   83be6:	d102      	bne.n	83bee <erase_spimem+0x7a>
		return -1;
   83be8:	f04f 33ff 	mov.w	r3, #4294967295
   83bec:	e000      	b.n	83bf0 <erase_spimem+0x7c>
	return 1;
   83bee:	2301      	movs	r3, #1
}
   83bf0:	4618      	mov	r0, r3
   83bf2:	3710      	adds	r7, #16
   83bf4:	46bd      	mov	sp, r7
   83bf6:	bd80      	pop	{r7, pc}
   83bf8:	2007b3f8 	.word	0x2007b3f8
   83bfc:	2007b57c 	.word	0x2007b57c
   83c00:	000840c5 	.word	0x000840c5
   83c04:	0008422d 	.word	0x0008422d
   83c08:	00083c41 	.word	0x00083c41

00083c0c <get_spimem_status_h>:
/* memory chip that was requested.										*/
/* @NOTE: This function is a helper and is ONLY to be used within a 	*/
/* section of code which has acquired the Spi0_Mutex.					*/
/************************************************************************/
static uint8_t get_spimem_status_h(uint32_t spi_chip)
{
   83c0c:	b580      	push	{r7, lr}
   83c0e:	b084      	sub	sp, #16
   83c10:	af00      	add	r7, sp, #0
   83c12:	6078      	str	r0, [r7, #4]
	uint16_t dumbuf[2];
	dumbuf[0] = RSR;											// Read Status Register.
   83c14:	2305      	movs	r3, #5
   83c16:	81bb      	strh	r3, [r7, #12]
	dumbuf[1] = 0x00;
   83c18:	2300      	movs	r3, #0
   83c1a:	81fb      	strh	r3, [r7, #14]

	spi_master_transfer(dumbuf, 2, (uint8_t)spi_chip);
   83c1c:	687b      	ldr	r3, [r7, #4]
   83c1e:	b2db      	uxtb	r3, r3
   83c20:	f107 020c 	add.w	r2, r7, #12
   83c24:	4610      	mov	r0, r2
   83c26:	2102      	movs	r1, #2
   83c28:	461a      	mov	r2, r3
   83c2a:	4b04      	ldr	r3, [pc, #16]	; (83c3c <get_spimem_status_h+0x30>)
   83c2c:	4798      	blx	r3
	return (uint8_t)dumbuf[1];						// Status of the Chip is returned.
   83c2e:	89fb      	ldrh	r3, [r7, #14]
   83c30:	b2db      	uxtb	r3, r3
}
   83c32:	4618      	mov	r0, r3
   83c34:	3710      	adds	r7, #16
   83c36:	46bd      	mov	sp, r7
   83c38:	bd80      	pop	{r7, pc}
   83c3a:	bf00      	nop
   83c3c:	000840c5 	.word	0x000840c5

00083c40 <check_if_wip>:
/* or when the SPI0 Mutex has already been acquired.					*/
/* @NOTE: If the operation takes longer than 5ms, this function returns */
/* -1 to indicate that a failure occurred.								*/
/************************************************************************/
uint32_t check_if_wip(uint32_t spi_chip)
{
   83c40:	b580      	push	{r7, lr}
   83c42:	b086      	sub	sp, #24
   83c44:	af00      	add	r7, sp, #0
   83c46:	6078      	str	r0, [r7, #4]
	uint8_t status;
	uint32_t timeout = 50;						// ~5ms timeout.
   83c48:	2332      	movs	r3, #50	; 0x32
   83c4a:	613b      	str	r3, [r7, #16]
	uint32_t ret_val = -1;;
   83c4c:	f04f 33ff 	mov.w	r3, #4294967295
   83c50:	60fb      	str	r3, [r7, #12]

	status = get_spimem_status_h(spi_chip);
   83c52:	6878      	ldr	r0, [r7, #4]
   83c54:	4b18      	ldr	r3, [pc, #96]	; (83cb8 <check_if_wip+0x78>)
   83c56:	4798      	blx	r3
   83c58:	4603      	mov	r3, r0
   83c5a:	75fb      	strb	r3, [r7, #23]
	status = status & 0x01;
   83c5c:	7dfb      	ldrb	r3, [r7, #23]
   83c5e:	f003 0301 	and.w	r3, r3, #1
   83c62:	75fb      	strb	r3, [r7, #23]
	
	while((status != 0x00) && (timeout--))			// Wait for WIP to be zero (Write-In-Progess)
   83c64:	e00b      	b.n	83c7e <check_if_wip+0x3e>
	{
		status = get_spimem_status_h(spi_chip);
   83c66:	6878      	ldr	r0, [r7, #4]
   83c68:	4b13      	ldr	r3, [pc, #76]	; (83cb8 <check_if_wip+0x78>)
   83c6a:	4798      	blx	r3
   83c6c:	4603      	mov	r3, r0
   83c6e:	75fb      	strb	r3, [r7, #23]
		status = status & 0x01;
   83c70:	7dfb      	ldrb	r3, [r7, #23]
   83c72:	f003 0301 	and.w	r3, r3, #1
   83c76:	75fb      	strb	r3, [r7, #23]
		delay_us(100);
   83c78:	2064      	movs	r0, #100	; 0x64
   83c7a:	4b10      	ldr	r3, [pc, #64]	; (83cbc <check_if_wip+0x7c>)
   83c7c:	4798      	blx	r3
	uint32_t ret_val = -1;;

	status = get_spimem_status_h(spi_chip);
	status = status & 0x01;
	
	while((status != 0x00) && (timeout--))			// Wait for WIP to be zero (Write-In-Progess)
   83c7e:	7dfb      	ldrb	r3, [r7, #23]
   83c80:	2b00      	cmp	r3, #0
   83c82:	d004      	beq.n	83c8e <check_if_wip+0x4e>
   83c84:	693b      	ldr	r3, [r7, #16]
   83c86:	1e5a      	subs	r2, r3, #1
   83c88:	613a      	str	r2, [r7, #16]
   83c8a:	2b00      	cmp	r3, #0
   83c8c:	d1eb      	bne.n	83c66 <check_if_wip+0x26>
		status = get_spimem_status_h(spi_chip);
		status = status & 0x01;
		delay_us(100);
	}
	
	if((status == 0x01) || (!timeout))				// Waiting took too long, return FAILURE.
   83c8e:	7dfb      	ldrb	r3, [r7, #23]
   83c90:	2b01      	cmp	r3, #1
   83c92:	d002      	beq.n	83c9a <check_if_wip+0x5a>
   83c94:	693b      	ldr	r3, [r7, #16]
   83c96:	2b00      	cmp	r3, #0
   83c98:	d101      	bne.n	83c9e <check_if_wip+0x5e>
		return ret_val;
   83c9a:	68fb      	ldr	r3, [r7, #12]
   83c9c:	e007      	b.n	83cae <check_if_wip+0x6e>
		
	if(status == 0x00)								// No Write in Progress, return 0.
   83c9e:	7dfb      	ldrb	r3, [r7, #23]
   83ca0:	2b00      	cmp	r3, #0
   83ca2:	d103      	bne.n	83cac <check_if_wip+0x6c>
	{
		ret_val = 0;
   83ca4:	2300      	movs	r3, #0
   83ca6:	60fb      	str	r3, [r7, #12]
		return ret_val;
   83ca8:	68fb      	ldr	r3, [r7, #12]
   83caa:	e000      	b.n	83cae <check_if_wip+0x6e>
	}
	else
		return ret_val;
   83cac:	68fb      	ldr	r3, [r7, #12]
}
   83cae:	4618      	mov	r0, r3
   83cb0:	3718      	adds	r7, #24
   83cb2:	46bd      	mov	sp, r7
   83cb4:	bd80      	pop	{r7, pc}
   83cb6:	bf00      	nop
   83cb8:	00083c0d 	.word	0x00083c0d
   83cbc:	0008425d 	.word	0x0008425d

00083cc0 <ready_for_command_h>:
/* @Note: This is a helper function and as such it should only be used	*/
/* within a section of code which as acquired the SPI0 Mutex.			*/
/* @Purpose: This function is used to ready a chip to receive a command */
/************************************************************************/
static uint32_t ready_for_command_h(uint32_t spi_chip)
{		
   83cc0:	b580      	push	{r7, lr}
   83cc2:	b084      	sub	sp, #16
   83cc4:	af00      	add	r7, sp, #0
   83cc6:	6078      	str	r0, [r7, #4]
	uint32_t check;
	
	check = check_if_wip(spi_chip);
   83cc8:	6878      	ldr	r0, [r7, #4]
   83cca:	4b13      	ldr	r3, [pc, #76]	; (83d18 <ready_for_command_h+0x58>)
   83ccc:	4798      	blx	r3
   83cce:	60f8      	str	r0, [r7, #12]
	if(check == 1)
   83cd0:	68fb      	ldr	r3, [r7, #12]
   83cd2:	2b01      	cmp	r3, #1
   83cd4:	d102      	bne.n	83cdc <ready_for_command_h+0x1c>
		return -1;
   83cd6:	f04f 33ff 	mov.w	r3, #4294967295
   83cda:	e019      	b.n	83d10 <ready_for_command_h+0x50>
			
	msg_buff[0] = WREN;										// Enable a Write.
   83cdc:	4b0f      	ldr	r3, [pc, #60]	; (83d1c <ready_for_command_h+0x5c>)
   83cde:	2206      	movs	r2, #6
   83ce0:	801a      	strh	r2, [r3, #0]
	spi_master_transfer(msg_buff, 1, spi_chip);
   83ce2:	687b      	ldr	r3, [r7, #4]
   83ce4:	b2db      	uxtb	r3, r3
   83ce6:	480d      	ldr	r0, [pc, #52]	; (83d1c <ready_for_command_h+0x5c>)
   83ce8:	2101      	movs	r1, #1
   83cea:	461a      	mov	r2, r3
   83cec:	4b0c      	ldr	r3, [pc, #48]	; (83d20 <ready_for_command_h+0x60>)
   83cee:	4798      	blx	r3
	
	check = get_spimem_status_h(spi_chip);
   83cf0:	6878      	ldr	r0, [r7, #4]
   83cf2:	4b0c      	ldr	r3, [pc, #48]	; (83d24 <ready_for_command_h+0x64>)
   83cf4:	4798      	blx	r3
   83cf6:	4603      	mov	r3, r0
   83cf8:	60fb      	str	r3, [r7, #12]
	check = check & 0x03;
   83cfa:	68fb      	ldr	r3, [r7, #12]
   83cfc:	f003 0303 	and.w	r3, r3, #3
   83d00:	60fb      	str	r3, [r7, #12]
	
	if(check != 0x02)
   83d02:	68fb      	ldr	r3, [r7, #12]
   83d04:	2b02      	cmp	r3, #2
   83d06:	d002      	beq.n	83d0e <ready_for_command_h+0x4e>
		return -1;
   83d08:	f04f 33ff 	mov.w	r3, #4294967295
   83d0c:	e000      	b.n	83d10 <ready_for_command_h+0x50>
		
	return 1;
   83d0e:	2301      	movs	r3, #1
}
   83d10:	4618      	mov	r0, r3
   83d12:	3710      	adds	r7, #16
   83d14:	46bd      	mov	sp, r7
   83d16:	bd80      	pop	{r7, pc}
   83d18:	00083c41 	.word	0x00083c41
   83d1c:	2007b178 	.word	0x2007b178
   83d20:	000840c5 	.word	0x000840c5
   83d24:	00083c0d 	.word	0x00083c0d

00083d28 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
   83d28:	b480      	push	{r7}
   83d2a:	b083      	sub	sp, #12
   83d2c:	af00      	add	r7, sp, #0
   83d2e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
   83d30:	687b      	ldr	r3, [r7, #4]
   83d32:	2b07      	cmp	r3, #7
   83d34:	d825      	bhi.n	83d82 <osc_get_rate+0x5a>
   83d36:	a201      	add	r2, pc, #4	; (adr r2, 83d3c <osc_get_rate+0x14>)
   83d38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   83d3c:	00083d5d 	.word	0x00083d5d
   83d40:	00083d63 	.word	0x00083d63
   83d44:	00083d69 	.word	0x00083d69
   83d48:	00083d6f 	.word	0x00083d6f
   83d4c:	00083d73 	.word	0x00083d73
   83d50:	00083d77 	.word	0x00083d77
   83d54:	00083d7b 	.word	0x00083d7b
   83d58:	00083d7f 	.word	0x00083d7f
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
   83d5c:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
   83d60:	e010      	b.n	83d84 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
   83d62:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   83d66:	e00d      	b.n	83d84 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
   83d68:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   83d6c:	e00a      	b.n	83d84 <osc_get_rate+0x5c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
   83d6e:	4b08      	ldr	r3, [pc, #32]	; (83d90 <osc_get_rate+0x68>)
   83d70:	e008      	b.n	83d84 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
   83d72:	4b08      	ldr	r3, [pc, #32]	; (83d94 <osc_get_rate+0x6c>)
   83d74:	e006      	b.n	83d84 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
   83d76:	4b08      	ldr	r3, [pc, #32]	; (83d98 <osc_get_rate+0x70>)
   83d78:	e004      	b.n	83d84 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
   83d7a:	4b07      	ldr	r3, [pc, #28]	; (83d98 <osc_get_rate+0x70>)
   83d7c:	e002      	b.n	83d84 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
   83d7e:	4b06      	ldr	r3, [pc, #24]	; (83d98 <osc_get_rate+0x70>)
   83d80:	e000      	b.n	83d84 <osc_get_rate+0x5c>
#endif
	}

	return 0;
   83d82:	2300      	movs	r3, #0
}
   83d84:	4618      	mov	r0, r3
   83d86:	370c      	adds	r7, #12
   83d88:	46bd      	mov	sp, r7
   83d8a:	f85d 7b04 	ldr.w	r7, [sp], #4
   83d8e:	4770      	bx	lr
   83d90:	003d0900 	.word	0x003d0900
   83d94:	007a1200 	.word	0x007a1200
   83d98:	00b71b00 	.word	0x00b71b00

00083d9c <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
   83d9c:	b580      	push	{r7, lr}
   83d9e:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
   83da0:	2006      	movs	r0, #6
   83da2:	4b04      	ldr	r3, [pc, #16]	; (83db4 <sysclk_get_main_hz+0x18>)
   83da4:	4798      	blx	r3
   83da6:	4602      	mov	r2, r0
   83da8:	4613      	mov	r3, r2
   83daa:	00db      	lsls	r3, r3, #3
   83dac:	1a9b      	subs	r3, r3, r2
   83dae:	005b      	lsls	r3, r3, #1
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
   83db0:	4618      	mov	r0, r3
   83db2:	bd80      	pop	{r7, pc}
   83db4:	00083d29 	.word	0x00083d29

00083db8 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
   83db8:	b580      	push	{r7, lr}
   83dba:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
   83dbc:	4b02      	ldr	r3, [pc, #8]	; (83dc8 <sysclk_get_cpu_hz+0x10>)
   83dbe:	4798      	blx	r3
   83dc0:	4603      	mov	r3, r0
   83dc2:	085b      	lsrs	r3, r3, #1
}
   83dc4:	4618      	mov	r0, r3
   83dc6:	bd80      	pop	{r7, pc}
   83dc8:	00083d9d 	.word	0x00083d9d

00083dcc <spi_reset>:
 * \brief Reset SPI and set it to Slave mode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_reset(Spi *p_spi)
{
   83dcc:	b480      	push	{r7}
   83dce:	b083      	sub	sp, #12
   83dd0:	af00      	add	r7, sp, #0
   83dd2:	6078      	str	r0, [r7, #4]
	p_spi->SPI_CR = SPI_CR_SWRST;
   83dd4:	687b      	ldr	r3, [r7, #4]
   83dd6:	2280      	movs	r2, #128	; 0x80
   83dd8:	601a      	str	r2, [r3, #0]
}
   83dda:	370c      	adds	r7, #12
   83ddc:	46bd      	mov	sp, r7
   83dde:	f85d 7b04 	ldr.w	r7, [sp], #4
   83de2:	4770      	bx	lr

00083de4 <spi_enable>:
 * \brief Enable SPI.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_enable(Spi *p_spi)
{
   83de4:	b480      	push	{r7}
   83de6:	b083      	sub	sp, #12
   83de8:	af00      	add	r7, sp, #0
   83dea:	6078      	str	r0, [r7, #4]
	p_spi->SPI_CR = SPI_CR_SPIEN;
   83dec:	687b      	ldr	r3, [r7, #4]
   83dee:	2201      	movs	r2, #1
   83df0:	601a      	str	r2, [r3, #0]
}
   83df2:	370c      	adds	r7, #12
   83df4:	46bd      	mov	sp, r7
   83df6:	f85d 7b04 	ldr.w	r7, [sp], #4
   83dfa:	4770      	bx	lr

00083dfc <spi_set_master_mode>:
 * \brief Set SPI to Master mode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_set_master_mode(Spi *p_spi)
{
   83dfc:	b480      	push	{r7}
   83dfe:	b083      	sub	sp, #12
   83e00:	af00      	add	r7, sp, #0
   83e02:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR |= SPI_MR_MSTR;
   83e04:	687b      	ldr	r3, [r7, #4]
   83e06:	685b      	ldr	r3, [r3, #4]
   83e08:	f043 0201 	orr.w	r2, r3, #1
   83e0c:	687b      	ldr	r3, [r7, #4]
   83e0e:	605a      	str	r2, [r3, #4]
}
   83e10:	370c      	adds	r7, #12
   83e12:	46bd      	mov	sp, r7
   83e14:	f85d 7b04 	ldr.w	r7, [sp], #4
   83e18:	4770      	bx	lr
   83e1a:	bf00      	nop

00083e1c <spi_set_variable_peripheral_select>:
 * Peripheral Chip Select can be controlled by SPI_TDR.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_set_variable_peripheral_select(Spi *p_spi)
{
   83e1c:	b480      	push	{r7}
   83e1e:	b083      	sub	sp, #12
   83e20:	af00      	add	r7, sp, #0
   83e22:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR |= SPI_MR_PS;
   83e24:	687b      	ldr	r3, [r7, #4]
   83e26:	685b      	ldr	r3, [r3, #4]
   83e28:	f043 0202 	orr.w	r2, r3, #2
   83e2c:	687b      	ldr	r3, [r7, #4]
   83e2e:	605a      	str	r2, [r3, #4]
}
   83e30:	370c      	adds	r7, #12
   83e32:	46bd      	mov	sp, r7
   83e34:	f85d 7b04 	ldr.w	r7, [sp], #4
   83e38:	4770      	bx	lr
   83e3a:	bf00      	nop

00083e3c <spi_disable_peripheral_select_decode>:
 * \brief Disable Peripheral Select Decode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_peripheral_select_decode(Spi *p_spi)
{
   83e3c:	b480      	push	{r7}
   83e3e:	b083      	sub	sp, #12
   83e40:	af00      	add	r7, sp, #0
   83e42:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR &= (~SPI_MR_PCSDEC);
   83e44:	687b      	ldr	r3, [r7, #4]
   83e46:	685b      	ldr	r3, [r3, #4]
   83e48:	f023 0204 	bic.w	r2, r3, #4
   83e4c:	687b      	ldr	r3, [r7, #4]
   83e4e:	605a      	str	r2, [r3, #4]
}
   83e50:	370c      	adds	r7, #12
   83e52:	46bd      	mov	sp, r7
   83e54:	f85d 7b04 	ldr.w	r7, [sp], #4
   83e58:	4770      	bx	lr
   83e5a:	bf00      	nop

00083e5c <spi_disable_mode_fault_detect>:
 * \brief Disable Mode Fault Detection.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_mode_fault_detect(Spi *p_spi)
{
   83e5c:	b480      	push	{r7}
   83e5e:	b083      	sub	sp, #12
   83e60:	af00      	add	r7, sp, #0
   83e62:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR |= SPI_MR_MODFDIS;
   83e64:	687b      	ldr	r3, [r7, #4]
   83e66:	685b      	ldr	r3, [r3, #4]
   83e68:	f043 0210 	orr.w	r2, r3, #16
   83e6c:	687b      	ldr	r3, [r7, #4]
   83e6e:	605a      	str	r2, [r3, #4]
}
   83e70:	370c      	adds	r7, #12
   83e72:	46bd      	mov	sp, r7
   83e74:	f85d 7b04 	ldr.w	r7, [sp], #4
   83e78:	4770      	bx	lr
   83e7a:	bf00      	nop

00083e7c <spi_disable_loopback>:
 * \brief Disable loopback mode.
 *
 * \param p_spi Pointer to an SPI instance.
 */
static inline void spi_disable_loopback(Spi *p_spi)
{
   83e7c:	b480      	push	{r7}
   83e7e:	b083      	sub	sp, #12
   83e80:	af00      	add	r7, sp, #0
   83e82:	6078      	str	r0, [r7, #4]
	p_spi->SPI_MR &= (~SPI_MR_LLB);
   83e84:	687b      	ldr	r3, [r7, #4]
   83e86:	685b      	ldr	r3, [r3, #4]
   83e88:	f023 0280 	bic.w	r2, r3, #128	; 0x80
   83e8c:	687b      	ldr	r3, [r7, #4]
   83e8e:	605a      	str	r2, [r3, #4]
}
   83e90:	370c      	adds	r7, #12
   83e92:	46bd      	mov	sp, r7
   83e94:	f85d 7b04 	ldr.w	r7, [sp], #4
   83e98:	4770      	bx	lr
   83e9a:	bf00      	nop

00083e9c <spi_read_status>:
 * \param p_spi Pointer to an SPI instance.
 *
 * \return SPI status register value.
 */
static inline uint32_t spi_read_status(Spi *p_spi)
{
   83e9c:	b480      	push	{r7}
   83e9e:	b083      	sub	sp, #12
   83ea0:	af00      	add	r7, sp, #0
   83ea2:	6078      	str	r0, [r7, #4]
	return p_spi->SPI_SR;
   83ea4:	687b      	ldr	r3, [r7, #4]
   83ea6:	691b      	ldr	r3, [r3, #16]
}
   83ea8:	4618      	mov	r0, r3
   83eaa:	370c      	adds	r7, #12
   83eac:	46bd      	mov	sp, r7
   83eae:	f85d 7b04 	ldr.w	r7, [sp], #4
   83eb2:	4770      	bx	lr

00083eb4 <SPI0_Handler>:
/* SPI_HANDLER				                                            */
/* @Purpose: This interrupt handler is to be used when the OBC is set up*/
/* to be a slave on the SPI bus.										*/
/************************************************************************/
void SPI_Handler(void)
{
   83eb4:	b580      	push	{r7, lr}
   83eb6:	b082      	sub	sp, #8
   83eb8:	af00      	add	r7, sp, #0
	static uint16_t data;
	uint8_t uc_pcs;
	uint32_t* reg_ptr = (uint32_t*)0x4000800C;		// SPI_TDR (SPI0)
   83eba:	4b0c      	ldr	r3, [pc, #48]	; (83eec <SPI0_Handler+0x38>)
   83ebc:	607b      	str	r3, [r7, #4]

	if (spi_read_status(SPI_SLAVE_BASE) & SPI_SR_RDRF) 
   83ebe:	480c      	ldr	r0, [pc, #48]	; (83ef0 <SPI0_Handler+0x3c>)
   83ec0:	4b0c      	ldr	r3, [pc, #48]	; (83ef4 <SPI0_Handler+0x40>)
   83ec2:	4798      	blx	r3
   83ec4:	4603      	mov	r3, r0
   83ec6:	f003 0301 	and.w	r3, r3, #1
   83eca:	2b00      	cmp	r3, #0
   83ecc:	d00b      	beq.n	83ee6 <SPI0_Handler+0x32>
	{
		spi_read(SPI_SLAVE_BASE, &data, &uc_pcs);	// SPI message is put into the 16-bit data variable.		
   83ece:	1cfb      	adds	r3, r7, #3
   83ed0:	4807      	ldr	r0, [pc, #28]	; (83ef0 <SPI0_Handler+0x3c>)
   83ed2:	4909      	ldr	r1, [pc, #36]	; (83ef8 <SPI0_Handler+0x44>)
   83ed4:	461a      	mov	r2, r3
   83ed6:	4b09      	ldr	r3, [pc, #36]	; (83efc <SPI0_Handler+0x48>)
   83ed8:	4798      	blx	r3
		*reg_ptr |= 0x00BB;		// transfer 0xFF back to the SSM.
   83eda:	687b      	ldr	r3, [r7, #4]
   83edc:	681b      	ldr	r3, [r3, #0]
   83ede:	f043 02bb 	orr.w	r2, r3, #187	; 0xbb
   83ee2:	687b      	ldr	r3, [r7, #4]
   83ee4:	601a      	str	r2, [r3, #0]
	}
}
   83ee6:	3708      	adds	r7, #8
   83ee8:	46bd      	mov	sp, r7
   83eea:	bd80      	pop	{r7, pc}
   83eec:	4000800c 	.word	0x4000800c
   83ef0:	40008000 	.word	0x40008000
   83ef4:	00083e9d 	.word	0x00083e9d
   83ef8:	20070bc0 	.word	0x20070bc0
   83efc:	00080211 	.word	0x00080211

00083f00 <spi_master_initialize>:
/************************************************************************/
/* SPI_MASTER_INITIALIZE				                                */
/* @Purpose: Initializes the OBC as a SPI master.						*/
/************************************************************************/
static void spi_master_initialize(void)
{
   83f00:	b590      	push	{r4, r7, lr}
   83f02:	b085      	sub	sp, #20
   83f04:	af00      	add	r7, sp, #0
	/* Configure an SPI peripheral. */
	uint32_t spi_chip_sel, spi_clk_freq, spi_clk_pol, spi_clk_pha;
	spi_enable_clock(SPI_MASTER_BASE);
   83f06:	4859      	ldr	r0, [pc, #356]	; (8406c <spi_master_initialize+0x16c>)
   83f08:	4b59      	ldr	r3, [pc, #356]	; (84070 <spi_master_initialize+0x170>)
   83f0a:	4798      	blx	r3
	spi_reset(SPI_MASTER_BASE);
   83f0c:	4857      	ldr	r0, [pc, #348]	; (8406c <spi_master_initialize+0x16c>)
   83f0e:	4b59      	ldr	r3, [pc, #356]	; (84074 <spi_master_initialize+0x174>)
   83f10:	4798      	blx	r3
	spi_set_master_mode(SPI_MASTER_BASE);
   83f12:	4856      	ldr	r0, [pc, #344]	; (8406c <spi_master_initialize+0x16c>)
   83f14:	4b58      	ldr	r3, [pc, #352]	; (84078 <spi_master_initialize+0x178>)
   83f16:	4798      	blx	r3
	spi_disable_mode_fault_detect(SPI_MASTER_BASE);
   83f18:	4854      	ldr	r0, [pc, #336]	; (8406c <spi_master_initialize+0x16c>)
   83f1a:	4b58      	ldr	r3, [pc, #352]	; (8407c <spi_master_initialize+0x17c>)
   83f1c:	4798      	blx	r3
	spi_disable_loopback(SPI_MASTER_BASE);
   83f1e:	4853      	ldr	r0, [pc, #332]	; (8406c <spi_master_initialize+0x16c>)
   83f20:	4b57      	ldr	r3, [pc, #348]	; (84080 <spi_master_initialize+0x180>)
   83f22:	4798      	blx	r3

	spi_set_peripheral_chip_select_value(SPI_MASTER_BASE, spi_get_pcs(2));	// This sets the value of PCS within the Mode Register.
   83f24:	4851      	ldr	r0, [pc, #324]	; (8406c <spi_master_initialize+0x16c>)
   83f26:	210b      	movs	r1, #11
   83f28:	4b56      	ldr	r3, [pc, #344]	; (84084 <spi_master_initialize+0x184>)
   83f2a:	4798      	blx	r3
	spi_set_variable_peripheral_select(SPI_MASTER_BASE);					// PCS needs to be set within each transfer (PCS within SPI_TDR).
   83f2c:	484f      	ldr	r0, [pc, #316]	; (8406c <spi_master_initialize+0x16c>)
   83f2e:	4b56      	ldr	r3, [pc, #344]	; (84088 <spi_master_initialize+0x188>)
   83f30:	4798      	blx	r3
	spi_disable_peripheral_select_decode(SPI_MASTER_BASE);					// Each CS is to be connected to a single device.
   83f32:	484e      	ldr	r0, [pc, #312]	; (8406c <spi_master_initialize+0x16c>)
   83f34:	4b55      	ldr	r3, [pc, #340]	; (8408c <spi_master_initialize+0x18c>)
   83f36:	4798      	blx	r3
	spi_set_delay_between_chip_select(SPI_MASTER_BASE, SPI_DLYBCS);
   83f38:	484c      	ldr	r0, [pc, #304]	; (8406c <spi_master_initialize+0x16c>)
   83f3a:	2100      	movs	r1, #0
   83f3c:	4b54      	ldr	r3, [pc, #336]	; (84090 <spi_master_initialize+0x190>)
   83f3e:	4798      	blx	r3

	/* Set communication parameters for CS0	*/
	spi_chip_sel = 0;
   83f40:	2300      	movs	r3, #0
   83f42:	60fb      	str	r3, [r7, #12]
	spi_clk_freq = 100000;
   83f44:	4b53      	ldr	r3, [pc, #332]	; (84094 <spi_master_initialize+0x194>)
   83f46:	60bb      	str	r3, [r7, #8]
	spi_clk_pol = 1;
   83f48:	2301      	movs	r3, #1
   83f4a:	607b      	str	r3, [r7, #4]
	spi_clk_pha = 0;
   83f4c:	2300      	movs	r3, #0
   83f4e:	603b      	str	r3, [r7, #0]
	spi_set_transfer_delay(SPI_MASTER_BASE, spi_chip_sel, SPI_DLYBS,
   83f50:	4846      	ldr	r0, [pc, #280]	; (8406c <spi_master_initialize+0x16c>)
   83f52:	68f9      	ldr	r1, [r7, #12]
   83f54:	2200      	movs	r2, #0
   83f56:	2302      	movs	r3, #2
   83f58:	4c4f      	ldr	r4, [pc, #316]	; (84098 <spi_master_initialize+0x198>)
   83f5a:	47a0      	blx	r4
			SPI_DLYBCT);
	spi_set_bits_per_transfer(SPI_MASTER_BASE, spi_chip_sel, SPI_CSR_BITS_16_BIT);
   83f5c:	4843      	ldr	r0, [pc, #268]	; (8406c <spi_master_initialize+0x16c>)
   83f5e:	68f9      	ldr	r1, [r7, #12]
   83f60:	2280      	movs	r2, #128	; 0x80
   83f62:	4b4e      	ldr	r3, [pc, #312]	; (8409c <spi_master_initialize+0x19c>)
   83f64:	4798      	blx	r3
	spi_set_baudrate_div(SPI_MASTER_BASE, spi_chip_sel, spi_calc_baudrate_div(spi_clk_freq, sysclk_get_cpu_hz())); 
   83f66:	4b4e      	ldr	r3, [pc, #312]	; (840a0 <spi_master_initialize+0x1a0>)
   83f68:	4798      	blx	r3
   83f6a:	4603      	mov	r3, r0
   83f6c:	68b8      	ldr	r0, [r7, #8]
   83f6e:	4619      	mov	r1, r3
   83f70:	4b4c      	ldr	r3, [pc, #304]	; (840a4 <spi_master_initialize+0x1a4>)
   83f72:	4798      	blx	r3
   83f74:	4603      	mov	r3, r0
   83f76:	b2db      	uxtb	r3, r3
   83f78:	483c      	ldr	r0, [pc, #240]	; (8406c <spi_master_initialize+0x16c>)
   83f7a:	68f9      	ldr	r1, [r7, #12]
   83f7c:	461a      	mov	r2, r3
   83f7e:	4b4a      	ldr	r3, [pc, #296]	; (840a8 <spi_master_initialize+0x1a8>)
   83f80:	4798      	blx	r3
	spi_configure_cs_behavior(SPI_MASTER_BASE, spi_chip_sel, SPI_CS_RISE_FORCED);		// CS rises after SPI transfers have completed.
   83f82:	483a      	ldr	r0, [pc, #232]	; (8406c <spi_master_initialize+0x16c>)
   83f84:	68f9      	ldr	r1, [r7, #12]
   83f86:	2204      	movs	r2, #4
   83f88:	4b48      	ldr	r3, [pc, #288]	; (840ac <spi_master_initialize+0x1ac>)
   83f8a:	4798      	blx	r3
	spi_set_clock_polarity(SPI_MASTER_BASE, spi_chip_sel, spi_clk_pol);
   83f8c:	4837      	ldr	r0, [pc, #220]	; (8406c <spi_master_initialize+0x16c>)
   83f8e:	68f9      	ldr	r1, [r7, #12]
   83f90:	687a      	ldr	r2, [r7, #4]
   83f92:	4b47      	ldr	r3, [pc, #284]	; (840b0 <spi_master_initialize+0x1b0>)
   83f94:	4798      	blx	r3
	spi_set_clock_phase(SPI_MASTER_BASE, spi_chip_sel, spi_clk_pha);
   83f96:	4835      	ldr	r0, [pc, #212]	; (8406c <spi_master_initialize+0x16c>)
   83f98:	68f9      	ldr	r1, [r7, #12]
   83f9a:	683a      	ldr	r2, [r7, #0]
   83f9c:	4b45      	ldr	r3, [pc, #276]	; (840b4 <spi_master_initialize+0x1b4>)
   83f9e:	4798      	blx	r3
	
	/* Set communication parameters for CS1	*/ // Currently being used for RTC
	spi_chip_sel = 1;
   83fa0:	2301      	movs	r3, #1
   83fa2:	60fb      	str	r3, [r7, #12]
	spi_clk_freq = 2000000;	// SPI CLK for RTC = 4MHz.
   83fa4:	4b44      	ldr	r3, [pc, #272]	; (840b8 <spi_master_initialize+0x1b8>)
   83fa6:	60bb      	str	r3, [r7, #8]
	spi_clk_pol = 1;
   83fa8:	2301      	movs	r3, #1
   83faa:	607b      	str	r3, [r7, #4]
	spi_clk_pha = 0;
   83fac:	2300      	movs	r3, #0
   83fae:	603b      	str	r3, [r7, #0]
	spi_set_transfer_delay(SPI_MASTER_BASE, spi_chip_sel, 0x45,
   83fb0:	482e      	ldr	r0, [pc, #184]	; (8406c <spi_master_initialize+0x16c>)
   83fb2:	68f9      	ldr	r1, [r7, #12]
   83fb4:	2245      	movs	r2, #69	; 0x45
   83fb6:	2302      	movs	r3, #2
   83fb8:	4c37      	ldr	r4, [pc, #220]	; (84098 <spi_master_initialize+0x198>)
   83fba:	47a0      	blx	r4
	0x02);
	spi_set_bits_per_transfer(SPI_MASTER_BASE, spi_chip_sel, SPI_CSR_BITS_16_BIT);
   83fbc:	482b      	ldr	r0, [pc, #172]	; (8406c <spi_master_initialize+0x16c>)
   83fbe:	68f9      	ldr	r1, [r7, #12]
   83fc0:	2280      	movs	r2, #128	; 0x80
   83fc2:	4b36      	ldr	r3, [pc, #216]	; (8409c <spi_master_initialize+0x19c>)
   83fc4:	4798      	blx	r3
	spi_set_baudrate_div(SPI_MASTER_BASE, spi_chip_sel, spi_calc_baudrate_div(spi_clk_freq, sysclk_get_cpu_hz()));
   83fc6:	4b36      	ldr	r3, [pc, #216]	; (840a0 <spi_master_initialize+0x1a0>)
   83fc8:	4798      	blx	r3
   83fca:	4603      	mov	r3, r0
   83fcc:	68b8      	ldr	r0, [r7, #8]
   83fce:	4619      	mov	r1, r3
   83fd0:	4b34      	ldr	r3, [pc, #208]	; (840a4 <spi_master_initialize+0x1a4>)
   83fd2:	4798      	blx	r3
   83fd4:	4603      	mov	r3, r0
   83fd6:	b2db      	uxtb	r3, r3
   83fd8:	4824      	ldr	r0, [pc, #144]	; (8406c <spi_master_initialize+0x16c>)
   83fda:	68f9      	ldr	r1, [r7, #12]
   83fdc:	461a      	mov	r2, r3
   83fde:	4b32      	ldr	r3, [pc, #200]	; (840a8 <spi_master_initialize+0x1a8>)
   83fe0:	4798      	blx	r3
	spi_configure_cs_behavior(SPI_MASTER_BASE, spi_chip_sel, SPI_CS_KEEP_LOW);
   83fe2:	4822      	ldr	r0, [pc, #136]	; (8406c <spi_master_initialize+0x16c>)
   83fe4:	68f9      	ldr	r1, [r7, #12]
   83fe6:	2208      	movs	r2, #8
   83fe8:	4b30      	ldr	r3, [pc, #192]	; (840ac <spi_master_initialize+0x1ac>)
   83fea:	4798      	blx	r3
	spi_set_clock_polarity(SPI_MASTER_BASE, spi_chip_sel, spi_clk_pol);
   83fec:	481f      	ldr	r0, [pc, #124]	; (8406c <spi_master_initialize+0x16c>)
   83fee:	68f9      	ldr	r1, [r7, #12]
   83ff0:	687a      	ldr	r2, [r7, #4]
   83ff2:	4b2f      	ldr	r3, [pc, #188]	; (840b0 <spi_master_initialize+0x1b0>)
   83ff4:	4798      	blx	r3
	spi_set_clock_phase(SPI_MASTER_BASE, spi_chip_sel, spi_clk_pha);
   83ff6:	481d      	ldr	r0, [pc, #116]	; (8406c <spi_master_initialize+0x16c>)
   83ff8:	68f9      	ldr	r1, [r7, #12]
   83ffa:	683a      	ldr	r2, [r7, #0]
   83ffc:	4b2d      	ldr	r3, [pc, #180]	; (840b4 <spi_master_initialize+0x1b4>)
   83ffe:	4798      	blx	r3
	
	/* Set communication parameters for CS2	*/ // Currently being used for SPIMEM
	spi_chip_sel = 2;
   84000:	2302      	movs	r3, #2
   84002:	60fb      	str	r3, [r7, #12]
	spi_clk_freq = 44000000;	// SPI CLK for MEM2 = 44MHz.
   84004:	4b2d      	ldr	r3, [pc, #180]	; (840bc <spi_master_initialize+0x1bc>)
   84006:	60bb      	str	r3, [r7, #8]
	spi_clk_pol = 1;
   84008:	2301      	movs	r3, #1
   8400a:	607b      	str	r3, [r7, #4]
	spi_clk_pha = 0;
   8400c:	2300      	movs	r3, #0
   8400e:	603b      	str	r3, [r7, #0]
	spi_set_transfer_delay(SPI_MASTER_BASE, spi_chip_sel, SPI_DLYBS,
   84010:	4816      	ldr	r0, [pc, #88]	; (8406c <spi_master_initialize+0x16c>)
   84012:	68f9      	ldr	r1, [r7, #12]
   84014:	2200      	movs	r2, #0
   84016:	2302      	movs	r3, #2
   84018:	4c1f      	ldr	r4, [pc, #124]	; (84098 <spi_master_initialize+0x198>)
   8401a:	47a0      	blx	r4
	SPI_DLYBCT);
	spi_set_bits_per_transfer(SPI_MASTER_BASE, spi_chip_sel, SPI_CSR_BITS_8_BIT);
   8401c:	4813      	ldr	r0, [pc, #76]	; (8406c <spi_master_initialize+0x16c>)
   8401e:	68f9      	ldr	r1, [r7, #12]
   84020:	2200      	movs	r2, #0
   84022:	4b1e      	ldr	r3, [pc, #120]	; (8409c <spi_master_initialize+0x19c>)
   84024:	4798      	blx	r3
	spi_set_baudrate_div(SPI_MASTER_BASE, spi_chip_sel, spi_calc_baudrate_div(spi_clk_freq, sysclk_get_cpu_hz()));
   84026:	4b1e      	ldr	r3, [pc, #120]	; (840a0 <spi_master_initialize+0x1a0>)
   84028:	4798      	blx	r3
   8402a:	4603      	mov	r3, r0
   8402c:	68b8      	ldr	r0, [r7, #8]
   8402e:	4619      	mov	r1, r3
   84030:	4b1c      	ldr	r3, [pc, #112]	; (840a4 <spi_master_initialize+0x1a4>)
   84032:	4798      	blx	r3
   84034:	4603      	mov	r3, r0
   84036:	b2db      	uxtb	r3, r3
   84038:	480c      	ldr	r0, [pc, #48]	; (8406c <spi_master_initialize+0x16c>)
   8403a:	68f9      	ldr	r1, [r7, #12]
   8403c:	461a      	mov	r2, r3
   8403e:	4b1a      	ldr	r3, [pc, #104]	; (840a8 <spi_master_initialize+0x1a8>)
   84040:	4798      	blx	r3
	spi_configure_cs_behavior(SPI_MASTER_BASE, spi_chip_sel, SPI_CS_KEEP_LOW);
   84042:	480a      	ldr	r0, [pc, #40]	; (8406c <spi_master_initialize+0x16c>)
   84044:	68f9      	ldr	r1, [r7, #12]
   84046:	2208      	movs	r2, #8
   84048:	4b18      	ldr	r3, [pc, #96]	; (840ac <spi_master_initialize+0x1ac>)
   8404a:	4798      	blx	r3
	spi_set_clock_polarity(SPI_MASTER_BASE, spi_chip_sel, spi_clk_pol);
   8404c:	4807      	ldr	r0, [pc, #28]	; (8406c <spi_master_initialize+0x16c>)
   8404e:	68f9      	ldr	r1, [r7, #12]
   84050:	687a      	ldr	r2, [r7, #4]
   84052:	4b17      	ldr	r3, [pc, #92]	; (840b0 <spi_master_initialize+0x1b0>)
   84054:	4798      	blx	r3
	spi_set_clock_phase(SPI_MASTER_BASE, spi_chip_sel, spi_clk_pha);
   84056:	4805      	ldr	r0, [pc, #20]	; (8406c <spi_master_initialize+0x16c>)
   84058:	68f9      	ldr	r1, [r7, #12]
   8405a:	683a      	ldr	r2, [r7, #0]
   8405c:	4b15      	ldr	r3, [pc, #84]	; (840b4 <spi_master_initialize+0x1b4>)
   8405e:	4798      	blx	r3
	
	/* Enable SPI Communication */
	spi_enable(SPI_MASTER_BASE);
   84060:	4802      	ldr	r0, [pc, #8]	; (8406c <spi_master_initialize+0x16c>)
   84062:	4b17      	ldr	r3, [pc, #92]	; (840c0 <spi_master_initialize+0x1c0>)
   84064:	4798      	blx	r3
}
   84066:	3714      	adds	r7, #20
   84068:	46bd      	mov	sp, r7
   8406a:	bd90      	pop	{r4, r7, pc}
   8406c:	40008000 	.word	0x40008000
   84070:	00080189 	.word	0x00080189
   84074:	00083dcd 	.word	0x00083dcd
   84078:	00083dfd 	.word	0x00083dfd
   8407c:	00083e5d 	.word	0x00083e5d
   84080:	00083e7d 	.word	0x00083e7d
   84084:	000801ad 	.word	0x000801ad
   84088:	00083e1d 	.word	0x00083e1d
   8408c:	00083e3d 	.word	0x00083e3d
   84090:	000801e1 	.word	0x000801e1
   84094:	000186a0 	.word	0x000186a0
   84098:	00080511 	.word	0x00080511
   8409c:	00080439 	.word	0x00080439
   840a0:	00083db9 	.word	0x00083db9
   840a4:	00080481 	.word	0x00080481
   840a8:	000804c1 	.word	0x000804c1
   840ac:	00080395 	.word	0x00080395
   840b0:	000802f5 	.word	0x000802f5
   840b4:	00080345 	.word	0x00080345
   840b8:	001e8480 	.word	0x001e8480
   840bc:	029f6300 	.word	0x029f6300
   840c0:	00083de5 	.word	0x00083de5

000840c4 <spi_master_transfer>:
/* @param: chip_sel: (0|1|2|3) determines which hardware chipselect is	*/
/* being used. Each CS has it's own SPI settings.						*/
/* @NOTE: CS will be kept low for the duration of these transfers.		*/
/************************************************************************/
void spi_master_transfer(void *p_buf, uint32_t size, uint8_t chip_sel)
{
   840c4:	b590      	push	{r4, r7, lr}
   840c6:	b089      	sub	sp, #36	; 0x24
   840c8:	af00      	add	r7, sp, #0
   840ca:	60f8      	str	r0, [r7, #12]
   840cc:	60b9      	str	r1, [r7, #8]
   840ce:	4613      	mov	r3, r2
   840d0:	71fb      	strb	r3, [r7, #7]
	uint32_t i = 0;
   840d2:	2300      	movs	r3, #0
   840d4:	61fb      	str	r3, [r7, #28]
	uint8_t pcs;
	pcs = spi_get_pcs(chip_sel);
   840d6:	79fb      	ldrb	r3, [r7, #7]
   840d8:	2201      	movs	r2, #1
   840da:	fa02 f303 	lsl.w	r3, r2, r3
   840de:	b2db      	uxtb	r3, r3
   840e0:	43db      	mvns	r3, r3
   840e2:	b2db      	uxtb	r3, r3
   840e4:	f003 030f 	and.w	r3, r3, #15
   840e8:	b2db      	uxtb	r3, r3
   840ea:	75fb      	strb	r3, [r7, #23]
	uint16_t data;
	//uint8_t	timeout = 84;	// ~1us timeout for getting the read status back.

	uint16_t *p_buffer;

	p_buffer = p_buf;
   840ec:	68fb      	ldr	r3, [r7, #12]
   840ee:	61bb      	str	r3, [r7, #24]
	
	if(size == 1)	// Only transfer a single message.
   840f0:	68bb      	ldr	r3, [r7, #8]
   840f2:	2b01      	cmp	r3, #1
   840f4:	d124      	bne.n	84140 <spi_master_transfer+0x7c>
	{
		spi_write(SPI_MASTER_BASE, p_buffer[i], pcs, 1);
   840f6:	69fb      	ldr	r3, [r7, #28]
   840f8:	005b      	lsls	r3, r3, #1
   840fa:	69ba      	ldr	r2, [r7, #24]
   840fc:	4413      	add	r3, r2
   840fe:	881a      	ldrh	r2, [r3, #0]
   84100:	7dfb      	ldrb	r3, [r7, #23]
   84102:	4841      	ldr	r0, [pc, #260]	; (84208 <spi_master_transfer+0x144>)
   84104:	4611      	mov	r1, r2
   84106:	461a      	mov	r2, r3
   84108:	2301      	movs	r3, #1
   8410a:	4c40      	ldr	r4, [pc, #256]	; (8420c <spi_master_transfer+0x148>)
   8410c:	47a0      	blx	r4
		// The last parameter above tells SPI whether this is the last byte to be transferred.
		/* Wait transfer done. */
		while ((spi_read_status(SPI_MASTER_BASE) & SPI_SR_RDRF) == 0);
   8410e:	bf00      	nop
   84110:	483d      	ldr	r0, [pc, #244]	; (84208 <spi_master_transfer+0x144>)
   84112:	4b3f      	ldr	r3, [pc, #252]	; (84210 <spi_master_transfer+0x14c>)
   84114:	4798      	blx	r3
   84116:	4603      	mov	r3, r0
   84118:	f003 0301 	and.w	r3, r3, #1
   8411c:	2b00      	cmp	r3, #0
   8411e:	d0f7      	beq.n	84110 <spi_master_transfer+0x4c>
		spi_read(SPI_MASTER_BASE, &data, &pcs);
   84120:	f107 0214 	add.w	r2, r7, #20
   84124:	f107 0317 	add.w	r3, r7, #23
   84128:	4837      	ldr	r0, [pc, #220]	; (84208 <spi_master_transfer+0x144>)
   8412a:	4611      	mov	r1, r2
   8412c:	461a      	mov	r2, r3
   8412e:	4b39      	ldr	r3, [pc, #228]	; (84214 <spi_master_transfer+0x150>)
   84130:	4798      	blx	r3
		p_buffer[i] = data;
   84132:	69fb      	ldr	r3, [r7, #28]
   84134:	005b      	lsls	r3, r3, #1
   84136:	69ba      	ldr	r2, [r7, #24]
   84138:	4413      	add	r3, r2
   8413a:	8aba      	ldrh	r2, [r7, #20]
   8413c:	801a      	strh	r2, [r3, #0]
		return;
   8413e:	e05f      	b.n	84200 <spi_master_transfer+0x13c>
	}
	
	// Keep CS low for the duration of the transfer, set high @ end.
	for (i = 0; i < (size - 1); i++) 
   84140:	2300      	movs	r3, #0
   84142:	61fb      	str	r3, [r7, #28]
   84144:	e029      	b.n	8419a <spi_master_transfer+0xd6>
	{
		spi_write(SPI_MASTER_BASE, p_buffer[i], pcs, 0);	
   84146:	69fb      	ldr	r3, [r7, #28]
   84148:	005b      	lsls	r3, r3, #1
   8414a:	69ba      	ldr	r2, [r7, #24]
   8414c:	4413      	add	r3, r2
   8414e:	881a      	ldrh	r2, [r3, #0]
   84150:	7dfb      	ldrb	r3, [r7, #23]
   84152:	482d      	ldr	r0, [pc, #180]	; (84208 <spi_master_transfer+0x144>)
   84154:	4611      	mov	r1, r2
   84156:	461a      	mov	r2, r3
   84158:	2300      	movs	r3, #0
   8415a:	4c2c      	ldr	r4, [pc, #176]	; (8420c <spi_master_transfer+0x148>)
   8415c:	47a0      	blx	r4
		/* Wait transfer done. */
		while ((spi_read_status(SPI_MASTER_BASE) & SPI_SR_RDRF) == 0);
   8415e:	bf00      	nop
   84160:	4829      	ldr	r0, [pc, #164]	; (84208 <spi_master_transfer+0x144>)
   84162:	4b2b      	ldr	r3, [pc, #172]	; (84210 <spi_master_transfer+0x14c>)
   84164:	4798      	blx	r3
   84166:	4603      	mov	r3, r0
   84168:	f003 0301 	and.w	r3, r3, #1
   8416c:	2b00      	cmp	r3, #0
   8416e:	d0f7      	beq.n	84160 <spi_master_transfer+0x9c>
		spi_read(SPI_MASTER_BASE, &data, &pcs);
   84170:	f107 0214 	add.w	r2, r7, #20
   84174:	f107 0317 	add.w	r3, r7, #23
   84178:	4823      	ldr	r0, [pc, #140]	; (84208 <spi_master_transfer+0x144>)
   8417a:	4611      	mov	r1, r2
   8417c:	461a      	mov	r2, r3
   8417e:	4b25      	ldr	r3, [pc, #148]	; (84214 <spi_master_transfer+0x150>)
   84180:	4798      	blx	r3
		p_buffer[i] = data;
   84182:	69fb      	ldr	r3, [r7, #28]
   84184:	005b      	lsls	r3, r3, #1
   84186:	69ba      	ldr	r2, [r7, #24]
   84188:	4413      	add	r3, r2
   8418a:	8aba      	ldrh	r2, [r7, #20]
   8418c:	801a      	strh	r2, [r3, #0]
		delay_us(100);
   8418e:	2064      	movs	r0, #100	; 0x64
   84190:	4b21      	ldr	r3, [pc, #132]	; (84218 <spi_master_transfer+0x154>)
   84192:	4798      	blx	r3
		p_buffer[i] = data;
		return;
	}
	
	// Keep CS low for the duration of the transfer, set high @ end.
	for (i = 0; i < (size - 1); i++) 
   84194:	69fb      	ldr	r3, [r7, #28]
   84196:	3301      	adds	r3, #1
   84198:	61fb      	str	r3, [r7, #28]
   8419a:	68bb      	ldr	r3, [r7, #8]
   8419c:	1e5a      	subs	r2, r3, #1
   8419e:	69fb      	ldr	r3, [r7, #28]
   841a0:	429a      	cmp	r2, r3
   841a2:	d8d0      	bhi.n	84146 <spi_master_transfer+0x82>
		while ((spi_read_status(SPI_MASTER_BASE) & SPI_SR_RDRF) == 0);
		spi_read(SPI_MASTER_BASE, &data, &pcs);
		p_buffer[i] = data;
		delay_us(100);
	}
	delay_us(100);
   841a4:	2064      	movs	r0, #100	; 0x64
   841a6:	4b1c      	ldr	r3, [pc, #112]	; (84218 <spi_master_transfer+0x154>)
   841a8:	4798      	blx	r3
	spi_write(SPI_MASTER_BASE, p_buffer[(size - 1)], pcs, 1);
   841aa:	68bb      	ldr	r3, [r7, #8]
   841ac:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
   841b0:	3b01      	subs	r3, #1
   841b2:	005b      	lsls	r3, r3, #1
   841b4:	69ba      	ldr	r2, [r7, #24]
   841b6:	4413      	add	r3, r2
   841b8:	881a      	ldrh	r2, [r3, #0]
   841ba:	7dfb      	ldrb	r3, [r7, #23]
   841bc:	4812      	ldr	r0, [pc, #72]	; (84208 <spi_master_transfer+0x144>)
   841be:	4611      	mov	r1, r2
   841c0:	461a      	mov	r2, r3
   841c2:	2301      	movs	r3, #1
   841c4:	4c11      	ldr	r4, [pc, #68]	; (8420c <spi_master_transfer+0x148>)
   841c6:	47a0      	blx	r4
	/* Wait transfer done. */
	while ((spi_read_status(SPI_MASTER_BASE) & SPI_SR_RDRF) == 0);
   841c8:	bf00      	nop
   841ca:	480f      	ldr	r0, [pc, #60]	; (84208 <spi_master_transfer+0x144>)
   841cc:	4b10      	ldr	r3, [pc, #64]	; (84210 <spi_master_transfer+0x14c>)
   841ce:	4798      	blx	r3
   841d0:	4603      	mov	r3, r0
   841d2:	f003 0301 	and.w	r3, r3, #1
   841d6:	2b00      	cmp	r3, #0
   841d8:	d0f7      	beq.n	841ca <spi_master_transfer+0x106>
	spi_read(SPI_MASTER_BASE, &data, &pcs);
   841da:	f107 0214 	add.w	r2, r7, #20
   841de:	f107 0317 	add.w	r3, r7, #23
   841e2:	4809      	ldr	r0, [pc, #36]	; (84208 <spi_master_transfer+0x144>)
   841e4:	4611      	mov	r1, r2
   841e6:	461a      	mov	r2, r3
   841e8:	4b0a      	ldr	r3, [pc, #40]	; (84214 <spi_master_transfer+0x150>)
   841ea:	4798      	blx	r3
	p_buffer[(size - 1)] = data;
   841ec:	68bb      	ldr	r3, [r7, #8]
   841ee:	f103 4300 	add.w	r3, r3, #2147483648	; 0x80000000
   841f2:	3b01      	subs	r3, #1
   841f4:	005b      	lsls	r3, r3, #1
   841f6:	69ba      	ldr	r2, [r7, #24]
   841f8:	4413      	add	r3, r2
   841fa:	8aba      	ldrh	r2, [r7, #20]
   841fc:	801a      	strh	r2, [r3, #0]
	return;
   841fe:	bf00      	nop
}
   84200:	3724      	adds	r7, #36	; 0x24
   84202:	46bd      	mov	sp, r7
   84204:	bd90      	pop	{r4, r7, pc}
   84206:	bf00      	nop
   84208:	40008000 	.word	0x40008000
   8420c:	00080281 	.word	0x00080281
   84210:	00083e9d 	.word	0x00083e9d
   84214:	00080211 	.word	0x00080211
   84218:	0008425d 	.word	0x0008425d

0008421c <spi_initialize>:
/************************************************************************/
/* SPI_INITIALIZE						                                */
/* @Purpose: Initializes SPI registers for the OBC.						*/
/************************************************************************/
void spi_initialize(void)
{
   8421c:	b580      	push	{r7, lr}
   8421e:	af00      	add	r7, sp, #0
	//uint32_t* reg_ptr = 0x4000800C;		// SPI_TDR (SPI0)
	//*reg_ptr |= 0x00BB;
	//spi_slave_initialize();
	spi_master_initialize();
   84220:	4b01      	ldr	r3, [pc, #4]	; (84228 <spi_initialize+0xc>)
   84222:	4798      	blx	r3

	return;
   84224:	bf00      	nop
}
   84226:	bd80      	pop	{r7, pc}
   84228:	00083f01 	.word	0x00083f01

0008422c <delay_ms>:
	while(timeout--){ }
	return;
}

void delay_ms(uint32_t ms)
{
   8422c:	b480      	push	{r7}
   8422e:	b085      	sub	sp, #20
   84230:	af00      	add	r7, sp, #0
   84232:	6078      	str	r0, [r7, #4]
	uint32_t timeout = ms * 84000;	// Number of clock cycles needed 
   84234:	687b      	ldr	r3, [r7, #4]
   84236:	4a08      	ldr	r2, [pc, #32]	; (84258 <delay_ms+0x2c>)
   84238:	fb02 f303 	mul.w	r3, r2, r3
   8423c:	60fb      	str	r3, [r7, #12]
	while(timeout--){ }
   8423e:	bf00      	nop
   84240:	68fb      	ldr	r3, [r7, #12]
   84242:	1e5a      	subs	r2, r3, #1
   84244:	60fa      	str	r2, [r7, #12]
   84246:	2b00      	cmp	r3, #0
   84248:	d1fa      	bne.n	84240 <delay_ms+0x14>
	return;
   8424a:	bf00      	nop
}
   8424c:	3714      	adds	r7, #20
   8424e:	46bd      	mov	sp, r7
   84250:	f85d 7b04 	ldr.w	r7, [sp], #4
   84254:	4770      	bx	lr
   84256:	bf00      	nop
   84258:	00014820 	.word	0x00014820

0008425c <delay_us>:

void delay_us(uint32_t us)
{
   8425c:	b480      	push	{r7}
   8425e:	b085      	sub	sp, #20
   84260:	af00      	add	r7, sp, #0
   84262:	6078      	str	r0, [r7, #4]
	uint32_t timeout = us * 84;	// Number of clock cycles needed
   84264:	687b      	ldr	r3, [r7, #4]
   84266:	2254      	movs	r2, #84	; 0x54
   84268:	fb02 f303 	mul.w	r3, r2, r3
   8426c:	60fb      	str	r3, [r7, #12]
	while(timeout--){ }
   8426e:	bf00      	nop
   84270:	68fb      	ldr	r3, [r7, #12]
   84272:	1e5a      	subs	r2, r3, #1
   84274:	60fa      	str	r2, [r7, #12]
   84276:	2b00      	cmp	r3, #0
   84278:	d1fa      	bne.n	84270 <delay_us+0x14>
	return;
   8427a:	bf00      	nop
}
   8427c:	3714      	adds	r7, #20
   8427e:	46bd      	mov	sp, r7
   84280:	f85d 7b04 	ldr.w	r7, [sp], #4
   84284:	4770      	bx	lr
   84286:	bf00      	nop

00084288 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
   84288:	b480      	push	{r7}
   8428a:	b083      	sub	sp, #12
   8428c:	af00      	add	r7, sp, #0
   8428e:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
   84290:	687b      	ldr	r3, [r7, #4]
   84292:	2b07      	cmp	r3, #7
   84294:	d825      	bhi.n	842e2 <osc_get_rate+0x5a>
   84296:	a201      	add	r2, pc, #4	; (adr r2, 8429c <osc_get_rate+0x14>)
   84298:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   8429c:	000842bd 	.word	0x000842bd
   842a0:	000842c3 	.word	0x000842c3
   842a4:	000842c9 	.word	0x000842c9
   842a8:	000842cf 	.word	0x000842cf
   842ac:	000842d3 	.word	0x000842d3
   842b0:	000842d7 	.word	0x000842d7
   842b4:	000842db 	.word	0x000842db
   842b8:	000842df 	.word	0x000842df
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
   842bc:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
   842c0:	e010      	b.n	842e4 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
   842c2:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   842c6:	e00d      	b.n	842e4 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
   842c8:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   842cc:	e00a      	b.n	842e4 <osc_get_rate+0x5c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
   842ce:	4b08      	ldr	r3, [pc, #32]	; (842f0 <osc_get_rate+0x68>)
   842d0:	e008      	b.n	842e4 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
   842d2:	4b08      	ldr	r3, [pc, #32]	; (842f4 <osc_get_rate+0x6c>)
   842d4:	e006      	b.n	842e4 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
   842d6:	4b08      	ldr	r3, [pc, #32]	; (842f8 <osc_get_rate+0x70>)
   842d8:	e004      	b.n	842e4 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
   842da:	4b07      	ldr	r3, [pc, #28]	; (842f8 <osc_get_rate+0x70>)
   842dc:	e002      	b.n	842e4 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
   842de:	4b06      	ldr	r3, [pc, #24]	; (842f8 <osc_get_rate+0x70>)
   842e0:	e000      	b.n	842e4 <osc_get_rate+0x5c>
#endif
	}

	return 0;
   842e2:	2300      	movs	r3, #0
}
   842e4:	4618      	mov	r0, r3
   842e6:	370c      	adds	r7, #12
   842e8:	46bd      	mov	sp, r7
   842ea:	f85d 7b04 	ldr.w	r7, [sp], #4
   842ee:	4770      	bx	lr
   842f0:	003d0900 	.word	0x003d0900
   842f4:	007a1200 	.word	0x007a1200
   842f8:	00b71b00 	.word	0x00b71b00

000842fc <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
   842fc:	b580      	push	{r7, lr}
   842fe:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
   84300:	2006      	movs	r0, #6
   84302:	4b04      	ldr	r3, [pc, #16]	; (84314 <sysclk_get_main_hz+0x18>)
   84304:	4798      	blx	r3
   84306:	4602      	mov	r2, r0
   84308:	4613      	mov	r3, r2
   8430a:	00db      	lsls	r3, r3, #3
   8430c:	1a9b      	subs	r3, r3, r2
   8430e:	005b      	lsls	r3, r3, #1
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
   84310:	4618      	mov	r0, r3
   84312:	bd80      	pop	{r7, pc}
   84314:	00084289 	.word	0x00084289

00084318 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
   84318:	b580      	push	{r7, lr}
   8431a:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
   8431c:	4b02      	ldr	r3, [pc, #8]	; (84328 <sysclk_get_cpu_hz+0x10>)
   8431e:	4798      	blx	r3
   84320:	4603      	mov	r3, r0
   84322:	085b      	lsrs	r3, r3, #1
}
   84324:	4618      	mov	r0, r3
   84326:	bd80      	pop	{r7, pc}
   84328:	000842fd 	.word	0x000842fd

0008432c <sysclk_enable_peripheral_clock>:
 * \brief Enable a peripheral's clock.
 *
 * \param ul_id Id (number) of the peripheral clock.
 */
static inline void sysclk_enable_peripheral_clock(uint32_t ul_id)
{
   8432c:	b580      	push	{r7, lr}
   8432e:	b082      	sub	sp, #8
   84330:	af00      	add	r7, sp, #0
   84332:	6078      	str	r0, [r7, #4]
	pmc_enable_periph_clk(ul_id);
   84334:	6878      	ldr	r0, [r7, #4]
   84336:	4b02      	ldr	r3, [pc, #8]	; (84340 <sysclk_enable_peripheral_clock+0x14>)
   84338:	4798      	blx	r3
}
   8433a:	3708      	adds	r7, #8
   8433c:	46bd      	mov	sp, r7
   8433e:	bd80      	pop	{r7, pc}
   84340:	00085b29 	.word	0x00085b29

00084344 <USART0_Handler>:
/* USART_HANDLER						                                */
/* @Purpose: Interrupt handler for USART. Echo the bytes received and	*/
/* start the next receive.												*/
/************************************************************************/
void USART_Handler(void)
{
   84344:	b580      	push	{r7, lr}
   84346:	b084      	sub	sp, #16
   84348:	af00      	add	r7, sp, #0
	uint32_t ul_status;
	uint32_t new_char = 0;	// For ease of reading, I have created this variable.
   8434a:	2300      	movs	r3, #0
   8434c:	60bb      	str	r3, [r7, #8]
	uint8_t command_completed = 0;
   8434e:	2300      	movs	r3, #0
   84350:	73fb      	strb	r3, [r7, #15]
	uint8_t i = 0;
   84352:	2300      	movs	r3, #0
   84354:	73bb      	strb	r3, [r7, #14]

	/* Read USART Status. */
	ul_status = usart_get_status(BOARD_USART);
   84356:	483b      	ldr	r0, [pc, #236]	; (84444 <USART0_Handler+0x100>)
   84358:	4b3b      	ldr	r3, [pc, #236]	; (84448 <USART0_Handler+0x104>)
   8435a:	4798      	blx	r3
   8435c:	6078      	str	r0, [r7, #4]
	
	pio_toggle_pin(LED4_GPIO);
   8435e:	2058      	movs	r0, #88	; 0x58
   84360:	4b3a      	ldr	r3, [pc, #232]	; (8444c <USART0_Handler+0x108>)
   84362:	4798      	blx	r3

	if (gs_uc_trans_mode == BYTE_TRANSFER)
   84364:	4b3a      	ldr	r3, [pc, #232]	; (84450 <USART0_Handler+0x10c>)
   84366:	781b      	ldrb	r3, [r3, #0]
   84368:	2b00      	cmp	r3, #0
   8436a:	d167      	bne.n	8443c <USART0_Handler+0xf8>
	{
		/* Transfer without PDC. */
		if (ul_status & US_CSR_RXRDY) 
   8436c:	687b      	ldr	r3, [r7, #4]
   8436e:	f003 0301 	and.w	r3, r3, #1
   84372:	2b00      	cmp	r3, #0
   84374:	d062      	beq.n	8443c <USART0_Handler+0xf8>
		{
			usart_getchar(BOARD_USART, (uint32_t *)&gs_ul_read_buffer);
   84376:	4833      	ldr	r0, [pc, #204]	; (84444 <USART0_Handler+0x100>)
   84378:	4936      	ldr	r1, [pc, #216]	; (84454 <USART0_Handler+0x110>)
   8437a:	4b37      	ldr	r3, [pc, #220]	; (84458 <USART0_Handler+0x114>)
   8437c:	4798      	blx	r3
			new_char = gs_ul_read_buffer;
   8437e:	4b35      	ldr	r3, [pc, #212]	; (84454 <USART0_Handler+0x110>)
   84380:	681b      	ldr	r3, [r3, #0]
   84382:	60bb      	str	r3, [r7, #8]
			
			if (new_char == 0x31)									// The character '1' was received, start "listening".
   84384:	68bb      	ldr	r3, [r7, #8]
   84386:	2b31      	cmp	r3, #49	; 0x31
   84388:	d102      	bne.n	84390 <USART0_Handler+0x4c>
				command_start = 1;
   8438a:	4b34      	ldr	r3, [pc, #208]	; (8445c <USART0_Handler+0x118>)
   8438c:	2201      	movs	r2, #1
   8438e:	701a      	strb	r2, [r3, #0]
				
			if (new_char == 0x32)									// The character '2' was received, execute command.
   84390:	68bb      	ldr	r3, [r7, #8]
   84392:	2b32      	cmp	r3, #50	; 0x32
   84394:	d102      	bne.n	8439c <USART0_Handler+0x58>
				command_end = 1;
   84396:	4b32      	ldr	r3, [pc, #200]	; (84460 <USART0_Handler+0x11c>)
   84398:	2201      	movs	r2, #1
   8439a:	701a      	strb	r2, [r3, #0]
				
			if ((command_start == 1) && (new_char != 0) && (new_char != 0x31) && new_char != 0x32)			// Since we are listening, we store the new characters.
   8439c:	4b2f      	ldr	r3, [pc, #188]	; (8445c <USART0_Handler+0x118>)
   8439e:	781b      	ldrb	r3, [r3, #0]
   843a0:	2b01      	cmp	r3, #1
   843a2:	d11e      	bne.n	843e2 <USART0_Handler+0x9e>
   843a4:	68bb      	ldr	r3, [r7, #8]
   843a6:	2b00      	cmp	r3, #0
   843a8:	d01b      	beq.n	843e2 <USART0_Handler+0x9e>
   843aa:	68bb      	ldr	r3, [r7, #8]
   843ac:	2b31      	cmp	r3, #49	; 0x31
   843ae:	d018      	beq.n	843e2 <USART0_Handler+0x9e>
   843b0:	68bb      	ldr	r3, [r7, #8]
   843b2:	2b32      	cmp	r3, #50	; 0x32
   843b4:	d015      	beq.n	843e2 <USART0_Handler+0x9e>
			{
				command_array[array_pos % 10] = new_char;
   843b6:	4b2b      	ldr	r3, [pc, #172]	; (84464 <USART0_Handler+0x120>)
   843b8:	781a      	ldrb	r2, [r3, #0]
   843ba:	4b2b      	ldr	r3, [pc, #172]	; (84468 <USART0_Handler+0x124>)
   843bc:	fba3 1302 	umull	r1, r3, r3, r2
   843c0:	08d9      	lsrs	r1, r3, #3
   843c2:	460b      	mov	r3, r1
   843c4:	009b      	lsls	r3, r3, #2
   843c6:	440b      	add	r3, r1
   843c8:	005b      	lsls	r3, r3, #1
   843ca:	1ad3      	subs	r3, r2, r3
   843cc:	b2db      	uxtb	r3, r3
   843ce:	68ba      	ldr	r2, [r7, #8]
   843d0:	b2d1      	uxtb	r1, r2
   843d2:	4a26      	ldr	r2, [pc, #152]	; (8446c <USART0_Handler+0x128>)
   843d4:	54d1      	strb	r1, [r2, r3]
				array_pos ++;
   843d6:	4b23      	ldr	r3, [pc, #140]	; (84464 <USART0_Handler+0x120>)
   843d8:	781b      	ldrb	r3, [r3, #0]
   843da:	3301      	adds	r3, #1
   843dc:	b2da      	uxtb	r2, r3
   843de:	4b21      	ldr	r3, [pc, #132]	; (84464 <USART0_Handler+0x120>)
   843e0:	701a      	strb	r2, [r3, #0]
			}
			// '1' and '2' were both received, execute command.
			if ((command_end == 1) && (command_start == 1))
   843e2:	4b1f      	ldr	r3, [pc, #124]	; (84460 <USART0_Handler+0x11c>)
   843e4:	781b      	ldrb	r3, [r3, #0]
   843e6:	2b01      	cmp	r3, #1
   843e8:	d11d      	bne.n	84426 <USART0_Handler+0xe2>
   843ea:	4b1c      	ldr	r3, [pc, #112]	; (8445c <USART0_Handler+0x118>)
   843ec:	781b      	ldrb	r3, [r3, #0]
   843ee:	2b01      	cmp	r3, #1
   843f0:	d119      	bne.n	84426 <USART0_Handler+0xe2>
			{
				// Check command function.
				check_command();
   843f2:	4b1f      	ldr	r3, [pc, #124]	; (84470 <USART0_Handler+0x12c>)
   843f4:	4798      	blx	r3
				command_end = 0;
   843f6:	4b1a      	ldr	r3, [pc, #104]	; (84460 <USART0_Handler+0x11c>)
   843f8:	2200      	movs	r2, #0
   843fa:	701a      	strb	r2, [r3, #0]
				command_start = 0;
   843fc:	4b17      	ldr	r3, [pc, #92]	; (8445c <USART0_Handler+0x118>)
   843fe:	2200      	movs	r2, #0
   84400:	701a      	strb	r2, [r3, #0]
				array_pos = 0;
   84402:	4b18      	ldr	r3, [pc, #96]	; (84464 <USART0_Handler+0x120>)
   84404:	2200      	movs	r2, #0
   84406:	701a      	strb	r2, [r3, #0]
					
				for (i = 0; i < 10; i ++)
   84408:	2300      	movs	r3, #0
   8440a:	73bb      	strb	r3, [r7, #14]
   8440c:	e006      	b.n	8441c <USART0_Handler+0xd8>
				{
					command_array[i] = 0;
   8440e:	7bbb      	ldrb	r3, [r7, #14]
   84410:	4a16      	ldr	r2, [pc, #88]	; (8446c <USART0_Handler+0x128>)
   84412:	2100      	movs	r1, #0
   84414:	54d1      	strb	r1, [r2, r3]
				check_command();
				command_end = 0;
				command_start = 0;
				array_pos = 0;
					
				for (i = 0; i < 10; i ++)
   84416:	7bbb      	ldrb	r3, [r7, #14]
   84418:	3301      	adds	r3, #1
   8441a:	73bb      	strb	r3, [r7, #14]
   8441c:	7bbb      	ldrb	r3, [r7, #14]
   8441e:	2b09      	cmp	r3, #9
   84420:	d9f5      	bls.n	8440e <USART0_Handler+0xca>
				{
					command_array[i] = 0;
				}
				command_completed = 1;
   84422:	2301      	movs	r3, #1
   84424:	73fb      	strb	r3, [r7, #15]
			}

			if (!command_completed)				
   84426:	7bfb      	ldrb	r3, [r7, #15]
   84428:	2b00      	cmp	r3, #0
   8442a:	d105      	bne.n	84438 <USART0_Handler+0xf4>
				usart_write(BOARD_USART, gs_ul_read_buffer);
   8442c:	4b09      	ldr	r3, [pc, #36]	; (84454 <USART0_Handler+0x110>)
   8442e:	681b      	ldr	r3, [r3, #0]
   84430:	4804      	ldr	r0, [pc, #16]	; (84444 <USART0_Handler+0x100>)
   84432:	4619      	mov	r1, r3
   84434:	4b0f      	ldr	r3, [pc, #60]	; (84474 <USART0_Handler+0x130>)
   84436:	4798      	blx	r3
					
			command_completed = 0;
   84438:	2300      	movs	r3, #0
   8443a:	73fb      	strb	r3, [r7, #15]
				
		}
	}
}
   8443c:	3710      	adds	r7, #16
   8443e:	46bd      	mov	sp, r7
   84440:	bd80      	pop	{r7, pc}
   84442:	bf00      	nop
   84444:	40098000 	.word	0x40098000
   84448:	00085d8d 	.word	0x00085d8d
   8444c:	0008553d 	.word	0x0008553d
   84450:	20070bc8 	.word	0x20070bc8
   84454:	20070bc4 	.word	0x20070bc4
   84458:	00085e11 	.word	0x00085e11
   8445c:	20070bc9 	.word	0x20070bc9
   84460:	20070bca 	.word	0x20070bca
   84464:	20070bd8 	.word	0x20070bd8
   84468:	cccccccd 	.word	0xcccccccd
   8446c:	20070bcc 	.word	0x20070bcc
   84470:	00084479 	.word	0x00084479
   84474:	00085ddd 	.word	0x00085ddd

00084478 <check_command>:
/*		This function will check the contents of the USART command		*/
/*		which was sent via a computer terminal and determine what		*/
/*		action to take.													*/
/************************************************************************/
void check_command(void)
{	
   84478:	b580      	push	{r7, lr}
   8447a:	b088      	sub	sp, #32
   8447c:	af00      	add	r7, sp, #0
	uint32_t character = 0;
   8447e:	2300      	movs	r3, #0
   84480:	61bb      	str	r3, [r7, #24]
	uint32_t sign = 1;
   84482:	2301      	movs	r3, #1
   84484:	617b      	str	r3, [r7, #20]
	
	char* message_array;
	
	char* check_array;

	uint8_t hk = 1;
   84486:	2301      	movs	r3, #1
   84488:	74fb      	strb	r3, [r7, #19]
	uint8_t sad = 1;
   8448a:	2301      	movs	r3, #1
   8448c:	74bb      	strb	r3, [r7, #18]
	uint8_t msg = 1;
   8448e:	2301      	movs	r3, #1
   84490:	747b      	strb	r3, [r7, #17]
	
	uint32_t temp = 295.0;
   84492:	f240 1327 	movw	r3, #295	; 0x127
   84496:	603b      	str	r3, [r7, #0]
	
	uint32_t temp1;
	
	uint8_t temp_int = 25, upper, lower;
   84498:	2319      	movs	r3, #25
   8449a:	743b      	strb	r3, [r7, #16]
	
	// Housekeeping requested. "hk" was sent.
	check_array = "hk";
   8449c:	4b7e      	ldr	r3, [pc, #504]	; (84698 <check_command+0x220>)
   8449e:	60fb      	str	r3, [r7, #12]
	
	hk =  check_string(check_array);
   844a0:	68f8      	ldr	r0, [r7, #12]
   844a2:	4b7e      	ldr	r3, [pc, #504]	; (8469c <check_command+0x224>)
   844a4:	4798      	blx	r3
   844a6:	4603      	mov	r3, r0
   844a8:	74fb      	strb	r3, [r7, #19]
	
	check_array = "i am sad";
   844aa:	4b7d      	ldr	r3, [pc, #500]	; (846a0 <check_command+0x228>)
   844ac:	60fb      	str	r3, [r7, #12]
	
	sad = check_string(check_array);
   844ae:	68f8      	ldr	r0, [r7, #12]
   844b0:	4b7a      	ldr	r3, [pc, #488]	; (8469c <check_command+0x224>)
   844b2:	4798      	blx	r3
   844b4:	4603      	mov	r3, r0
   844b6:	74bb      	strb	r3, [r7, #18]
	
	check_array = "msg";
   844b8:	4b7a      	ldr	r3, [pc, #488]	; (846a4 <check_command+0x22c>)
   844ba:	60fb      	str	r3, [r7, #12]
	
	msg = check_string(check_array);
   844bc:	68f8      	ldr	r0, [r7, #12]
   844be:	4b77      	ldr	r3, [pc, #476]	; (8469c <check_command+0x224>)
   844c0:	4798      	blx	r3
   844c2:	4603      	mov	r3, r0
   844c4:	747b      	strb	r3, [r7, #17]
	
	if (hk == 1)
   844c6:	7cfb      	ldrb	r3, [r7, #19]
   844c8:	2b01      	cmp	r3, #1
   844ca:	f040 8088 	bne.w	845de <check_command+0x166>
	{	
		
		message_array = "\n\rSYSTEMS ARE NOMINAL, SIR.\n\r";
   844ce:	4b76      	ldr	r3, [pc, #472]	; (846a8 <check_command+0x230>)
   844d0:	61fb      	str	r3, [r7, #28]
				
		while(*message_array)
   844d2:	e00d      	b.n	844f0 <check_command+0x78>
		{
			character = *message_array;
   844d4:	69fb      	ldr	r3, [r7, #28]
   844d6:	781b      	ldrb	r3, [r3, #0]
   844d8:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));	// Send the character.
   844da:	bf00      	nop
   844dc:	4873      	ldr	r0, [pc, #460]	; (846ac <check_command+0x234>)
   844de:	69b9      	ldr	r1, [r7, #24]
   844e0:	4b73      	ldr	r3, [pc, #460]	; (846b0 <check_command+0x238>)
   844e2:	4798      	blx	r3
   844e4:	4603      	mov	r3, r0
   844e6:	2b00      	cmp	r3, #0
   844e8:	d1f8      	bne.n	844dc <check_command+0x64>
			
			message_array++;
   844ea:	69fb      	ldr	r3, [r7, #28]
   844ec:	3301      	adds	r3, #1
   844ee:	61fb      	str	r3, [r7, #28]
	if (hk == 1)
	{	
		
		message_array = "\n\rSYSTEMS ARE NOMINAL, SIR.\n\r";
				
		while(*message_array)
   844f0:	69fb      	ldr	r3, [r7, #28]
   844f2:	781b      	ldrb	r3, [r3, #0]
   844f4:	2b00      	cmp	r3, #0
   844f6:	d1ed      	bne.n	844d4 <check_command+0x5c>
			while(usart_write(BOARD_USART, character));	// Send the character.
			
			message_array++;
		}
		
		message_array = "\n\rSUBSYSTEM TEMPERATURE IS ";
   844f8:	4b6e      	ldr	r3, [pc, #440]	; (846b4 <check_command+0x23c>)
   844fa:	61fb      	str	r3, [r7, #28]
		
		while(*message_array)
   844fc:	e00d      	b.n	8451a <check_command+0xa2>
		{
			character = *message_array;
   844fe:	69fb      	ldr	r3, [r7, #28]
   84500:	781b      	ldrb	r3, [r3, #0]
   84502:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));	// Send the character.
   84504:	bf00      	nop
   84506:	4869      	ldr	r0, [pc, #420]	; (846ac <check_command+0x234>)
   84508:	69b9      	ldr	r1, [r7, #24]
   8450a:	4b69      	ldr	r3, [pc, #420]	; (846b0 <check_command+0x238>)
   8450c:	4798      	blx	r3
   8450e:	4603      	mov	r3, r0
   84510:	2b00      	cmp	r3, #0
   84512:	d1f8      	bne.n	84506 <check_command+0x8e>
			
			message_array++;
   84514:	69fb      	ldr	r3, [r7, #28]
   84516:	3301      	adds	r3, #1
   84518:	61fb      	str	r3, [r7, #28]
			message_array++;
		}
		
		message_array = "\n\rSUBSYSTEM TEMPERATURE IS ";
		
		while(*message_array)
   8451a:	69fb      	ldr	r3, [r7, #28]
   8451c:	781b      	ldrb	r3, [r3, #0]
   8451e:	2b00      	cmp	r3, #0
   84520:	d1ed      	bne.n	844fe <check_command+0x86>
			while(usart_write(BOARD_USART, character));	// Send the character.
			
			message_array++;
		}
		
		temp = glob_stored_data[0];						// This is the ADC value retrieved from the subsystem.
   84522:	4b65      	ldr	r3, [pc, #404]	; (846b8 <check_command+0x240>)
   84524:	681b      	ldr	r3, [r3, #0]
   84526:	603b      	str	r3, [r7, #0]
			
		sign = convert_to_temp(&temp);						// Temperature returned is in degrees Celsius.
   84528:	463b      	mov	r3, r7
   8452a:	4618      	mov	r0, r3
   8452c:	4b63      	ldr	r3, [pc, #396]	; (846bc <check_command+0x244>)
   8452e:	4798      	blx	r3
   84530:	6178      	str	r0, [r7, #20]

		temp_int = (uint8_t)temp;						// Convert the float to an 8-bit integer.
   84532:	683b      	ldr	r3, [r7, #0]
   84534:	743b      	strb	r3, [r7, #16]
		
		temp_int = convert_to_bcd(temp_int);				// Convert the temperature into a BCD.
   84536:	7c3b      	ldrb	r3, [r7, #16]
   84538:	4618      	mov	r0, r3
   8453a:	4b61      	ldr	r3, [pc, #388]	; (846c0 <check_command+0x248>)
   8453c:	4798      	blx	r3
   8453e:	4603      	mov	r3, r0
   84540:	743b      	strb	r3, [r7, #16]
		
		lower = temp_int << 4;
   84542:	7c3b      	ldrb	r3, [r7, #16]
   84544:	011b      	lsls	r3, r3, #4
   84546:	72fb      	strb	r3, [r7, #11]
		lower = lower >> 4;
   84548:	7afb      	ldrb	r3, [r7, #11]
   8454a:	091b      	lsrs	r3, r3, #4
   8454c:	72fb      	strb	r3, [r7, #11]
		upper = temp_int >> 4;
   8454e:	7c3b      	ldrb	r3, [r7, #16]
   84550:	091b      	lsrs	r3, r3, #4
   84552:	72bb      	strb	r3, [r7, #10]
		
		lower += (uint8_t)0x30;								// Convert to ASCII form.
   84554:	7afb      	ldrb	r3, [r7, #11]
   84556:	3330      	adds	r3, #48	; 0x30
   84558:	72fb      	strb	r3, [r7, #11]
		upper += (uint8_t)0x30;
   8455a:	7abb      	ldrb	r3, [r7, #10]
   8455c:	3330      	adds	r3, #48	; 0x30
   8455e:	72bb      	strb	r3, [r7, #10]
		
		if(sign)
   84560:	697b      	ldr	r3, [r7, #20]
   84562:	2b00      	cmp	r3, #0
   84564:	d00a      	beq.n	8457c <check_command+0x104>
		{
			character = 0x2B;
   84566:	232b      	movs	r3, #43	; 0x2b
   84568:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));				// Send "+"
   8456a:	bf00      	nop
   8456c:	484f      	ldr	r0, [pc, #316]	; (846ac <check_command+0x234>)
   8456e:	69b9      	ldr	r1, [r7, #24]
   84570:	4b4f      	ldr	r3, [pc, #316]	; (846b0 <check_command+0x238>)
   84572:	4798      	blx	r3
   84574:	4603      	mov	r3, r0
   84576:	2b00      	cmp	r3, #0
   84578:	d1f8      	bne.n	8456c <check_command+0xf4>
		{
			character = 0x2D;
			while(usart_write(BOARD_USART, character));				// Send "-"
		}
	
		while(usart_write(BOARD_USART, upper));				// Send the upper digit.
   8457a:	e009      	b.n	84590 <check_command+0x118>
			character = 0x2B;
			while(usart_write(BOARD_USART, character));				// Send "+"
		}
		else
		{
			character = 0x2D;
   8457c:	232d      	movs	r3, #45	; 0x2d
   8457e:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));				// Send "-"
   84580:	bf00      	nop
   84582:	484a      	ldr	r0, [pc, #296]	; (846ac <check_command+0x234>)
   84584:	69b9      	ldr	r1, [r7, #24]
   84586:	4b4a      	ldr	r3, [pc, #296]	; (846b0 <check_command+0x238>)
   84588:	4798      	blx	r3
   8458a:	4603      	mov	r3, r0
   8458c:	2b00      	cmp	r3, #0
   8458e:	d1f8      	bne.n	84582 <check_command+0x10a>
		}
	
		while(usart_write(BOARD_USART, upper));				// Send the upper digit.
   84590:	bf00      	nop
   84592:	7abb      	ldrb	r3, [r7, #10]
   84594:	4845      	ldr	r0, [pc, #276]	; (846ac <check_command+0x234>)
   84596:	4619      	mov	r1, r3
   84598:	4b45      	ldr	r3, [pc, #276]	; (846b0 <check_command+0x238>)
   8459a:	4798      	blx	r3
   8459c:	4603      	mov	r3, r0
   8459e:	2b00      	cmp	r3, #0
   845a0:	d1f7      	bne.n	84592 <check_command+0x11a>
		while(usart_write(BOARD_USART, lower));				// Send the lower digit.			
   845a2:	bf00      	nop
   845a4:	7afb      	ldrb	r3, [r7, #11]
   845a6:	4841      	ldr	r0, [pc, #260]	; (846ac <check_command+0x234>)
   845a8:	4619      	mov	r1, r3
   845aa:	4b41      	ldr	r3, [pc, #260]	; (846b0 <check_command+0x238>)
   845ac:	4798      	blx	r3
   845ae:	4603      	mov	r3, r0
   845b0:	2b00      	cmp	r3, #0
   845b2:	d1f7      	bne.n	845a4 <check_command+0x12c>
		
		message_array = " C\n\r";							// Finish the sentence.
   845b4:	4b43      	ldr	r3, [pc, #268]	; (846c4 <check_command+0x24c>)
   845b6:	61fb      	str	r3, [r7, #28]

		while(*message_array)
   845b8:	e00d      	b.n	845d6 <check_command+0x15e>
		{
			character = *message_array;
   845ba:	69fb      	ldr	r3, [r7, #28]
   845bc:	781b      	ldrb	r3, [r3, #0]
   845be:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));	// Send the character.
   845c0:	bf00      	nop
   845c2:	483a      	ldr	r0, [pc, #232]	; (846ac <check_command+0x234>)
   845c4:	69b9      	ldr	r1, [r7, #24]
   845c6:	4b3a      	ldr	r3, [pc, #232]	; (846b0 <check_command+0x238>)
   845c8:	4798      	blx	r3
   845ca:	4603      	mov	r3, r0
   845cc:	2b00      	cmp	r3, #0
   845ce:	d1f8      	bne.n	845c2 <check_command+0x14a>
			
			message_array++;
   845d0:	69fb      	ldr	r3, [r7, #28]
   845d2:	3301      	adds	r3, #1
   845d4:	61fb      	str	r3, [r7, #28]
		while(usart_write(BOARD_USART, upper));				// Send the upper digit.
		while(usart_write(BOARD_USART, lower));				// Send the lower digit.			
		
		message_array = " C\n\r";							// Finish the sentence.

		while(*message_array)
   845d6:	69fb      	ldr	r3, [r7, #28]
   845d8:	781b      	ldrb	r3, [r3, #0]
   845da:	2b00      	cmp	r3, #0
   845dc:	d1ed      	bne.n	845ba <check_command+0x142>
			
			message_array++;
		}	
	}
	
	if (sad == 1)
   845de:	7cbb      	ldrb	r3, [r7, #18]
   845e0:	2b01      	cmp	r3, #1
   845e2:	d114      	bne.n	8460e <check_command+0x196>
	{	
		
		message_array = "\n\rDO YOU WANT A BISCUIT?\n\r";
   845e4:	4b38      	ldr	r3, [pc, #224]	; (846c8 <check_command+0x250>)
   845e6:	61fb      	str	r3, [r7, #28]
		
		while(*message_array)
   845e8:	e00d      	b.n	84606 <check_command+0x18e>
		{
			character = *message_array;
   845ea:	69fb      	ldr	r3, [r7, #28]
   845ec:	781b      	ldrb	r3, [r3, #0]
   845ee:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));	// Send the character.
   845f0:	bf00      	nop
   845f2:	482e      	ldr	r0, [pc, #184]	; (846ac <check_command+0x234>)
   845f4:	69b9      	ldr	r1, [r7, #24]
   845f6:	4b2e      	ldr	r3, [pc, #184]	; (846b0 <check_command+0x238>)
   845f8:	4798      	blx	r3
   845fa:	4603      	mov	r3, r0
   845fc:	2b00      	cmp	r3, #0
   845fe:	d1f8      	bne.n	845f2 <check_command+0x17a>
			
			message_array++;
   84600:	69fb      	ldr	r3, [r7, #28]
   84602:	3301      	adds	r3, #1
   84604:	61fb      	str	r3, [r7, #28]
	if (sad == 1)
	{	
		
		message_array = "\n\rDO YOU WANT A BISCUIT?\n\r";
		
		while(*message_array)
   84606:	69fb      	ldr	r3, [r7, #28]
   84608:	781b      	ldrb	r3, [r3, #0]
   8460a:	2b00      	cmp	r3, #0
   8460c:	d1ed      	bne.n	845ea <check_command+0x172>
			
			message_array++;
		}
	}
	
	if (msg == 1)
   8460e:	7c7b      	ldrb	r3, [r7, #17]
   84610:	2b01      	cmp	r3, #1
   84612:	d13d      	bne.n	84690 <check_command+0x218>
	{
		
		message_array = "\n\rA MESSAGE WAS RECEIVED FROM COMS: ";
   84614:	4b2d      	ldr	r3, [pc, #180]	; (846cc <check_command+0x254>)
   84616:	61fb      	str	r3, [r7, #28]
		
		while(*message_array)
   84618:	e00d      	b.n	84636 <check_command+0x1be>
		{
			character = *message_array;
   8461a:	69fb      	ldr	r3, [r7, #28]
   8461c:	781b      	ldrb	r3, [r3, #0]
   8461e:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));	// Send the character.
   84620:	bf00      	nop
   84622:	4822      	ldr	r0, [pc, #136]	; (846ac <check_command+0x234>)
   84624:	69b9      	ldr	r1, [r7, #24]
   84626:	4b22      	ldr	r3, [pc, #136]	; (846b0 <check_command+0x238>)
   84628:	4798      	blx	r3
   8462a:	4603      	mov	r3, r0
   8462c:	2b00      	cmp	r3, #0
   8462e:	d1f8      	bne.n	84622 <check_command+0x1aa>
			
			message_array++;
   84630:	69fb      	ldr	r3, [r7, #28]
   84632:	3301      	adds	r3, #1
   84634:	61fb      	str	r3, [r7, #28]
	if (msg == 1)
	{
		
		message_array = "\n\rA MESSAGE WAS RECEIVED FROM COMS: ";
		
		while(*message_array)
   84636:	69fb      	ldr	r3, [r7, #28]
   84638:	781b      	ldrb	r3, [r3, #0]
   8463a:	2b00      	cmp	r3, #0
   8463c:	d1ed      	bne.n	8461a <check_command+0x1a2>
			while(usart_write(BOARD_USART, character));	// Send the character.
			
			message_array++;
		}
		
		temp1 = (uint32_t)(glob_stored_message[0]);	// This is the ADC value retrieved from the subsystem.
   8463e:	4b24      	ldr	r3, [pc, #144]	; (846d0 <check_command+0x258>)
   84640:	681b      	ldr	r3, [r3, #0]
   84642:	607b      	str	r3, [r7, #4]
		temp1 = temp1 & (uint32_t)0x000000FF;
   84644:	687b      	ldr	r3, [r7, #4]
   84646:	b2db      	uxtb	r3, r3
   84648:	607b      	str	r3, [r7, #4]
		
		if ( (temp1 > 0x40) || (temp1 < 0x5B) )
   8464a:	687b      	ldr	r3, [r7, #4]
   8464c:	2b40      	cmp	r3, #64	; 0x40
   8464e:	d802      	bhi.n	84656 <check_command+0x1de>
   84650:	687b      	ldr	r3, [r7, #4]
   84652:	2b5a      	cmp	r3, #90	; 0x5a
   84654:	d807      	bhi.n	84666 <check_command+0x1ee>
		{
			while(usart_write(BOARD_USART, temp1));				// Send the ASCII character.		
   84656:	bf00      	nop
   84658:	4814      	ldr	r0, [pc, #80]	; (846ac <check_command+0x234>)
   8465a:	6879      	ldr	r1, [r7, #4]
   8465c:	4b14      	ldr	r3, [pc, #80]	; (846b0 <check_command+0x238>)
   8465e:	4798      	blx	r3
   84660:	4603      	mov	r3, r0
   84662:	2b00      	cmp	r3, #0
   84664:	d1f8      	bne.n	84658 <check_command+0x1e0>
		//if ( (temp1 > 0x20) || (temp1 < 0x5B) )
		//{
			//while(usart_write(BOARD_USART, temp1));				// Send the ASCII character.
		//}
		
		message_array = "\n\r";								// Finish the sentence.
   84666:	4b1b      	ldr	r3, [pc, #108]	; (846d4 <check_command+0x25c>)
   84668:	61fb      	str	r3, [r7, #28]

		while(*message_array)
   8466a:	e00d      	b.n	84688 <check_command+0x210>
		{
			character = *message_array;
   8466c:	69fb      	ldr	r3, [r7, #28]
   8466e:	781b      	ldrb	r3, [r3, #0]
   84670:	61bb      	str	r3, [r7, #24]
			while(usart_write(BOARD_USART, character));	// Send the character.
   84672:	bf00      	nop
   84674:	480d      	ldr	r0, [pc, #52]	; (846ac <check_command+0x234>)
   84676:	69b9      	ldr	r1, [r7, #24]
   84678:	4b0d      	ldr	r3, [pc, #52]	; (846b0 <check_command+0x238>)
   8467a:	4798      	blx	r3
   8467c:	4603      	mov	r3, r0
   8467e:	2b00      	cmp	r3, #0
   84680:	d1f8      	bne.n	84674 <check_command+0x1fc>
			
			message_array++;
   84682:	69fb      	ldr	r3, [r7, #28]
   84684:	3301      	adds	r3, #1
   84686:	61fb      	str	r3, [r7, #28]
			//while(usart_write(BOARD_USART, temp1));				// Send the ASCII character.
		//}
		
		message_array = "\n\r";								// Finish the sentence.

		while(*message_array)
   84688:	69fb      	ldr	r3, [r7, #28]
   8468a:	781b      	ldrb	r3, [r3, #0]
   8468c:	2b00      	cmp	r3, #0
   8468e:	d1ed      	bne.n	8466c <check_command+0x1f4>
			
			message_array++;
		}
	}
	
	return;
   84690:	bf00      	nop
}
   84692:	3720      	adds	r7, #32
   84694:	46bd      	mov	sp, r7
   84696:	bd80      	pop	{r7, pc}
   84698:	0008b048 	.word	0x0008b048
   8469c:	000846d9 	.word	0x000846d9
   846a0:	0008b04c 	.word	0x0008b04c
   846a4:	0008b058 	.word	0x0008b058
   846a8:	0008b05c 	.word	0x0008b05c
   846ac:	40098000 	.word	0x40098000
   846b0:	00085ddd 	.word	0x00085ddd
   846b4:	0008b07c 	.word	0x0008b07c
   846b8:	2007ae08 	.word	0x2007ae08
   846bc:	00084735 	.word	0x00084735
   846c0:	000847cd 	.word	0x000847cd
   846c4:	0008b098 	.word	0x0008b098
   846c8:	0008b0a0 	.word	0x0008b0a0
   846cc:	0008b0bc 	.word	0x0008b0bc
   846d0:	2007b538 	.word	0x2007b538
   846d4:	0008b0e4 	.word	0x0008b0e4

000846d8 <check_string>:
/*		is equal to the array of chars in command_array (which is		*/
/*		defined globally.												*/	
/************************************************************************/

uint8_t check_string(char* str_to_check)
{
   846d8:	b480      	push	{r7}
   846da:	b085      	sub	sp, #20
   846dc:	af00      	add	r7, sp, #0
   846de:	6078      	str	r0, [r7, #4]
	uint8_t	i = 0;
   846e0:	2300      	movs	r3, #0
   846e2:	73fb      	strb	r3, [r7, #15]
	uint8_t ret_val = 1;
   846e4:	2301      	movs	r3, #1
   846e6:	73bb      	strb	r3, [r7, #14]
	
	char* temp_str;
	
	temp_str = str_to_check;
   846e8:	687b      	ldr	r3, [r7, #4]
   846ea:	60bb      	str	r3, [r7, #8]
	
	for (i = 0; i < 10; i++)
   846ec:	2300      	movs	r3, #0
   846ee:	73fb      	strb	r3, [r7, #15]
   846f0:	e014      	b.n	8471c <check_string+0x44>
	{
		if (*temp_str != command_array[i])
   846f2:	68bb      	ldr	r3, [r7, #8]
   846f4:	781a      	ldrb	r2, [r3, #0]
   846f6:	7bfb      	ldrb	r3, [r7, #15]
   846f8:	490d      	ldr	r1, [pc, #52]	; (84730 <check_string+0x58>)
   846fa:	5ccb      	ldrb	r3, [r1, r3]
   846fc:	429a      	cmp	r2, r3
   846fe:	d002      	beq.n	84706 <check_string+0x2e>
		{
			ret_val = 0;
   84700:	2300      	movs	r3, #0
   84702:	73bb      	strb	r3, [r7, #14]
			break;
   84704:	e00d      	b.n	84722 <check_string+0x4a>
		}
		if (!*temp_str)
   84706:	68bb      	ldr	r3, [r7, #8]
   84708:	781b      	ldrb	r3, [r3, #0]
   8470a:	2b00      	cmp	r3, #0
   8470c:	d100      	bne.n	84710 <check_string+0x38>
			break;
   8470e:	e008      	b.n	84722 <check_string+0x4a>
			
		temp_str++;
   84710:	68bb      	ldr	r3, [r7, #8]
   84712:	3301      	adds	r3, #1
   84714:	60bb      	str	r3, [r7, #8]
	
	char* temp_str;
	
	temp_str = str_to_check;
	
	for (i = 0; i < 10; i++)
   84716:	7bfb      	ldrb	r3, [r7, #15]
   84718:	3301      	adds	r3, #1
   8471a:	73fb      	strb	r3, [r7, #15]
   8471c:	7bfb      	ldrb	r3, [r7, #15]
   8471e:	2b09      	cmp	r3, #9
   84720:	d9e7      	bls.n	846f2 <check_string+0x1a>
			break;
			
		temp_str++;
	}
	
	return ret_val;
   84722:	7bbb      	ldrb	r3, [r7, #14]
}
   84724:	4618      	mov	r0, r3
   84726:	3714      	adds	r7, #20
   84728:	46bd      	mov	sp, r7
   8472a:	f85d 7b04 	ldr.w	r7, [sp], #4
   8472e:	4770      	bx	lr
   84730:	20070bcc 	.word	0x20070bcc

00084734 <convert_to_temp>:
/*		It then takes this raw reading and converts it into a positive	*/
/*		temperature reading. The function will return a 1 if the temp	*/
/*		was nonnegative, and 0 otherwise.								*/
/************************************************************************/
uint32_t convert_to_temp(uint32_t* temp)
{
   84734:	b580      	push	{r7, lr}
   84736:	b084      	sub	sp, #16
   84738:	af00      	add	r7, sp, #0
   8473a:	6078      	str	r0, [r7, #4]
	uint32_t temperature;
	float t = 0.0;
   8473c:	f04f 0300 	mov.w	r3, #0
   84740:	60fb      	str	r3, [r7, #12]
	
	temperature = *temp;
   84742:	687b      	ldr	r3, [r7, #4]
   84744:	681b      	ldr	r3, [r3, #0]
   84746:	60bb      	str	r3, [r7, #8]
	
	temperature = temperature >> 2;
   84748:	68bb      	ldr	r3, [r7, #8]
   8474a:	089b      	lsrs	r3, r3, #2
   8474c:	60bb      	str	r3, [r7, #8]
	
	t = (float)temperature;
   8474e:	4b1b      	ldr	r3, [pc, #108]	; (847bc <convert_to_temp+0x88>)
   84750:	68b8      	ldr	r0, [r7, #8]
   84752:	4798      	blx	r3
   84754:	4603      	mov	r3, r0
   84756:	60fb      	str	r3, [r7, #12]
	
	t *= 0.03125;
   84758:	4b19      	ldr	r3, [pc, #100]	; (847c0 <convert_to_temp+0x8c>)
   8475a:	68f8      	ldr	r0, [r7, #12]
   8475c:	f04f 5174 	mov.w	r1, #1023410176	; 0x3d000000
   84760:	4798      	blx	r3
   84762:	4603      	mov	r3, r0
   84764:	60fb      	str	r3, [r7, #12]
	
	t = t / (float)1.0;
	
	if (t >= (float)0.0)
   84766:	4b17      	ldr	r3, [pc, #92]	; (847c4 <convert_to_temp+0x90>)
   84768:	68f8      	ldr	r0, [r7, #12]
   8476a:	f04f 0100 	mov.w	r1, #0
   8476e:	4798      	blx	r3
   84770:	4603      	mov	r3, r0
   84772:	2b00      	cmp	r3, #0
   84774:	d009      	beq.n	8478a <convert_to_temp+0x56>
	{
		temperature = (uint32_t)t;
   84776:	4b14      	ldr	r3, [pc, #80]	; (847c8 <convert_to_temp+0x94>)
   84778:	68f8      	ldr	r0, [r7, #12]
   8477a:	4798      	blx	r3
   8477c:	4603      	mov	r3, r0
   8477e:	60bb      	str	r3, [r7, #8]
		*temp = temperature;
   84780:	687b      	ldr	r3, [r7, #4]
   84782:	68ba      	ldr	r2, [r7, #8]
   84784:	601a      	str	r2, [r3, #0]
		return 1;	
   84786:	2301      	movs	r3, #1
   84788:	e013      	b.n	847b2 <convert_to_temp+0x7e>
	}
	else
	{	
		temperature *= (float)-1.0;
   8478a:	4b0c      	ldr	r3, [pc, #48]	; (847bc <convert_to_temp+0x88>)
   8478c:	68b8      	ldr	r0, [r7, #8]
   8478e:	4798      	blx	r3
   84790:	4603      	mov	r3, r0
   84792:	f083 4200 	eor.w	r2, r3, #2147483648	; 0x80000000
   84796:	4b0c      	ldr	r3, [pc, #48]	; (847c8 <convert_to_temp+0x94>)
   84798:	4610      	mov	r0, r2
   8479a:	4798      	blx	r3
   8479c:	4603      	mov	r3, r0
   8479e:	60bb      	str	r3, [r7, #8]
		temperature = (uint32_t)t;
   847a0:	4b09      	ldr	r3, [pc, #36]	; (847c8 <convert_to_temp+0x94>)
   847a2:	68f8      	ldr	r0, [r7, #12]
   847a4:	4798      	blx	r3
   847a6:	4603      	mov	r3, r0
   847a8:	60bb      	str	r3, [r7, #8]
		*temp = temperature;
   847aa:	687b      	ldr	r3, [r7, #4]
   847ac:	68ba      	ldr	r2, [r7, #8]
   847ae:	601a      	str	r2, [r3, #0]
		return 0;
   847b0:	2300      	movs	r3, #0
	}
}
   847b2:	4618      	mov	r0, r3
   847b4:	3710      	adds	r7, #16
   847b6:	46bd      	mov	sp, r7
   847b8:	bd80      	pop	{r7, pc}
   847ba:	bf00      	nop
   847bc:	0008a881 	.word	0x0008a881
   847c0:	0008a931 	.word	0x0008a931
   847c4:	0008ac95 	.word	0x0008ac95
   847c8:	0008acbd 	.word	0x0008acbd

000847cc <convert_to_bcd>:
/*		The sole purpose of this helper function is to take an integer	*/
/*		and convert it into BCD form (upper four bits = 'tens' & the	*/
/*		lower four bits = 'ones'.										*/
/************************************************************************/
uint8_t convert_to_bcd(uint8_t temp)
{
   847cc:	b480      	push	{r7}
   847ce:	b085      	sub	sp, #20
   847d0:	af00      	add	r7, sp, #0
   847d2:	4603      	mov	r3, r0
   847d4:	71fb      	strb	r3, [r7, #7]
	uint8_t upper = 0, lower = 0, ret_val = 0;
   847d6:	2300      	movs	r3, #0
   847d8:	73fb      	strb	r3, [r7, #15]
   847da:	2300      	movs	r3, #0
   847dc:	73bb      	strb	r3, [r7, #14]
   847de:	2300      	movs	r3, #0
   847e0:	737b      	strb	r3, [r7, #13]
	
	if(temp > 9)
   847e2:	79fb      	ldrb	r3, [r7, #7]
   847e4:	2b09      	cmp	r3, #9
   847e6:	d919      	bls.n	8481c <convert_to_bcd+0x50>
	{
		lower = temp % 10;
   847e8:	79fa      	ldrb	r2, [r7, #7]
   847ea:	4b10      	ldr	r3, [pc, #64]	; (8482c <convert_to_bcd+0x60>)
   847ec:	fba3 1302 	umull	r1, r3, r3, r2
   847f0:	08d9      	lsrs	r1, r3, #3
   847f2:	460b      	mov	r3, r1
   847f4:	009b      	lsls	r3, r3, #2
   847f6:	440b      	add	r3, r1
   847f8:	005b      	lsls	r3, r3, #1
   847fa:	1ad3      	subs	r3, r2, r3
   847fc:	73bb      	strb	r3, [r7, #14]
		upper = temp / 10;
   847fe:	79fa      	ldrb	r2, [r7, #7]
   84800:	4b0a      	ldr	r3, [pc, #40]	; (8482c <convert_to_bcd+0x60>)
   84802:	fba3 1302 	umull	r1, r3, r3, r2
   84806:	08db      	lsrs	r3, r3, #3
   84808:	73fb      	strb	r3, [r7, #15]
		
		upper = upper << 4;
   8480a:	7bfb      	ldrb	r3, [r7, #15]
   8480c:	011b      	lsls	r3, r3, #4
   8480e:	73fb      	strb	r3, [r7, #15]
		
		ret_val = upper | lower;
   84810:	7bfa      	ldrb	r2, [r7, #15]
   84812:	7bbb      	ldrb	r3, [r7, #14]
   84814:	4313      	orrs	r3, r2
   84816:	737b      	strb	r3, [r7, #13]
			
		return ret_val;
   84818:	7b7b      	ldrb	r3, [r7, #13]
   8481a:	e000      	b.n	8481e <convert_to_bcd+0x52>
	}
	else
		return temp;
   8481c:	79fb      	ldrb	r3, [r7, #7]
}
   8481e:	4618      	mov	r0, r3
   84820:	3714      	adds	r7, #20
   84822:	46bd      	mov	sp, r7
   84824:	f85d 7b04 	ldr.w	r7, [sp], #4
   84828:	4770      	bx	lr
   8482a:	bf00      	nop
   8482c:	cccccccd 	.word	0xcccccccd

00084830 <usart_initialize>:
/* @Purpose: Configure USART in normal (serial rs232) mode, asynchronous*/
/* 8 bitsd, 1 stop bit, no parity, 115200 bauds and enable its transmit	*/
/* & receive.															*/
/************************************************************************/
void usart_initialize(void)
{
   84830:	b5b0      	push	{r4, r5, r7, lr}
   84832:	b086      	sub	sp, #24
   84834:	af00      	add	r7, sp, #0
	const sam_usart_opt_t usart_console_settings = {
   84836:	4b11      	ldr	r3, [pc, #68]	; (8487c <usart_initialize+0x4c>)
   84838:	463c      	mov	r4, r7
   8483a:	461d      	mov	r5, r3
   8483c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
   8483e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
   84840:	e895 0003 	ldmia.w	r5, {r0, r1}
   84844:	e884 0003 	stmia.w	r4, {r0, r1}
		/* This field is only used in IrDA mode. */
		0
	};

	/* Enable the peripheral clock in the PMC. */
	sysclk_enable_peripheral_clock(BOARD_ID_USART);
   84848:	2011      	movs	r0, #17
   8484a:	4b0d      	ldr	r3, [pc, #52]	; (84880 <usart_initialize+0x50>)
   8484c:	4798      	blx	r3

	/* Configure USART in serial mode. */
	usart_init_rs232(BOARD_USART, &usart_console_settings,
   8484e:	4b0d      	ldr	r3, [pc, #52]	; (84884 <usart_initialize+0x54>)
   84850:	4798      	blx	r3
   84852:	4603      	mov	r3, r0
   84854:	463a      	mov	r2, r7
   84856:	480c      	ldr	r0, [pc, #48]	; (84888 <usart_initialize+0x58>)
   84858:	4611      	mov	r1, r2
   8485a:	461a      	mov	r2, r3
   8485c:	4b0b      	ldr	r3, [pc, #44]	; (8488c <usart_initialize+0x5c>)
   8485e:	4798      	blx	r3
	sysclk_get_cpu_hz());

	/* Disable all the interrupts. */
	usart_disable_interrupt(BOARD_USART, ALL_INTERRUPT_MASK);
   84860:	4809      	ldr	r0, [pc, #36]	; (84888 <usart_initialize+0x58>)
   84862:	f04f 31ff 	mov.w	r1, #4294967295
   84866:	4b0a      	ldr	r3, [pc, #40]	; (84890 <usart_initialize+0x60>)
   84868:	4798      	blx	r3

	/* Enable the receiver and transmitter. */
	usart_enable_tx(BOARD_USART);
   8486a:	4807      	ldr	r0, [pc, #28]	; (84888 <usart_initialize+0x58>)
   8486c:	4b09      	ldr	r3, [pc, #36]	; (84894 <usart_initialize+0x64>)
   8486e:	4798      	blx	r3
	usart_enable_rx(BOARD_USART);
   84870:	4805      	ldr	r0, [pc, #20]	; (84888 <usart_initialize+0x58>)
   84872:	4b09      	ldr	r3, [pc, #36]	; (84898 <usart_initialize+0x68>)
   84874:	4798      	blx	r3

	/* Configure and enable interrupt of USART. */
	// NVIC_EnableIRQ(USART_IRQn);
}
   84876:	3718      	adds	r7, #24
   84878:	46bd      	mov	sp, r7
   8487a:	bdb0      	pop	{r4, r5, r7, pc}
   8487c:	0008b0e8 	.word	0x0008b0e8
   84880:	0008432d 	.word	0x0008432d
   84884:	00084319 	.word	0x00084319
   84888:	40098000 	.word	0x40098000
   8488c:	00085c8d 	.word	0x00085c8d
   84890:	00085d71 	.word	0x00085d71
   84894:	00085d11 	.word	0x00085d11
   84898:	00085d41 	.word	0x00085d41

0008489c <osc_enable>:
#define OSC_MAINCK_XTAL_HZ			BOARD_FREQ_MAINCK_XTAL			//!< External crystal oscillator.
#define OSC_MAINCK_BYPASS_HZ		BOARD_FREQ_MAINCK_BYPASS		//!< External bypass oscillator.
//@}

static inline void osc_enable(uint32_t ul_id)
{
   8489c:	b580      	push	{r7, lr}
   8489e:	b082      	sub	sp, #8
   848a0:	af00      	add	r7, sp, #0
   848a2:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
   848a4:	687b      	ldr	r3, [r7, #4]
   848a6:	2b07      	cmp	r3, #7
   848a8:	d82e      	bhi.n	84908 <osc_enable+0x6c>
   848aa:	a201      	add	r2, pc, #4	; (adr r2, 848b0 <osc_enable+0x14>)
   848ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   848b0:	00084909 	.word	0x00084909
   848b4:	000848d1 	.word	0x000848d1
   848b8:	000848d9 	.word	0x000848d9
   848bc:	000848e1 	.word	0x000848e1
   848c0:	000848e9 	.word	0x000848e9
   848c4:	000848f1 	.word	0x000848f1
   848c8:	000848f9 	.word	0x000848f9
   848cc:	00084901 	.word	0x00084901
	case OSC_SLCK_32K_RC:
		break;

	case OSC_SLCK_32K_XTAL:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_XTAL);
   848d0:	2000      	movs	r0, #0
   848d2:	4b0f      	ldr	r3, [pc, #60]	; (84910 <osc_enable+0x74>)
   848d4:	4798      	blx	r3
		break;
   848d6:	e017      	b.n	84908 <osc_enable+0x6c>

	case OSC_SLCK_32K_BYPASS:
		pmc_switch_sclk_to_32kxtal(PMC_OSC_BYPASS);
   848d8:	2001      	movs	r0, #1
   848da:	4b0d      	ldr	r3, [pc, #52]	; (84910 <osc_enable+0x74>)
   848dc:	4798      	blx	r3
		break;
   848de:	e013      	b.n	84908 <osc_enable+0x6c>


	case OSC_MAINCK_4M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_4_MHz);
   848e0:	2000      	movs	r0, #0
   848e2:	4b0c      	ldr	r3, [pc, #48]	; (84914 <osc_enable+0x78>)
   848e4:	4798      	blx	r3
		break;
   848e6:	e00f      	b.n	84908 <osc_enable+0x6c>

	case OSC_MAINCK_8M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_8_MHz);
   848e8:	2010      	movs	r0, #16
   848ea:	4b0a      	ldr	r3, [pc, #40]	; (84914 <osc_enable+0x78>)
   848ec:	4798      	blx	r3
		break;
   848ee:	e00b      	b.n	84908 <osc_enable+0x6c>

	case OSC_MAINCK_12M_RC:
		pmc_switch_mainck_to_fastrc(CKGR_MOR_MOSCRCF_12_MHz);
   848f0:	2020      	movs	r0, #32
   848f2:	4b08      	ldr	r3, [pc, #32]	; (84914 <osc_enable+0x78>)
   848f4:	4798      	blx	r3
		break;
   848f6:	e007      	b.n	84908 <osc_enable+0x6c>


	case OSC_MAINCK_XTAL:
		pmc_switch_mainck_to_xtal(PMC_OSC_XTAL);
   848f8:	2000      	movs	r0, #0
   848fa:	4b07      	ldr	r3, [pc, #28]	; (84918 <osc_enable+0x7c>)
   848fc:	4798      	blx	r3
		break;
   848fe:	e003      	b.n	84908 <osc_enable+0x6c>

	case OSC_MAINCK_BYPASS:
		pmc_switch_mainck_to_xtal(PMC_OSC_BYPASS);
   84900:	2001      	movs	r0, #1
   84902:	4b05      	ldr	r3, [pc, #20]	; (84918 <osc_enable+0x7c>)
   84904:	4798      	blx	r3
		break;
   84906:	bf00      	nop
	}
}
   84908:	3708      	adds	r7, #8
   8490a:	46bd      	mov	sp, r7
   8490c:	bd80      	pop	{r7, pc}
   8490e:	bf00      	nop
   84910:	00085941 	.word	0x00085941
   84914:	000859b1 	.word	0x000859b1
   84918:	00085a51 	.word	0x00085a51

0008491c <osc_is_ready>:
		break;
	}
}

static inline bool osc_is_ready(uint32_t ul_id)
{
   8491c:	b580      	push	{r7, lr}
   8491e:	b082      	sub	sp, #8
   84920:	af00      	add	r7, sp, #0
   84922:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
   84924:	687b      	ldr	r3, [r7, #4]
   84926:	2b07      	cmp	r3, #7
   84928:	d826      	bhi.n	84978 <osc_is_ready+0x5c>
   8492a:	a201      	add	r2, pc, #4	; (adr r2, 84930 <osc_is_ready+0x14>)
   8492c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   84930:	00084951 	.word	0x00084951
   84934:	00084955 	.word	0x00084955
   84938:	00084955 	.word	0x00084955
   8493c:	00084967 	.word	0x00084967
   84940:	00084967 	.word	0x00084967
   84944:	00084967 	.word	0x00084967
   84948:	00084967 	.word	0x00084967
   8494c:	00084967 	.word	0x00084967
	case OSC_SLCK_32K_RC:
		return 1;
   84950:	2301      	movs	r3, #1
   84952:	e012      	b.n	8497a <osc_is_ready+0x5e>

	case OSC_SLCK_32K_XTAL:
	case OSC_SLCK_32K_BYPASS:
		return pmc_osc_is_ready_32kxtal();
   84954:	4b0b      	ldr	r3, [pc, #44]	; (84984 <osc_is_ready+0x68>)
   84956:	4798      	blx	r3
   84958:	4603      	mov	r3, r0
   8495a:	2b00      	cmp	r3, #0
   8495c:	bf0c      	ite	eq
   8495e:	2300      	moveq	r3, #0
   84960:	2301      	movne	r3, #1
   84962:	b2db      	uxtb	r3, r3
   84964:	e009      	b.n	8497a <osc_is_ready+0x5e>
	case OSC_MAINCK_4M_RC:
	case OSC_MAINCK_8M_RC:
	case OSC_MAINCK_12M_RC:
	case OSC_MAINCK_XTAL:
	case OSC_MAINCK_BYPASS:
		return pmc_osc_is_ready_mainck();
   84966:	4b08      	ldr	r3, [pc, #32]	; (84988 <osc_is_ready+0x6c>)
   84968:	4798      	blx	r3
   8496a:	4603      	mov	r3, r0
   8496c:	2b00      	cmp	r3, #0
   8496e:	bf0c      	ite	eq
   84970:	2300      	moveq	r3, #0
   84972:	2301      	movne	r3, #1
   84974:	b2db      	uxtb	r3, r3
   84976:	e000      	b.n	8497a <osc_is_ready+0x5e>
	}

	return 0;
   84978:	2300      	movs	r3, #0
}
   8497a:	4618      	mov	r0, r3
   8497c:	3708      	adds	r7, #8
   8497e:	46bd      	mov	sp, r7
   84980:	bd80      	pop	{r7, pc}
   84982:	bf00      	nop
   84984:	0008597d 	.word	0x0008597d
   84988:	00085abd 	.word	0x00085abd

0008498c <osc_get_rate>:

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
   8498c:	b480      	push	{r7}
   8498e:	b083      	sub	sp, #12
   84990:	af00      	add	r7, sp, #0
   84992:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
   84994:	687b      	ldr	r3, [r7, #4]
   84996:	2b07      	cmp	r3, #7
   84998:	d825      	bhi.n	849e6 <osc_get_rate+0x5a>
   8499a:	a201      	add	r2, pc, #4	; (adr r2, 849a0 <osc_get_rate+0x14>)
   8499c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   849a0:	000849c1 	.word	0x000849c1
   849a4:	000849c7 	.word	0x000849c7
   849a8:	000849cd 	.word	0x000849cd
   849ac:	000849d3 	.word	0x000849d3
   849b0:	000849d7 	.word	0x000849d7
   849b4:	000849db 	.word	0x000849db
   849b8:	000849df 	.word	0x000849df
   849bc:	000849e3 	.word	0x000849e3
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
   849c0:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
   849c4:	e010      	b.n	849e8 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
   849c6:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   849ca:	e00d      	b.n	849e8 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
   849cc:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   849d0:	e00a      	b.n	849e8 <osc_get_rate+0x5c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
   849d2:	4b08      	ldr	r3, [pc, #32]	; (849f4 <osc_get_rate+0x68>)
   849d4:	e008      	b.n	849e8 <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
   849d6:	4b08      	ldr	r3, [pc, #32]	; (849f8 <osc_get_rate+0x6c>)
   849d8:	e006      	b.n	849e8 <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
   849da:	4b08      	ldr	r3, [pc, #32]	; (849fc <osc_get_rate+0x70>)
   849dc:	e004      	b.n	849e8 <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
   849de:	4b07      	ldr	r3, [pc, #28]	; (849fc <osc_get_rate+0x70>)
   849e0:	e002      	b.n	849e8 <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
   849e2:	4b06      	ldr	r3, [pc, #24]	; (849fc <osc_get_rate+0x70>)
   849e4:	e000      	b.n	849e8 <osc_get_rate+0x5c>
#endif
	}

	return 0;
   849e6:	2300      	movs	r3, #0
}
   849e8:	4618      	mov	r0, r3
   849ea:	370c      	adds	r7, #12
   849ec:	46bd      	mov	sp, r7
   849ee:	f85d 7b04 	ldr.w	r7, [sp], #4
   849f2:	4770      	bx	lr
   849f4:	003d0900 	.word	0x003d0900
   849f8:	007a1200 	.word	0x007a1200
   849fc:	00b71b00 	.word	0x00b71b00

00084a00 <osc_wait_ready>:
 * to become stable and ready to use as a clock source.
 *
 * \param id A number identifying the oscillator to wait for.
 */
static inline void osc_wait_ready(uint8_t id)
{
   84a00:	b580      	push	{r7, lr}
   84a02:	b082      	sub	sp, #8
   84a04:	af00      	add	r7, sp, #0
   84a06:	4603      	mov	r3, r0
   84a08:	71fb      	strb	r3, [r7, #7]
	while (!osc_is_ready(id)) {
   84a0a:	bf00      	nop
   84a0c:	79fb      	ldrb	r3, [r7, #7]
   84a0e:	4618      	mov	r0, r3
   84a10:	4b05      	ldr	r3, [pc, #20]	; (84a28 <osc_wait_ready+0x28>)
   84a12:	4798      	blx	r3
   84a14:	4603      	mov	r3, r0
   84a16:	f083 0301 	eor.w	r3, r3, #1
   84a1a:	b2db      	uxtb	r3, r3
   84a1c:	2b00      	cmp	r3, #0
   84a1e:	d1f5      	bne.n	84a0c <osc_wait_ready+0xc>
		/* Do nothing */
	}
}
   84a20:	3708      	adds	r7, #8
   84a22:	46bd      	mov	sp, r7
   84a24:	bd80      	pop	{r7, pc}
   84a26:	bf00      	nop
   84a28:	0008491d 	.word	0x0008491d

00084a2c <pll_config_init>:
 * \note The SAM3X PLL hardware interprets mul as mul+1. For readability the hardware mul+1
 * is hidden in this implementation. Use mul as mul effective value.
 */
static inline void pll_config_init(struct pll_config *p_cfg,
		enum pll_source e_src, uint32_t ul_div, uint32_t ul_mul)
{
   84a2c:	b580      	push	{r7, lr}
   84a2e:	b086      	sub	sp, #24
   84a30:	af00      	add	r7, sp, #0
   84a32:	60f8      	str	r0, [r7, #12]
   84a34:	607a      	str	r2, [r7, #4]
   84a36:	603b      	str	r3, [r7, #0]
   84a38:	460b      	mov	r3, r1
   84a3a:	72fb      	strb	r3, [r7, #11]
	uint32_t vco_hz;

	Assert(e_src < PLL_NR_SOURCES);

	if (ul_div == 0 && ul_mul == 0) { /* Must only be true for UTMI PLL */
   84a3c:	687b      	ldr	r3, [r7, #4]
   84a3e:	2b00      	cmp	r3, #0
   84a40:	d107      	bne.n	84a52 <pll_config_init+0x26>
   84a42:	683b      	ldr	r3, [r7, #0]
   84a44:	2b00      	cmp	r3, #0
   84a46:	d104      	bne.n	84a52 <pll_config_init+0x26>
		p_cfg->ctrl = CKGR_UCKR_UPLLCOUNT(PLL_COUNT);
   84a48:	68fb      	ldr	r3, [r7, #12]
   84a4a:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
   84a4e:	601a      	str	r2, [r3, #0]
   84a50:	e019      	b.n	84a86 <pll_config_init+0x5a>
	} else { /* PLLA */
		/* Calculate internal VCO frequency */
		vco_hz = osc_get_rate(e_src) / ul_div;
   84a52:	7afb      	ldrb	r3, [r7, #11]
   84a54:	4618      	mov	r0, r3
   84a56:	4b0d      	ldr	r3, [pc, #52]	; (84a8c <pll_config_init+0x60>)
   84a58:	4798      	blx	r3
   84a5a:	4602      	mov	r2, r0
   84a5c:	687b      	ldr	r3, [r7, #4]
   84a5e:	fbb2 f3f3 	udiv	r3, r2, r3
   84a62:	617b      	str	r3, [r7, #20]
		Assert(vco_hz >= PLL_INPUT_MIN_HZ);
		Assert(vco_hz <= PLL_INPUT_MAX_HZ);
		
		vco_hz *= ul_mul;
   84a64:	697b      	ldr	r3, [r7, #20]
   84a66:	683a      	ldr	r2, [r7, #0]
   84a68:	fb02 f303 	mul.w	r3, r2, r3
   84a6c:	617b      	str	r3, [r7, #20]
		Assert(vco_hz >= PLL_OUTPUT_MIN_HZ);
		Assert(vco_hz <= PLL_OUTPUT_MAX_HZ);
	
		/* PMC hardware will automatically make it mul+1 */
		p_cfg->ctrl = CKGR_PLLAR_MULA(ul_mul - 1) | CKGR_PLLAR_DIVA(ul_div) | CKGR_PLLAR_PLLACOUNT(PLL_COUNT);
   84a6e:	683b      	ldr	r3, [r7, #0]
   84a70:	3b01      	subs	r3, #1
   84a72:	041a      	lsls	r2, r3, #16
   84a74:	4b06      	ldr	r3, [pc, #24]	; (84a90 <pll_config_init+0x64>)
   84a76:	4013      	ands	r3, r2
   84a78:	687a      	ldr	r2, [r7, #4]
   84a7a:	b2d2      	uxtb	r2, r2
   84a7c:	4313      	orrs	r3, r2
   84a7e:	f443 527c 	orr.w	r2, r3, #16128	; 0x3f00
   84a82:	68fb      	ldr	r3, [r7, #12]
   84a84:	601a      	str	r2, [r3, #0]
	}
}
   84a86:	3718      	adds	r7, #24
   84a88:	46bd      	mov	sp, r7
   84a8a:	bd80      	pop	{r7, pc}
   84a8c:	0008498d 	.word	0x0008498d
   84a90:	07ff0000 	.word	0x07ff0000

00084a94 <pll_enable>:
		PMC->CKGR_UCKR = p_cfg->ctrl;
	}
}

static inline void pll_enable(const struct pll_config *p_cfg, uint32_t ul_pll_id)
{
   84a94:	b580      	push	{r7, lr}
   84a96:	b082      	sub	sp, #8
   84a98:	af00      	add	r7, sp, #0
   84a9a:	6078      	str	r0, [r7, #4]
   84a9c:	6039      	str	r1, [r7, #0]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID) {
   84a9e:	683b      	ldr	r3, [r7, #0]
   84aa0:	2b00      	cmp	r3, #0
   84aa2:	d108      	bne.n	84ab6 <pll_enable+0x22>
		pmc_disable_pllack(); // Always stop PLL first!
   84aa4:	4b08      	ldr	r3, [pc, #32]	; (84ac8 <pll_enable+0x34>)
   84aa6:	4798      	blx	r3
		PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | p_cfg->ctrl;
   84aa8:	4b08      	ldr	r3, [pc, #32]	; (84acc <pll_enable+0x38>)
   84aaa:	687a      	ldr	r2, [r7, #4]
   84aac:	6812      	ldr	r2, [r2, #0]
   84aae:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
   84ab2:	629a      	str	r2, [r3, #40]	; 0x28
   84ab4:	e005      	b.n	84ac2 <pll_enable+0x2e>
	} else {
		PMC->CKGR_UCKR = p_cfg->ctrl | CKGR_UCKR_UPLLEN;
   84ab6:	4b05      	ldr	r3, [pc, #20]	; (84acc <pll_enable+0x38>)
   84ab8:	687a      	ldr	r2, [r7, #4]
   84aba:	6812      	ldr	r2, [r2, #0]
   84abc:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
   84ac0:	61da      	str	r2, [r3, #28]
	}
}
   84ac2:	3708      	adds	r7, #8
   84ac4:	46bd      	mov	sp, r7
   84ac6:	bd80      	pop	{r7, pc}
   84ac8:	00085ad9 	.word	0x00085ad9
   84acc:	400e0600 	.word	0x400e0600

00084ad0 <pll_is_locked>:
	else
		PMC->CKGR_UCKR &= ~CKGR_UCKR_UPLLEN;
}

static inline uint32_t pll_is_locked(uint32_t ul_pll_id)
{
   84ad0:	b580      	push	{r7, lr}
   84ad2:	b082      	sub	sp, #8
   84ad4:	af00      	add	r7, sp, #0
   84ad6:	6078      	str	r0, [r7, #4]
	Assert(ul_pll_id < NR_PLLS);
	
	if (ul_pll_id == PLLA_ID)
   84ad8:	687b      	ldr	r3, [r7, #4]
   84ada:	2b00      	cmp	r3, #0
   84adc:	d103      	bne.n	84ae6 <pll_is_locked+0x16>
		return pmc_is_locked_pllack();
   84ade:	4b05      	ldr	r3, [pc, #20]	; (84af4 <pll_is_locked+0x24>)
   84ae0:	4798      	blx	r3
   84ae2:	4603      	mov	r3, r0
   84ae4:	e002      	b.n	84aec <pll_is_locked+0x1c>
	else
		return pmc_is_locked_upll();
   84ae6:	4b04      	ldr	r3, [pc, #16]	; (84af8 <pll_is_locked+0x28>)
   84ae8:	4798      	blx	r3
   84aea:	4603      	mov	r3, r0
}
   84aec:	4618      	mov	r0, r3
   84aee:	3708      	adds	r7, #8
   84af0:	46bd      	mov	sp, r7
   84af2:	bd80      	pop	{r7, pc}
   84af4:	00085af1 	.word	0x00085af1
   84af8:	00085b0d 	.word	0x00085b0d

00084afc <pll_enable_source>:

static inline void pll_enable_source(enum pll_source e_src)
{
   84afc:	b580      	push	{r7, lr}
   84afe:	b082      	sub	sp, #8
   84b00:	af00      	add	r7, sp, #0
   84b02:	4603      	mov	r3, r0
   84b04:	71fb      	strb	r3, [r7, #7]
	switch (e_src) {
   84b06:	79fb      	ldrb	r3, [r7, #7]
   84b08:	3b03      	subs	r3, #3
   84b0a:	2b04      	cmp	r3, #4
   84b0c:	d808      	bhi.n	84b20 <pll_enable_source+0x24>
	case PLL_SRC_MAINCK_4M_RC:
	case PLL_SRC_MAINCK_8M_RC:
	case PLL_SRC_MAINCK_12M_RC:
	case PLL_SRC_MAINCK_XTAL:
	case PLL_SRC_MAINCK_BYPASS:
		osc_enable(e_src);
   84b0e:	79fb      	ldrb	r3, [r7, #7]
   84b10:	4618      	mov	r0, r3
   84b12:	4b05      	ldr	r3, [pc, #20]	; (84b28 <pll_enable_source+0x2c>)
   84b14:	4798      	blx	r3
		osc_wait_ready(e_src);
   84b16:	79fb      	ldrb	r3, [r7, #7]
   84b18:	4618      	mov	r0, r3
   84b1a:	4b04      	ldr	r3, [pc, #16]	; (84b2c <pll_enable_source+0x30>)
   84b1c:	4798      	blx	r3
		break;
   84b1e:	e000      	b.n	84b22 <pll_enable_source+0x26>

	default:
		Assert(false);
		break;
   84b20:	bf00      	nop
	}
}
   84b22:	3708      	adds	r7, #8
   84b24:	46bd      	mov	sp, r7
   84b26:	bd80      	pop	{r7, pc}
   84b28:	0008489d 	.word	0x0008489d
   84b2c:	00084a01 	.word	0x00084a01

00084b30 <pll_wait_for_lock>:
 *
 * \retval STATUS_OK The PLL is now locked.
 * \retval ERR_TIMEOUT Timed out waiting for PLL to become locked.
 */
static inline int pll_wait_for_lock(unsigned int pll_id)
{
   84b30:	b580      	push	{r7, lr}
   84b32:	b082      	sub	sp, #8
   84b34:	af00      	add	r7, sp, #0
   84b36:	6078      	str	r0, [r7, #4]
	Assert(pll_id < NR_PLLS);

	while (!pll_is_locked(pll_id)) {
   84b38:	bf00      	nop
   84b3a:	6878      	ldr	r0, [r7, #4]
   84b3c:	4b04      	ldr	r3, [pc, #16]	; (84b50 <pll_wait_for_lock+0x20>)
   84b3e:	4798      	blx	r3
   84b40:	4603      	mov	r3, r0
   84b42:	2b00      	cmp	r3, #0
   84b44:	d0f9      	beq.n	84b3a <pll_wait_for_lock+0xa>
		/* Do nothing */
	}

	return 0;
   84b46:	2300      	movs	r3, #0
}
   84b48:	4618      	mov	r0, r3
   84b4a:	3708      	adds	r7, #8
   84b4c:	46bd      	mov	sp, r7
   84b4e:	bd80      	pop	{r7, pc}
   84b50:	00084ad1 	.word	0x00084ad1

00084b54 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
   84b54:	b580      	push	{r7, lr}
   84b56:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
   84b58:	2006      	movs	r0, #6
   84b5a:	4b04      	ldr	r3, [pc, #16]	; (84b6c <sysclk_get_main_hz+0x18>)
   84b5c:	4798      	blx	r3
   84b5e:	4602      	mov	r2, r0
   84b60:	4613      	mov	r3, r2
   84b62:	00db      	lsls	r3, r3, #3
   84b64:	1a9b      	subs	r3, r3, r2
   84b66:	005b      	lsls	r3, r3, #1
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
   84b68:	4618      	mov	r0, r3
   84b6a:	bd80      	pop	{r7, pc}
   84b6c:	0008498d 	.word	0x0008498d

00084b70 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
   84b70:	b580      	push	{r7, lr}
   84b72:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
   84b74:	4b02      	ldr	r3, [pc, #8]	; (84b80 <sysclk_get_cpu_hz+0x10>)
   84b76:	4798      	blx	r3
   84b78:	4603      	mov	r3, r0
   84b7a:	085b      	lsrs	r3, r3, #1
}
   84b7c:	4618      	mov	r0, r3
   84b7e:	bd80      	pop	{r7, pc}
   84b80:	00084b55 	.word	0x00084b55

00084b84 <sysclk_init>:
	pll_disable(1);
}
#endif // CONFIG_USBCLK_SOURCE

void sysclk_init(void)
{
   84b84:	b590      	push	{r4, r7, lr}
   84b86:	b083      	sub	sp, #12
   84b88:	af00      	add	r7, sp, #0
	struct pll_config pllcfg;

	/* Set a flash wait state depending on the new cpu frequency */
	system_init_flash(sysclk_get_cpu_hz());
   84b8a:	4b10      	ldr	r3, [pc, #64]	; (84bcc <sysclk_init+0x48>)
   84b8c:	4798      	blx	r3
   84b8e:	4603      	mov	r3, r0
   84b90:	4618      	mov	r0, r3
   84b92:	4b0f      	ldr	r3, [pc, #60]	; (84bd0 <sysclk_init+0x4c>)
   84b94:	4798      	blx	r3
		pmc_switch_mck_to_mainck(CONFIG_SYSCLK_PRES);
		break;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		pll_enable_source(CONFIG_PLL0_SOURCE);
   84b96:	2006      	movs	r0, #6
   84b98:	4b0e      	ldr	r3, [pc, #56]	; (84bd4 <sysclk_init+0x50>)
   84b9a:	4798      	blx	r3
		pll_config_defaults(&pllcfg, 0);
   84b9c:	1d3b      	adds	r3, r7, #4
   84b9e:	4618      	mov	r0, r3
   84ba0:	2106      	movs	r1, #6
   84ba2:	2201      	movs	r2, #1
   84ba4:	230e      	movs	r3, #14
   84ba6:	4c0c      	ldr	r4, [pc, #48]	; (84bd8 <sysclk_init+0x54>)
   84ba8:	47a0      	blx	r4
		pll_enable(&pllcfg, 0);
   84baa:	1d3b      	adds	r3, r7, #4
   84bac:	4618      	mov	r0, r3
   84bae:	2100      	movs	r1, #0
   84bb0:	4b0a      	ldr	r3, [pc, #40]	; (84bdc <sysclk_init+0x58>)
   84bb2:	4798      	blx	r3
		pll_wait_for_lock(0);
   84bb4:	2000      	movs	r0, #0
   84bb6:	4b0a      	ldr	r3, [pc, #40]	; (84be0 <sysclk_init+0x5c>)
   84bb8:	4798      	blx	r3
		pmc_switch_mck_to_pllack(CONFIG_SYSCLK_PRES);
   84bba:	2010      	movs	r0, #16
   84bbc:	4b09      	ldr	r3, [pc, #36]	; (84be4 <sysclk_init+0x60>)
   84bbe:	4798      	blx	r3
		break;
   84bc0:	bf00      	nop
		pmc_switch_mck_to_upllck(CONFIG_SYSCLK_PRES);
		break;
	}

	/* Update the SystemFrequency variable */
	SystemCoreClockUpdate();
   84bc2:	4b09      	ldr	r3, [pc, #36]	; (84be8 <sysclk_init+0x64>)
   84bc4:	4798      	blx	r3

#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
	/* Signal that the internal frequencies are setup */
	sysclk_initialized = 1;
#endif
}
   84bc6:	370c      	adds	r7, #12
   84bc8:	46bd      	mov	sp, r7
   84bca:	bd90      	pop	{r4, r7, pc}
   84bcc:	00084b71 	.word	0x00084b71
   84bd0:	000860d1 	.word	0x000860d1
   84bd4:	00084afd 	.word	0x00084afd
   84bd8:	00084a2d 	.word	0x00084a2d
   84bdc:	00084a95 	.word	0x00084a95
   84be0:	00084b31 	.word	0x00084b31
   84be4:	000858bd 	.word	0x000858bd
   84be8:	00085f51 	.word	0x00085f51

00084bec <safe_board_init>:
/************************************************************************/
/* SAFE BOARD INIT                                                      */
/************************************************************************/

void safe_board_init(void)
{	
   84bec:	b580      	push	{r7, lr}
   84bee:	af00      	add	r7, sp, #0
	uint32_t wdt_mode, wdt_timer;	// Values used in initializing WDT.

	#ifndef CONF_BOARD_KEEP_WATCHDOG_AT_INIT
	/* Disable the watchdog */
	WDT->WDT_MR = WDT_MR_WDDIS;
   84bf0:	4b11      	ldr	r3, [pc, #68]	; (84c38 <safe_board_init+0x4c>)
   84bf2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   84bf6:	605a      	str	r2, [r3, #4]
	#endif

	/*Configure CAN related pins*/
	#ifdef CONF_BOARD_CAN0
	/* Configure the CAN0 TX and RX pins. */
	gpio_configure_pin(PIN_CAN0_RX_IDX, PIN_CAN0_RX_FLAGS);
   84bf8:	2001      	movs	r0, #1
   84bfa:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84bfe:	4b0f      	ldr	r3, [pc, #60]	; (84c3c <safe_board_init+0x50>)
   84c00:	4798      	blx	r3
	gpio_configure_pin(PIN_CAN0_TX_IDX, PIN_CAN0_TX_FLAGS);
   84c02:	2000      	movs	r0, #0
   84c04:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84c08:	4b0c      	ldr	r3, [pc, #48]	; (84c3c <safe_board_init+0x50>)
   84c0a:	4798      	blx	r3
	/* Configure the transiver0 RS & EN pins. */
	gpio_configure_pin(PIN_CAN0_TR_RS_IDX, PIN_CAN0_TR_RS_FLAGS);
   84c0c:	2034      	movs	r0, #52	; 0x34
   84c0e:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
   84c12:	4b0a      	ldr	r3, [pc, #40]	; (84c3c <safe_board_init+0x50>)
   84c14:	4798      	blx	r3
	gpio_configure_pin(PIN_CAN0_TR_EN_IDX, PIN_CAN0_TR_EN_FLAGS);
   84c16:	2035      	movs	r0, #53	; 0x35
   84c18:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
   84c1c:	4b07      	ldr	r3, [pc, #28]	; (84c3c <safe_board_init+0x50>)
   84c1e:	4798      	blx	r3
	#endif

	#ifdef CONF_BOARD_CAN1
	/* Configure the CAN1 TX and RX pin. */
	gpio_configure_pin(PIN_CAN1_RX_IDX, PIN_CAN1_RX_FLAGS);
   84c20:	202f      	movs	r0, #47	; 0x2f
   84c22:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84c26:	4b05      	ldr	r3, [pc, #20]	; (84c3c <safe_board_init+0x50>)
   84c28:	4798      	blx	r3
	gpio_configure_pin(PIN_CAN1_TX_IDX, PIN_CAN1_TX_FLAGS);
   84c2a:	202e      	movs	r0, #46	; 0x2e
   84c2c:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84c30:	4b02      	ldr	r3, [pc, #8]	; (84c3c <safe_board_init+0x50>)
   84c32:	4798      	blx	r3
	/* Configure the transiver1 RS & EN pins. */
	//gpio_configure_pin(PIN_CAN1_TR_RS_IDX, PIN_CAN1_TR_RS_FLAGS);
	//gpio_configure_pin(PIN_CAN1_TR_EN_IDX, PIN_CAN1_TR_EN_FLAGS);
	#endif
	return;
   84c34:	bf00      	nop
}
   84c36:	bd80      	pop	{r7, pc}
   84c38:	400e1a50 	.word	0x400e1a50
   84c3c:	0008559d 	.word	0x0008559d

00084c40 <board_init>:

/**
 * \brief Initialize board watchdog timer and pins.
 */
void board_init(void)
{
   84c40:	b580      	push	{r7, lr}
   84c42:	af00      	add	r7, sp, #0
	/* Configure Power LED */
	gpio_configure_pin(LED3_GPIO, LED3_FLAGS);
   84c44:	2057      	movs	r0, #87	; 0x57
   84c46:	f04f 5140 	mov.w	r1, #805306368	; 0x30000000
   84c4a:	4b38      	ldr	r3, [pc, #224]	; (84d2c <board_init+0xec>)
   84c4c:	4798      	blx	r3
	gpio_set_pin_high(LED3_GPIO); /* Turned on by default */
   84c4e:	2057      	movs	r0, #87	; 0x57
   84c50:	4b37      	ldr	r3, [pc, #220]	; (84d30 <board_init+0xf0>)
   84c52:	4798      	blx	r3

	/* Configure User LED pins */
	gpio_configure_pin(LED0_GPIO, LED0_FLAGS);
   84c54:	203b      	movs	r0, #59	; 0x3b
   84c56:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   84c5a:	4b34      	ldr	r3, [pc, #208]	; (84d2c <board_init+0xec>)
   84c5c:	4798      	blx	r3
	gpio_configure_pin(LED1_GPIO, LED1_FLAGS);
   84c5e:	2055      	movs	r0, #85	; 0x55
   84c60:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   84c64:	4b31      	ldr	r3, [pc, #196]	; (84d2c <board_init+0xec>)
   84c66:	4798      	blx	r3
	gpio_configure_pin(LED2_GPIO, LED2_FLAGS);
   84c68:	2056      	movs	r0, #86	; 0x56
   84c6a:	f04f 5160 	mov.w	r1, #939524096	; 0x38000000
   84c6e:	4b2f      	ldr	r3, [pc, #188]	; (84d2c <board_init+0xec>)
   84c70:	4798      	blx	r3
	
	/* Configure SSM Reset pins */
	gpio_configure_pin(EPS_RST_GPIO, EPS_RST_FLAGS_OFF);
   84c72:	203a      	movs	r0, #58	; 0x3a
   84c74:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
   84c78:	4b2c      	ldr	r3, [pc, #176]	; (84d2c <board_init+0xec>)
   84c7a:	4798      	blx	r3
	gpio_configure_pin(COMS_RST_GPIO, COMS_RST_FLAGS_OFF);
   84c7c:	2020      	movs	r0, #32
   84c7e:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
   84c82:	4b2a      	ldr	r3, [pc, #168]	; (84d2c <board_init+0xec>)
   84c84:	4798      	blx	r3
	gpio_configure_pin(PAY_RST_GPIO, PAY_RST_FLAGS_OFF);	
   84c86:	200e      	movs	r0, #14
   84c88:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
   84c8c:	4b27      	ldr	r3, [pc, #156]	; (84d2c <board_init+0xec>)
   84c8e:	4798      	blx	r3
	
	/* Configure SSM Reprogramming pins */
	gpio_configure_pin(MISO_A_GPIO, MISO_A_FLAGS_OFF);
   84c90:	201b      	movs	r0, #27
   84c92:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
   84c96:	4b25      	ldr	r3, [pc, #148]	; (84d2c <board_init+0xec>)
   84c98:	4798      	blx	r3
	gpio_configure_pin(MOSI_A_GPIO, MOSI_A_FLAGS_OFF);
   84c9a:	201b      	movs	r0, #27
   84c9c:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
   84ca0:	4b22      	ldr	r3, [pc, #136]	; (84d2c <board_init+0xec>)
   84ca2:	4798      	blx	r3
	gpio_configure_pin(SCK_A_GPIO, SCK_A_FLAGS_OFF);
   84ca4:	201b      	movs	r0, #27
   84ca6:	f04f 5120 	mov.w	r1, #671088640	; 0x28000000
   84caa:	4b20      	ldr	r3, [pc, #128]	; (84d2c <board_init+0xec>)
   84cac:	4798      	blx	r3
	
#ifdef CONF_BOARD_UART_CONSOLE
	/* Configure UART pins */
	gpio_configure_group(PINS_UART_PIO, PINS_UART, PINS_UART_FLAGS);
   84cae:	4821      	ldr	r0, [pc, #132]	; (84d34 <board_init+0xf4>)
   84cb0:	f44f 7140 	mov.w	r1, #768	; 0x300
   84cb4:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
   84cb8:	4b1f      	ldr	r3, [pc, #124]	; (84d38 <board_init+0xf8>)
   84cba:	4798      	blx	r3
	//gpio_configure_pin(PIN_PWMC_PWMH0_TRIG, PIN_PWMC_PWMH0_TRIG_FLAG);
//#endif

	/* Configure SPI0 pins */
#ifdef CONF_BOARD_SPI0
	gpio_configure_pin(SPI0_MISO_GPIO, SPI0_MISO_FLAGS);
   84cbc:	2019      	movs	r0, #25
   84cbe:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84cc2:	4b1a      	ldr	r3, [pc, #104]	; (84d2c <board_init+0xec>)
   84cc4:	4798      	blx	r3
	gpio_configure_pin(SPI0_MOSI_GPIO, SPI0_MOSI_FLAGS);
   84cc6:	201a      	movs	r0, #26
   84cc8:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84ccc:	4b17      	ldr	r3, [pc, #92]	; (84d2c <board_init+0xec>)
   84cce:	4798      	blx	r3
	gpio_configure_pin(SPI0_SPCK_GPIO, SPI0_SPCK_FLAGS);
   84cd0:	201b      	movs	r0, #27
   84cd2:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84cd6:	4b15      	ldr	r3, [pc, #84]	; (84d2c <board_init+0xec>)
   84cd8:	4798      	blx	r3
	 * CONF_BOARD_SPI_NPCS_GPIO and
	 * CONF_BOARD_SPI_NPCS_FLAGS macros.
	 */

#   ifdef CONF_BOARD_SPI0_NPCS0
		gpio_configure_pin(SPI0_NPCS0_GPIO, SPI0_NPCS0_FLAGS);
   84cda:	201c      	movs	r0, #28
   84cdc:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84ce0:	4b12      	ldr	r3, [pc, #72]	; (84d2c <board_init+0xec>)
   84ce2:	4798      	blx	r3
#   endif

#   ifdef CONF_BOARD_SPI0_NPCS1
#       if defined(CONF_BOARD_SPI0_NPCS1_GPIO) && \
		defined(CONF_BOARD_SPI0_NPCS1_FLAGS)
			gpio_configure_pin(CONF_BOARD_SPI0_NPCS1_GPIO,
   84ce4:	2034      	movs	r0, #52	; 0x34
   84ce6:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   84cea:	4b10      	ldr	r3, [pc, #64]	; (84d2c <board_init+0xec>)
   84cec:	4798      	blx	r3
#   endif

#   ifdef CONF_BOARD_SPI0_NPCS2
#       if defined(CONF_BOARD_SPI0_NPCS2_GPIO) && \
		defined(CONF_BOARD_SPI0_NPCS2_FLAGS)
			gpio_configure_pin(CONF_BOARD_SPI0_NPCS2_GPIO,
   84cee:	2035      	movs	r0, #53	; 0x35
   84cf0:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   84cf4:	4b0d      	ldr	r3, [pc, #52]	; (84d2c <board_init+0xec>)
   84cf6:	4798      	blx	r3
#   endif

#   ifdef CONF_BOARD_SPI0_NPCS3
#       if defined(CONF_BOARD_SPI0_NPCS3_GPIO) && \
		defined(CONF_BOARD_SPI0_NPCS3_FLAGS)
			gpio_configure_pin(CONF_BOARD_SPI0_NPCS3_GPIO,
   84cf8:	2037      	movs	r0, #55	; 0x37
   84cfa:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   84cfe:	4b0b      	ldr	r3, [pc, #44]	; (84d2c <board_init+0xec>)
   84d00:	4798      	blx	r3
					SPI0_NPCS3_PA31_FLAGS);
#       endif
#   endif

#	ifdef CONF_SPI_MEM1
		gpio_configure_pin(SPI0_MEM1_HOLD, SPI0_MEM1_HOLD_FLAGS);
   84d02:	2015      	movs	r0, #21
   84d04:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84d08:	4b08      	ldr	r3, [pc, #32]	; (84d2c <board_init+0xec>)
   84d0a:	4798      	blx	r3
#	endif

#	ifdef TEMP_SENSOR
		gpio_configure_pin(TEMP_SS, TEMP_SS_FLAGS);
   84d0c:	2033      	movs	r0, #51	; 0x33
   84d0e:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   84d12:	4b06      	ldr	r3, [pc, #24]	; (84d2c <board_init+0xec>)
   84d14:	4798      	blx	r3

#endif // #ifdef CONF_BOARD_SPI0

#ifdef CONF_BOARD_USART_RXD
	/* Configure USART RXD pin */
	gpio_configure_pin(PIN_USART0_RXD_IDX, PIN_USART0_RXD_FLAGS);
   84d16:	200a      	movs	r0, #10
   84d18:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84d1c:	4b03      	ldr	r3, [pc, #12]	; (84d2c <board_init+0xec>)
   84d1e:	4798      	blx	r3
#endif

#ifdef CONF_BOARD_USART_TXD
	/* Configure USART TXD pin */
	gpio_configure_pin(PIN_USART0_TXD_IDX, PIN_USART0_TXD_FLAGS);
   84d20:	200b      	movs	r0, #11
   84d22:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   84d26:	4b01      	ldr	r3, [pc, #4]	; (84d2c <board_init+0xec>)
   84d28:	4798      	blx	r3
#endif

}
   84d2a:	bd80      	pop	{r7, pc}
   84d2c:	0008559d 	.word	0x0008559d
   84d30:	000854d5 	.word	0x000854d5
   84d34:	400e0e00 	.word	0x400e0e00
   84d38:	000856d9 	.word	0x000856d9

00084d3c <can_set_baudrate>:
 *
 * \retval Set the baudrate successfully or not.
 */
static uint32_t can_set_baudrate(Can *p_can, uint32_t ul_mck,
		uint32_t ul_baudrate)
{
   84d3c:	b580      	push	{r7, lr}
   84d3e:	b08a      	sub	sp, #40	; 0x28
   84d40:	af00      	add	r7, sp, #0
   84d42:	60f8      	str	r0, [r7, #12]
   84d44:	60b9      	str	r1, [r7, #8]
   84d46:	607a      	str	r2, [r7, #4]
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
   84d48:	687b      	ldr	r3, [r7, #4]
   84d4a:	f246 12a8 	movw	r2, #25000	; 0x61a8
   84d4e:	fb02 f203 	mul.w	r2, r2, r3
   84d52:	68bb      	ldr	r3, [r7, #8]
   84d54:	4413      	add	r3, r2
   84d56:	1e5a      	subs	r2, r3, #1
			(ul_baudrate * CAN_MAX_TQ_NUM * 1000)) >
   84d58:	687b      	ldr	r3, [r7, #4]
   84d5a:	f246 11a8 	movw	r1, #25000	; 0x61a8
   84d5e:	fb01 f303 	mul.w	r3, r1, r3
	uint32_t ul_cur_mod;
	can_bit_timing_t *p_bit_time;

	/* Check whether the baudrate prescale will be greater than the max
	 * divide value. */
	if (((ul_mck + (ul_baudrate * CAN_MAX_TQ_NUM * 1000 - 1)) /
   84d62:	fbb2 f3f3 	udiv	r3, r2, r3
   84d66:	2b80      	cmp	r3, #128	; 0x80
   84d68:	d901      	bls.n	84d6e <can_set_baudrate+0x32>
			(ul_baudrate * CAN_MAX_TQ_NUM * 1000)) >
			CAN_BAUDRATE_MAX_DIV) {
		return 0;
   84d6a:	2300      	movs	r3, #0
   84d6c:	e085      	b.n	84e7a <can_set_baudrate+0x13e>
	}

	/* Check whether the input MCK is too small. */
	if ((ul_mck / 2)  < ul_baudrate * CAN_MIN_TQ_NUM * 1000) {
   84d6e:	68bb      	ldr	r3, [r7, #8]
   84d70:	085a      	lsrs	r2, r3, #1
   84d72:	687b      	ldr	r3, [r7, #4]
   84d74:	f44f 51fa 	mov.w	r1, #8000	; 0x1f40
   84d78:	fb01 f303 	mul.w	r3, r1, r3
   84d7c:	429a      	cmp	r2, r3
   84d7e:	d201      	bcs.n	84d84 <can_set_baudrate+0x48>
		return 0;
   84d80:	2300      	movs	r3, #0
   84d82:	e07a      	b.n	84e7a <can_set_baudrate+0x13e>
	}

	/* Initialize it as the minimum Time Quantum. */
	uc_tq = CAN_MIN_TQ_NUM;
   84d84:	2308      	movs	r3, #8
   84d86:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	ul_mod = 0xffffffff;
   84d8a:	f04f 33ff 	mov.w	r3, #4294967295
   84d8e:	623b      	str	r3, [r7, #32]
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
   84d90:	2308      	movs	r3, #8
   84d92:	77fb      	strb	r3, [r7, #31]
   84d94:	e02b      	b.n	84dee <can_set_baudrate+0xb2>
		if ((ul_mck / (ul_baudrate * i * 1000)) <=
   84d96:	7ffb      	ldrb	r3, [r7, #31]
   84d98:	687a      	ldr	r2, [r7, #4]
   84d9a:	fb02 f303 	mul.w	r3, r2, r3
   84d9e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   84da2:	fb02 f303 	mul.w	r3, r2, r3
   84da6:	68ba      	ldr	r2, [r7, #8]
   84da8:	fbb2 f3f3 	udiv	r3, r2, r3
   84dac:	2b80      	cmp	r3, #128	; 0x80
   84dae:	d81b      	bhi.n	84de8 <can_set_baudrate+0xac>
				CAN_BAUDRATE_MAX_DIV) {
			ul_cur_mod = ul_mck % (ul_baudrate * i * 1000);
   84db0:	7ffb      	ldrb	r3, [r7, #31]
   84db2:	687a      	ldr	r2, [r7, #4]
   84db4:	fb02 f303 	mul.w	r3, r2, r3
   84db8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   84dbc:	fb02 f203 	mul.w	r2, r2, r3
   84dc0:	68bb      	ldr	r3, [r7, #8]
   84dc2:	fbb3 f1f2 	udiv	r1, r3, r2
   84dc6:	fb02 f201 	mul.w	r2, r2, r1
   84dca:	1a9b      	subs	r3, r3, r2
   84dcc:	61bb      	str	r3, [r7, #24]
			if (ul_cur_mod < ul_mod) {
   84dce:	69ba      	ldr	r2, [r7, #24]
   84dd0:	6a3b      	ldr	r3, [r7, #32]
   84dd2:	429a      	cmp	r2, r3
   84dd4:	d208      	bcs.n	84de8 <can_set_baudrate+0xac>
				ul_mod = ul_cur_mod;
   84dd6:	69bb      	ldr	r3, [r7, #24]
   84dd8:	623b      	str	r3, [r7, #32]
				uc_tq = i;
   84dda:	7ffb      	ldrb	r3, [r7, #31]
   84ddc:	f887 3027 	strb.w	r3, [r7, #39]	; 0x27
				if (!ul_mod) {
   84de0:	6a3b      	ldr	r3, [r7, #32]
   84de2:	2b00      	cmp	r3, #0
   84de4:	d100      	bne.n	84de8 <can_set_baudrate+0xac>
					break;
   84de6:	e005      	b.n	84df4 <can_set_baudrate+0xb8>

	/* Initialize the remainder as the max value. When the remainder is 0,
	 *get the right TQ number. */
	ul_mod = 0xffffffff;
	/* Find out the approximate Time Quantum according to the baudrate. */
	for (uint8_t i = CAN_MIN_TQ_NUM; i <= CAN_MAX_TQ_NUM; i++) {
   84de8:	7ffb      	ldrb	r3, [r7, #31]
   84dea:	3301      	adds	r3, #1
   84dec:	77fb      	strb	r3, [r7, #31]
   84dee:	7ffb      	ldrb	r3, [r7, #31]
   84df0:	2b19      	cmp	r3, #25
   84df2:	d9d0      	bls.n	84d96 <can_set_baudrate+0x5a>
			}
		}
	}

	/* Calculate the baudrate prescale value. */
	uc_prescale = ul_mck / (ul_baudrate * uc_tq * 1000);
   84df4:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   84df8:	687a      	ldr	r2, [r7, #4]
   84dfa:	fb02 f303 	mul.w	r3, r2, r3
   84dfe:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
   84e02:	fb02 f303 	mul.w	r3, r2, r3
   84e06:	68ba      	ldr	r2, [r7, #8]
   84e08:	fbb2 f3f3 	udiv	r3, r2, r3
   84e0c:	75fb      	strb	r3, [r7, #23]
	if (uc_prescale < 2) {
   84e0e:	7dfb      	ldrb	r3, [r7, #23]
   84e10:	2b01      	cmp	r3, #1
   84e12:	d801      	bhi.n	84e18 <can_set_baudrate+0xdc>
		return 0;
   84e14:	2300      	movs	r3, #0
   84e16:	e030      	b.n	84e7a <can_set_baudrate+0x13e>
	}

	/* Get the right CAN BIT Timing group. */
	p_bit_time = (can_bit_timing_t *)&can_bit_time[uc_tq - CAN_MIN_TQ_NUM];
   84e18:	f897 3027 	ldrb.w	r3, [r7, #39]	; 0x27
   84e1c:	f1a3 0208 	sub.w	r2, r3, #8
   84e20:	4613      	mov	r3, r2
   84e22:	005b      	lsls	r3, r3, #1
   84e24:	4413      	add	r3, r2
   84e26:	005b      	lsls	r3, r3, #1
   84e28:	4a16      	ldr	r2, [pc, #88]	; (84e84 <can_set_baudrate+0x148>)
   84e2a:	4413      	add	r3, r2
   84e2c:	613b      	str	r3, [r7, #16]

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);
   84e2e:	68f8      	ldr	r0, [r7, #12]
   84e30:	4b15      	ldr	r3, [pc, #84]	; (84e88 <can_set_baudrate+0x14c>)
   84e32:	4798      	blx	r3

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
   84e34:	693b      	ldr	r3, [r7, #16]
   84e36:	78db      	ldrb	r3, [r3, #3]
   84e38:	3b01      	subs	r3, #1
   84e3a:	f003 0207 	and.w	r2, r3, #7
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
   84e3e:	693b      	ldr	r3, [r7, #16]
   84e40:	789b      	ldrb	r3, [r3, #2]
   84e42:	3b01      	subs	r3, #1
   84e44:	011b      	lsls	r3, r3, #4
   84e46:	f003 0370 	and.w	r3, r3, #112	; 0x70

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
   84e4a:	431a      	orrs	r2, r3
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
   84e4c:	693b      	ldr	r3, [r7, #16]
   84e4e:	785b      	ldrb	r3, [r3, #1]
   84e50:	3b01      	subs	r3, #1
   84e52:	021b      	lsls	r3, r3, #8
   84e54:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
   84e58:	431a      	orrs	r2, r3
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
   84e5a:	693b      	ldr	r3, [r7, #16]
   84e5c:	791b      	ldrb	r3, [r3, #4]
   84e5e:	3b01      	subs	r3, #1
   84e60:	031b      	lsls	r3, r3, #12
   84e62:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
	can_disable(p_can);

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
   84e66:	431a      	orrs	r2, r3
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
			CAN_BR_BRP(uc_prescale - 1);
   84e68:	7dfb      	ldrb	r3, [r7, #23]
   84e6a:	3b01      	subs	r3, #1
   84e6c:	041b      	lsls	r3, r3, #16
   84e6e:	f403 03fe 	and.w	r3, r3, #8323072	; 0x7f0000

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
   84e72:	431a      	orrs	r2, r3

	/* Before modifying the CANBR register, disable the CAN controller. */
	can_disable(p_can);

	/* Write into the CAN baudrate register. */
	p_can->CAN_BR = CAN_BR_PHASE2(p_bit_time->uc_phase2 - 1) |
   84e74:	68fb      	ldr	r3, [r7, #12]
   84e76:	615a      	str	r2, [r3, #20]
			CAN_BR_PHASE1(p_bit_time->uc_phase1 - 1) |
			CAN_BR_PROPAG(p_bit_time->uc_prog - 1) |
			CAN_BR_SJW(p_bit_time->uc_sjw - 1) |
			CAN_BR_BRP(uc_prescale - 1);
	return 1;
   84e78:	2301      	movs	r3, #1
}
   84e7a:	4618      	mov	r0, r3
   84e7c:	3728      	adds	r7, #40	; 0x28
   84e7e:	46bd      	mov	sp, r7
   84e80:	bd80      	pop	{r7, pc}
   84e82:	bf00      	nop
   84e84:	0008b100 	.word	0x0008b100
   84e88:	00084f35 	.word	0x00084f35

00084e8c <can_init>:
 *
 * \note PMC clock for CAN peripheral should be enabled before calling this
 *function.
 */
uint32_t can_init(Can *p_can, uint32_t ul_mck, uint32_t ul_baudrate)
{
   84e8c:	b580      	push	{r7, lr}
   84e8e:	b086      	sub	sp, #24
   84e90:	af00      	add	r7, sp, #0
   84e92:	60f8      	str	r0, [r7, #12]
   84e94:	60b9      	str	r1, [r7, #8]
   84e96:	607a      	str	r2, [r7, #4]
	uint32_t ul_flag;
	uint32_t ul_tick;

	/* Initialize the baudrate for CAN module. */
	ul_flag = can_set_baudrate(p_can, ul_mck, ul_baudrate);
   84e98:	68f8      	ldr	r0, [r7, #12]
   84e9a:	68b9      	ldr	r1, [r7, #8]
   84e9c:	687a      	ldr	r2, [r7, #4]
   84e9e:	4b17      	ldr	r3, [pc, #92]	; (84efc <can_init+0x70>)
   84ea0:	4798      	blx	r3
   84ea2:	6178      	str	r0, [r7, #20]
	if (ul_flag == 0) {
   84ea4:	697b      	ldr	r3, [r7, #20]
   84ea6:	2b00      	cmp	r3, #0
   84ea8:	d101      	bne.n	84eae <can_init+0x22>
		return 0;
   84eaa:	2300      	movs	r3, #0
   84eac:	e021      	b.n	84ef2 <can_init+0x66>
	}

	/* Reset the CAN eight message mailbox. */
	can_reset_all_mailbox(p_can);
   84eae:	68f8      	ldr	r0, [r7, #12]
   84eb0:	4b13      	ldr	r3, [pc, #76]	; (84f00 <can_init+0x74>)
   84eb2:	4798      	blx	r3

	/* Enable the CAN controller. */
	can_enable(p_can);
   84eb4:	68f8      	ldr	r0, [r7, #12]
   84eb6:	4b13      	ldr	r3, [pc, #76]	; (84f04 <can_init+0x78>)
   84eb8:	4798      	blx	r3

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
   84eba:	2300      	movs	r3, #0
   84ebc:	617b      	str	r3, [r7, #20]
	ul_tick = 0;
   84ebe:	2300      	movs	r3, #0
   84ec0:	613b      	str	r3, [r7, #16]
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
   84ec2:	e006      	b.n	84ed2 <can_init+0x46>
		ul_flag = can_get_status(p_can);
   84ec4:	68f8      	ldr	r0, [r7, #12]
   84ec6:	4b10      	ldr	r3, [pc, #64]	; (84f08 <can_init+0x7c>)
   84ec8:	4798      	blx	r3
   84eca:	6178      	str	r0, [r7, #20]
		ul_tick++;
   84ecc:	693b      	ldr	r3, [r7, #16]
   84ece:	3301      	adds	r3, #1
   84ed0:	613b      	str	r3, [r7, #16]
	can_enable(p_can);

	/* Wait until the CAN is synchronized with the bus activity. */
	ul_flag = 0;
	ul_tick = 0;
	while (!(ul_flag & CAN_SR_WAKEUP) && (ul_tick < CAN_TIMEOUT)) {
   84ed2:	697b      	ldr	r3, [r7, #20]
   84ed4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
   84ed8:	2b00      	cmp	r3, #0
   84eda:	d103      	bne.n	84ee4 <can_init+0x58>
   84edc:	693a      	ldr	r2, [r7, #16]
   84ede:	4b0b      	ldr	r3, [pc, #44]	; (84f0c <can_init+0x80>)
   84ee0:	429a      	cmp	r2, r3
   84ee2:	d9ef      	bls.n	84ec4 <can_init+0x38>
		ul_flag = can_get_status(p_can);
		ul_tick++;
	}

	/* Timeout or the CAN module has been synchronized with the bus. */
	if (CAN_TIMEOUT == ul_tick) {
   84ee4:	693a      	ldr	r2, [r7, #16]
   84ee6:	4b0a      	ldr	r3, [pc, #40]	; (84f10 <can_init+0x84>)
   84ee8:	429a      	cmp	r2, r3
   84eea:	d101      	bne.n	84ef0 <can_init+0x64>
		return 0;
   84eec:	2300      	movs	r3, #0
   84eee:	e000      	b.n	84ef2 <can_init+0x66>
	} else {
		return 1;
   84ef0:	2301      	movs	r3, #1
	}
}
   84ef2:	4618      	mov	r0, r3
   84ef4:	3718      	adds	r7, #24
   84ef6:	46bd      	mov	sp, r7
   84ef8:	bd80      	pop	{r7, pc}
   84efa:	bf00      	nop
   84efc:	00084d3d 	.word	0x00084d3d
   84f00:	000852cd 	.word	0x000852cd
   84f04:	00084f15 	.word	0x00084f15
   84f08:	00084f8d 	.word	0x00084f8d
   84f0c:	0001869f 	.word	0x0001869f
   84f10:	000186a0 	.word	0x000186a0

00084f14 <can_enable>:
 * \brief Enable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_enable(Can *p_can)
{
   84f14:	b480      	push	{r7}
   84f16:	b083      	sub	sp, #12
   84f18:	af00      	add	r7, sp, #0
   84f1a:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR |= CAN_MR_CANEN;
   84f1c:	687b      	ldr	r3, [r7, #4]
   84f1e:	681b      	ldr	r3, [r3, #0]
   84f20:	f043 0201 	orr.w	r2, r3, #1
   84f24:	687b      	ldr	r3, [r7, #4]
   84f26:	601a      	str	r2, [r3, #0]
}
   84f28:	370c      	adds	r7, #12
   84f2a:	46bd      	mov	sp, r7
   84f2c:	f85d 7b04 	ldr.w	r7, [sp], #4
   84f30:	4770      	bx	lr
   84f32:	bf00      	nop

00084f34 <can_disable>:
 * \brief Disable CAN Controller.
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 */
void can_disable(Can *p_can)
{
   84f34:	b480      	push	{r7}
   84f36:	b083      	sub	sp, #12
   84f38:	af00      	add	r7, sp, #0
   84f3a:	6078      	str	r0, [r7, #4]
	p_can->CAN_MR &= ~CAN_MR_CANEN;
   84f3c:	687b      	ldr	r3, [r7, #4]
   84f3e:	681b      	ldr	r3, [r3, #0]
   84f40:	f023 0201 	bic.w	r2, r3, #1
   84f44:	687b      	ldr	r3, [r7, #4]
   84f46:	601a      	str	r2, [r3, #0]
}
   84f48:	370c      	adds	r7, #12
   84f4a:	46bd      	mov	sp, r7
   84f4c:	f85d 7b04 	ldr.w	r7, [sp], #4
   84f50:	4770      	bx	lr
   84f52:	bf00      	nop

00084f54 <can_enable_interrupt>:
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 * \param dw_mask Interrupt to be enabled.
 */
void can_enable_interrupt(Can *p_can, uint32_t dw_mask)
{
   84f54:	b480      	push	{r7}
   84f56:	b083      	sub	sp, #12
   84f58:	af00      	add	r7, sp, #0
   84f5a:	6078      	str	r0, [r7, #4]
   84f5c:	6039      	str	r1, [r7, #0]
	p_can->CAN_IER = dw_mask;
   84f5e:	687b      	ldr	r3, [r7, #4]
   84f60:	683a      	ldr	r2, [r7, #0]
   84f62:	605a      	str	r2, [r3, #4]
}
   84f64:	370c      	adds	r7, #12
   84f66:	46bd      	mov	sp, r7
   84f68:	f85d 7b04 	ldr.w	r7, [sp], #4
   84f6c:	4770      	bx	lr
   84f6e:	bf00      	nop

00084f70 <can_disable_interrupt>:
 *
 * \param p_can  Pointer to a CAN peripheral instance.
 * \param dw_mask Interrupt to be disabled.
 */
void can_disable_interrupt(Can *p_can, uint32_t dw_mask)
{
   84f70:	b480      	push	{r7}
   84f72:	b083      	sub	sp, #12
   84f74:	af00      	add	r7, sp, #0
   84f76:	6078      	str	r0, [r7, #4]
   84f78:	6039      	str	r1, [r7, #0]
	p_can->CAN_IDR = dw_mask;
   84f7a:	687b      	ldr	r3, [r7, #4]
   84f7c:	683a      	ldr	r2, [r7, #0]
   84f7e:	609a      	str	r2, [r3, #8]
}
   84f80:	370c      	adds	r7, #12
   84f82:	46bd      	mov	sp, r7
   84f84:	f85d 7b04 	ldr.w	r7, [sp], #4
   84f88:	4770      	bx	lr
   84f8a:	bf00      	nop

00084f8c <can_get_status>:
 * \param p_can Pointer to a CAN peripheral instance.
 *
 * \retval CAN status.
 */
uint32_t can_get_status(Can *p_can)
{
   84f8c:	b480      	push	{r7}
   84f8e:	b083      	sub	sp, #12
   84f90:	af00      	add	r7, sp, #0
   84f92:	6078      	str	r0, [r7, #4]
	return (p_can->CAN_SR);
   84f94:	687b      	ldr	r3, [r7, #4]
   84f96:	691b      	ldr	r3, [r3, #16]
}
   84f98:	4618      	mov	r0, r3
   84f9a:	370c      	adds	r7, #12
   84f9c:	46bd      	mov	sp, r7
   84f9e:	f85d 7b04 	ldr.w	r7, [sp], #4
   84fa2:	4770      	bx	lr

00084fa4 <can_global_send_transfer_cmd>:
 *
 * \param p_can   Pointer to a CAN peripheral instance.
 * \param uc_mask Mask for mailboxes that are requested to transfer.
 */
void can_global_send_transfer_cmd(Can *p_can, uint8_t uc_mask)
{
   84fa4:	b480      	push	{r7}
   84fa6:	b085      	sub	sp, #20
   84fa8:	af00      	add	r7, sp, #0
   84faa:	6078      	str	r0, [r7, #4]
   84fac:	460b      	mov	r3, r1
   84fae:	70fb      	strb	r3, [r7, #3]
	uint32_t ul_reg;

	ul_reg = p_can->CAN_TCR & ((uint32_t) ~GLOBAL_MAILBOX_MASK);
   84fb0:	687b      	ldr	r3, [r7, #4]
   84fb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   84fb4:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
   84fb8:	60fb      	str	r3, [r7, #12]
	p_can->CAN_TCR = ul_reg | uc_mask;
   84fba:	78fa      	ldrb	r2, [r7, #3]
   84fbc:	68fb      	ldr	r3, [r7, #12]
   84fbe:	431a      	orrs	r2, r3
   84fc0:	687b      	ldr	r3, [r7, #4]
   84fc2:	625a      	str	r2, [r3, #36]	; 0x24
}
   84fc4:	3714      	adds	r7, #20
   84fc6:	46bd      	mov	sp, r7
   84fc8:	f85d 7b04 	ldr.w	r7, [sp], #4
   84fcc:	4770      	bx	lr
   84fce:	bf00      	nop

00084fd0 <can_mailbox_get_status>:
 * \param uc_index Indicate which mailbox is to be read.
 *
 * \retval The mailbox status.
 */
uint32_t can_mailbox_get_status(Can *p_can, uint8_t uc_index)
{
   84fd0:	b480      	push	{r7}
   84fd2:	b083      	sub	sp, #12
   84fd4:	af00      	add	r7, sp, #0
   84fd6:	6078      	str	r0, [r7, #4]
   84fd8:	460b      	mov	r3, r1
   84fda:	70fb      	strb	r3, [r7, #3]
	return (p_can->CAN_MB[uc_index].CAN_MSR);
   84fdc:	78fb      	ldrb	r3, [r7, #3]
   84fde:	687a      	ldr	r2, [r7, #4]
   84fe0:	015b      	lsls	r3, r3, #5
   84fe2:	4413      	add	r3, r2
   84fe4:	f503 7304 	add.w	r3, r3, #528	; 0x210
   84fe8:	681b      	ldr	r3, [r3, #0]
}
   84fea:	4618      	mov	r0, r3
   84fec:	370c      	adds	r7, #12
   84fee:	46bd      	mov	sp, r7
   84ff0:	f85d 7b04 	ldr.w	r7, [sp], #4
   84ff4:	4770      	bx	lr
   84ff6:	bf00      	nop

00084ff8 <can_mailbox_send_transfer_cmd>:
 *
 * \param p_can   Pointer to a CAN peripheral instance.
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
void can_mailbox_send_transfer_cmd(Can *p_can, can_mb_conf_t *p_mailbox)
{
   84ff8:	b480      	push	{r7}
   84ffa:	b085      	sub	sp, #20
   84ffc:	af00      	add	r7, sp, #0
   84ffe:	6078      	str	r0, [r7, #4]
   85000:	6039      	str	r1, [r7, #0]
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
   85002:	683b      	ldr	r3, [r7, #0]
   85004:	681b      	ldr	r3, [r3, #0]
   85006:	73fb      	strb	r3, [r7, #15]

	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MTCR |
   85008:	7bfb      	ldrb	r3, [r7, #15]
			CAN_MCR_MDLC(p_mailbox->uc_length);;
   8500a:	683a      	ldr	r2, [r7, #0]
   8500c:	7992      	ldrb	r2, [r2, #6]
   8500e:	0412      	lsls	r2, r2, #16
   85010:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
{
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;

	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MTCR |
   85014:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
   85018:	6879      	ldr	r1, [r7, #4]
   8501a:	015b      	lsls	r3, r3, #5
   8501c:	440b      	add	r3, r1
   8501e:	f503 7306 	add.w	r3, r3, #536	; 0x218
   85022:	605a      	str	r2, [r3, #4]
			CAN_MCR_MDLC(p_mailbox->uc_length);;
}
   85024:	3714      	adds	r7, #20
   85026:	46bd      	mov	sp, r7
   85028:	f85d 7b04 	ldr.w	r7, [sp], #4
   8502c:	4770      	bx	lr
   8502e:	bf00      	nop

00085030 <can_mailbox_init>:
 *
 * \param p_can    Pointer to a CAN peripheral instance.
 * \param p_mailbox Pointer to a CAN mailbox instance.
 */
void can_mailbox_init(Can *p_can, can_mb_conf_t *p_mailbox)
{
   85030:	b480      	push	{r7}
   85032:	b085      	sub	sp, #20
   85034:	af00      	add	r7, sp, #0
   85036:	6078      	str	r0, [r7, #4]
   85038:	6039      	str	r1, [r7, #0]
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
   8503a:	683b      	ldr	r3, [r7, #0]
   8503c:	681b      	ldr	r3, [r3, #0]
   8503e:	73fb      	strb	r3, [r7, #15]
	/* Check the object type of the mailbox. If it's used to disable the
	 * mailbox, reset the whole mailbox. */
	if (!p_mailbox->uc_obj_type) {
   85040:	683b      	ldr	r3, [r7, #0]
   85042:	791b      	ldrb	r3, [r3, #4]
   85044:	2b00      	cmp	r3, #0
   85046:	d12e      	bne.n	850a6 <can_mailbox_init+0x76>
		p_can->CAN_MB[uc_index].CAN_MMR = 0;
   85048:	7bfb      	ldrb	r3, [r7, #15]
   8504a:	687a      	ldr	r2, [r7, #4]
   8504c:	3310      	adds	r3, #16
   8504e:	015b      	lsls	r3, r3, #5
   85050:	4413      	add	r3, r2
   85052:	2200      	movs	r2, #0
   85054:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MAM = 0;
   85056:	7bfb      	ldrb	r3, [r7, #15]
   85058:	687a      	ldr	r2, [r7, #4]
   8505a:	3310      	adds	r3, #16
   8505c:	015b      	lsls	r3, r3, #5
   8505e:	4413      	add	r3, r2
   85060:	2200      	movs	r2, #0
   85062:	605a      	str	r2, [r3, #4]
		p_can->CAN_MB[uc_index].CAN_MID = 0;
   85064:	7bfb      	ldrb	r3, [r7, #15]
   85066:	687a      	ldr	r2, [r7, #4]
   85068:	015b      	lsls	r3, r3, #5
   8506a:	4413      	add	r3, r2
   8506c:	f503 7302 	add.w	r3, r3, #520	; 0x208
   85070:	2200      	movs	r2, #0
   85072:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MDL = 0;
   85074:	7bfb      	ldrb	r3, [r7, #15]
   85076:	687a      	ldr	r2, [r7, #4]
   85078:	015b      	lsls	r3, r3, #5
   8507a:	4413      	add	r3, r2
   8507c:	f503 7304 	add.w	r3, r3, #528	; 0x210
   85080:	2200      	movs	r2, #0
   85082:	605a      	str	r2, [r3, #4]
		p_can->CAN_MB[uc_index].CAN_MDH = 0;
   85084:	7bfb      	ldrb	r3, [r7, #15]
   85086:	687a      	ldr	r2, [r7, #4]
   85088:	015b      	lsls	r3, r3, #5
   8508a:	4413      	add	r3, r2
   8508c:	f503 7306 	add.w	r3, r3, #536	; 0x218
   85090:	2200      	movs	r2, #0
   85092:	601a      	str	r2, [r3, #0]
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
   85094:	7bfb      	ldrb	r3, [r7, #15]
   85096:	687a      	ldr	r2, [r7, #4]
   85098:	015b      	lsls	r3, r3, #5
   8509a:	4413      	add	r3, r2
   8509c:	f503 7306 	add.w	r3, r3, #536	; 0x218
   850a0:	2200      	movs	r2, #0
   850a2:	605a      	str	r2, [r3, #4]
		return;
   850a4:	e04e      	b.n	85144 <can_mailbox_init+0x114>
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
   850a6:	7bfb      	ldrb	r3, [r7, #15]
   850a8:	7bfa      	ldrb	r2, [r7, #15]
   850aa:	6879      	ldr	r1, [r7, #4]
   850ac:	3210      	adds	r2, #16
   850ae:	0152      	lsls	r2, r2, #5
   850b0:	440a      	add	r2, r1
   850b2:	6812      	ldr	r2, [r2, #0]
   850b4:	f422 2170 	bic.w	r1, r2, #983040	; 0xf0000
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);
   850b8:	683a      	ldr	r2, [r7, #0]
   850ba:	79d2      	ldrb	r2, [r2, #7]
   850bc:	0412      	lsls	r2, r2, #16
		return;
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
			~CAN_MMR_PRIOR_Msk) |
   850be:	430a      	orrs	r2, r1
		p_can->CAN_MB[uc_index].CAN_MCR = 0;
		return;
	}

	/* Set the priority in Transmit mode. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
   850c0:	6879      	ldr	r1, [r7, #4]
   850c2:	3310      	adds	r3, #16
   850c4:	015b      	lsls	r3, r3, #5
   850c6:	440b      	add	r3, r1
   850c8:	601a      	str	r2, [r3, #0]
			~CAN_MMR_PRIOR_Msk) |
			(p_mailbox->uc_tx_prio << CAN_MMR_PRIOR_Pos);

	/* Set the message ID and message acceptance mask for the mailbox in
	 * other modes. */
	if (p_mailbox->uc_id_ver) {
   850ca:	683b      	ldr	r3, [r7, #0]
   850cc:	795b      	ldrb	r3, [r3, #5]
   850ce:	2b00      	cmp	r3, #0
   850d0:	d015      	beq.n	850fe <can_mailbox_init+0xce>
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk |
   850d2:	7bfb      	ldrb	r3, [r7, #15]
   850d4:	683a      	ldr	r2, [r7, #0]
   850d6:	68d2      	ldr	r2, [r2, #12]
   850d8:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
   850dc:	6879      	ldr	r1, [r7, #4]
   850de:	3310      	adds	r3, #16
   850e0:	015b      	lsls	r3, r3, #5
   850e2:	440b      	add	r3, r1
   850e4:	605a      	str	r2, [r3, #4]
				CAN_MAM_MIDE;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
   850e6:	7bfb      	ldrb	r3, [r7, #15]
   850e8:	683a      	ldr	r2, [r7, #0]
   850ea:	6912      	ldr	r2, [r2, #16]
   850ec:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
   850f0:	6879      	ldr	r1, [r7, #4]
   850f2:	015b      	lsls	r3, r3, #5
   850f4:	440b      	add	r3, r1
   850f6:	f503 7302 	add.w	r3, r3, #520	; 0x208
   850fa:	601a      	str	r2, [r3, #0]
   850fc:	e010      	b.n	85120 <can_mailbox_init+0xf0>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
   850fe:	7bfb      	ldrb	r3, [r7, #15]
   85100:	683a      	ldr	r2, [r7, #0]
   85102:	68d2      	ldr	r2, [r2, #12]
   85104:	6879      	ldr	r1, [r7, #4]
   85106:	3310      	adds	r3, #16
   85108:	015b      	lsls	r3, r3, #5
   8510a:	440b      	add	r3, r1
   8510c:	605a      	str	r2, [r3, #4]
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
   8510e:	7bfb      	ldrb	r3, [r7, #15]
   85110:	683a      	ldr	r2, [r7, #0]
   85112:	6912      	ldr	r2, [r2, #16]
   85114:	6879      	ldr	r1, [r7, #4]
   85116:	015b      	lsls	r3, r3, #5
   85118:	440b      	add	r3, r1
   8511a:	f503 7302 	add.w	r3, r3, #520	; 0x208
   8511e:	601a      	str	r2, [r3, #0]
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
   85120:	7bfb      	ldrb	r3, [r7, #15]
   85122:	7bfa      	ldrb	r2, [r7, #15]
   85124:	6879      	ldr	r1, [r7, #4]
   85126:	3210      	adds	r2, #16
   85128:	0152      	lsls	r2, r2, #5
   8512a:	440a      	add	r2, r1
   8512c:	6812      	ldr	r2, [r2, #0]
   8512e:	f022 61e0 	bic.w	r1, r2, #117440512	; 0x7000000
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
   85132:	683a      	ldr	r2, [r7, #0]
   85134:	7912      	ldrb	r2, [r2, #4]
   85136:	0612      	lsls	r2, r2, #24
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
			~CAN_MMR_MOT_Msk) |
   85138:	430a      	orrs	r2, r1
		p_can->CAN_MB[uc_index].CAN_MAM = p_mailbox->ul_id_msk;
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
	}

	/* Set up mailbox in one of the five different modes. */
	p_can->CAN_MB[uc_index].CAN_MMR = (p_can->CAN_MB[uc_index].CAN_MMR &
   8513a:	6879      	ldr	r1, [r7, #4]
   8513c:	3310      	adds	r3, #16
   8513e:	015b      	lsls	r3, r3, #5
   85140:	440b      	add	r3, r1
   85142:	601a      	str	r2, [r3, #0]
			~CAN_MMR_MOT_Msk) |
			(p_mailbox->uc_obj_type << CAN_MMR_MOT_Pos);
}
   85144:	3714      	adds	r7, #20
   85146:	46bd      	mov	sp, r7
   85148:	f85d 7b04 	ldr.w	r7, [sp], #4
   8514c:	4770      	bx	lr
   8514e:	bf00      	nop

00085150 <can_mailbox_read>:
 * \retval Different CAN mailbox transfer status.
 *
 * \note Read the mailbox status before calling this function.
 */
uint32_t can_mailbox_read(Can *p_can, can_mb_conf_t *p_mailbox)
{
   85150:	b580      	push	{r7, lr}
   85152:	b086      	sub	sp, #24
   85154:	af00      	add	r7, sp, #0
   85156:	6078      	str	r0, [r7, #4]
   85158:	6039      	str	r1, [r7, #0]
	uint32_t ul_status;
	uint8_t uc_index;
	uint32_t ul_retval;

	ul_retval = 0;
   8515a:	2300      	movs	r3, #0
   8515c:	617b      	str	r3, [r7, #20]
	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
   8515e:	683b      	ldr	r3, [r7, #0]
   85160:	681b      	ldr	r3, [r3, #0]
   85162:	74fb      	strb	r3, [r7, #19]
	ul_status = p_mailbox->ul_status;
   85164:	683b      	ldr	r3, [r7, #0]
   85166:	689b      	ldr	r3, [r3, #8]
   85168:	60fb      	str	r3, [r7, #12]

	/* Check whether there is overwriting happening in Receive with
	 * Overwrite mode,
	 * or there're messages lost in Receive mode. */
	if ((ul_status & CAN_MSR_MRDY) && (ul_status & CAN_MSR_MMI)) {
   8516a:	68fb      	ldr	r3, [r7, #12]
   8516c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
   85170:	2b00      	cmp	r3, #0
   85172:	d006      	beq.n	85182 <can_mailbox_read+0x32>
   85174:	68fb      	ldr	r3, [r7, #12]
   85176:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   8517a:	2b00      	cmp	r3, #0
   8517c:	d001      	beq.n	85182 <can_mailbox_read+0x32>
		ul_retval = CAN_MAILBOX_RX_OVER;
   8517e:	2302      	movs	r3, #2
   85180:	617b      	str	r3, [r7, #20]
	}

	/* Read the message family ID. */
	p_mailbox->ul_fid = p_can->CAN_MB[uc_index].CAN_MFID &
   85182:	7cfb      	ldrb	r3, [r7, #19]
   85184:	687a      	ldr	r2, [r7, #4]
   85186:	015b      	lsls	r3, r3, #5
   85188:	4413      	add	r3, r2
   8518a:	f503 7302 	add.w	r3, r3, #520	; 0x208
   8518e:	685b      	ldr	r3, [r3, #4]
   85190:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
   85194:	683b      	ldr	r3, [r7, #0]
   85196:	615a      	str	r2, [r3, #20]
			CAN_MFID_MFID_Msk;

	/* Read received data length. */
	p_mailbox->uc_length
		= (ul_status & CAN_MSR_MDLC_Msk) >> CAN_MSR_MDLC_Pos;
   85198:	68fb      	ldr	r3, [r7, #12]
   8519a:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
   8519e:	0c1b      	lsrs	r3, r3, #16
   851a0:	b2da      	uxtb	r2, r3
   851a2:	683b      	ldr	r3, [r7, #0]
   851a4:	719a      	strb	r2, [r3, #6]

	/* Read received data. */
	p_mailbox->ul_datal = p_can->CAN_MB[uc_index].CAN_MDL;
   851a6:	7cfb      	ldrb	r3, [r7, #19]
   851a8:	687a      	ldr	r2, [r7, #4]
   851aa:	015b      	lsls	r3, r3, #5
   851ac:	4413      	add	r3, r2
   851ae:	f503 7304 	add.w	r3, r3, #528	; 0x210
   851b2:	685a      	ldr	r2, [r3, #4]
   851b4:	683b      	ldr	r3, [r7, #0]
   851b6:	619a      	str	r2, [r3, #24]
	if (p_mailbox->uc_length > 4) {
   851b8:	683b      	ldr	r3, [r7, #0]
   851ba:	799b      	ldrb	r3, [r3, #6]
   851bc:	2b04      	cmp	r3, #4
   851be:	d908      	bls.n	851d2 <can_mailbox_read+0x82>
		p_mailbox->ul_datah = p_can->CAN_MB[uc_index].CAN_MDH;
   851c0:	7cfb      	ldrb	r3, [r7, #19]
   851c2:	687a      	ldr	r2, [r7, #4]
   851c4:	015b      	lsls	r3, r3, #5
   851c6:	4413      	add	r3, r2
   851c8:	f503 7306 	add.w	r3, r3, #536	; 0x218
   851cc:	681a      	ldr	r2, [r3, #0]
   851ce:	683b      	ldr	r3, [r7, #0]
   851d0:	61da      	str	r2, [r3, #28]
	}

	/* Read the mailbox status again to check whether the software needs to
	 * re-read mailbox data register. */
	p_mailbox->ul_status = p_can->CAN_MB[uc_index].CAN_MSR;
   851d2:	7cfb      	ldrb	r3, [r7, #19]
   851d4:	687a      	ldr	r2, [r7, #4]
   851d6:	015b      	lsls	r3, r3, #5
   851d8:	4413      	add	r3, r2
   851da:	f503 7304 	add.w	r3, r3, #528	; 0x210
   851de:	681a      	ldr	r2, [r3, #0]
   851e0:	683b      	ldr	r3, [r7, #0]
   851e2:	609a      	str	r2, [r3, #8]
	ul_status = p_mailbox->ul_status;
   851e4:	683b      	ldr	r3, [r7, #0]
   851e6:	689b      	ldr	r3, [r3, #8]
   851e8:	60fb      	str	r3, [r7, #12]
	if (ul_status & CAN_MSR_MMI) {
   851ea:	68fb      	ldr	r3, [r7, #12]
   851ec:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   851f0:	2b00      	cmp	r3, #0
   851f2:	d003      	beq.n	851fc <can_mailbox_read+0xac>
		ul_retval |= CAN_MAILBOX_RX_NEED_RD_AGAIN;
   851f4:	697b      	ldr	r3, [r7, #20]
   851f6:	f043 0304 	orr.w	r3, r3, #4
   851fa:	617b      	str	r3, [r7, #20]
	} else {
		ul_retval |= CAN_MAILBOX_TRANSFER_OK;
	}

	/* Enable next receive process. */
	can_mailbox_send_transfer_cmd(p_can, p_mailbox);
   851fc:	6878      	ldr	r0, [r7, #4]
   851fe:	6839      	ldr	r1, [r7, #0]
   85200:	4b03      	ldr	r3, [pc, #12]	; (85210 <can_mailbox_read+0xc0>)
   85202:	4798      	blx	r3

	return ul_retval;
   85204:	697b      	ldr	r3, [r7, #20]
}
   85206:	4618      	mov	r0, r3
   85208:	3718      	adds	r7, #24
   8520a:	46bd      	mov	sp, r7
   8520c:	bd80      	pop	{r7, pc}
   8520e:	bf00      	nop
   85210:	00084ff9 	.word	0x00084ff9

00085214 <can_mailbox_write>:
 * \note After calling this function, the mailbox message won't be sent out
 *until
 * can_mailbox_send_transfer_cmd() is called.
 */
uint32_t can_mailbox_write(Can *p_can, can_mb_conf_t *p_mailbox)
{
   85214:	b580      	push	{r7, lr}
   85216:	b084      	sub	sp, #16
   85218:	af00      	add	r7, sp, #0
   8521a:	6078      	str	r0, [r7, #4]
   8521c:	6039      	str	r1, [r7, #0]
	uint32_t ul_status;
	uint8_t uc_index;

	uc_index = (uint8_t)p_mailbox->ul_mb_idx;
   8521e:	683b      	ldr	r3, [r7, #0]
   85220:	681b      	ldr	r3, [r3, #0]
   85222:	73fb      	strb	r3, [r7, #15]
	/* Read the mailbox status firstly to check whether the mailbox is ready
	 *or not. */
	p_mailbox->ul_status = can_mailbox_get_status(p_can, uc_index);
   85224:	7bfb      	ldrb	r3, [r7, #15]
   85226:	6878      	ldr	r0, [r7, #4]
   85228:	4619      	mov	r1, r3
   8522a:	4b27      	ldr	r3, [pc, #156]	; (852c8 <can_mailbox_write+0xb4>)
   8522c:	4798      	blx	r3
   8522e:	4602      	mov	r2, r0
   85230:	683b      	ldr	r3, [r7, #0]
   85232:	609a      	str	r2, [r3, #8]
	ul_status = p_mailbox->ul_status;
   85234:	683b      	ldr	r3, [r7, #0]
   85236:	689b      	ldr	r3, [r3, #8]
   85238:	60bb      	str	r3, [r7, #8]
	if (!(ul_status & CAN_MSR_MRDY)) {
   8523a:	68bb      	ldr	r3, [r7, #8]
   8523c:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
   85240:	2b00      	cmp	r3, #0
   85242:	d101      	bne.n	85248 <can_mailbox_write+0x34>
		return CAN_MAILBOX_NOT_READY;
   85244:	2301      	movs	r3, #1
   85246:	e03b      	b.n	852c0 <can_mailbox_write+0xac>
	}

	/* Write transmit identifier. */
	if (p_mailbox->uc_id_ver) {
   85248:	683b      	ldr	r3, [r7, #0]
   8524a:	795b      	ldrb	r3, [r3, #5]
   8524c:	2b00      	cmp	r3, #0
   8524e:	d00b      	beq.n	85268 <can_mailbox_write+0x54>
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id |
   85250:	7bfb      	ldrb	r3, [r7, #15]
   85252:	683a      	ldr	r2, [r7, #0]
   85254:	6912      	ldr	r2, [r2, #16]
   85256:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
   8525a:	6879      	ldr	r1, [r7, #4]
   8525c:	015b      	lsls	r3, r3, #5
   8525e:	440b      	add	r3, r1
   85260:	f503 7302 	add.w	r3, r3, #520	; 0x208
   85264:	601a      	str	r2, [r3, #0]
   85266:	e008      	b.n	8527a <can_mailbox_write+0x66>
				CAN_MAM_MIDE;
	} else {
		p_can->CAN_MB[uc_index].CAN_MID = p_mailbox->ul_id;
   85268:	7bfb      	ldrb	r3, [r7, #15]
   8526a:	683a      	ldr	r2, [r7, #0]
   8526c:	6912      	ldr	r2, [r2, #16]
   8526e:	6879      	ldr	r1, [r7, #4]
   85270:	015b      	lsls	r3, r3, #5
   85272:	440b      	add	r3, r1
   85274:	f503 7302 	add.w	r3, r3, #520	; 0x208
   85278:	601a      	str	r2, [r3, #0]
	}

	/* Write transmit data into mailbox data register. */
	p_can->CAN_MB[uc_index].CAN_MDL = p_mailbox->ul_datal;
   8527a:	7bfb      	ldrb	r3, [r7, #15]
   8527c:	683a      	ldr	r2, [r7, #0]
   8527e:	6992      	ldr	r2, [r2, #24]
   85280:	6879      	ldr	r1, [r7, #4]
   85282:	015b      	lsls	r3, r3, #5
   85284:	440b      	add	r3, r1
   85286:	f503 7304 	add.w	r3, r3, #528	; 0x210
   8528a:	605a      	str	r2, [r3, #4]
	if (p_mailbox->uc_length > 4) {
   8528c:	683b      	ldr	r3, [r7, #0]
   8528e:	799b      	ldrb	r3, [r3, #6]
   85290:	2b04      	cmp	r3, #4
   85292:	d908      	bls.n	852a6 <can_mailbox_write+0x92>
		p_can->CAN_MB[uc_index].CAN_MDH = p_mailbox->ul_datah;
   85294:	7bfb      	ldrb	r3, [r7, #15]
   85296:	683a      	ldr	r2, [r7, #0]
   85298:	69d2      	ldr	r2, [r2, #28]
   8529a:	6879      	ldr	r1, [r7, #4]
   8529c:	015b      	lsls	r3, r3, #5
   8529e:	440b      	add	r3, r1
   852a0:	f503 7306 	add.w	r3, r3, #536	; 0x218
   852a4:	601a      	str	r2, [r3, #0]
	}

	/* Write transmit data length into mailbox control register. */
	p_can->CAN_MB[uc_index].CAN_MCR = CAN_MCR_MDLC(p_mailbox->uc_length);
   852a6:	7bfb      	ldrb	r3, [r7, #15]
   852a8:	683a      	ldr	r2, [r7, #0]
   852aa:	7992      	ldrb	r2, [r2, #6]
   852ac:	0412      	lsls	r2, r2, #16
   852ae:	f402 2270 	and.w	r2, r2, #983040	; 0xf0000
   852b2:	6879      	ldr	r1, [r7, #4]
   852b4:	015b      	lsls	r3, r3, #5
   852b6:	440b      	add	r3, r1
   852b8:	f503 7306 	add.w	r3, r3, #536	; 0x218
   852bc:	605a      	str	r2, [r3, #4]

	return CAN_MAILBOX_TRANSFER_OK;
   852be:	2300      	movs	r3, #0
}
   852c0:	4618      	mov	r0, r3
   852c2:	3710      	adds	r7, #16
   852c4:	46bd      	mov	sp, r7
   852c6:	bd80      	pop	{r7, pc}
   852c8:	00084fd1 	.word	0x00084fd1

000852cc <can_reset_all_mailbox>:
 * \brief Reset the eight mailboxes.
 *
 * \param p_can Pointer to a CAN peripheral instance.
 */
void can_reset_all_mailbox(Can *p_can)
{
   852cc:	b580      	push	{r7, lr}
   852ce:	b08c      	sub	sp, #48	; 0x30
   852d0:	af00      	add	r7, sp, #0
   852d2:	6078      	str	r0, [r7, #4]
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;
   852d4:	2300      	movs	r3, #0
   852d6:	743b      	strb	r3, [r7, #16]

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
   852d8:	2300      	movs	r3, #0
   852da:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   852de:	e00d      	b.n	852fc <can_reset_all_mailbox+0x30>
		mb_config_t.ul_mb_idx = i;
   852e0:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   852e4:	60fb      	str	r3, [r7, #12]
		can_mailbox_init(p_can, &mb_config_t);
   852e6:	f107 030c 	add.w	r3, r7, #12
   852ea:	6878      	ldr	r0, [r7, #4]
   852ec:	4619      	mov	r1, r3
   852ee:	4b07      	ldr	r3, [pc, #28]	; (8530c <can_reset_all_mailbox+0x40>)
   852f0:	4798      	blx	r3
	can_mb_conf_t mb_config_t;

	/* Set the mailbox object type parameter to disable the mailbox. */
	mb_config_t.uc_obj_type = CAN_MB_DISABLE_MODE;

	for (uint8_t i = 0; i < CANMB_NUMBER; i++) {
   852f2:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   852f6:	3301      	adds	r3, #1
   852f8:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
   852fc:	f897 302f 	ldrb.w	r3, [r7, #47]	; 0x2f
   85300:	2b07      	cmp	r3, #7
   85302:	d9ed      	bls.n	852e0 <can_reset_all_mailbox+0x14>
		mb_config_t.ul_mb_idx = i;
		can_mailbox_init(p_can, &mb_config_t);
	}
}
   85304:	3730      	adds	r7, #48	; 0x30
   85306:	46bd      	mov	sp, r7
   85308:	bd80      	pop	{r7, pc}
   8530a:	bf00      	nop
   8530c:	00085031 	.word	0x00085031

00085310 <pio_pull_up>:
 * \param ul_pull_up_enable Indicates if the pin(s) internal pull-up shall be
 * configured.
 */
void pio_pull_up(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_pull_up_enable)
{
   85310:	b480      	push	{r7}
   85312:	b085      	sub	sp, #20
   85314:	af00      	add	r7, sp, #0
   85316:	60f8      	str	r0, [r7, #12]
   85318:	60b9      	str	r1, [r7, #8]
   8531a:	607a      	str	r2, [r7, #4]
	/* Enable the pull-up(s) if necessary */
	if (ul_pull_up_enable) {
   8531c:	687b      	ldr	r3, [r7, #4]
   8531e:	2b00      	cmp	r3, #0
   85320:	d003      	beq.n	8532a <pio_pull_up+0x1a>
		p_pio->PIO_PUER = ul_mask;
   85322:	68fb      	ldr	r3, [r7, #12]
   85324:	68ba      	ldr	r2, [r7, #8]
   85326:	665a      	str	r2, [r3, #100]	; 0x64
   85328:	e002      	b.n	85330 <pio_pull_up+0x20>
	} else {
		p_pio->PIO_PUDR = ul_mask;
   8532a:	68fb      	ldr	r3, [r7, #12]
   8532c:	68ba      	ldr	r2, [r7, #8]
   8532e:	661a      	str	r2, [r3, #96]	; 0x60
	}
}
   85330:	3714      	adds	r7, #20
   85332:	46bd      	mov	sp, r7
   85334:	f85d 7b04 	ldr.w	r7, [sp], #4
   85338:	4770      	bx	lr
   8533a:	bf00      	nop

0008533c <pio_set_peripheral>:
 * \param ul_type PIO type.
 * \param ul_mask Bitmask of one or more pin(s) to configure.
 */
void pio_set_peripheral(Pio *p_pio, const pio_type_t ul_type,
		const uint32_t ul_mask)
{
   8533c:	b480      	push	{r7}
   8533e:	b087      	sub	sp, #28
   85340:	af00      	add	r7, sp, #0
   85342:	60f8      	str	r0, [r7, #12]
   85344:	60b9      	str	r1, [r7, #8]
   85346:	607a      	str	r2, [r7, #4]
	uint32_t ul_sr;

	/* Disable interrupts on the pin(s) */
	p_pio->PIO_IDR = ul_mask;
   85348:	68fb      	ldr	r3, [r7, #12]
   8534a:	687a      	ldr	r2, [r7, #4]
   8534c:	645a      	str	r2, [r3, #68]	; 0x44
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
	}
#elif (SAM3XA|| SAM3U)
	switch (ul_type) {
   8534e:	68bb      	ldr	r3, [r7, #8]
   85350:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   85354:	d01f      	beq.n	85396 <pio_set_peripheral+0x5a>
   85356:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   8535a:	d805      	bhi.n	85368 <pio_set_peripheral+0x2c>
   8535c:	2b00      	cmp	r3, #0
   8535e:	d027      	beq.n	853b0 <pio_set_peripheral+0x74>
   85360:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
   85364:	d00a      	beq.n	8537c <pio_set_peripheral+0x40>
   85366:	e01f      	b.n	853a8 <pio_set_peripheral+0x6c>
   85368:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   8536c:	d020      	beq.n	853b0 <pio_set_peripheral+0x74>
   8536e:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   85372:	d01d      	beq.n	853b0 <pio_set_peripheral+0x74>
   85374:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   85378:	d01a      	beq.n	853b0 <pio_set_peripheral+0x74>
   8537a:	e015      	b.n	853a8 <pio_set_peripheral+0x6c>
	case PIO_PERIPH_A:
		ul_sr = p_pio->PIO_ABSR;
   8537c:	68fb      	ldr	r3, [r7, #12]
   8537e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   85380:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABSR &= (~ul_mask & ul_sr);
   85382:	68fb      	ldr	r3, [r7, #12]
   85384:	6f1a      	ldr	r2, [r3, #112]	; 0x70
   85386:	687b      	ldr	r3, [r7, #4]
   85388:	43d9      	mvns	r1, r3
   8538a:	697b      	ldr	r3, [r7, #20]
   8538c:	400b      	ands	r3, r1
   8538e:	401a      	ands	r2, r3
   85390:	68fb      	ldr	r3, [r7, #12]
   85392:	671a      	str	r2, [r3, #112]	; 0x70
		break;
   85394:	e008      	b.n	853a8 <pio_set_peripheral+0x6c>

	case PIO_PERIPH_B:
		ul_sr = p_pio->PIO_ABSR;
   85396:	68fb      	ldr	r3, [r7, #12]
   85398:	6f1b      	ldr	r3, [r3, #112]	; 0x70
   8539a:	617b      	str	r3, [r7, #20]
		p_pio->PIO_ABSR = (ul_mask | ul_sr);
   8539c:	687a      	ldr	r2, [r7, #4]
   8539e:	697b      	ldr	r3, [r7, #20]
   853a0:	431a      	orrs	r2, r3
   853a2:	68fb      	ldr	r3, [r7, #12]
   853a4:	671a      	str	r2, [r3, #112]	; 0x70
		break;
   853a6:	bf00      	nop
#else
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
   853a8:	68fb      	ldr	r3, [r7, #12]
   853aa:	687a      	ldr	r2, [r7, #4]
   853ac:	605a      	str	r2, [r3, #4]
   853ae:	e000      	b.n	853b2 <pio_set_peripheral+0x76>
		// other types are invalid in this function
	case PIO_INPUT:
	case PIO_OUTPUT_0:
	case PIO_OUTPUT_1:
	case PIO_NOT_A_PIN:
		return;
   853b0:	bf00      	nop
#error "Unsupported device"
#endif

	// Remove the pins from under the control of PIO
	p_pio->PIO_PDR = ul_mask;
}
   853b2:	371c      	adds	r7, #28
   853b4:	46bd      	mov	sp, r7
   853b6:	f85d 7b04 	ldr.w	r7, [sp], #4
   853ba:	4770      	bx	lr

000853bc <pio_set_input>:
 * \param ul_mask Bitmask indicating which pin(s) to configure as input(s).
 * \param ul_attribute PIO attribute(s).
 */
void pio_set_input(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_attribute)
{
   853bc:	b580      	push	{r7, lr}
   853be:	b084      	sub	sp, #16
   853c0:	af00      	add	r7, sp, #0
   853c2:	60f8      	str	r0, [r7, #12]
   853c4:	60b9      	str	r1, [r7, #8]
   853c6:	607a      	str	r2, [r7, #4]
	pio_disable_interrupt(p_pio, ul_mask);
   853c8:	68f8      	ldr	r0, [r7, #12]
   853ca:	68b9      	ldr	r1, [r7, #8]
   853cc:	4b14      	ldr	r3, [pc, #80]	; (85420 <pio_set_input+0x64>)
   853ce:	4798      	blx	r3
	//pio_pull_up(p_pio, ul_mask, ul_attribute & PIO_PULLUP);

	/* Enable Input Filter if necessary */
	if (ul_attribute & (PIO_DEGLITCH | PIO_DEBOUNCE)) {
   853d0:	687b      	ldr	r3, [r7, #4]
   853d2:	f003 030a 	and.w	r3, r3, #10
   853d6:	2b00      	cmp	r3, #0
   853d8:	d003      	beq.n	853e2 <pio_set_input+0x26>
		p_pio->PIO_IFER = ul_mask;
   853da:	68fb      	ldr	r3, [r7, #12]
   853dc:	68ba      	ldr	r2, [r7, #8]
   853de:	621a      	str	r2, [r3, #32]
   853e0:	e002      	b.n	853e8 <pio_set_input+0x2c>
	} else {
		p_pio->PIO_IFDR = ul_mask;
   853e2:	68fb      	ldr	r3, [r7, #12]
   853e4:	68ba      	ldr	r2, [r7, #8]
   853e6:	625a      	str	r2, [r3, #36]	; 0x24
			p_pio->PIO_IFSCER = ul_mask;
		}
	}
#elif (SAM3XA|| SAM3U)
	/* Enable de-glitch or de-bounce if necessary */
	if (ul_attribute & PIO_DEGLITCH) {
   853e8:	687b      	ldr	r3, [r7, #4]
   853ea:	f003 0302 	and.w	r3, r3, #2
   853ee:	2b00      	cmp	r3, #0
   853f0:	d004      	beq.n	853fc <pio_set_input+0x40>
		p_pio->PIO_SCIFSR = ul_mask;
   853f2:	68fb      	ldr	r3, [r7, #12]
   853f4:	68ba      	ldr	r2, [r7, #8]
   853f6:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
   853fa:	e008      	b.n	8540e <pio_set_input+0x52>
	} else {
		if (ul_attribute & PIO_DEBOUNCE) {
   853fc:	687b      	ldr	r3, [r7, #4]
   853fe:	f003 0308 	and.w	r3, r3, #8
   85402:	2b00      	cmp	r3, #0
   85404:	d003      	beq.n	8540e <pio_set_input+0x52>
			p_pio->PIO_SCIFSR = ul_mask;
   85406:	68fb      	ldr	r3, [r7, #12]
   85408:	68ba      	ldr	r2, [r7, #8]
   8540a:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
#else
#error "Unsupported device"
#endif

	/* Configure pin as input */
	p_pio->PIO_ODR = ul_mask;
   8540e:	68fb      	ldr	r3, [r7, #12]
   85410:	68ba      	ldr	r2, [r7, #8]
   85412:	615a      	str	r2, [r3, #20]
	p_pio->PIO_PER = ul_mask;
   85414:	68fb      	ldr	r3, [r7, #12]
   85416:	68ba      	ldr	r2, [r7, #8]
   85418:	601a      	str	r2, [r3, #0]
}
   8541a:	3710      	adds	r7, #16
   8541c:	46bd      	mov	sp, r7
   8541e:	bd80      	pop	{r7, pc}
   85420:	00085489 	.word	0x00085489

00085424 <pio_set_output>:
 */
void pio_set_output(Pio *p_pio, const uint32_t ul_mask,
		const uint32_t ul_default_level,
		const uint32_t ul_multidrive_enable,
		const uint32_t ul_pull_up_enable)
{
   85424:	b580      	push	{r7, lr}
   85426:	b084      	sub	sp, #16
   85428:	af00      	add	r7, sp, #0
   8542a:	60f8      	str	r0, [r7, #12]
   8542c:	60b9      	str	r1, [r7, #8]
   8542e:	607a      	str	r2, [r7, #4]
   85430:	603b      	str	r3, [r7, #0]
	pio_disable_interrupt(p_pio, ul_mask);
   85432:	68f8      	ldr	r0, [r7, #12]
   85434:	68b9      	ldr	r1, [r7, #8]
   85436:	4b12      	ldr	r3, [pc, #72]	; (85480 <pio_set_output+0x5c>)
   85438:	4798      	blx	r3
	pio_pull_up(p_pio, ul_mask, ul_pull_up_enable);
   8543a:	68f8      	ldr	r0, [r7, #12]
   8543c:	68b9      	ldr	r1, [r7, #8]
   8543e:	69ba      	ldr	r2, [r7, #24]
   85440:	4b10      	ldr	r3, [pc, #64]	; (85484 <pio_set_output+0x60>)
   85442:	4798      	blx	r3

	/* Enable multi-drive if necessary */
	if (ul_multidrive_enable) {
   85444:	683b      	ldr	r3, [r7, #0]
   85446:	2b00      	cmp	r3, #0
   85448:	d003      	beq.n	85452 <pio_set_output+0x2e>
		p_pio->PIO_MDER = ul_mask;
   8544a:	68fb      	ldr	r3, [r7, #12]
   8544c:	68ba      	ldr	r2, [r7, #8]
   8544e:	651a      	str	r2, [r3, #80]	; 0x50
   85450:	e002      	b.n	85458 <pio_set_output+0x34>
	} else {
		p_pio->PIO_MDDR = ul_mask;
   85452:	68fb      	ldr	r3, [r7, #12]
   85454:	68ba      	ldr	r2, [r7, #8]
   85456:	655a      	str	r2, [r3, #84]	; 0x54
	}

	/* Set default value */
	if (ul_default_level) {
   85458:	687b      	ldr	r3, [r7, #4]
   8545a:	2b00      	cmp	r3, #0
   8545c:	d003      	beq.n	85466 <pio_set_output+0x42>
		p_pio->PIO_SODR = ul_mask;
   8545e:	68fb      	ldr	r3, [r7, #12]
   85460:	68ba      	ldr	r2, [r7, #8]
   85462:	631a      	str	r2, [r3, #48]	; 0x30
   85464:	e002      	b.n	8546c <pio_set_output+0x48>
	} else {
		p_pio->PIO_CODR = ul_mask;
   85466:	68fb      	ldr	r3, [r7, #12]
   85468:	68ba      	ldr	r2, [r7, #8]
   8546a:	635a      	str	r2, [r3, #52]	; 0x34
	}

	/* Configure pin(s) as output(s) */
	p_pio->PIO_OER = ul_mask;
   8546c:	68fb      	ldr	r3, [r7, #12]
   8546e:	68ba      	ldr	r2, [r7, #8]
   85470:	611a      	str	r2, [r3, #16]
	p_pio->PIO_PER = ul_mask;
   85472:	68fb      	ldr	r3, [r7, #12]
   85474:	68ba      	ldr	r2, [r7, #8]
   85476:	601a      	str	r2, [r3, #0]
}
   85478:	3710      	adds	r7, #16
   8547a:	46bd      	mov	sp, r7
   8547c:	bd80      	pop	{r7, pc}
   8547e:	bf00      	nop
   85480:	00085489 	.word	0x00085489
   85484:	00085311 	.word	0x00085311

00085488 <pio_disable_interrupt>:
 *
 * \param p_pio Pointer to a PIO instance.
 * \param ul_mask Interrupt sources bit map.
 */
void pio_disable_interrupt(Pio *p_pio, const uint32_t ul_mask)
{
   85488:	b480      	push	{r7}
   8548a:	b083      	sub	sp, #12
   8548c:	af00      	add	r7, sp, #0
   8548e:	6078      	str	r0, [r7, #4]
   85490:	6039      	str	r1, [r7, #0]
	p_pio->PIO_IDR = ul_mask;
   85492:	687b      	ldr	r3, [r7, #4]
   85494:	683a      	ldr	r2, [r7, #0]
   85496:	645a      	str	r2, [r3, #68]	; 0x44
}
   85498:	370c      	adds	r7, #12
   8549a:	46bd      	mov	sp, r7
   8549c:	f85d 7b04 	ldr.w	r7, [sp], #4
   854a0:	4770      	bx	lr
   854a2:	bf00      	nop

000854a4 <pio_get_interrupt_status>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt status mask value.
 */
uint32_t pio_get_interrupt_status(const Pio *p_pio)
{
   854a4:	b480      	push	{r7}
   854a6:	b083      	sub	sp, #12
   854a8:	af00      	add	r7, sp, #0
   854aa:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_ISR;
   854ac:	687b      	ldr	r3, [r7, #4]
   854ae:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
}
   854b0:	4618      	mov	r0, r3
   854b2:	370c      	adds	r7, #12
   854b4:	46bd      	mov	sp, r7
   854b6:	f85d 7b04 	ldr.w	r7, [sp], #4
   854ba:	4770      	bx	lr

000854bc <pio_get_interrupt_mask>:
 * \param p_pio Pointer to a PIO instance.
 *
 * \return The interrupt mask value.
 */
uint32_t pio_get_interrupt_mask(const Pio *p_pio)
{
   854bc:	b480      	push	{r7}
   854be:	b083      	sub	sp, #12
   854c0:	af00      	add	r7, sp, #0
   854c2:	6078      	str	r0, [r7, #4]
	return p_pio->PIO_IMR;
   854c4:	687b      	ldr	r3, [r7, #4]
   854c6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
}
   854c8:	4618      	mov	r0, r3
   854ca:	370c      	adds	r7, #12
   854cc:	46bd      	mov	sp, r7
   854ce:	f85d 7b04 	ldr.w	r7, [sp], #4
   854d2:	4770      	bx	lr

000854d4 <pio_set_pin_high>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called beforehand.
 */
void pio_set_pin_high(uint32_t ul_pin)
{
   854d4:	b480      	push	{r7}
   854d6:	b085      	sub	sp, #20
   854d8:	af00      	add	r7, sp, #0
   854da:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
   854dc:	687b      	ldr	r3, [r7, #4]
   854de:	095b      	lsrs	r3, r3, #5
   854e0:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   854e4:	f203 7307 	addw	r3, r3, #1799	; 0x707
   854e8:	025b      	lsls	r3, r3, #9
   854ea:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 1.
	p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
   854ec:	687b      	ldr	r3, [r7, #4]
   854ee:	f003 031f 	and.w	r3, r3, #31
   854f2:	2201      	movs	r2, #1
   854f4:	fa02 f303 	lsl.w	r3, r2, r3
   854f8:	461a      	mov	r2, r3
   854fa:	68fb      	ldr	r3, [r7, #12]
   854fc:	631a      	str	r2, [r3, #48]	; 0x30
}
   854fe:	3714      	adds	r7, #20
   85500:	46bd      	mov	sp, r7
   85502:	f85d 7b04 	ldr.w	r7, [sp], #4
   85506:	4770      	bx	lr

00085508 <pio_set_pin_low>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_set_pin_low(uint32_t ul_pin)
{
   85508:	b480      	push	{r7}
   8550a:	b085      	sub	sp, #20
   8550c:	af00      	add	r7, sp, #0
   8550e:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
   85510:	687b      	ldr	r3, [r7, #4]
   85512:	095b      	lsrs	r3, r3, #5
   85514:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   85518:	f203 7307 	addw	r3, r3, #1799	; 0x707
   8551c:	025b      	lsls	r3, r3, #9
   8551e:	60fb      	str	r3, [r7, #12]
	// Value to be driven on the I/O line: 0.
	p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
   85520:	687b      	ldr	r3, [r7, #4]
   85522:	f003 031f 	and.w	r3, r3, #31
   85526:	2201      	movs	r2, #1
   85528:	fa02 f303 	lsl.w	r3, r2, r3
   8552c:	461a      	mov	r2, r3
   8552e:	68fb      	ldr	r3, [r7, #12]
   85530:	635a      	str	r2, [r3, #52]	; 0x34
}
   85532:	3714      	adds	r7, #20
   85534:	46bd      	mov	sp, r7
   85536:	f85d 7b04 	ldr.w	r7, [sp], #4
   8553a:	4770      	bx	lr

0008553c <pio_toggle_pin>:
 * \param ul_pin The pin index.
 *
 * \note The function \ref pio_configure_pin must be called before.
 */
void pio_toggle_pin(uint32_t ul_pin)
{
   8553c:	b480      	push	{r7}
   8553e:	b085      	sub	sp, #20
   85540:	af00      	add	r7, sp, #0
   85542:	6078      	str	r0, [r7, #4]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
   85544:	687b      	ldr	r3, [r7, #4]
   85546:	095b      	lsrs	r3, r3, #5
   85548:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   8554c:	f203 7307 	addw	r3, r3, #1799	; 0x707
   85550:	025b      	lsls	r3, r3, #9
   85552:	60fb      	str	r3, [r7, #12]
	if (p_pio->PIO_ODSR & (1 << (ul_pin & 0x1F))) {
   85554:	68fb      	ldr	r3, [r7, #12]
   85556:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   85558:	687b      	ldr	r3, [r7, #4]
   8555a:	f003 031f 	and.w	r3, r3, #31
   8555e:	2101      	movs	r1, #1
   85560:	fa01 f303 	lsl.w	r3, r1, r3
   85564:	4013      	ands	r3, r2
   85566:	2b00      	cmp	r3, #0
   85568:	d009      	beq.n	8557e <pio_toggle_pin+0x42>
		// Value to be driven on the I/O line: 0.
		p_pio->PIO_CODR = 1 << (ul_pin & 0x1F);
   8556a:	687b      	ldr	r3, [r7, #4]
   8556c:	f003 031f 	and.w	r3, r3, #31
   85570:	2201      	movs	r2, #1
   85572:	fa02 f303 	lsl.w	r3, r2, r3
   85576:	461a      	mov	r2, r3
   85578:	68fb      	ldr	r3, [r7, #12]
   8557a:	635a      	str	r2, [r3, #52]	; 0x34
   8557c:	e008      	b.n	85590 <pio_toggle_pin+0x54>
	} else {
		// Value to be driven on the I/O line: 1.
		p_pio->PIO_SODR = 1 << (ul_pin & 0x1F);
   8557e:	687b      	ldr	r3, [r7, #4]
   85580:	f003 031f 	and.w	r3, r3, #31
   85584:	2201      	movs	r2, #1
   85586:	fa02 f303 	lsl.w	r3, r2, r3
   8558a:	461a      	mov	r2, r3
   8558c:	68fb      	ldr	r3, [r7, #12]
   8558e:	631a      	str	r2, [r3, #48]	; 0x30
	}
}
   85590:	3714      	adds	r7, #20
   85592:	46bd      	mov	sp, r7
   85594:	f85d 7b04 	ldr.w	r7, [sp], #4
   85598:	4770      	bx	lr
   8559a:	bf00      	nop

0008559c <pio_configure_pin>:
 * \param ul_flags Pins attributes.
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin(uint32_t ul_pin, const uint32_t ul_flags)
{
   8559c:	b590      	push	{r4, r7, lr}
   8559e:	b087      	sub	sp, #28
   855a0:	af02      	add	r7, sp, #8
   855a2:	6078      	str	r0, [r7, #4]
   855a4:	6039      	str	r1, [r7, #0]
	Pio *p_pio = (Pio *)((uint32_t)PIOA + (PIO_DELTA * (ul_pin >> 5)));
   855a6:	687b      	ldr	r3, [r7, #4]
   855a8:	095b      	lsrs	r3, r3, #5
   855aa:	f503 1300 	add.w	r3, r3, #2097152	; 0x200000
   855ae:	f203 7307 	addw	r3, r3, #1799	; 0x707
   855b2:	025b      	lsls	r3, r3, #9
   855b4:	60fb      	str	r3, [r7, #12]

	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
   855b6:	683b      	ldr	r3, [r7, #0]
   855b8:	f003 43f0 	and.w	r3, r3, #2013265920	; 0x78000000
   855bc:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   855c0:	d048      	beq.n	85654 <pio_configure_pin+0xb8>
   855c2:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   855c6:	d806      	bhi.n	855d6 <pio_configure_pin+0x3a>
   855c8:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
   855cc:	d00a      	beq.n	855e4 <pio_configure_pin+0x48>
   855ce:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   855d2:	d023      	beq.n	8561c <pio_configure_pin+0x80>
   855d4:	e070      	b.n	856b8 <pio_configure_pin+0x11c>
   855d6:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   855da:	d047      	beq.n	8566c <pio_configure_pin+0xd0>
   855dc:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   855e0:	d044      	beq.n	8566c <pio_configure_pin+0xd0>
   855e2:	e069      	b.n	856b8 <pio_configure_pin+0x11c>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, (1 << (ul_pin & 0x1F)));
   855e4:	687b      	ldr	r3, [r7, #4]
   855e6:	f003 031f 	and.w	r3, r3, #31
   855ea:	2201      	movs	r2, #1
   855ec:	fa02 f303 	lsl.w	r3, r2, r3
   855f0:	68f8      	ldr	r0, [r7, #12]
   855f2:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   855f6:	461a      	mov	r2, r3
   855f8:	4b33      	ldr	r3, [pc, #204]	; (856c8 <pio_configure_pin+0x12c>)
   855fa:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
   855fc:	687b      	ldr	r3, [r7, #4]
   855fe:	f003 031f 	and.w	r3, r3, #31
   85602:	2201      	movs	r2, #1
   85604:	fa02 f303 	lsl.w	r3, r2, r3
   85608:	461a      	mov	r2, r3
   8560a:	683b      	ldr	r3, [r7, #0]
   8560c:	f003 0301 	and.w	r3, r3, #1
   85610:	68f8      	ldr	r0, [r7, #12]
   85612:	4611      	mov	r1, r2
   85614:	461a      	mov	r2, r3
   85616:	4b2d      	ldr	r3, [pc, #180]	; (856cc <pio_configure_pin+0x130>)
   85618:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
   8561a:	e04f      	b.n	856bc <pio_configure_pin+0x120>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, (1 << (ul_pin & 0x1F)));
   8561c:	687b      	ldr	r3, [r7, #4]
   8561e:	f003 031f 	and.w	r3, r3, #31
   85622:	2201      	movs	r2, #1
   85624:	fa02 f303 	lsl.w	r3, r2, r3
   85628:	68f8      	ldr	r0, [r7, #12]
   8562a:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   8562e:	461a      	mov	r2, r3
   85630:	4b25      	ldr	r3, [pc, #148]	; (856c8 <pio_configure_pin+0x12c>)
   85632:	4798      	blx	r3
		pio_pull_up(p_pio, (1 << (ul_pin & 0x1F)),
   85634:	687b      	ldr	r3, [r7, #4]
   85636:	f003 031f 	and.w	r3, r3, #31
   8563a:	2201      	movs	r2, #1
   8563c:	fa02 f303 	lsl.w	r3, r2, r3
   85640:	461a      	mov	r2, r3
   85642:	683b      	ldr	r3, [r7, #0]
   85644:	f003 0301 	and.w	r3, r3, #1
   85648:	68f8      	ldr	r0, [r7, #12]
   8564a:	4611      	mov	r1, r2
   8564c:	461a      	mov	r2, r3
   8564e:	4b1f      	ldr	r3, [pc, #124]	; (856cc <pio_configure_pin+0x130>)
   85650:	4798      	blx	r3
				(ul_flags & PIO_PULLUP));
		break;
   85652:	e033      	b.n	856bc <pio_configure_pin+0x120>
				(ul_flags & PIO_PULLUP));
		break;
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
   85654:	687b      	ldr	r3, [r7, #4]
   85656:	f003 031f 	and.w	r3, r3, #31
   8565a:	2201      	movs	r2, #1
   8565c:	fa02 f303 	lsl.w	r3, r2, r3
   85660:	68f8      	ldr	r0, [r7, #12]
   85662:	4619      	mov	r1, r3
   85664:	683a      	ldr	r2, [r7, #0]
   85666:	4b1a      	ldr	r3, [pc, #104]	; (856d0 <pio_configure_pin+0x134>)
   85668:	4798      	blx	r3
		break;
   8566a:	e027      	b.n	856bc <pio_configure_pin+0x120>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   8566c:	687b      	ldr	r3, [r7, #4]
   8566e:	f003 031f 	and.w	r3, r3, #31
   85672:	2201      	movs	r2, #1
   85674:	fa02 f303 	lsl.w	r3, r2, r3
   85678:	4619      	mov	r1, r3
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
   8567a:	683b      	ldr	r3, [r7, #0]
   8567c:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   85680:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   85684:	bf14      	ite	ne
   85686:	2300      	movne	r3, #0
   85688:	2301      	moveq	r3, #1
   8568a:	b2db      	uxtb	r3, r3
   8568c:	461a      	mov	r2, r3
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
   8568e:	683b      	ldr	r3, [r7, #0]
   85690:	f003 0304 	and.w	r3, r3, #4
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   85694:	2b00      	cmp	r3, #0
   85696:	bf0c      	ite	eq
   85698:	2300      	moveq	r3, #0
   8569a:	2301      	movne	r3, #1
   8569c:	b2db      	uxtb	r3, r3
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
   8569e:	6838      	ldr	r0, [r7, #0]
   856a0:	f000 0001 	and.w	r0, r0, #1
		pio_set_input(p_pio, (1 << (ul_pin & 0x1F)), ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, (1 << (ul_pin & 0x1F)),
   856a4:	2800      	cmp	r0, #0
   856a6:	bf0c      	ite	eq
   856a8:	2000      	moveq	r0, #0
   856aa:	2001      	movne	r0, #1
   856ac:	b2c0      	uxtb	r0, r0
   856ae:	9000      	str	r0, [sp, #0]
   856b0:	68f8      	ldr	r0, [r7, #12]
   856b2:	4c08      	ldr	r4, [pc, #32]	; (856d4 <pio_configure_pin+0x138>)
   856b4:	47a0      	blx	r4
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
   856b6:	e001      	b.n	856bc <pio_configure_pin+0x120>

	default:
		return 0;
   856b8:	2300      	movs	r3, #0
   856ba:	e000      	b.n	856be <pio_configure_pin+0x122>
	}

	return 1;
   856bc:	2301      	movs	r3, #1
}
   856be:	4618      	mov	r0, r3
   856c0:	3714      	adds	r7, #20
   856c2:	46bd      	mov	sp, r7
   856c4:	bd90      	pop	{r4, r7, pc}
   856c6:	bf00      	nop
   856c8:	0008533d 	.word	0x0008533d
   856cc:	00085311 	.word	0x00085311
   856d0:	000853bd 	.word	0x000853bd
   856d4:	00085425 	.word	0x00085425

000856d8 <pio_configure_pin_group>:
 *
 * \return Whether the pin(s) have been configured properly.
 */
uint32_t pio_configure_pin_group(Pio *p_pio,
		uint32_t ul_mask, const uint32_t ul_flags)
{
   856d8:	b590      	push	{r4, r7, lr}
   856da:	b087      	sub	sp, #28
   856dc:	af02      	add	r7, sp, #8
   856de:	60f8      	str	r0, [r7, #12]
   856e0:	60b9      	str	r1, [r7, #8]
   856e2:	607a      	str	r2, [r7, #4]
	/* Configure pins */
	switch (ul_flags & PIO_TYPE_Msk) {
   856e4:	687b      	ldr	r3, [r7, #4]
   856e6:	f003 43f0 	and.w	r3, r3, #2013265920	; 0x78000000
   856ea:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   856ee:	d02e      	beq.n	8574e <pio_configure_pin_group+0x76>
   856f0:	f1b3 5f20 	cmp.w	r3, #671088640	; 0x28000000
   856f4:	d806      	bhi.n	85704 <pio_configure_pin_group+0x2c>
   856f6:	f1b3 6f00 	cmp.w	r3, #134217728	; 0x8000000
   856fa:	d00a      	beq.n	85712 <pio_configure_pin_group+0x3a>
   856fc:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
   85700:	d016      	beq.n	85730 <pio_configure_pin_group+0x58>
   85702:	e04a      	b.n	8579a <pio_configure_pin_group+0xc2>
   85704:	f1b3 5f40 	cmp.w	r3, #805306368	; 0x30000000
   85708:	d027      	beq.n	8575a <pio_configure_pin_group+0x82>
   8570a:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   8570e:	d024      	beq.n	8575a <pio_configure_pin_group+0x82>
   85710:	e043      	b.n	8579a <pio_configure_pin_group+0xc2>
	case PIO_TYPE_PIO_PERIPH_A:
		pio_set_peripheral(p_pio, PIO_PERIPH_A, ul_mask);
   85712:	68f8      	ldr	r0, [r7, #12]
   85714:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
   85718:	68ba      	ldr	r2, [r7, #8]
   8571a:	4b23      	ldr	r3, [pc, #140]	; (857a8 <pio_configure_pin_group+0xd0>)
   8571c:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
   8571e:	687b      	ldr	r3, [r7, #4]
   85720:	f003 0301 	and.w	r3, r3, #1
   85724:	68f8      	ldr	r0, [r7, #12]
   85726:	68b9      	ldr	r1, [r7, #8]
   85728:	461a      	mov	r2, r3
   8572a:	4b20      	ldr	r3, [pc, #128]	; (857ac <pio_configure_pin_group+0xd4>)
   8572c:	4798      	blx	r3
		break;
   8572e:	e036      	b.n	8579e <pio_configure_pin_group+0xc6>
	case PIO_TYPE_PIO_PERIPH_B:
		pio_set_peripheral(p_pio, PIO_PERIPH_B, ul_mask);
   85730:	68f8      	ldr	r0, [r7, #12]
   85732:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
   85736:	68ba      	ldr	r2, [r7, #8]
   85738:	4b1b      	ldr	r3, [pc, #108]	; (857a8 <pio_configure_pin_group+0xd0>)
   8573a:	4798      	blx	r3
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
   8573c:	687b      	ldr	r3, [r7, #4]
   8573e:	f003 0301 	and.w	r3, r3, #1
   85742:	68f8      	ldr	r0, [r7, #12]
   85744:	68b9      	ldr	r1, [r7, #8]
   85746:	461a      	mov	r2, r3
   85748:	4b18      	ldr	r3, [pc, #96]	; (857ac <pio_configure_pin_group+0xd4>)
   8574a:	4798      	blx	r3
		break;
   8574c:	e027      	b.n	8579e <pio_configure_pin_group+0xc6>
		pio_pull_up(p_pio, ul_mask, (ul_flags & PIO_PULLUP));
		break;
#     endif

	case PIO_TYPE_PIO_INPUT:
		pio_set_input(p_pio, ul_mask, ul_flags);
   8574e:	68f8      	ldr	r0, [r7, #12]
   85750:	68b9      	ldr	r1, [r7, #8]
   85752:	687a      	ldr	r2, [r7, #4]
   85754:	4b16      	ldr	r3, [pc, #88]	; (857b0 <pio_configure_pin_group+0xd8>)
   85756:	4798      	blx	r3
		break;
   85758:	e021      	b.n	8579e <pio_configure_pin_group+0xc6>

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
   8575a:	687b      	ldr	r3, [r7, #4]
   8575c:	f003 5360 	and.w	r3, r3, #939524096	; 0x38000000
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
   85760:	f1b3 5f60 	cmp.w	r3, #939524096	; 0x38000000
   85764:	bf14      	ite	ne
   85766:	2300      	movne	r3, #0
   85768:	2301      	moveq	r3, #1
   8576a:	b2db      	uxtb	r3, r3
   8576c:	461a      	mov	r2, r3
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
   8576e:	687b      	ldr	r3, [r7, #4]
   85770:	f003 0304 	and.w	r3, r3, #4
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
   85774:	2b00      	cmp	r3, #0
   85776:	bf0c      	ite	eq
   85778:	2300      	moveq	r3, #0
   8577a:	2301      	movne	r3, #1
   8577c:	b2db      	uxtb	r3, r3
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
   8577e:	6879      	ldr	r1, [r7, #4]
   85780:	f001 0101 	and.w	r1, r1, #1
		pio_set_input(p_pio, ul_mask, ul_flags);
		break;

	case PIO_TYPE_PIO_OUTPUT_0:
	case PIO_TYPE_PIO_OUTPUT_1:
		pio_set_output(p_pio, ul_mask,
   85784:	2900      	cmp	r1, #0
   85786:	bf0c      	ite	eq
   85788:	2100      	moveq	r1, #0
   8578a:	2101      	movne	r1, #1
   8578c:	b2c9      	uxtb	r1, r1
   8578e:	9100      	str	r1, [sp, #0]
   85790:	68f8      	ldr	r0, [r7, #12]
   85792:	68b9      	ldr	r1, [r7, #8]
   85794:	4c07      	ldr	r4, [pc, #28]	; (857b4 <pio_configure_pin_group+0xdc>)
   85796:	47a0      	blx	r4
				((ul_flags & PIO_TYPE_PIO_OUTPUT_1)
				== PIO_TYPE_PIO_OUTPUT_1) ? 1 : 0,
				(ul_flags & PIO_OPENDRAIN) ? 1 : 0,
				(ul_flags & PIO_PULLUP) ? 1 : 0);
		break;
   85798:	e001      	b.n	8579e <pio_configure_pin_group+0xc6>

	default:
		return 0;
   8579a:	2300      	movs	r3, #0
   8579c:	e000      	b.n	857a0 <pio_configure_pin_group+0xc8>
	}

	return 1;
   8579e:	2301      	movs	r3, #1
}
   857a0:	4618      	mov	r0, r3
   857a2:	3714      	adds	r7, #20
   857a4:	46bd      	mov	sp, r7
   857a6:	bd90      	pop	{r4, r7, pc}
   857a8:	0008533d 	.word	0x0008533d
   857ac:	00085311 	.word	0x00085311
   857b0:	000853bd 	.word	0x000853bd
   857b4:	00085425 	.word	0x00085425

000857b8 <pio_handler_process>:
 *
 * \param p_pio PIO controller base address.
 * \param ul_id PIO controller ID.
 */
void pio_handler_process(Pio *p_pio, uint32_t ul_id)
{
   857b8:	b580      	push	{r7, lr}
   857ba:	b084      	sub	sp, #16
   857bc:	af00      	add	r7, sp, #0
   857be:	6078      	str	r0, [r7, #4]
   857c0:	6039      	str	r1, [r7, #0]
	uint32_t status;
	uint32_t i;

	/* Read PIO controller status */
	status = pio_get_interrupt_status(p_pio);
   857c2:	6878      	ldr	r0, [r7, #4]
   857c4:	4b22      	ldr	r3, [pc, #136]	; (85850 <pio_handler_process+0x98>)
   857c6:	4798      	blx	r3
   857c8:	60f8      	str	r0, [r7, #12]
	status &= pio_get_interrupt_mask(p_pio);
   857ca:	6878      	ldr	r0, [r7, #4]
   857cc:	4b21      	ldr	r3, [pc, #132]	; (85854 <pio_handler_process+0x9c>)
   857ce:	4798      	blx	r3
   857d0:	4603      	mov	r3, r0
   857d2:	68fa      	ldr	r2, [r7, #12]
   857d4:	4013      	ands	r3, r2
   857d6:	60fb      	str	r3, [r7, #12]

	/* Check pending events */
	if (status != 0) {
   857d8:	68fb      	ldr	r3, [r7, #12]
   857da:	2b00      	cmp	r3, #0
   857dc:	d035      	beq.n	8584a <pio_handler_process+0x92>
		/* Find triggering source */
		i = 0;
   857de:	2300      	movs	r3, #0
   857e0:	60bb      	str	r3, [r7, #8]
		while (status != 0) {
   857e2:	e02f      	b.n	85844 <pio_handler_process+0x8c>
			/* Source is configured on the same controller */
			if (gs_interrupt_sources[i].id == ul_id) {
   857e4:	4a1c      	ldr	r2, [pc, #112]	; (85858 <pio_handler_process+0xa0>)
   857e6:	68bb      	ldr	r3, [r7, #8]
   857e8:	011b      	lsls	r3, r3, #4
   857ea:	4413      	add	r3, r2
   857ec:	681a      	ldr	r2, [r3, #0]
   857ee:	683b      	ldr	r3, [r7, #0]
   857f0:	429a      	cmp	r2, r3
   857f2:	d124      	bne.n	8583e <pio_handler_process+0x86>
				/* Source has PIOs whose statuses have changed */
				if ((status & gs_interrupt_sources[i].mask) != 0) {
   857f4:	4a18      	ldr	r2, [pc, #96]	; (85858 <pio_handler_process+0xa0>)
   857f6:	68bb      	ldr	r3, [r7, #8]
   857f8:	011b      	lsls	r3, r3, #4
   857fa:	4413      	add	r3, r2
   857fc:	685a      	ldr	r2, [r3, #4]
   857fe:	68fb      	ldr	r3, [r7, #12]
   85800:	4013      	ands	r3, r2
   85802:	2b00      	cmp	r3, #0
   85804:	d01b      	beq.n	8583e <pio_handler_process+0x86>
					gs_interrupt_sources[i].handler(gs_interrupt_sources[i].id,
   85806:	4a14      	ldr	r2, [pc, #80]	; (85858 <pio_handler_process+0xa0>)
   85808:	68bb      	ldr	r3, [r7, #8]
   8580a:	011b      	lsls	r3, r3, #4
   8580c:	4413      	add	r3, r2
   8580e:	3308      	adds	r3, #8
   85810:	685b      	ldr	r3, [r3, #4]
   85812:	4911      	ldr	r1, [pc, #68]	; (85858 <pio_handler_process+0xa0>)
   85814:	68ba      	ldr	r2, [r7, #8]
   85816:	0112      	lsls	r2, r2, #4
   85818:	440a      	add	r2, r1
   8581a:	6811      	ldr	r1, [r2, #0]
   8581c:	480e      	ldr	r0, [pc, #56]	; (85858 <pio_handler_process+0xa0>)
   8581e:	68ba      	ldr	r2, [r7, #8]
   85820:	0112      	lsls	r2, r2, #4
   85822:	4402      	add	r2, r0
   85824:	6852      	ldr	r2, [r2, #4]
   85826:	4608      	mov	r0, r1
   85828:	4611      	mov	r1, r2
   8582a:	4798      	blx	r3
							gs_interrupt_sources[i].mask);
					status &= ~(gs_interrupt_sources[i].mask);
   8582c:	4a0a      	ldr	r2, [pc, #40]	; (85858 <pio_handler_process+0xa0>)
   8582e:	68bb      	ldr	r3, [r7, #8]
   85830:	011b      	lsls	r3, r3, #4
   85832:	4413      	add	r3, r2
   85834:	685b      	ldr	r3, [r3, #4]
   85836:	43db      	mvns	r3, r3
   85838:	68fa      	ldr	r2, [r7, #12]
   8583a:	4013      	ands	r3, r2
   8583c:	60fb      	str	r3, [r7, #12]
				}
			}
			i++;
   8583e:	68bb      	ldr	r3, [r7, #8]
   85840:	3301      	adds	r3, #1
   85842:	60bb      	str	r3, [r7, #8]

	/* Check pending events */
	if (status != 0) {
		/* Find triggering source */
		i = 0;
		while (status != 0) {
   85844:	68fb      	ldr	r3, [r7, #12]
   85846:	2b00      	cmp	r3, #0
   85848:	d1cc      	bne.n	857e4 <pio_handler_process+0x2c>
				}
			}
			i++;
		}
	}
}
   8584a:	3710      	adds	r7, #16
   8584c:	46bd      	mov	sp, r7
   8584e:	bd80      	pop	{r7, pc}
   85850:	000854a5 	.word	0x000854a5
   85854:	000854bd 	.word	0x000854bd
   85858:	20070bdc 	.word	0x20070bdc

0008585c <PIOA_Handler>:
/**
 * \brief Parallel IO Controller A interrupt handler.
 * Redefined PIOA interrupt handler for NVIC interrupt table.
 */
void PIOA_Handler(void)
{
   8585c:	b580      	push	{r7, lr}
   8585e:	af00      	add	r7, sp, #0
	pio_handler_process(PIOA, ID_PIOA);
   85860:	4802      	ldr	r0, [pc, #8]	; (8586c <PIOA_Handler+0x10>)
   85862:	210b      	movs	r1, #11
   85864:	4b02      	ldr	r3, [pc, #8]	; (85870 <PIOA_Handler+0x14>)
   85866:	4798      	blx	r3
}
   85868:	bd80      	pop	{r7, pc}
   8586a:	bf00      	nop
   8586c:	400e0e00 	.word	0x400e0e00
   85870:	000857b9 	.word	0x000857b9

00085874 <PIOB_Handler>:
/**
 * \brief Parallel IO Controller B interrupt handler
 * Redefined PIOB interrupt handler for NVIC interrupt table.
 */
void PIOB_Handler(void)
{
   85874:	b580      	push	{r7, lr}
   85876:	af00      	add	r7, sp, #0
    pio_handler_process(PIOB, ID_PIOB);
   85878:	4802      	ldr	r0, [pc, #8]	; (85884 <PIOB_Handler+0x10>)
   8587a:	210c      	movs	r1, #12
   8587c:	4b02      	ldr	r3, [pc, #8]	; (85888 <PIOB_Handler+0x14>)
   8587e:	4798      	blx	r3
}
   85880:	bd80      	pop	{r7, pc}
   85882:	bf00      	nop
   85884:	400e1000 	.word	0x400e1000
   85888:	000857b9 	.word	0x000857b9

0008588c <PIOC_Handler>:
/**
 * \brief Parallel IO Controller C interrupt handler.
 * Redefined PIOC interrupt handler for NVIC interrupt table.
 */
void PIOC_Handler(void)
{
   8588c:	b580      	push	{r7, lr}
   8588e:	af00      	add	r7, sp, #0
	pio_handler_process(PIOC, ID_PIOC);
   85890:	4802      	ldr	r0, [pc, #8]	; (8589c <PIOC_Handler+0x10>)
   85892:	210d      	movs	r1, #13
   85894:	4b02      	ldr	r3, [pc, #8]	; (858a0 <PIOC_Handler+0x14>)
   85896:	4798      	blx	r3
}
   85898:	bd80      	pop	{r7, pc}
   8589a:	bf00      	nop
   8589c:	400e1200 	.word	0x400e1200
   858a0:	000857b9 	.word	0x000857b9

000858a4 <PIOD_Handler>:
/**
 * \brief Parallel IO Controller D interrupt handler.
 * Redefined PIOD interrupt handler for NVIC interrupt table.
 */
void PIOD_Handler(void)
{
   858a4:	b580      	push	{r7, lr}
   858a6:	af00      	add	r7, sp, #0
	pio_handler_process(PIOD, ID_PIOD);
   858a8:	4802      	ldr	r0, [pc, #8]	; (858b4 <PIOD_Handler+0x10>)
   858aa:	210e      	movs	r1, #14
   858ac:	4b02      	ldr	r3, [pc, #8]	; (858b8 <PIOD_Handler+0x14>)
   858ae:	4798      	blx	r3
}
   858b0:	bd80      	pop	{r7, pc}
   858b2:	bf00      	nop
   858b4:	400e1400 	.word	0x400e1400
   858b8:	000857b9 	.word	0x000857b9

000858bc <pmc_switch_mck_to_pllack>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
   858bc:	b480      	push	{r7}
   858be:	b085      	sub	sp, #20
   858c0:	af00      	add	r7, sp, #0
   858c2:	6078      	str	r0, [r7, #4]
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
   858c4:	4b1d      	ldr	r3, [pc, #116]	; (8593c <pmc_switch_mck_to_pllack+0x80>)
   858c6:	4a1d      	ldr	r2, [pc, #116]	; (8593c <pmc_switch_mck_to_pllack+0x80>)
   858c8:	6b12      	ldr	r2, [r2, #48]	; 0x30
   858ca:	f022 0170 	bic.w	r1, r2, #112	; 0x70
   858ce:	687a      	ldr	r2, [r7, #4]
   858d0:	430a      	orrs	r2, r1
   858d2:	631a      	str	r2, [r3, #48]	; 0x30
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   858d4:	f44f 6300 	mov.w	r3, #2048	; 0x800
   858d8:	60fb      	str	r3, [r7, #12]
   858da:	e007      	b.n	858ec <pmc_switch_mck_to_pllack+0x30>
			--ul_timeout) {
		if (ul_timeout == 0) {
   858dc:	68fb      	ldr	r3, [r7, #12]
   858de:	2b00      	cmp	r3, #0
   858e0:	d101      	bne.n	858e6 <pmc_switch_mck_to_pllack+0x2a>
			return 1;
   858e2:	2301      	movs	r3, #1
   858e4:	e023      	b.n	8592e <pmc_switch_mck_to_pllack+0x72>
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
   858e6:	68fb      	ldr	r3, [r7, #12]
   858e8:	3b01      	subs	r3, #1
   858ea:	60fb      	str	r3, [r7, #12]
uint32_t pmc_switch_mck_to_pllack(uint32_t ul_pres)
{
	uint32_t ul_timeout;

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_PRES_Msk)) | ul_pres;
	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   858ec:	4b13      	ldr	r3, [pc, #76]	; (8593c <pmc_switch_mck_to_pllack+0x80>)
   858ee:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   858f0:	f003 0308 	and.w	r3, r3, #8
   858f4:	2b00      	cmp	r3, #0
   858f6:	d0f1      	beq.n	858dc <pmc_switch_mck_to_pllack+0x20>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
   858f8:	4b10      	ldr	r3, [pc, #64]	; (8593c <pmc_switch_mck_to_pllack+0x80>)
   858fa:	4a10      	ldr	r2, [pc, #64]	; (8593c <pmc_switch_mck_to_pllack+0x80>)
   858fc:	6b12      	ldr	r2, [r2, #48]	; 0x30
   858fe:	f022 0203 	bic.w	r2, r2, #3
   85902:	f042 0202 	orr.w	r2, r2, #2
   85906:	631a      	str	r2, [r3, #48]	; 0x30
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   85908:	f44f 6300 	mov.w	r3, #2048	; 0x800
   8590c:	60fb      	str	r3, [r7, #12]
   8590e:	e007      	b.n	85920 <pmc_switch_mck_to_pllack+0x64>
			--ul_timeout) {
		if (ul_timeout == 0) {
   85910:	68fb      	ldr	r3, [r7, #12]
   85912:	2b00      	cmp	r3, #0
   85914:	d101      	bne.n	8591a <pmc_switch_mck_to_pllack+0x5e>
			return 1;
   85916:	2301      	movs	r3, #1
   85918:	e009      	b.n	8592e <pmc_switch_mck_to_pllack+0x72>

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
			--ul_timeout) {
   8591a:	68fb      	ldr	r3, [r7, #12]
   8591c:	3b01      	subs	r3, #1
   8591e:	60fb      	str	r3, [r7, #12]
	}

	PMC->PMC_MCKR = (PMC->PMC_MCKR & (~PMC_MCKR_CSS_Msk)) |
			PMC_MCKR_CSS_PLLA_CLK;

	for (ul_timeout = PMC_TIMEOUT; !(PMC->PMC_SR & PMC_SR_MCKRDY);
   85920:	4b06      	ldr	r3, [pc, #24]	; (8593c <pmc_switch_mck_to_pllack+0x80>)
   85922:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   85924:	f003 0308 	and.w	r3, r3, #8
   85928:	2b00      	cmp	r3, #0
   8592a:	d0f1      	beq.n	85910 <pmc_switch_mck_to_pllack+0x54>
		if (ul_timeout == 0) {
			return 1;
		}
	}

	return 0;
   8592c:	2300      	movs	r3, #0
}
   8592e:	4618      	mov	r0, r3
   85930:	3714      	adds	r7, #20
   85932:	46bd      	mov	sp, r7
   85934:	f85d 7b04 	ldr.w	r7, [sp], #4
   85938:	4770      	bx	lr
   8593a:	bf00      	nop
   8593c:	400e0600 	.word	0x400e0600

00085940 <pmc_switch_sclk_to_32kxtal>:
 * power supply.
 *
 * \param ul_bypass 0 for Xtal, 1 for bypass.
 */
void pmc_switch_sclk_to_32kxtal(uint32_t ul_bypass)
{
   85940:	b480      	push	{r7}
   85942:	b083      	sub	sp, #12
   85944:	af00      	add	r7, sp, #0
   85946:	6078      	str	r0, [r7, #4]
	/* Set Bypass mode if required */
	if (ul_bypass == 1) {
   85948:	687b      	ldr	r3, [r7, #4]
   8594a:	2b01      	cmp	r3, #1
   8594c:	d107      	bne.n	8595e <pmc_switch_sclk_to_32kxtal+0x1e>
		SUPC->SUPC_MR |= SUPC_MR_KEY(SUPC_KEY_VALUE) |
   8594e:	4a0a      	ldr	r2, [pc, #40]	; (85978 <pmc_switch_sclk_to_32kxtal+0x38>)
   85950:	4b09      	ldr	r3, [pc, #36]	; (85978 <pmc_switch_sclk_to_32kxtal+0x38>)
   85952:	689b      	ldr	r3, [r3, #8]
   85954:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
   85958:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
   8595c:	6093      	str	r3, [r2, #8]
				SUPC_MR_OSCBYPASS;
	}

	SUPC->SUPC_CR |= SUPC_CR_KEY(SUPC_KEY_VALUE) | SUPC_CR_XTALSEL;
   8595e:	4a06      	ldr	r2, [pc, #24]	; (85978 <pmc_switch_sclk_to_32kxtal+0x38>)
   85960:	4b05      	ldr	r3, [pc, #20]	; (85978 <pmc_switch_sclk_to_32kxtal+0x38>)
   85962:	681b      	ldr	r3, [r3, #0]
   85964:	f043 4325 	orr.w	r3, r3, #2768240640	; 0xa5000000
   85968:	f043 0308 	orr.w	r3, r3, #8
   8596c:	6013      	str	r3, [r2, #0]
}
   8596e:	370c      	adds	r7, #12
   85970:	46bd      	mov	sp, r7
   85972:	f85d 7b04 	ldr.w	r7, [sp], #4
   85976:	4770      	bx	lr
   85978:	400e1a10 	.word	0x400e1a10

0008597c <pmc_osc_is_ready_32kxtal>:
 *
 * \retval 1 External 32k Xtal is ready.
 * \retval 0 External 32k Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_32kxtal(void)
{
   8597c:	b480      	push	{r7}
   8597e:	af00      	add	r7, sp, #0
	return ((SUPC->SUPC_SR & SUPC_SR_OSCSEL)
   85980:	4b09      	ldr	r3, [pc, #36]	; (859a8 <pmc_osc_is_ready_32kxtal+0x2c>)
   85982:	695b      	ldr	r3, [r3, #20]
   85984:	f003 0380 	and.w	r3, r3, #128	; 0x80
			&& (PMC->PMC_SR & PMC_SR_OSCSELS));
   85988:	2b00      	cmp	r3, #0
   8598a:	d007      	beq.n	8599c <pmc_osc_is_ready_32kxtal+0x20>
   8598c:	4b07      	ldr	r3, [pc, #28]	; (859ac <pmc_osc_is_ready_32kxtal+0x30>)
   8598e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   85990:	f003 0380 	and.w	r3, r3, #128	; 0x80
   85994:	2b00      	cmp	r3, #0
   85996:	d001      	beq.n	8599c <pmc_osc_is_ready_32kxtal+0x20>
   85998:	2301      	movs	r3, #1
   8599a:	e000      	b.n	8599e <pmc_osc_is_ready_32kxtal+0x22>
   8599c:	2300      	movs	r3, #0
}
   8599e:	4618      	mov	r0, r3
   859a0:	46bd      	mov	sp, r7
   859a2:	f85d 7b04 	ldr.w	r7, [sp], #4
   859a6:	4770      	bx	lr
   859a8:	400e1a10 	.word	0x400e1a10
   859ac:	400e0600 	.word	0x400e0600

000859b0 <pmc_switch_mainck_to_fastrc>:
 * \retval 0 Success.
 * \retval 1 Timeout error.
 * \retval 2 Invalid frequency.
 */
void pmc_switch_mainck_to_fastrc(uint32_t ul_moscrcf)
{
   859b0:	b480      	push	{r7}
   859b2:	b085      	sub	sp, #20
   859b4:	af00      	add	r7, sp, #0
   859b6:	6078      	str	r0, [r7, #4]
	uint32_t ul_needXTEN = 0;
   859b8:	2300      	movs	r3, #0
   859ba:	60fb      	str	r3, [r7, #12]

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
   859bc:	4b21      	ldr	r3, [pc, #132]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   859be:	6a1b      	ldr	r3, [r3, #32]
   859c0:	f003 0301 	and.w	r3, r3, #1
   859c4:	2b00      	cmp	r3, #0
   859c6:	d00e      	beq.n	859e6 <pmc_switch_mainck_to_fastrc+0x36>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
   859c8:	4a1e      	ldr	r2, [pc, #120]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   859ca:	4b1e      	ldr	r3, [pc, #120]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   859cc:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
   859ce:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
   859d2:	f023 0378 	bic.w	r3, r3, #120	; 0x78
   859d6:	6879      	ldr	r1, [r7, #4]
   859d8:	430b      	orrs	r3, r1
   859da:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
   859de:	f043 0308 	orr.w	r3, r3, #8
{
	uint32_t ul_needXTEN = 0;

	/* Enable Fast RC oscillator but DO NOT switch to RC now */
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
   859e2:	6213      	str	r3, [r2, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
   859e4:	e00b      	b.n	859fe <pmc_switch_mainck_to_fastrc+0x4e>
	if (PMC->CKGR_MOR & CKGR_MOR_MOSCXTEN) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
   859e6:	2301      	movs	r3, #1
   859e8:	60fb      	str	r3, [r7, #12]
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
   859ea:	4a16      	ldr	r2, [pc, #88]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   859ec:	4b15      	ldr	r3, [pc, #84]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   859ee:	6a19      	ldr	r1, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
   859f0:	4b15      	ldr	r3, [pc, #84]	; (85a48 <pmc_switch_mainck_to_fastrc+0x98>)
   859f2:	400b      	ands	r3, r1
   859f4:	6879      	ldr	r1, [r7, #4]
   859f6:	4319      	orrs	r1, r3
   859f8:	4b14      	ldr	r3, [pc, #80]	; (85a4c <pmc_switch_mainck_to_fastrc+0x9c>)
   859fa:	430b      	orrs	r3, r1
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCRCEN |
				ul_moscrcf;
	} else {
		ul_needXTEN = 1;
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCRCF_Msk) |
   859fc:	6213      	str	r3, [r2, #32]
				CKGR_MOR_MOSCXTEN | CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME) |
				ul_moscrcf;
	}

	/* Wait the Fast RC to stabilize */
	while (!(PMC->PMC_SR & PMC_SR_MOSCRCS));
   859fe:	bf00      	nop
   85a00:	4b10      	ldr	r3, [pc, #64]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   85a02:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   85a04:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
   85a08:	2b00      	cmp	r3, #0
   85a0a:	d0f9      	beq.n	85a00 <pmc_switch_mainck_to_fastrc+0x50>

	/* Switch to Fast RC */
	PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCSEL) | PMC_CKGR_MOR_KEY_VALUE;
   85a0c:	4a0d      	ldr	r2, [pc, #52]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   85a0e:	4b0d      	ldr	r3, [pc, #52]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   85a10:	6a1b      	ldr	r3, [r3, #32]
   85a12:	f023 739b 	bic.w	r3, r3, #20316160	; 0x1360000
   85a16:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
   85a1a:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
   85a1e:	6213      	str	r3, [r2, #32]

	/* Disable xtal oscillator */
	if (ul_needXTEN) {
   85a20:	68fb      	ldr	r3, [r7, #12]
   85a22:	2b00      	cmp	r3, #0
   85a24:	d009      	beq.n	85a3a <pmc_switch_mainck_to_fastrc+0x8a>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   85a26:	4a07      	ldr	r2, [pc, #28]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   85a28:	4b06      	ldr	r3, [pc, #24]	; (85a44 <pmc_switch_mainck_to_fastrc+0x94>)
   85a2a:	6a1b      	ldr	r3, [r3, #32]
   85a2c:	f423 135c 	bic.w	r3, r3, #3604480	; 0x370000
   85a30:	f023 0301 	bic.w	r3, r3, #1
   85a34:	f443 135c 	orr.w	r3, r3, #3604480	; 0x370000
   85a38:	6213      	str	r3, [r2, #32]
				PMC_CKGR_MOR_KEY_VALUE;
	}
}
   85a3a:	3714      	adds	r7, #20
   85a3c:	46bd      	mov	sp, r7
   85a3e:	f85d 7b04 	ldr.w	r7, [sp], #4
   85a42:	4770      	bx	lr
   85a44:	400e0600 	.word	0x400e0600
   85a48:	ffc8c086 	.word	0xffc8c086
   85a4c:	00373f09 	.word	0x00373f09

00085a50 <pmc_switch_mainck_to_xtal>:
 *
 * \retval 0 Success.
 * \retval 1 Timeout error.
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
   85a50:	b480      	push	{r7}
   85a52:	b083      	sub	sp, #12
   85a54:	af00      	add	r7, sp, #0
   85a56:	6078      	str	r0, [r7, #4]
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
   85a58:	687b      	ldr	r3, [r7, #4]
   85a5a:	2b00      	cmp	r3, #0
   85a5c:	d008      	beq.n	85a70 <pmc_switch_mainck_to_xtal+0x20>
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   85a5e:	4912      	ldr	r1, [pc, #72]	; (85aa8 <pmc_switch_mainck_to_xtal+0x58>)
   85a60:	4b11      	ldr	r3, [pc, #68]	; (85aa8 <pmc_switch_mainck_to_xtal+0x58>)
   85a62:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
   85a64:	4a11      	ldr	r2, [pc, #68]	; (85aac <pmc_switch_mainck_to_xtal+0x5c>)
   85a66:	401a      	ands	r2, r3
   85a68:	4b11      	ldr	r3, [pc, #68]	; (85ab0 <pmc_switch_mainck_to_xtal+0x60>)
   85a6a:	4313      	orrs	r3, r2
 */
void pmc_switch_mainck_to_xtal(uint32_t ul_bypass)
{
	/* Enable Main Xtal oscillator */
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
   85a6c:	620b      	str	r3, [r1, #32]
   85a6e:	e016      	b.n	85a9e <pmc_switch_mainck_to_xtal+0x4e>
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   85a70:	490d      	ldr	r1, [pc, #52]	; (85aa8 <pmc_switch_mainck_to_xtal+0x58>)
   85a72:	4b0d      	ldr	r3, [pc, #52]	; (85aa8 <pmc_switch_mainck_to_xtal+0x58>)
   85a74:	6a1b      	ldr	r3, [r3, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
   85a76:	4a0f      	ldr	r2, [pc, #60]	; (85ab4 <pmc_switch_mainck_to_xtal+0x64>)
   85a78:	401a      	ands	r2, r3
   85a7a:	4b0f      	ldr	r3, [pc, #60]	; (85ab8 <pmc_switch_mainck_to_xtal+0x68>)
   85a7c:	4313      	orrs	r3, r2
	if (ul_bypass) {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTEN) |
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTBY |
				CKGR_MOR_MOSCSEL;
	} else {
		PMC->CKGR_MOR = (PMC->CKGR_MOR & ~CKGR_MOR_MOSCXTBY) |
   85a7e:	620b      	str	r3, [r1, #32]
				PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCXTEN |
				CKGR_MOR_MOSCXTST(PMC_XTAL_STARTUP_TIME);
		/* Wait the Xtal to stabilize */
		while (!(PMC->PMC_SR & PMC_SR_MOSCXTS));
   85a80:	bf00      	nop
   85a82:	4b09      	ldr	r3, [pc, #36]	; (85aa8 <pmc_switch_mainck_to_xtal+0x58>)
   85a84:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   85a86:	f003 0301 	and.w	r3, r3, #1
   85a8a:	2b00      	cmp	r3, #0
   85a8c:	d0f9      	beq.n	85a82 <pmc_switch_mainck_to_xtal+0x32>

		PMC->CKGR_MOR |= PMC_CKGR_MOR_KEY_VALUE | CKGR_MOR_MOSCSEL;
   85a8e:	4a06      	ldr	r2, [pc, #24]	; (85aa8 <pmc_switch_mainck_to_xtal+0x58>)
   85a90:	4b05      	ldr	r3, [pc, #20]	; (85aa8 <pmc_switch_mainck_to_xtal+0x58>)
   85a92:	6a1b      	ldr	r3, [r3, #32]
   85a94:	f043 739b 	orr.w	r3, r3, #20316160	; 0x1360000
   85a98:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
   85a9c:	6213      	str	r3, [r2, #32]
	}
}
   85a9e:	370c      	adds	r7, #12
   85aa0:	46bd      	mov	sp, r7
   85aa2:	f85d 7b04 	ldr.w	r7, [sp], #4
   85aa6:	4770      	bx	lr
   85aa8:	400e0600 	.word	0x400e0600
   85aac:	fec8fffc 	.word	0xfec8fffc
   85ab0:	01370002 	.word	0x01370002
   85ab4:	ffc8c0fc 	.word	0xffc8c0fc
   85ab8:	00373f01 	.word	0x00373f01

00085abc <pmc_osc_is_ready_mainck>:
 *
 * \retval 1 Xtal is ready.
 * \retval 0 Xtal is not ready.
 */
uint32_t pmc_osc_is_ready_mainck(void)
{
   85abc:	b480      	push	{r7}
   85abe:	af00      	add	r7, sp, #0
	return PMC->PMC_SR & PMC_SR_MOSCSELS;
   85ac0:	4b04      	ldr	r3, [pc, #16]	; (85ad4 <pmc_osc_is_ready_mainck+0x18>)
   85ac2:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   85ac4:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
}
   85ac8:	4618      	mov	r0, r3
   85aca:	46bd      	mov	sp, r7
   85acc:	f85d 7b04 	ldr.w	r7, [sp], #4
   85ad0:	4770      	bx	lr
   85ad2:	bf00      	nop
   85ad4:	400e0600 	.word	0x400e0600

00085ad8 <pmc_disable_pllack>:

/**
 * \brief Disable PLLA clock.
 */
void pmc_disable_pllack(void)
{
   85ad8:	b480      	push	{r7}
   85ada:	af00      	add	r7, sp, #0
	PMC->CKGR_PLLAR = CKGR_PLLAR_ONE | CKGR_PLLAR_MULA(0);
   85adc:	4b03      	ldr	r3, [pc, #12]	; (85aec <pmc_disable_pllack+0x14>)
   85ade:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
   85ae2:	629a      	str	r2, [r3, #40]	; 0x28
}
   85ae4:	46bd      	mov	sp, r7
   85ae6:	f85d 7b04 	ldr.w	r7, [sp], #4
   85aea:	4770      	bx	lr
   85aec:	400e0600 	.word	0x400e0600

00085af0 <pmc_is_locked_pllack>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_pllack(void)
{
   85af0:	b480      	push	{r7}
   85af2:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKA);
   85af4:	4b04      	ldr	r3, [pc, #16]	; (85b08 <pmc_is_locked_pllack+0x18>)
   85af6:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   85af8:	f003 0302 	and.w	r3, r3, #2
}
   85afc:	4618      	mov	r0, r3
   85afe:	46bd      	mov	sp, r7
   85b00:	f85d 7b04 	ldr.w	r7, [sp], #4
   85b04:	4770      	bx	lr
   85b06:	bf00      	nop
   85b08:	400e0600 	.word	0x400e0600

00085b0c <pmc_is_locked_upll>:
 *
 * \retval 0 Not locked.
 * \retval 1 Locked.
 */
uint32_t pmc_is_locked_upll(void)
{
   85b0c:	b480      	push	{r7}
   85b0e:	af00      	add	r7, sp, #0
	return (PMC->PMC_SR & PMC_SR_LOCKU);
   85b10:	4b04      	ldr	r3, [pc, #16]	; (85b24 <pmc_is_locked_upll+0x18>)
   85b12:	6e9b      	ldr	r3, [r3, #104]	; 0x68
   85b14:	f003 0340 	and.w	r3, r3, #64	; 0x40
}
   85b18:	4618      	mov	r0, r3
   85b1a:	46bd      	mov	sp, r7
   85b1c:	f85d 7b04 	ldr.w	r7, [sp], #4
   85b20:	4770      	bx	lr
   85b22:	bf00      	nop
   85b24:	400e0600 	.word	0x400e0600

00085b28 <pmc_enable_periph_clk>:
 *
 * \retval 0 Success.
 * \retval 1 Invalid parameter.
 */
uint32_t pmc_enable_periph_clk(uint32_t ul_id)
{
   85b28:	b480      	push	{r7}
   85b2a:	b083      	sub	sp, #12
   85b2c:	af00      	add	r7, sp, #0
   85b2e:	6078      	str	r0, [r7, #4]
	if (ul_id > MAX_PERIPH_ID) {
   85b30:	687b      	ldr	r3, [r7, #4]
   85b32:	2b2c      	cmp	r3, #44	; 0x2c
   85b34:	d901      	bls.n	85b3a <pmc_enable_periph_clk+0x12>
		return 1;
   85b36:	2301      	movs	r3, #1
   85b38:	e02f      	b.n	85b9a <pmc_enable_periph_clk+0x72>
	}

	if (ul_id < 32) {
   85b3a:	687b      	ldr	r3, [r7, #4]
   85b3c:	2b1f      	cmp	r3, #31
   85b3e:	d813      	bhi.n	85b68 <pmc_enable_periph_clk+0x40>
		if ((PMC->PMC_PCSR0 & (1u << ul_id)) != (1u << ul_id)) {
   85b40:	4b19      	ldr	r3, [pc, #100]	; (85ba8 <pmc_enable_periph_clk+0x80>)
   85b42:	699a      	ldr	r2, [r3, #24]
   85b44:	687b      	ldr	r3, [r7, #4]
   85b46:	2101      	movs	r1, #1
   85b48:	fa01 f303 	lsl.w	r3, r1, r3
   85b4c:	401a      	ands	r2, r3
   85b4e:	687b      	ldr	r3, [r7, #4]
   85b50:	2101      	movs	r1, #1
   85b52:	fa01 f303 	lsl.w	r3, r1, r3
   85b56:	429a      	cmp	r2, r3
   85b58:	d01e      	beq.n	85b98 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER0 = 1 << ul_id;
   85b5a:	4b13      	ldr	r3, [pc, #76]	; (85ba8 <pmc_enable_periph_clk+0x80>)
   85b5c:	687a      	ldr	r2, [r7, #4]
   85b5e:	2101      	movs	r1, #1
   85b60:	fa01 f202 	lsl.w	r2, r1, r2
   85b64:	611a      	str	r2, [r3, #16]
   85b66:	e017      	b.n	85b98 <pmc_enable_periph_clk+0x70>
		}
#if (SAM3S || SAM3XA || SAM4S)
	} else {
		ul_id -= 32;
   85b68:	687b      	ldr	r3, [r7, #4]
   85b6a:	3b20      	subs	r3, #32
   85b6c:	607b      	str	r3, [r7, #4]
		if ((PMC->PMC_PCSR1 & (1u << ul_id)) != (1u << ul_id)) {
   85b6e:	4b0e      	ldr	r3, [pc, #56]	; (85ba8 <pmc_enable_periph_clk+0x80>)
   85b70:	f8d3 2108 	ldr.w	r2, [r3, #264]	; 0x108
   85b74:	687b      	ldr	r3, [r7, #4]
   85b76:	2101      	movs	r1, #1
   85b78:	fa01 f303 	lsl.w	r3, r1, r3
   85b7c:	401a      	ands	r2, r3
   85b7e:	687b      	ldr	r3, [r7, #4]
   85b80:	2101      	movs	r1, #1
   85b82:	fa01 f303 	lsl.w	r3, r1, r3
   85b86:	429a      	cmp	r2, r3
   85b88:	d006      	beq.n	85b98 <pmc_enable_periph_clk+0x70>
			PMC->PMC_PCER1 = 1 << ul_id;
   85b8a:	4b07      	ldr	r3, [pc, #28]	; (85ba8 <pmc_enable_periph_clk+0x80>)
   85b8c:	687a      	ldr	r2, [r7, #4]
   85b8e:	2101      	movs	r1, #1
   85b90:	fa01 f202 	lsl.w	r2, r1, r2
   85b94:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
		}
#endif
	}

	return 0;
   85b98:	2300      	movs	r3, #0
}
   85b9a:	4618      	mov	r0, r3
   85b9c:	370c      	adds	r7, #12
   85b9e:	46bd      	mov	sp, r7
   85ba0:	f85d 7b04 	ldr.w	r7, [sp], #4
   85ba4:	4770      	bx	lr
   85ba6:	bf00      	nop
   85ba8:	400e0600 	.word	0x400e0600

00085bac <usart_set_async_baudrate>:
 * \retval 1 Baud rate set point is out of range for the given input clock 
 * frequency.
 */
static uint32_t usart_set_async_baudrate(Usart *p_usart,
		uint32_t baudrate, uint32_t ul_mck)
{
   85bac:	b480      	push	{r7}
   85bae:	b089      	sub	sp, #36	; 0x24
   85bb0:	af00      	add	r7, sp, #0
   85bb2:	60f8      	str	r0, [r7, #12]
   85bb4:	60b9      	str	r1, [r7, #8]
   85bb6:	607a      	str	r2, [r7, #4]
	uint32_t cd_fp;
	uint32_t cd;
	uint32_t fp;

	/* Calculate the receiver sampling divide of baudrate clock. */
	if (ul_mck >= HIGH_FRQ_SAMPLE_DIV * baudrate) {
   85bb8:	68bb      	ldr	r3, [r7, #8]
   85bba:	011a      	lsls	r2, r3, #4
   85bbc:	687b      	ldr	r3, [r7, #4]
   85bbe:	429a      	cmp	r2, r3
   85bc0:	d802      	bhi.n	85bc8 <usart_set_async_baudrate+0x1c>
		over = HIGH_FRQ_SAMPLE_DIV;
   85bc2:	2310      	movs	r3, #16
   85bc4:	61fb      	str	r3, [r7, #28]
   85bc6:	e001      	b.n	85bcc <usart_set_async_baudrate+0x20>
	} else {
		over = LOW_FRQ_SAMPLE_DIV;
   85bc8:	2308      	movs	r3, #8
   85bca:	61fb      	str	r3, [r7, #28]
	}

	/* Calculate the clock divider according to the fraction calculated formula. */
	cd_fp = (8 * ul_mck + (over * baudrate) / 2) / (over * baudrate);
   85bcc:	687b      	ldr	r3, [r7, #4]
   85bce:	00da      	lsls	r2, r3, #3
   85bd0:	69fb      	ldr	r3, [r7, #28]
   85bd2:	68b9      	ldr	r1, [r7, #8]
   85bd4:	fb01 f303 	mul.w	r3, r1, r3
   85bd8:	085b      	lsrs	r3, r3, #1
   85bda:	441a      	add	r2, r3
   85bdc:	69fb      	ldr	r3, [r7, #28]
   85bde:	68b9      	ldr	r1, [r7, #8]
   85be0:	fb01 f303 	mul.w	r3, r1, r3
   85be4:	fbb2 f3f3 	udiv	r3, r2, r3
   85be8:	61bb      	str	r3, [r7, #24]
	cd = cd_fp >> 3;
   85bea:	69bb      	ldr	r3, [r7, #24]
   85bec:	08db      	lsrs	r3, r3, #3
   85bee:	617b      	str	r3, [r7, #20]
	fp = cd_fp & 0x07;
   85bf0:	69bb      	ldr	r3, [r7, #24]
   85bf2:	f003 0307 	and.w	r3, r3, #7
   85bf6:	613b      	str	r3, [r7, #16]
	if (cd < MIN_CD_VALUE || cd > MAX_CD_VALUE) {
   85bf8:	697b      	ldr	r3, [r7, #20]
   85bfa:	2b00      	cmp	r3, #0
   85bfc:	d003      	beq.n	85c06 <usart_set_async_baudrate+0x5a>
   85bfe:	697b      	ldr	r3, [r7, #20]
   85c00:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
   85c04:	d301      	bcc.n	85c0a <usart_set_async_baudrate+0x5e>
		return 1;
   85c06:	2301      	movs	r3, #1
   85c08:	e00f      	b.n	85c2a <usart_set_async_baudrate+0x7e>
	}

	/* Configure the OVER bit in MR register. */
	if (over == 8) {
   85c0a:	69fb      	ldr	r3, [r7, #28]
   85c0c:	2b08      	cmp	r3, #8
   85c0e:	d105      	bne.n	85c1c <usart_set_async_baudrate+0x70>
		p_usart->US_MR |= US_MR_OVER;
   85c10:	68fb      	ldr	r3, [r7, #12]
   85c12:	685b      	ldr	r3, [r3, #4]
   85c14:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
   85c18:	68fb      	ldr	r3, [r7, #12]
   85c1a:	605a      	str	r2, [r3, #4]
	}

	/* Configure the baudrate generate register. */
	p_usart->US_BRGR = (cd << US_BRGR_CD_Pos) | (fp << US_BRGR_FP_Pos);
   85c1c:	693b      	ldr	r3, [r7, #16]
   85c1e:	041a      	lsls	r2, r3, #16
   85c20:	697b      	ldr	r3, [r7, #20]
   85c22:	431a      	orrs	r2, r3
   85c24:	68fb      	ldr	r3, [r7, #12]
   85c26:	621a      	str	r2, [r3, #32]

	return 0;
   85c28:	2300      	movs	r3, #0
}
   85c2a:	4618      	mov	r0, r3
   85c2c:	3724      	adds	r7, #36	; 0x24
   85c2e:	46bd      	mov	sp, r7
   85c30:	f85d 7b04 	ldr.w	r7, [sp], #4
   85c34:	4770      	bx	lr
   85c36:	bf00      	nop

00085c38 <usart_reset>:
 * \brief Reset the USART and disable TX and RX.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset(Usart *p_usart)
{
   85c38:	b580      	push	{r7, lr}
   85c3a:	b082      	sub	sp, #8
   85c3c:	af00      	add	r7, sp, #0
   85c3e:	6078      	str	r0, [r7, #4]
	/* Disable the Write Protect. Some register can't be written if the write protect is enabled. */
	usart_disable_writeprotect(p_usart);
   85c40:	6878      	ldr	r0, [r7, #4]
   85c42:	4b0d      	ldr	r3, [pc, #52]	; (85c78 <usart_reset+0x40>)
   85c44:	4798      	blx	r3

	/* Reset mode and other registers that could cause unpredictable behavior after reset. */
	p_usart->US_MR = 0;
   85c46:	687b      	ldr	r3, [r7, #4]
   85c48:	2200      	movs	r2, #0
   85c4a:	605a      	str	r2, [r3, #4]
	p_usart->US_RTOR = 0;
   85c4c:	687b      	ldr	r3, [r7, #4]
   85c4e:	2200      	movs	r2, #0
   85c50:	625a      	str	r2, [r3, #36]	; 0x24
	p_usart->US_TTGR = 0;
   85c52:	687b      	ldr	r3, [r7, #4]
   85c54:	2200      	movs	r2, #0
   85c56:	629a      	str	r2, [r3, #40]	; 0x28

	/* Disable TX and RX, reset status bits and turn off RTS and DTR if exist. */
	usart_reset_tx(p_usart);
   85c58:	6878      	ldr	r0, [r7, #4]
   85c5a:	4b08      	ldr	r3, [pc, #32]	; (85c7c <usart_reset+0x44>)
   85c5c:	4798      	blx	r3
	usart_reset_rx(p_usart);
   85c5e:	6878      	ldr	r0, [r7, #4]
   85c60:	4b07      	ldr	r3, [pc, #28]	; (85c80 <usart_reset+0x48>)
   85c62:	4798      	blx	r3
	usart_reset_status(p_usart);
   85c64:	6878      	ldr	r0, [r7, #4]
   85c66:	4b07      	ldr	r3, [pc, #28]	; (85c84 <usart_reset+0x4c>)
   85c68:	4798      	blx	r3
	usart_drive_RTS_pin_high(p_usart);
   85c6a:	6878      	ldr	r0, [r7, #4]
   85c6c:	4b06      	ldr	r3, [pc, #24]	; (85c88 <usart_reset+0x50>)
   85c6e:	4798      	blx	r3
#if (SAM3S || SAM4S || SAM3U)
	usart_drive_DTR_pin_high(p_usart);
#endif
}
   85c70:	3708      	adds	r7, #8
   85c72:	46bd      	mov	sp, r7
   85c74:	bd80      	pop	{r7, pc}
   85c76:	bf00      	nop
   85c78:	00085e59 	.word	0x00085e59
   85c7c:	00085d29 	.word	0x00085d29
   85c80:	00085d59 	.word	0x00085d59
   85c84:	00085da5 	.word	0x00085da5
   85c88:	00085dc1 	.word	0x00085dc1

00085c8c <usart_init_rs232>:
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_init_rs232(Usart *p_usart,
		const sam_usart_opt_t *p_usart_opt, uint32_t ul_mck)
{
   85c8c:	b580      	push	{r7, lr}
   85c8e:	b084      	sub	sp, #16
   85c90:	af00      	add	r7, sp, #0
   85c92:	60f8      	str	r0, [r7, #12]
   85c94:	60b9      	str	r1, [r7, #8]
   85c96:	607a      	str	r2, [r7, #4]
	static uint32_t ul_reg_val;

	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);
   85c98:	68f8      	ldr	r0, [r7, #12]
   85c9a:	4b1a      	ldr	r3, [pc, #104]	; (85d04 <usart_init_rs232+0x78>)
   85c9c:	4798      	blx	r3

	ul_reg_val = 0;
   85c9e:	4b1a      	ldr	r3, [pc, #104]	; (85d08 <usart_init_rs232+0x7c>)
   85ca0:	2200      	movs	r2, #0
   85ca2:	601a      	str	r2, [r3, #0]
	/* Check whether the input values are legal. */
	if (!p_usart_opt ||
   85ca4:	68bb      	ldr	r3, [r7, #8]
   85ca6:	2b00      	cmp	r3, #0
   85ca8:	d009      	beq.n	85cbe <usart_init_rs232+0x32>
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
   85caa:	68bb      	ldr	r3, [r7, #8]
   85cac:	681b      	ldr	r3, [r3, #0]
   85cae:	68f8      	ldr	r0, [r7, #12]
   85cb0:	4619      	mov	r1, r3
   85cb2:	687a      	ldr	r2, [r7, #4]
   85cb4:	4b15      	ldr	r3, [pc, #84]	; (85d0c <usart_init_rs232+0x80>)
   85cb6:	4798      	blx	r3
   85cb8:	4603      	mov	r3, r0
	/* Reset the USART and shut down TX and RX. */
	usart_reset(p_usart);

	ul_reg_val = 0;
	/* Check whether the input values are legal. */
	if (!p_usart_opt ||
   85cba:	2b00      	cmp	r3, #0
   85cbc:	d001      	beq.n	85cc2 <usart_init_rs232+0x36>
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
		return 1;
   85cbe:	2301      	movs	r3, #1
   85cc0:	e01b      	b.n	85cfa <usart_init_rs232+0x6e>
	}

	/* Configure the character length, parity type, channel mode and stop bit length. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
   85cc2:	68bb      	ldr	r3, [r7, #8]
   85cc4:	685a      	ldr	r2, [r3, #4]
   85cc6:	68bb      	ldr	r3, [r7, #8]
   85cc8:	689b      	ldr	r3, [r3, #8]
   85cca:	431a      	orrs	r2, r3
				p_usart_opt->channel_mode | p_usart_opt->stop_bits;
   85ccc:	68bb      	ldr	r3, [r7, #8]
   85cce:	691b      	ldr	r3, [r3, #16]
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the character length, parity type, channel mode and stop bit length. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
   85cd0:	431a      	orrs	r2, r3
				p_usart_opt->channel_mode | p_usart_opt->stop_bits;
   85cd2:	68bb      	ldr	r3, [r7, #8]
   85cd4:	68db      	ldr	r3, [r3, #12]
   85cd6:	431a      	orrs	r2, r3
		usart_set_async_baudrate(p_usart, p_usart_opt->baudrate, ul_mck)) {
		return 1;
	}

	/* Configure the character length, parity type, channel mode and stop bit length. */
	ul_reg_val |= p_usart_opt->char_length | p_usart_opt->parity_type |
   85cd8:	4b0b      	ldr	r3, [pc, #44]	; (85d08 <usart_init_rs232+0x7c>)
   85cda:	681b      	ldr	r3, [r3, #0]
   85cdc:	431a      	orrs	r2, r3
   85cde:	4b0a      	ldr	r3, [pc, #40]	; (85d08 <usart_init_rs232+0x7c>)
   85ce0:	601a      	str	r2, [r3, #0]
				p_usart_opt->channel_mode | p_usart_opt->stop_bits;
	
	/* Configure the USART mode as normal mode. */
	ul_reg_val |= US_MR_USART_MODE_NORMAL;
   85ce2:	4b09      	ldr	r3, [pc, #36]	; (85d08 <usart_init_rs232+0x7c>)
   85ce4:	681a      	ldr	r2, [r3, #0]
   85ce6:	4b08      	ldr	r3, [pc, #32]	; (85d08 <usart_init_rs232+0x7c>)
   85ce8:	601a      	str	r2, [r3, #0]
	
	p_usart->US_MR |= ul_reg_val;
   85cea:	68fb      	ldr	r3, [r7, #12]
   85cec:	685a      	ldr	r2, [r3, #4]
   85cee:	4b06      	ldr	r3, [pc, #24]	; (85d08 <usart_init_rs232+0x7c>)
   85cf0:	681b      	ldr	r3, [r3, #0]
   85cf2:	431a      	orrs	r2, r3
   85cf4:	68fb      	ldr	r3, [r7, #12]
   85cf6:	605a      	str	r2, [r3, #4]
	
	return 0;
   85cf8:	2300      	movs	r3, #0
}
   85cfa:	4618      	mov	r0, r3
   85cfc:	3710      	adds	r7, #16
   85cfe:	46bd      	mov	sp, r7
   85d00:	bd80      	pop	{r7, pc}
   85d02:	bf00      	nop
   85d04:	00085c39 	.word	0x00085c39
   85d08:	20070c4c 	.word	0x20070c4c
   85d0c:	00085bad 	.word	0x00085bad

00085d10 <usart_enable_tx>:
 * \brief Enable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_tx(Usart *p_usart)
{
   85d10:	b480      	push	{r7}
   85d12:	b083      	sub	sp, #12
   85d14:	af00      	add	r7, sp, #0
   85d16:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_TXEN;
   85d18:	687b      	ldr	r3, [r7, #4]
   85d1a:	2240      	movs	r2, #64	; 0x40
   85d1c:	601a      	str	r2, [r3, #0]
}
   85d1e:	370c      	adds	r7, #12
   85d20:	46bd      	mov	sp, r7
   85d22:	f85d 7b04 	ldr.w	r7, [sp], #4
   85d26:	4770      	bx	lr

00085d28 <usart_reset_tx>:
 * \brief Immediately stop and disable USART transmitter.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_tx(Usart *p_usart)
{
   85d28:	b480      	push	{r7}
   85d2a:	b083      	sub	sp, #12
   85d2c:	af00      	add	r7, sp, #0
   85d2e:	6078      	str	r0, [r7, #4]
	/* Reset transmitter */
	p_usart->US_CR = US_CR_RSTTX | US_CR_TXDIS;
   85d30:	687b      	ldr	r3, [r7, #4]
   85d32:	2288      	movs	r2, #136	; 0x88
   85d34:	601a      	str	r2, [r3, #0]
}
   85d36:	370c      	adds	r7, #12
   85d38:	46bd      	mov	sp, r7
   85d3a:	f85d 7b04 	ldr.w	r7, [sp], #4
   85d3e:	4770      	bx	lr

00085d40 <usart_enable_rx>:
 * \brief Enable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_enable_rx(Usart *p_usart)
{
   85d40:	b480      	push	{r7}
   85d42:	b083      	sub	sp, #12
   85d44:	af00      	add	r7, sp, #0
   85d46:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RXEN;
   85d48:	687b      	ldr	r3, [r7, #4]
   85d4a:	2210      	movs	r2, #16
   85d4c:	601a      	str	r2, [r3, #0]
}
   85d4e:	370c      	adds	r7, #12
   85d50:	46bd      	mov	sp, r7
   85d52:	f85d 7b04 	ldr.w	r7, [sp], #4
   85d56:	4770      	bx	lr

00085d58 <usart_reset_rx>:
 * \brief Immediately stop and disable USART receiver.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_rx(Usart *p_usart)
{
   85d58:	b480      	push	{r7}
   85d5a:	b083      	sub	sp, #12
   85d5c:	af00      	add	r7, sp, #0
   85d5e:	6078      	str	r0, [r7, #4]
	/* Reset Receiver */
	p_usart->US_CR = US_CR_RSTRX | US_CR_RXDIS;
   85d60:	687b      	ldr	r3, [r7, #4]
   85d62:	2224      	movs	r2, #36	; 0x24
   85d64:	601a      	str	r2, [r3, #0]
}
   85d66:	370c      	adds	r7, #12
   85d68:	46bd      	mov	sp, r7
   85d6a:	f85d 7b04 	ldr.w	r7, [sp], #4
   85d6e:	4770      	bx	lr

00085d70 <usart_disable_interrupt>:
 *
 * \param p_usart Pointer to a USART peripheral.
 * \param ul_sources Interrupt sources bit map.
 */
void usart_disable_interrupt(Usart *p_usart, uint32_t ul_sources)
{
   85d70:	b480      	push	{r7}
   85d72:	b083      	sub	sp, #12
   85d74:	af00      	add	r7, sp, #0
   85d76:	6078      	str	r0, [r7, #4]
   85d78:	6039      	str	r1, [r7, #0]
	p_usart->US_IDR = ul_sources;
   85d7a:	687b      	ldr	r3, [r7, #4]
   85d7c:	683a      	ldr	r2, [r7, #0]
   85d7e:	60da      	str	r2, [r3, #12]
}
   85d80:	370c      	adds	r7, #12
   85d82:	46bd      	mov	sp, r7
   85d84:	f85d 7b04 	ldr.w	r7, [sp], #4
   85d88:	4770      	bx	lr
   85d8a:	bf00      	nop

00085d8c <usart_get_status>:
 * \param p_usart Pointer to a USART instance.
 *
 * \return The current USART status.
 */
uint32_t usart_get_status(Usart *p_usart)
{
   85d8c:	b480      	push	{r7}
   85d8e:	b083      	sub	sp, #12
   85d90:	af00      	add	r7, sp, #0
   85d92:	6078      	str	r0, [r7, #4]
	return p_usart->US_CSR;
   85d94:	687b      	ldr	r3, [r7, #4]
   85d96:	695b      	ldr	r3, [r3, #20]
}
   85d98:	4618      	mov	r0, r3
   85d9a:	370c      	adds	r7, #12
   85d9c:	46bd      	mov	sp, r7
   85d9e:	f85d 7b04 	ldr.w	r7, [sp], #4
   85da2:	4770      	bx	lr

00085da4 <usart_reset_status>:
 * \brief Reset status bits (PARE, OVER, MANERR, UNRE and PXBRK in US_CSR).
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_reset_status(Usart *p_usart)
{
   85da4:	b480      	push	{r7}
   85da6:	b083      	sub	sp, #12
   85da8:	af00      	add	r7, sp, #0
   85daa:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RSTSTA;
   85dac:	687b      	ldr	r3, [r7, #4]
   85dae:	f44f 7280 	mov.w	r2, #256	; 0x100
   85db2:	601a      	str	r2, [r3, #0]
}
   85db4:	370c      	adds	r7, #12
   85db6:	46bd      	mov	sp, r7
   85db8:	f85d 7b04 	ldr.w	r7, [sp], #4
   85dbc:	4770      	bx	lr
   85dbe:	bf00      	nop

00085dc0 <usart_drive_RTS_pin_high>:
 * \brief Drive the pin RTS to 1.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_drive_RTS_pin_high(Usart *p_usart)
{
   85dc0:	b480      	push	{r7}
   85dc2:	b083      	sub	sp, #12
   85dc4:	af00      	add	r7, sp, #0
   85dc6:	6078      	str	r0, [r7, #4]
	p_usart->US_CR = US_CR_RTSDIS;
   85dc8:	687b      	ldr	r3, [r7, #4]
   85dca:	f44f 2200 	mov.w	r2, #524288	; 0x80000
   85dce:	601a      	str	r2, [r3, #0]
}
   85dd0:	370c      	adds	r7, #12
   85dd2:	46bd      	mov	sp, r7
   85dd4:	f85d 7b04 	ldr.w	r7, [sp], #4
   85dd8:	4770      	bx	lr
   85dda:	bf00      	nop

00085ddc <usart_write>:
 *
 * \retval 0 on success.
 * \retval 1 on failure.
 */
uint32_t usart_write(Usart *p_usart, uint32_t c)
{
   85ddc:	b480      	push	{r7}
   85dde:	b083      	sub	sp, #12
   85de0:	af00      	add	r7, sp, #0
   85de2:	6078      	str	r0, [r7, #4]
   85de4:	6039      	str	r1, [r7, #0]
	if (!(p_usart->US_CSR & US_CSR_TXRDY)) {
   85de6:	687b      	ldr	r3, [r7, #4]
   85de8:	695b      	ldr	r3, [r3, #20]
   85dea:	f003 0302 	and.w	r3, r3, #2
   85dee:	2b00      	cmp	r3, #0
   85df0:	d101      	bne.n	85df6 <usart_write+0x1a>
		return 1;
   85df2:	2301      	movs	r3, #1
   85df4:	e005      	b.n	85e02 <usart_write+0x26>
	}

	p_usart->US_THR = US_THR_TXCHR(c);
   85df6:	683b      	ldr	r3, [r7, #0]
   85df8:	f3c3 0208 	ubfx	r2, r3, #0, #9
   85dfc:	687b      	ldr	r3, [r7, #4]
   85dfe:	61da      	str	r2, [r3, #28]
	return 0;
   85e00:	2300      	movs	r3, #0
}
   85e02:	4618      	mov	r0, r3
   85e04:	370c      	adds	r7, #12
   85e06:	46bd      	mov	sp, r7
   85e08:	f85d 7b04 	ldr.w	r7, [sp], #4
   85e0c:	4770      	bx	lr
   85e0e:	bf00      	nop

00085e10 <usart_getchar>:
 *
 * \retval 0 Data has been received.
 * \retval 1 on failure.
 */
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
   85e10:	b480      	push	{r7}
   85e12:	b085      	sub	sp, #20
   85e14:	af00      	add	r7, sp, #0
   85e16:	6078      	str	r0, [r7, #4]
   85e18:	6039      	str	r1, [r7, #0]
	uint32_t timeout = USART_DEFAULT_TIMEOUT;
   85e1a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
   85e1e:	60fb      	str	r3, [r7, #12]

	/* If the receiver is empty, wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
   85e20:	e006      	b.n	85e30 <usart_getchar+0x20>
		if (!timeout--) {
   85e22:	68fb      	ldr	r3, [r7, #12]
   85e24:	1e5a      	subs	r2, r3, #1
   85e26:	60fa      	str	r2, [r7, #12]
   85e28:	2b00      	cmp	r3, #0
   85e2a:	d101      	bne.n	85e30 <usart_getchar+0x20>
			return 1;
   85e2c:	2301      	movs	r3, #1
   85e2e:	e00c      	b.n	85e4a <usart_getchar+0x3a>
uint32_t usart_getchar(Usart *p_usart, uint32_t *c)
{
	uint32_t timeout = USART_DEFAULT_TIMEOUT;

	/* If the receiver is empty, wait until it's not empty or timeout has reached. */
	while (!(p_usart->US_CSR & US_CSR_RXRDY)) {
   85e30:	687b      	ldr	r3, [r7, #4]
   85e32:	695b      	ldr	r3, [r3, #20]
   85e34:	f003 0301 	and.w	r3, r3, #1
   85e38:	2b00      	cmp	r3, #0
   85e3a:	d0f2      	beq.n	85e22 <usart_getchar+0x12>
			return 1;
		}
	}

	/* Read character */
	*c = p_usart->US_RHR & US_RHR_RXCHR_Msk;
   85e3c:	687b      	ldr	r3, [r7, #4]
   85e3e:	699b      	ldr	r3, [r3, #24]
   85e40:	f3c3 0208 	ubfx	r2, r3, #0, #9
   85e44:	683b      	ldr	r3, [r7, #0]
   85e46:	601a      	str	r2, [r3, #0]

	return 0;
   85e48:	2300      	movs	r3, #0
}
   85e4a:	4618      	mov	r0, r3
   85e4c:	3714      	adds	r7, #20
   85e4e:	46bd      	mov	sp, r7
   85e50:	f85d 7b04 	ldr.w	r7, [sp], #4
   85e54:	4770      	bx	lr
   85e56:	bf00      	nop

00085e58 <usart_disable_writeprotect>:
 * \brief Disable write protect of USART registers.
 *
 * \param p_usart Pointer to a USART instance.
 */
void usart_disable_writeprotect(Usart *p_usart)
{
   85e58:	b480      	push	{r7}
   85e5a:	b083      	sub	sp, #12
   85e5c:	af00      	add	r7, sp, #0
   85e5e:	6078      	str	r0, [r7, #4]
	p_usart->US_WPMR = US_WPMR_WPKEY(US_WPKEY_VALUE);
   85e60:	687b      	ldr	r3, [r7, #4]
   85e62:	4a04      	ldr	r2, [pc, #16]	; (85e74 <usart_disable_writeprotect+0x1c>)
   85e64:	f8c3 20e4 	str.w	r2, [r3, #228]	; 0xe4
}
   85e68:	370c      	adds	r7, #12
   85e6a:	46bd      	mov	sp, r7
   85e6c:	f85d 7b04 	ldr.w	r7, [sp], #4
   85e70:	4770      	bx	lr
   85e72:	bf00      	nop
   85e74:	55534100 	.word	0x55534100

00085e78 <wdt_restart>:

/**
 * \brief Restart the watchdog timer.
 */
void wdt_restart(Wdt *p_wdt)
{
   85e78:	b480      	push	{r7}
   85e7a:	b083      	sub	sp, #12
   85e7c:	af00      	add	r7, sp, #0
   85e7e:	6078      	str	r0, [r7, #4]
	if (p_wdt == WDT) {
   85e80:	687a      	ldr	r2, [r7, #4]
   85e82:	4b05      	ldr	r3, [pc, #20]	; (85e98 <wdt_restart+0x20>)
   85e84:	429a      	cmp	r2, r3
   85e86:	d102      	bne.n	85e8e <wdt_restart+0x16>
		p_wdt->WDT_CR = WDT_KEY_PASSWORD | WDT_CR_WDRSTT;
   85e88:	687b      	ldr	r3, [r7, #4]
   85e8a:	4a04      	ldr	r2, [pc, #16]	; (85e9c <wdt_restart+0x24>)
   85e8c:	601a      	str	r2, [r3, #0]
#if (SAM4C || SAM4CM || SAM4CP)
	else {
		p_wdt->WDT_CR = RSWDT_CR_KEY(0xC4u) | RSWDT_CR_WDRSTT;
	}
#endif
}
   85e8e:	370c      	adds	r7, #12
   85e90:	46bd      	mov	sp, r7
   85e92:	f85d 7b04 	ldr.w	r7, [sp], #4
   85e96:	4770      	bx	lr
   85e98:	400e1a50 	.word	0x400e1a50
   85e9c:	a5000001 	.word	0xa5000001

00085ea0 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
   85ea0:	b480      	push	{r7}
   85ea2:	af00      	add	r7, sp, #0
	while (1) {
	}
   85ea4:	e7fe      	b.n	85ea4 <Dummy_Handler+0x4>
   85ea6:	bf00      	nop

00085ea8 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
   85ea8:	b580      	push	{r7, lr}
   85eaa:	b082      	sub	sp, #8
   85eac:	af00      	add	r7, sp, #0
	uint32_t *pSrc, *pDest;

	/* Initialize the relocate segment */
	pSrc = &_etext;
   85eae:	4b1e      	ldr	r3, [pc, #120]	; (85f28 <Reset_Handler+0x80>)
   85eb0:	607b      	str	r3, [r7, #4]
	pDest = &_srelocate;
   85eb2:	4b1e      	ldr	r3, [pc, #120]	; (85f2c <Reset_Handler+0x84>)
   85eb4:	603b      	str	r3, [r7, #0]

	if (pSrc != pDest) {
   85eb6:	687a      	ldr	r2, [r7, #4]
   85eb8:	683b      	ldr	r3, [r7, #0]
   85eba:	429a      	cmp	r2, r3
   85ebc:	d00c      	beq.n	85ed8 <Reset_Handler+0x30>
		for (; pDest < &_erelocate;) {
   85ebe:	e007      	b.n	85ed0 <Reset_Handler+0x28>
			*pDest++ = *pSrc++;
   85ec0:	683b      	ldr	r3, [r7, #0]
   85ec2:	1d1a      	adds	r2, r3, #4
   85ec4:	603a      	str	r2, [r7, #0]
   85ec6:	687a      	ldr	r2, [r7, #4]
   85ec8:	1d11      	adds	r1, r2, #4
   85eca:	6079      	str	r1, [r7, #4]
   85ecc:	6812      	ldr	r2, [r2, #0]
   85ece:	601a      	str	r2, [r3, #0]
	/* Initialize the relocate segment */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
		for (; pDest < &_erelocate;) {
   85ed0:	683a      	ldr	r2, [r7, #0]
   85ed2:	4b17      	ldr	r3, [pc, #92]	; (85f30 <Reset_Handler+0x88>)
   85ed4:	429a      	cmp	r2, r3
   85ed6:	d3f3      	bcc.n	85ec0 <Reset_Handler+0x18>
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   85ed8:	4b16      	ldr	r3, [pc, #88]	; (85f34 <Reset_Handler+0x8c>)
   85eda:	603b      	str	r3, [r7, #0]
   85edc:	e004      	b.n	85ee8 <Reset_Handler+0x40>
		*pDest++ = 0;
   85ede:	683b      	ldr	r3, [r7, #0]
   85ee0:	1d1a      	adds	r2, r3, #4
   85ee2:	603a      	str	r2, [r7, #0]
   85ee4:	2200      	movs	r2, #0
   85ee6:	601a      	str	r2, [r3, #0]
			*pDest++ = *pSrc++;
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   85ee8:	683a      	ldr	r2, [r7, #0]
   85eea:	4b13      	ldr	r3, [pc, #76]	; (85f38 <Reset_Handler+0x90>)
   85eec:	429a      	cmp	r2, r3
   85eee:	d3f6      	bcc.n	85ede <Reset_Handler+0x36>
		*pDest++ = 0;
	}

	/* Set the vector table base address */
	pSrc = (uint32_t *) & _sfixed;
   85ef0:	4b12      	ldr	r3, [pc, #72]	; (85f3c <Reset_Handler+0x94>)
   85ef2:	607b      	str	r3, [r7, #4]
	SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
   85ef4:	4a12      	ldr	r2, [pc, #72]	; (85f40 <Reset_Handler+0x98>)
   85ef6:	687b      	ldr	r3, [r7, #4]
   85ef8:	f023 4360 	bic.w	r3, r3, #3758096384	; 0xe0000000
   85efc:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
   85f00:	6093      	str	r3, [r2, #8]

	if (((uint32_t) pSrc >= IRAM0_ADDR) && ((uint32_t) pSrc < NFC_RAM_ADDR)) {
   85f02:	687b      	ldr	r3, [r7, #4]
   85f04:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
   85f08:	d309      	bcc.n	85f1e <Reset_Handler+0x76>
   85f0a:	687a      	ldr	r2, [r7, #4]
   85f0c:	4b0d      	ldr	r3, [pc, #52]	; (85f44 <Reset_Handler+0x9c>)
   85f0e:	429a      	cmp	r2, r3
   85f10:	d805      	bhi.n	85f1e <Reset_Handler+0x76>
		SCB->VTOR |= 1 << SCB_VTOR_TBLBASE_Pos;
   85f12:	4b0b      	ldr	r3, [pc, #44]	; (85f40 <Reset_Handler+0x98>)
   85f14:	4a0a      	ldr	r2, [pc, #40]	; (85f40 <Reset_Handler+0x98>)
   85f16:	6892      	ldr	r2, [r2, #8]
   85f18:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
   85f1c:	609a      	str	r2, [r3, #8]
	}

	/* Initialize the C library */
	__libc_init_array();
   85f1e:	4b0a      	ldr	r3, [pc, #40]	; (85f48 <Reset_Handler+0xa0>)
   85f20:	4798      	blx	r3

	/* Branch to main function */
	main();
   85f22:	4b0a      	ldr	r3, [pc, #40]	; (85f4c <Reset_Handler+0xa4>)
   85f24:	4798      	blx	r3

	/* Infinite loop */
	while (1);
   85f26:	e7fe      	b.n	85f26 <Reset_Handler+0x7e>
   85f28:	0008b1bc 	.word	0x0008b1bc
   85f2c:	20070000 	.word	0x20070000
   85f30:	20070438 	.word	0x20070438
   85f34:	20070438 	.word	0x20070438
   85f38:	2007d588 	.word	0x2007d588
   85f3c:	00080000 	.word	0x00080000
   85f40:	e000ed00 	.word	0xe000ed00
   85f44:	200fffff 	.word	0x200fffff
   85f48:	0008acfd 	.word	0x0008acfd
   85f4c:	00089f45 	.word	0x00089f45

00085f50 <SystemCoreClockUpdate>:

	SystemCoreClock = CHIP_FREQ_CPU_MAX;
}

void SystemCoreClockUpdate(void)
{
   85f50:	b480      	push	{r7}
   85f52:	af00      	add	r7, sp, #0
	/* Determine clock frequency according to clock register values */
	switch (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) {
   85f54:	4b56      	ldr	r3, [pc, #344]	; (860b0 <SystemCoreClockUpdate+0x160>)
   85f56:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   85f58:	f003 0303 	and.w	r3, r3, #3
   85f5c:	2b03      	cmp	r3, #3
   85f5e:	f200 808a 	bhi.w	86076 <SystemCoreClockUpdate+0x126>
   85f62:	a101      	add	r1, pc, #4	; (adr r1, 85f68 <SystemCoreClockUpdate+0x18>)
   85f64:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
   85f68:	00085f79 	.word	0x00085f79
   85f6c:	00085f99 	.word	0x00085f99
   85f70:	00085fe9 	.word	0x00085fe9
   85f74:	00085fe9 	.word	0x00085fe9
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
   85f78:	4b4e      	ldr	r3, [pc, #312]	; (860b4 <SystemCoreClockUpdate+0x164>)
   85f7a:	695b      	ldr	r3, [r3, #20]
   85f7c:	f003 0380 	and.w	r3, r3, #128	; 0x80
   85f80:	2b00      	cmp	r3, #0
   85f82:	d004      	beq.n	85f8e <SystemCoreClockUpdate+0x3e>
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
   85f84:	4b4c      	ldr	r3, [pc, #304]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85f86:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   85f8a:	601a      	str	r2, [r3, #0]
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
		}
		break;
   85f8c:	e073      	b.n	86076 <SystemCoreClockUpdate+0x126>
	switch (PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) {
	case PMC_MCKR_CSS_SLOW_CLK:	/* Slow clock */
		if (SUPC->SUPC_SR & SUPC_SR_OSCSEL) {
			SystemCoreClock = CHIP_FREQ_XTAL_32K;
		} else {
			SystemCoreClock = CHIP_FREQ_SLCK_RC;
   85f8e:	4b4a      	ldr	r3, [pc, #296]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85f90:	f44f 42fa 	mov.w	r2, #32000	; 0x7d00
   85f94:	601a      	str	r2, [r3, #0]
		}
		break;
   85f96:	e06e      	b.n	86076 <SystemCoreClockUpdate+0x126>
	case PMC_MCKR_CSS_MAIN_CLK:	/* Main clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   85f98:	4b45      	ldr	r3, [pc, #276]	; (860b0 <SystemCoreClockUpdate+0x160>)
   85f9a:	6a1b      	ldr	r3, [r3, #32]
   85f9c:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   85fa0:	2b00      	cmp	r3, #0
   85fa2:	d003      	beq.n	85fac <SystemCoreClockUpdate+0x5c>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   85fa4:	4b44      	ldr	r3, [pc, #272]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85fa6:	4a45      	ldr	r2, [pc, #276]	; (860bc <SystemCoreClockUpdate+0x16c>)
   85fa8:	601a      	str	r2, [r3, #0]
   85faa:	e01c      	b.n	85fe6 <SystemCoreClockUpdate+0x96>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   85fac:	4b42      	ldr	r3, [pc, #264]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85fae:	4a44      	ldr	r2, [pc, #272]	; (860c0 <SystemCoreClockUpdate+0x170>)
   85fb0:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   85fb2:	4b3f      	ldr	r3, [pc, #252]	; (860b0 <SystemCoreClockUpdate+0x160>)
   85fb4:	6a1b      	ldr	r3, [r3, #32]
   85fb6:	f003 0370 	and.w	r3, r3, #112	; 0x70
   85fba:	2b10      	cmp	r3, #16
   85fbc:	d004      	beq.n	85fc8 <SystemCoreClockUpdate+0x78>
   85fbe:	2b20      	cmp	r3, #32
   85fc0:	d008      	beq.n	85fd4 <SystemCoreClockUpdate+0x84>
   85fc2:	2b00      	cmp	r3, #0
   85fc4:	d00e      	beq.n	85fe4 <SystemCoreClockUpdate+0x94>
				break;
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
				break;
			default:
				break;
   85fc6:	e00e      	b.n	85fe6 <SystemCoreClockUpdate+0x96>

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
   85fc8:	4b3b      	ldr	r3, [pc, #236]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85fca:	681b      	ldr	r3, [r3, #0]
   85fcc:	005a      	lsls	r2, r3, #1
   85fce:	4b3a      	ldr	r3, [pc, #232]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85fd0:	601a      	str	r2, [r3, #0]
				break;
   85fd2:	e008      	b.n	85fe6 <SystemCoreClockUpdate+0x96>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
   85fd4:	4b38      	ldr	r3, [pc, #224]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85fd6:	681a      	ldr	r2, [r3, #0]
   85fd8:	4613      	mov	r3, r2
   85fda:	005b      	lsls	r3, r3, #1
   85fdc:	441a      	add	r2, r3
   85fde:	4b36      	ldr	r3, [pc, #216]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85fe0:	601a      	str	r2, [r3, #0]
				break;
   85fe2:	e000      	b.n	85fe6 <SystemCoreClockUpdate+0x96>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
   85fe4:	bf00      	nop
				break;
			default:
				break;
			}
		}
		break;
   85fe6:	e046      	b.n	86076 <SystemCoreClockUpdate+0x126>
	case PMC_MCKR_CSS_PLLA_CLK:	/* PLLA clock */
	case PMC_MCKR_CSS_UPLL_CLK:	/* UPLL clock */
		if (PMC->CKGR_MOR & CKGR_MOR_MOSCSEL) {
   85fe8:	4b31      	ldr	r3, [pc, #196]	; (860b0 <SystemCoreClockUpdate+0x160>)
   85fea:	6a1b      	ldr	r3, [r3, #32]
   85fec:	f003 7380 	and.w	r3, r3, #16777216	; 0x1000000
   85ff0:	2b00      	cmp	r3, #0
   85ff2:	d003      	beq.n	85ffc <SystemCoreClockUpdate+0xac>
			SystemCoreClock = CHIP_FREQ_XTAL_12M;
   85ff4:	4b30      	ldr	r3, [pc, #192]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85ff6:	4a31      	ldr	r2, [pc, #196]	; (860bc <SystemCoreClockUpdate+0x16c>)
   85ff8:	601a      	str	r2, [r3, #0]
   85ffa:	e01c      	b.n	86036 <SystemCoreClockUpdate+0xe6>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;
   85ffc:	4b2e      	ldr	r3, [pc, #184]	; (860b8 <SystemCoreClockUpdate+0x168>)
   85ffe:	4a30      	ldr	r2, [pc, #192]	; (860c0 <SystemCoreClockUpdate+0x170>)
   86000:	601a      	str	r2, [r3, #0]

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
   86002:	4b2b      	ldr	r3, [pc, #172]	; (860b0 <SystemCoreClockUpdate+0x160>)
   86004:	6a1b      	ldr	r3, [r3, #32]
   86006:	f003 0370 	and.w	r3, r3, #112	; 0x70
   8600a:	2b10      	cmp	r3, #16
   8600c:	d004      	beq.n	86018 <SystemCoreClockUpdate+0xc8>
   8600e:	2b20      	cmp	r3, #32
   86010:	d008      	beq.n	86024 <SystemCoreClockUpdate+0xd4>
   86012:	2b00      	cmp	r3, #0
   86014:	d00e      	beq.n	86034 <SystemCoreClockUpdate+0xe4>
				break;
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
				break;
			default:
				break;
   86016:	e00e      	b.n	86036 <SystemCoreClockUpdate+0xe6>

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
			case CKGR_MOR_MOSCRCF_8_MHz:
				SystemCoreClock *= 2U;
   86018:	4b27      	ldr	r3, [pc, #156]	; (860b8 <SystemCoreClockUpdate+0x168>)
   8601a:	681b      	ldr	r3, [r3, #0]
   8601c:	005a      	lsls	r2, r3, #1
   8601e:	4b26      	ldr	r3, [pc, #152]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86020:	601a      	str	r2, [r3, #0]
				break;
   86022:	e008      	b.n	86036 <SystemCoreClockUpdate+0xe6>
			case CKGR_MOR_MOSCRCF_12_MHz:
				SystemCoreClock *= 3U;
   86024:	4b24      	ldr	r3, [pc, #144]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86026:	681a      	ldr	r2, [r3, #0]
   86028:	4613      	mov	r3, r2
   8602a:	005b      	lsls	r3, r3, #1
   8602c:	441a      	add	r2, r3
   8602e:	4b22      	ldr	r3, [pc, #136]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86030:	601a      	str	r2, [r3, #0]
				break;
   86032:	e000      	b.n	86036 <SystemCoreClockUpdate+0xe6>
		} else {
			SystemCoreClock = CHIP_FREQ_MAINCK_RC_4MHZ;

			switch (PMC->CKGR_MOR & CKGR_MOR_MOSCRCF_Msk) {
			case CKGR_MOR_MOSCRCF_4_MHz:
				break;
   86034:	bf00      	nop
				break;
			default:
				break;
			}
		}
		if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
   86036:	4b1e      	ldr	r3, [pc, #120]	; (860b0 <SystemCoreClockUpdate+0x160>)
   86038:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8603a:	f003 0303 	and.w	r3, r3, #3
   8603e:	2b02      	cmp	r3, #2
   86040:	d115      	bne.n	8606e <SystemCoreClockUpdate+0x11e>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   86042:	4b1b      	ldr	r3, [pc, #108]	; (860b0 <SystemCoreClockUpdate+0x160>)
   86044:	6a9a      	ldr	r2, [r3, #40]	; 0x28
   86046:	4b1f      	ldr	r3, [pc, #124]	; (860c4 <SystemCoreClockUpdate+0x174>)
   86048:	4013      	ands	r3, r2
   8604a:	0c1b      	lsrs	r3, r3, #16
				                            CKGR_PLLAR_MULA_Pos) + 1U);
   8604c:	3301      	adds	r3, #1
			default:
				break;
			}
		}
		if ((PMC->PMC_MCKR & PMC_MCKR_CSS_Msk) == PMC_MCKR_CSS_PLLA_CLK) {
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
   8604e:	4a1a      	ldr	r2, [pc, #104]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86050:	6812      	ldr	r2, [r2, #0]
   86052:	fb02 f203 	mul.w	r2, r2, r3
   86056:	4b18      	ldr	r3, [pc, #96]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86058:	601a      	str	r2, [r3, #0]
				                            CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
   8605a:	4b17      	ldr	r3, [pc, #92]	; (860b8 <SystemCoreClockUpdate+0x168>)
   8605c:	681a      	ldr	r2, [r3, #0]
   8605e:	4b14      	ldr	r3, [pc, #80]	; (860b0 <SystemCoreClockUpdate+0x160>)
   86060:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   86062:	b2db      	uxtb	r3, r3
   86064:	fbb2 f2f3 	udiv	r2, r2, r3
   86068:	4b13      	ldr	r3, [pc, #76]	; (860b8 <SystemCoreClockUpdate+0x168>)
   8606a:	601a      	str	r2, [r3, #0]
				                             CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock = SYS_UTMIPLL / 2U;
		}
		break;
   8606c:	e002      	b.n	86074 <SystemCoreClockUpdate+0x124>
			SystemCoreClock *= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_MULA_Msk) >> 
				                            CKGR_PLLAR_MULA_Pos) + 1U);
			SystemCoreClock /= ((((PMC->CKGR_PLLAR) & CKGR_PLLAR_DIVA_Msk) >> 
				                             CKGR_PLLAR_DIVA_Pos));
		} else {
			SystemCoreClock = SYS_UTMIPLL / 2U;
   8606e:	4b12      	ldr	r3, [pc, #72]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86070:	4a15      	ldr	r2, [pc, #84]	; (860c8 <SystemCoreClockUpdate+0x178>)
   86072:	601a      	str	r2, [r3, #0]
		}
		break;
   86074:	bf00      	nop
	}

	if ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) == PMC_MCKR_PRES_CLK_3) {
   86076:	4b0e      	ldr	r3, [pc, #56]	; (860b0 <SystemCoreClockUpdate+0x160>)
   86078:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8607a:	f003 0370 	and.w	r3, r3, #112	; 0x70
   8607e:	2b70      	cmp	r3, #112	; 0x70
   86080:	d108      	bne.n	86094 <SystemCoreClockUpdate+0x144>
		SystemCoreClock /= 3U;
   86082:	4b0d      	ldr	r3, [pc, #52]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86084:	681a      	ldr	r2, [r3, #0]
   86086:	4b11      	ldr	r3, [pc, #68]	; (860cc <SystemCoreClockUpdate+0x17c>)
   86088:	fba3 1302 	umull	r1, r3, r3, r2
   8608c:	085a      	lsrs	r2, r3, #1
   8608e:	4b0a      	ldr	r3, [pc, #40]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86090:	601a      	str	r2, [r3, #0]
   86092:	e009      	b.n	860a8 <SystemCoreClockUpdate+0x158>
	} else {
		SystemCoreClock >>= ((PMC->PMC_MCKR & PMC_MCKR_PRES_Msk) >> 
   86094:	4b08      	ldr	r3, [pc, #32]	; (860b8 <SystemCoreClockUpdate+0x168>)
   86096:	681a      	ldr	r2, [r3, #0]
   86098:	4b05      	ldr	r3, [pc, #20]	; (860b0 <SystemCoreClockUpdate+0x160>)
   8609a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8609c:	f003 0370 	and.w	r3, r3, #112	; 0x70
   860a0:	091b      	lsrs	r3, r3, #4
   860a2:	40da      	lsrs	r2, r3
   860a4:	4b04      	ldr	r3, [pc, #16]	; (860b8 <SystemCoreClockUpdate+0x168>)
   860a6:	601a      	str	r2, [r3, #0]
			                          PMC_MCKR_PRES_Pos);
	}
}
   860a8:	46bd      	mov	sp, r7
   860aa:	f85d 7b04 	ldr.w	r7, [sp], #4
   860ae:	4770      	bx	lr
   860b0:	400e0600 	.word	0x400e0600
   860b4:	400e1a10 	.word	0x400e1a10
   860b8:	20070000 	.word	0x20070000
   860bc:	00b71b00 	.word	0x00b71b00
   860c0:	003d0900 	.word	0x003d0900
   860c4:	07ff0000 	.word	0x07ff0000
   860c8:	0e4e1c00 	.word	0x0e4e1c00
   860cc:	aaaaaaab 	.word	0xaaaaaaab

000860d0 <system_init_flash>:

/** 
 * Initialize flash.
 */
void system_init_flash(uint32_t ul_clk)
{
   860d0:	b480      	push	{r7}
   860d2:	b083      	sub	sp, #12
   860d4:	af00      	add	r7, sp, #0
   860d6:	6078      	str	r0, [r7, #4]
	/* Set FWS for embedded Flash access according to operating frequency */
	if (ul_clk < CHIP_FREQ_FWS_0) {
   860d8:	687a      	ldr	r2, [r7, #4]
   860da:	4b1f      	ldr	r3, [pc, #124]	; (86158 <system_init_flash+0x88>)
   860dc:	429a      	cmp	r2, r3
   860de:	d806      	bhi.n	860ee <system_init_flash+0x1e>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(0);
   860e0:	4b1e      	ldr	r3, [pc, #120]	; (8615c <system_init_flash+0x8c>)
   860e2:	2200      	movs	r2, #0
   860e4:	601a      	str	r2, [r3, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(0);
   860e6:	4b1e      	ldr	r3, [pc, #120]	; (86160 <system_init_flash+0x90>)
   860e8:	2200      	movs	r2, #0
   860ea:	601a      	str	r2, [r3, #0]
   860ec:	e02e      	b.n	8614c <system_init_flash+0x7c>
	} else if (ul_clk < CHIP_FREQ_FWS_1) {
   860ee:	687a      	ldr	r2, [r7, #4]
   860f0:	4b1c      	ldr	r3, [pc, #112]	; (86164 <system_init_flash+0x94>)
   860f2:	429a      	cmp	r2, r3
   860f4:	d808      	bhi.n	86108 <system_init_flash+0x38>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(1);
   860f6:	4b19      	ldr	r3, [pc, #100]	; (8615c <system_init_flash+0x8c>)
   860f8:	f44f 7280 	mov.w	r2, #256	; 0x100
   860fc:	601a      	str	r2, [r3, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(1);
   860fe:	4b18      	ldr	r3, [pc, #96]	; (86160 <system_init_flash+0x90>)
   86100:	f44f 7280 	mov.w	r2, #256	; 0x100
   86104:	601a      	str	r2, [r3, #0]
   86106:	e021      	b.n	8614c <system_init_flash+0x7c>
	} else if (ul_clk < CHIP_FREQ_FWS_2) {
   86108:	687a      	ldr	r2, [r7, #4]
   8610a:	4b17      	ldr	r3, [pc, #92]	; (86168 <system_init_flash+0x98>)
   8610c:	429a      	cmp	r2, r3
   8610e:	d808      	bhi.n	86122 <system_init_flash+0x52>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(2);
   86110:	4b12      	ldr	r3, [pc, #72]	; (8615c <system_init_flash+0x8c>)
   86112:	f44f 7200 	mov.w	r2, #512	; 0x200
   86116:	601a      	str	r2, [r3, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(2);
   86118:	4b11      	ldr	r3, [pc, #68]	; (86160 <system_init_flash+0x90>)
   8611a:	f44f 7200 	mov.w	r2, #512	; 0x200
   8611e:	601a      	str	r2, [r3, #0]
   86120:	e014      	b.n	8614c <system_init_flash+0x7c>
	} else if (ul_clk < CHIP_FREQ_FWS_3) {
   86122:	687a      	ldr	r2, [r7, #4]
   86124:	4b11      	ldr	r3, [pc, #68]	; (8616c <system_init_flash+0x9c>)
   86126:	429a      	cmp	r2, r3
   86128:	d808      	bhi.n	8613c <system_init_flash+0x6c>
		EFC0->EEFC_FMR = EEFC_FMR_FWS(3);
   8612a:	4b0c      	ldr	r3, [pc, #48]	; (8615c <system_init_flash+0x8c>)
   8612c:	f44f 7240 	mov.w	r2, #768	; 0x300
   86130:	601a      	str	r2, [r3, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(3);
   86132:	4b0b      	ldr	r3, [pc, #44]	; (86160 <system_init_flash+0x90>)
   86134:	f44f 7240 	mov.w	r2, #768	; 0x300
   86138:	601a      	str	r2, [r3, #0]
   8613a:	e007      	b.n	8614c <system_init_flash+0x7c>
	} else {
		EFC0->EEFC_FMR = EEFC_FMR_FWS(4);
   8613c:	4b07      	ldr	r3, [pc, #28]	; (8615c <system_init_flash+0x8c>)
   8613e:	f44f 6280 	mov.w	r2, #1024	; 0x400
   86142:	601a      	str	r2, [r3, #0]
		EFC1->EEFC_FMR = EEFC_FMR_FWS(4);
   86144:	4b06      	ldr	r3, [pc, #24]	; (86160 <system_init_flash+0x90>)
   86146:	f44f 6280 	mov.w	r2, #1024	; 0x400
   8614a:	601a      	str	r2, [r3, #0]
	}
}
   8614c:	370c      	adds	r7, #12
   8614e:	46bd      	mov	sp, r7
   86150:	f85d 7b04 	ldr.w	r7, [sp], #4
   86154:	4770      	bx	lr
   86156:	bf00      	nop
   86158:	0157529f 	.word	0x0157529f
   8615c:	400e0a00 	.word	0x400e0a00
   86160:	400e0c00 	.word	0x400e0c00
   86164:	0206cc7f 	.word	0x0206cc7f
   86168:	0328b73f 	.word	0x0328b73f
   8616c:	04a62f7f 	.word	0x04a62f7f

00086170 <vListInitialise>:
#include <stdlib.h>
#include "FreeRTOS.h"
#include "list.h"

void vListInitialise( List_t * const pxList )
{
   86170:	b480      	push	{r7}
   86172:	b083      	sub	sp, #12
   86174:	af00      	add	r7, sp, #0
   86176:	6078      	str	r0, [r7, #4]
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   86178:	687b      	ldr	r3, [r7, #4]
   8617a:	f103 0208 	add.w	r2, r3, #8
   8617e:	687b      	ldr	r3, [r7, #4]
   86180:	605a      	str	r2, [r3, #4]

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
   86182:	687b      	ldr	r3, [r7, #4]
   86184:	f04f 32ff 	mov.w	r2, #4294967295
   86188:	609a      	str	r2, [r3, #8]

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   8618a:	687b      	ldr	r3, [r7, #4]
   8618c:	f103 0208 	add.w	r2, r3, #8
   86190:	687b      	ldr	r3, [r7, #4]
   86192:	60da      	str	r2, [r3, #12]
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   86194:	687b      	ldr	r3, [r7, #4]
   86196:	f103 0208 	add.w	r2, r3, #8
   8619a:	687b      	ldr	r3, [r7, #4]
   8619c:	611a      	str	r2, [r3, #16]

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
   8619e:	687b      	ldr	r3, [r7, #4]
   861a0:	2200      	movs	r2, #0
   861a2:	601a      	str	r2, [r3, #0]
}
   861a4:	370c      	adds	r7, #12
   861a6:	46bd      	mov	sp, r7
   861a8:	f85d 7b04 	ldr.w	r7, [sp], #4
   861ac:	4770      	bx	lr
   861ae:	bf00      	nop

000861b0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
   861b0:	b480      	push	{r7}
   861b2:	b083      	sub	sp, #12
   861b4:	af00      	add	r7, sp, #0
   861b6:	6078      	str	r0, [r7, #4]
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
   861b8:	687b      	ldr	r3, [r7, #4]
   861ba:	2200      	movs	r2, #0
   861bc:	611a      	str	r2, [r3, #16]
}
   861be:	370c      	adds	r7, #12
   861c0:	46bd      	mov	sp, r7
   861c2:	f85d 7b04 	ldr.w	r7, [sp], #4
   861c6:	4770      	bx	lr

000861c8 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   861c8:	b480      	push	{r7}
   861ca:	b085      	sub	sp, #20
   861cc:	af00      	add	r7, sp, #0
   861ce:	6078      	str	r0, [r7, #4]
   861d0:	6039      	str	r1, [r7, #0]
ListItem_t * const pxIndex = pxList->pxIndex;
   861d2:	687b      	ldr	r3, [r7, #4]
   861d4:	685b      	ldr	r3, [r3, #4]
   861d6:	60fb      	str	r3, [r7, #12]

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
   861d8:	683b      	ldr	r3, [r7, #0]
   861da:	68fa      	ldr	r2, [r7, #12]
   861dc:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
   861de:	68fb      	ldr	r3, [r7, #12]
   861e0:	689a      	ldr	r2, [r3, #8]
   861e2:	683b      	ldr	r3, [r7, #0]
   861e4:	609a      	str	r2, [r3, #8]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
   861e6:	68fb      	ldr	r3, [r7, #12]
   861e8:	689b      	ldr	r3, [r3, #8]
   861ea:	683a      	ldr	r2, [r7, #0]
   861ec:	605a      	str	r2, [r3, #4]
	pxIndex->pxPrevious = pxNewListItem;
   861ee:	68fb      	ldr	r3, [r7, #12]
   861f0:	683a      	ldr	r2, [r7, #0]
   861f2:	609a      	str	r2, [r3, #8]

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   861f4:	683b      	ldr	r3, [r7, #0]
   861f6:	687a      	ldr	r2, [r7, #4]
   861f8:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   861fa:	687b      	ldr	r3, [r7, #4]
   861fc:	681b      	ldr	r3, [r3, #0]
   861fe:	1c5a      	adds	r2, r3, #1
   86200:	687b      	ldr	r3, [r7, #4]
   86202:	601a      	str	r2, [r3, #0]
}
   86204:	3714      	adds	r7, #20
   86206:	46bd      	mov	sp, r7
   86208:	f85d 7b04 	ldr.w	r7, [sp], #4
   8620c:	4770      	bx	lr
   8620e:	bf00      	nop

00086210 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
   86210:	b480      	push	{r7}
   86212:	b085      	sub	sp, #20
   86214:	af00      	add	r7, sp, #0
   86216:	6078      	str	r0, [r7, #4]
   86218:	6039      	str	r1, [r7, #0]
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
   8621a:	683b      	ldr	r3, [r7, #0]
   8621c:	681b      	ldr	r3, [r3, #0]
   8621e:	60bb      	str	r3, [r7, #8]
	are stored in ready lists (all of which have the same xItemValue value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
   86220:	68bb      	ldr	r3, [r7, #8]
   86222:	f1b3 3fff 	cmp.w	r3, #4294967295
   86226:	d103      	bne.n	86230 <vListInsert+0x20>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
   86228:	687b      	ldr	r3, [r7, #4]
   8622a:	691b      	ldr	r3, [r3, #16]
   8622c:	60fb      	str	r3, [r7, #12]
   8622e:	e00c      	b.n	8624a <vListInsert+0x3a>
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips, and ensure
		configASSERT() is defined!  http://www.freertos.org/a00110.html#configASSERT
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
   86230:	687b      	ldr	r3, [r7, #4]
   86232:	3308      	adds	r3, #8
   86234:	60fb      	str	r3, [r7, #12]
   86236:	e002      	b.n	8623e <vListInsert+0x2e>
   86238:	68fb      	ldr	r3, [r7, #12]
   8623a:	685b      	ldr	r3, [r3, #4]
   8623c:	60fb      	str	r3, [r7, #12]
   8623e:	68fb      	ldr	r3, [r7, #12]
   86240:	685b      	ldr	r3, [r3, #4]
   86242:	681a      	ldr	r2, [r3, #0]
   86244:	68bb      	ldr	r3, [r7, #8]
   86246:	429a      	cmp	r2, r3
   86248:	d9f6      	bls.n	86238 <vListInsert+0x28>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
   8624a:	68fb      	ldr	r3, [r7, #12]
   8624c:	685a      	ldr	r2, [r3, #4]
   8624e:	683b      	ldr	r3, [r7, #0]
   86250:	605a      	str	r2, [r3, #4]
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
   86252:	683b      	ldr	r3, [r7, #0]
   86254:	685b      	ldr	r3, [r3, #4]
   86256:	683a      	ldr	r2, [r7, #0]
   86258:	609a      	str	r2, [r3, #8]
	pxNewListItem->pxPrevious = pxIterator;
   8625a:	683b      	ldr	r3, [r7, #0]
   8625c:	68fa      	ldr	r2, [r7, #12]
   8625e:	609a      	str	r2, [r3, #8]
	pxIterator->pxNext = pxNewListItem;
   86260:	68fb      	ldr	r3, [r7, #12]
   86262:	683a      	ldr	r2, [r7, #0]
   86264:	605a      	str	r2, [r3, #4]

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
   86266:	683b      	ldr	r3, [r7, #0]
   86268:	687a      	ldr	r2, [r7, #4]
   8626a:	611a      	str	r2, [r3, #16]

	( pxList->uxNumberOfItems )++;
   8626c:	687b      	ldr	r3, [r7, #4]
   8626e:	681b      	ldr	r3, [r3, #0]
   86270:	1c5a      	adds	r2, r3, #1
   86272:	687b      	ldr	r3, [r7, #4]
   86274:	601a      	str	r2, [r3, #0]
}
   86276:	3714      	adds	r7, #20
   86278:	46bd      	mov	sp, r7
   8627a:	f85d 7b04 	ldr.w	r7, [sp], #4
   8627e:	4770      	bx	lr

00086280 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
   86280:	b480      	push	{r7}
   86282:	b085      	sub	sp, #20
   86284:	af00      	add	r7, sp, #0
   86286:	6078      	str	r0, [r7, #4]
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
   86288:	687b      	ldr	r3, [r7, #4]
   8628a:	691b      	ldr	r3, [r3, #16]
   8628c:	60fb      	str	r3, [r7, #12]

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
   8628e:	687b      	ldr	r3, [r7, #4]
   86290:	685b      	ldr	r3, [r3, #4]
   86292:	687a      	ldr	r2, [r7, #4]
   86294:	6892      	ldr	r2, [r2, #8]
   86296:	609a      	str	r2, [r3, #8]
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
   86298:	687b      	ldr	r3, [r7, #4]
   8629a:	689b      	ldr	r3, [r3, #8]
   8629c:	687a      	ldr	r2, [r7, #4]
   8629e:	6852      	ldr	r2, [r2, #4]
   862a0:	605a      	str	r2, [r3, #4]

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
   862a2:	68fb      	ldr	r3, [r7, #12]
   862a4:	685a      	ldr	r2, [r3, #4]
   862a6:	687b      	ldr	r3, [r7, #4]
   862a8:	429a      	cmp	r2, r3
   862aa:	d103      	bne.n	862b4 <uxListRemove+0x34>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
   862ac:	687b      	ldr	r3, [r7, #4]
   862ae:	689a      	ldr	r2, [r3, #8]
   862b0:	68fb      	ldr	r3, [r7, #12]
   862b2:	605a      	str	r2, [r3, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
   862b4:	687b      	ldr	r3, [r7, #4]
   862b6:	2200      	movs	r2, #0
   862b8:	611a      	str	r2, [r3, #16]
	( pxList->uxNumberOfItems )--;
   862ba:	68fb      	ldr	r3, [r7, #12]
   862bc:	681b      	ldr	r3, [r3, #0]
   862be:	1e5a      	subs	r2, r3, #1
   862c0:	68fb      	ldr	r3, [r7, #12]
   862c2:	601a      	str	r2, [r3, #0]

	return pxList->uxNumberOfItems;
   862c4:	68fb      	ldr	r3, [r7, #12]
   862c6:	681b      	ldr	r3, [r3, #0]
}
   862c8:	4618      	mov	r0, r3
   862ca:	3714      	adds	r7, #20
   862cc:	46bd      	mov	sp, r7
   862ce:	f85d 7b04 	ldr.w	r7, [sp], #4
   862d2:	4770      	bx	lr

000862d4 <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
   862d4:	b480      	push	{r7}
   862d6:	b085      	sub	sp, #20
   862d8:	af00      	add	r7, sp, #0
   862da:	60f8      	str	r0, [r7, #12]
   862dc:	60b9      	str	r1, [r7, #8]
   862de:	607a      	str	r2, [r7, #4]
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
   862e0:	68fb      	ldr	r3, [r7, #12]
   862e2:	3b04      	subs	r3, #4
   862e4:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
   862e6:	68fb      	ldr	r3, [r7, #12]
   862e8:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
   862ec:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   862ee:	68fb      	ldr	r3, [r7, #12]
   862f0:	3b04      	subs	r3, #4
   862f2:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
   862f4:	68ba      	ldr	r2, [r7, #8]
   862f6:	68fb      	ldr	r3, [r7, #12]
   862f8:	601a      	str	r2, [r3, #0]
	pxTopOfStack--;
   862fa:	68fb      	ldr	r3, [r7, #12]
   862fc:	3b04      	subs	r3, #4
   862fe:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) portTASK_RETURN_ADDRESS;	/* LR */
   86300:	4a09      	ldr	r2, [pc, #36]	; (86328 <pxPortInitialiseStack+0x54>)
   86302:	68fb      	ldr	r3, [r7, #12]
   86304:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
   86306:	68fb      	ldr	r3, [r7, #12]
   86308:	3b14      	subs	r3, #20
   8630a:	60fb      	str	r3, [r7, #12]
	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
   8630c:	687a      	ldr	r2, [r7, #4]
   8630e:	68fb      	ldr	r3, [r7, #12]
   86310:	601a      	str	r2, [r3, #0]
	pxTopOfStack -= 8;	/* R11, R10, R9, R8, R7, R6, R5 and R4. */
   86312:	68fb      	ldr	r3, [r7, #12]
   86314:	3b20      	subs	r3, #32
   86316:	60fb      	str	r3, [r7, #12]

	return pxTopOfStack;
   86318:	68fb      	ldr	r3, [r7, #12]
}
   8631a:	4618      	mov	r0, r3
   8631c:	3714      	adds	r7, #20
   8631e:	46bd      	mov	sp, r7
   86320:	f85d 7b04 	ldr.w	r7, [sp], #4
   86324:	4770      	bx	lr
   86326:	bf00      	nop
   86328:	0008632d 	.word	0x0008632d

0008632c <prvTaskExitError>:
/*-----------------------------------------------------------*/

static void prvTaskExitError( void )
{
   8632c:	b580      	push	{r7, lr}
   8632e:	af00      	add	r7, sp, #0
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
   86330:	4b05      	ldr	r3, [pc, #20]	; (86348 <prvTaskExitError+0x1c>)
   86332:	681b      	ldr	r3, [r3, #0]
   86334:	f1b3 3fff 	cmp.w	r3, #4294967295
   86338:	d002      	beq.n	86340 <prvTaskExitError+0x14>
   8633a:	4b04      	ldr	r3, [pc, #16]	; (8634c <prvTaskExitError+0x20>)
   8633c:	4798      	blx	r3
   8633e:	e7fe      	b.n	8633e <prvTaskExitError+0x12>
	portDISABLE_INTERRUPTS();
   86340:	4b02      	ldr	r3, [pc, #8]	; (8634c <prvTaskExitError+0x20>)
   86342:	4798      	blx	r3
	for( ;; );
   86344:	e7fe      	b.n	86344 <prvTaskExitError+0x18>
   86346:	bf00      	nop
   86348:	20070004 	.word	0x20070004
   8634c:	000864f9 	.word	0x000864f9

00086350 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
   86350:	4b07      	ldr	r3, [pc, #28]	; (86370 <pxCurrentTCBConst2>)
   86352:	6819      	ldr	r1, [r3, #0]
   86354:	6808      	ldr	r0, [r1, #0]
   86356:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8635a:	f380 8809 	msr	PSP, r0
   8635e:	f3bf 8f6f 	isb	sy
   86362:	f04f 0000 	mov.w	r0, #0
   86366:	f380 8811 	msr	BASEPRI, r0
   8636a:	f04e 0e0d 	orr.w	lr, lr, #13
   8636e:	4770      	bx	lr

00086370 <pxCurrentTCBConst2>:
   86370:	2007ac70 	.word	0x2007ac70

00086374 <prvPortStartFirstTask>:
}
/*-----------------------------------------------------------*/

static void prvPortStartFirstTask( void )
{
	__asm volatile(
   86374:	4806      	ldr	r0, [pc, #24]	; (86390 <prvPortStartFirstTask+0x1c>)
   86376:	6800      	ldr	r0, [r0, #0]
   86378:	6800      	ldr	r0, [r0, #0]
   8637a:	f380 8808 	msr	MSP, r0
   8637e:	b662      	cpsie	i
   86380:	b661      	cpsie	f
   86382:	f3bf 8f4f 	dsb	sy
   86386:	f3bf 8f6f 	isb	sy
   8638a:	df00      	svc	0
   8638c:	bf00      	nop
   8638e:	0000      	.short	0x0000
   86390:	e000ed08 	.word	0xe000ed08

00086394 <xPortStartScheduler>:

/*
 * See header file for description.
 */
BaseType_t xPortStartScheduler( void )
{
   86394:	b580      	push	{r7, lr}
   86396:	b084      	sub	sp, #16
   86398:	af00      	add	r7, sp, #0
	configASSERT( configMAX_SYSCALL_INTERRUPT_PRIORITY );

	#if( configASSERT_DEFINED == 1 )
	{
		volatile uint32_t ulOriginalPriority;
		volatile uint8_t * const pucFirstUserPriorityRegister = ( volatile uint8_t * const ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER );
   8639a:	4b28      	ldr	r3, [pc, #160]	; (8643c <xPortStartScheduler+0xa8>)
   8639c:	60fb      	str	r3, [r7, #12]
		functions can be called.  ISR safe functions are those that end in
		"FromISR".  FreeRTOS maintains separate thread and ISR API functions to
		ensure interrupt entry is as fast and simple as possible.

		Save the interrupt priority value that is about to be clobbered. */
		ulOriginalPriority = *pucFirstUserPriorityRegister;
   8639e:	68fb      	ldr	r3, [r7, #12]
   863a0:	781b      	ldrb	r3, [r3, #0]
   863a2:	b2db      	uxtb	r3, r3
   863a4:	60bb      	str	r3, [r7, #8]

		/* Determine the number of priority bits available.  First write to all
		possible bits. */
		*pucFirstUserPriorityRegister = portMAX_8_BIT_VALUE;
   863a6:	68fb      	ldr	r3, [r7, #12]
   863a8:	22ff      	movs	r2, #255	; 0xff
   863aa:	701a      	strb	r2, [r3, #0]

		/* Read the value back to see how many bits stuck. */
		ucMaxPriorityValue = *pucFirstUserPriorityRegister;
   863ac:	68fb      	ldr	r3, [r7, #12]
   863ae:	781b      	ldrb	r3, [r3, #0]
   863b0:	b2db      	uxtb	r3, r3
   863b2:	71fb      	strb	r3, [r7, #7]

		/* Use the same mask on the maximum system call priority. */
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;
   863b4:	79fb      	ldrb	r3, [r7, #7]
   863b6:	b2db      	uxtb	r3, r3
   863b8:	f023 035f 	bic.w	r3, r3, #95	; 0x5f
   863bc:	b2da      	uxtb	r2, r3
   863be:	4b20      	ldr	r3, [pc, #128]	; (86440 <xPortStartScheduler+0xac>)
   863c0:	701a      	strb	r2, [r3, #0]

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
   863c2:	4b20      	ldr	r3, [pc, #128]	; (86444 <xPortStartScheduler+0xb0>)
   863c4:	2207      	movs	r2, #7
   863c6:	601a      	str	r2, [r3, #0]
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   863c8:	e009      	b.n	863de <xPortStartScheduler+0x4a>
		{
			ulMaxPRIGROUPValue--;
   863ca:	4b1e      	ldr	r3, [pc, #120]	; (86444 <xPortStartScheduler+0xb0>)
   863cc:	681b      	ldr	r3, [r3, #0]
   863ce:	1e5a      	subs	r2, r3, #1
   863d0:	4b1c      	ldr	r3, [pc, #112]	; (86444 <xPortStartScheduler+0xb0>)
   863d2:	601a      	str	r2, [r3, #0]
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
   863d4:	79fb      	ldrb	r3, [r7, #7]
   863d6:	b2db      	uxtb	r3, r3
   863d8:	005b      	lsls	r3, r3, #1
   863da:	b2db      	uxtb	r3, r3
   863dc:	71fb      	strb	r3, [r7, #7]
		ucMaxSysCallPriority = configMAX_SYSCALL_INTERRUPT_PRIORITY & ucMaxPriorityValue;

		/* Calculate the maximum acceptable priority group value for the number
		of bits read back. */
		ulMaxPRIGROUPValue = portMAX_PRIGROUP_BITS;
		while( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) == portTOP_BIT_OF_BYTE )
   863de:	79fb      	ldrb	r3, [r7, #7]
   863e0:	b2db      	uxtb	r3, r3
   863e2:	b2db      	uxtb	r3, r3
   863e4:	b25b      	sxtb	r3, r3
   863e6:	2b00      	cmp	r3, #0
   863e8:	dbef      	blt.n	863ca <xPortStartScheduler+0x36>
			ucMaxPriorityValue <<= ( uint8_t ) 0x01;
		}

		/* Shift the priority group value back to its position within the AIRCR
		register. */
		ulMaxPRIGROUPValue <<= portPRIGROUP_SHIFT;
   863ea:	4b16      	ldr	r3, [pc, #88]	; (86444 <xPortStartScheduler+0xb0>)
   863ec:	681b      	ldr	r3, [r3, #0]
   863ee:	021a      	lsls	r2, r3, #8
   863f0:	4b14      	ldr	r3, [pc, #80]	; (86444 <xPortStartScheduler+0xb0>)
   863f2:	601a      	str	r2, [r3, #0]
		ulMaxPRIGROUPValue &= portPRIORITY_GROUP_MASK;
   863f4:	4b13      	ldr	r3, [pc, #76]	; (86444 <xPortStartScheduler+0xb0>)
   863f6:	681b      	ldr	r3, [r3, #0]
   863f8:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   863fc:	4b11      	ldr	r3, [pc, #68]	; (86444 <xPortStartScheduler+0xb0>)
   863fe:	601a      	str	r2, [r3, #0]

		/* Restore the clobbered interrupt priority register to its original
		value. */
		*pucFirstUserPriorityRegister = ulOriginalPriority;
   86400:	68bb      	ldr	r3, [r7, #8]
   86402:	b2da      	uxtb	r2, r3
   86404:	68fb      	ldr	r3, [r7, #12]
   86406:	701a      	strb	r2, [r3, #0]
	}
	#endif /* conifgASSERT_DEFINED */

	/* Make PendSV and SysTick the lowest priority interrupts. */
	portNVIC_SYSPRI2_REG |= portNVIC_PENDSV_PRI;
   86408:	4b0f      	ldr	r3, [pc, #60]	; (86448 <xPortStartScheduler+0xb4>)
   8640a:	4a0f      	ldr	r2, [pc, #60]	; (86448 <xPortStartScheduler+0xb4>)
   8640c:	6812      	ldr	r2, [r2, #0]
   8640e:	f442 0270 	orr.w	r2, r2, #15728640	; 0xf00000
   86412:	601a      	str	r2, [r3, #0]
	portNVIC_SYSPRI2_REG |= portNVIC_SYSTICK_PRI;
   86414:	4b0c      	ldr	r3, [pc, #48]	; (86448 <xPortStartScheduler+0xb4>)
   86416:	4a0c      	ldr	r2, [pc, #48]	; (86448 <xPortStartScheduler+0xb4>)
   86418:	6812      	ldr	r2, [r2, #0]
   8641a:	f042 4270 	orr.w	r2, r2, #4026531840	; 0xf0000000
   8641e:	601a      	str	r2, [r3, #0]

	/* Start the timer that generates the tick ISR.  Interrupts are disabled
	here already. */
	vPortSetupTimerInterrupt();
   86420:	4b0a      	ldr	r3, [pc, #40]	; (8644c <xPortStartScheduler+0xb8>)
   86422:	4798      	blx	r3

	/* Initialise the critical nesting count ready for the first task. */
	uxCriticalNesting = 0;
   86424:	4b0a      	ldr	r3, [pc, #40]	; (86450 <xPortStartScheduler+0xbc>)
   86426:	2200      	movs	r2, #0
   86428:	601a      	str	r2, [r3, #0]

	/* Start the first task. */
	prvPortStartFirstTask();
   8642a:	4b0a      	ldr	r3, [pc, #40]	; (86454 <xPortStartScheduler+0xc0>)
   8642c:	4798      	blx	r3

	/* Should never get here as the tasks will now be executing!  Call the task
	exit error function to prevent compiler warnings about a static function
	not being called in the case that the application writer overrides this
	functionality by defining configTASK_RETURN_ADDRESS. */
	prvTaskExitError();
   8642e:	4b0a      	ldr	r3, [pc, #40]	; (86458 <xPortStartScheduler+0xc4>)
   86430:	4798      	blx	r3

	/* Should not get here! */
	return 0;
   86432:	2300      	movs	r3, #0
}
   86434:	4618      	mov	r0, r3
   86436:	3710      	adds	r7, #16
   86438:	46bd      	mov	sp, r7
   8643a:	bd80      	pop	{r7, pc}
   8643c:	e000e400 	.word	0xe000e400
   86440:	20070c50 	.word	0x20070c50
   86444:	20070c54 	.word	0x20070c54
   86448:	e000ed20 	.word	0xe000ed20
   8644c:	0008658d 	.word	0x0008658d
   86450:	20070004 	.word	0x20070004
   86454:	00086375 	.word	0x00086375
   86458:	0008632d 	.word	0x0008632d

0008645c <vPortYield>:
	configASSERT( uxCriticalNesting == 1000UL );
}
/*-----------------------------------------------------------*/

void vPortYield( void )
{
   8645c:	b480      	push	{r7}
   8645e:	af00      	add	r7, sp, #0
	/* Set a PendSV to request a context switch. */
	portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   86460:	4b05      	ldr	r3, [pc, #20]	; (86478 <vPortYield+0x1c>)
   86462:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   86466:	601a      	str	r2, [r3, #0]

	/* Barriers are normally not required but do ensure the code is completely
	within the specified behaviour for the architecture. */
	__asm volatile( "dsb" );
   86468:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   8646c:	f3bf 8f6f 	isb	sy
}
   86470:	46bd      	mov	sp, r7
   86472:	f85d 7b04 	ldr.w	r7, [sp], #4
   86476:	4770      	bx	lr
   86478:	e000ed04 	.word	0xe000ed04

0008647c <vPortEnterCritical>:
/*-----------------------------------------------------------*/

void vPortEnterCritical( void )
{
   8647c:	b580      	push	{r7, lr}
   8647e:	af00      	add	r7, sp, #0
	portDISABLE_INTERRUPTS();
   86480:	4b0c      	ldr	r3, [pc, #48]	; (864b4 <vPortEnterCritical+0x38>)
   86482:	4798      	blx	r3
	uxCriticalNesting++;
   86484:	4b0c      	ldr	r3, [pc, #48]	; (864b8 <vPortEnterCritical+0x3c>)
   86486:	681b      	ldr	r3, [r3, #0]
   86488:	1c5a      	adds	r2, r3, #1
   8648a:	4b0b      	ldr	r3, [pc, #44]	; (864b8 <vPortEnterCritical+0x3c>)
   8648c:	601a      	str	r2, [r3, #0]
	__asm volatile( "dsb" );
   8648e:	f3bf 8f4f 	dsb	sy
	__asm volatile( "isb" );
   86492:	f3bf 8f6f 	isb	sy
	/* This is not the interrupt safe version of the enter critical function so
	assert() if it is being called from an interrupt context.  Only API 
	functions that end in "FromISR" can be used in an interrupt.  Only assert if
	the critical nesting count is 1 to protect against recursive calls if the
	assert function also uses a critical section. */
	if( uxCriticalNesting == 1 )
   86496:	4b08      	ldr	r3, [pc, #32]	; (864b8 <vPortEnterCritical+0x3c>)
   86498:	681b      	ldr	r3, [r3, #0]
   8649a:	2b01      	cmp	r3, #1
   8649c:	d108      	bne.n	864b0 <vPortEnterCritical+0x34>
	{
		configASSERT( ( portNVIC_INT_CTRL_REG & portVECTACTIVE_MASK ) == 0 );
   8649e:	4b07      	ldr	r3, [pc, #28]	; (864bc <vPortEnterCritical+0x40>)
   864a0:	681b      	ldr	r3, [r3, #0]
   864a2:	f003 031f 	and.w	r3, r3, #31
   864a6:	2b00      	cmp	r3, #0
   864a8:	d002      	beq.n	864b0 <vPortEnterCritical+0x34>
   864aa:	4b02      	ldr	r3, [pc, #8]	; (864b4 <vPortEnterCritical+0x38>)
   864ac:	4798      	blx	r3
   864ae:	e7fe      	b.n	864ae <vPortEnterCritical+0x32>
	}
}
   864b0:	bd80      	pop	{r7, pc}
   864b2:	bf00      	nop
   864b4:	000864f9 	.word	0x000864f9
   864b8:	20070004 	.word	0x20070004
   864bc:	e000ed04 	.word	0xe000ed04

000864c0 <vPortExitCritical>:
/*-----------------------------------------------------------*/

void vPortExitCritical( void )
{
   864c0:	b580      	push	{r7, lr}
   864c2:	af00      	add	r7, sp, #0
	configASSERT( uxCriticalNesting );
   864c4:	4b09      	ldr	r3, [pc, #36]	; (864ec <vPortExitCritical+0x2c>)
   864c6:	681b      	ldr	r3, [r3, #0]
   864c8:	2b00      	cmp	r3, #0
   864ca:	d102      	bne.n	864d2 <vPortExitCritical+0x12>
   864cc:	4b08      	ldr	r3, [pc, #32]	; (864f0 <vPortExitCritical+0x30>)
   864ce:	4798      	blx	r3
   864d0:	e7fe      	b.n	864d0 <vPortExitCritical+0x10>
	uxCriticalNesting--;
   864d2:	4b06      	ldr	r3, [pc, #24]	; (864ec <vPortExitCritical+0x2c>)
   864d4:	681b      	ldr	r3, [r3, #0]
   864d6:	1e5a      	subs	r2, r3, #1
   864d8:	4b04      	ldr	r3, [pc, #16]	; (864ec <vPortExitCritical+0x2c>)
   864da:	601a      	str	r2, [r3, #0]
	if( uxCriticalNesting == 0 )
   864dc:	4b03      	ldr	r3, [pc, #12]	; (864ec <vPortExitCritical+0x2c>)
   864de:	681b      	ldr	r3, [r3, #0]
   864e0:	2b00      	cmp	r3, #0
   864e2:	d102      	bne.n	864ea <vPortExitCritical+0x2a>
	{
		portENABLE_INTERRUPTS();
   864e4:	2000      	movs	r0, #0
   864e6:	4b03      	ldr	r3, [pc, #12]	; (864f4 <vPortExitCritical+0x34>)
   864e8:	4798      	blx	r3
	}
}
   864ea:	bd80      	pop	{r7, pc}
   864ec:	20070004 	.word	0x20070004
   864f0:	000864f9 	.word	0x000864f9
   864f4:	0008650d 	.word	0x0008650d

000864f8 <ulPortSetInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) uint32_t ulPortSetInterruptMask( void )
{
	__asm volatile														\
   864f8:	f3ef 8011 	mrs	r0, BASEPRI
   864fc:	f04f 01a0 	mov.w	r1, #160	; 0xa0
   86500:	f381 8811 	msr	BASEPRI, r1
   86504:	4770      	bx	lr
		:: "i" ( configMAX_SYSCALL_INTERRUPT_PRIORITY ) : "r0", "r1"	\
	);

	/* This return will not be reached but is necessary to prevent compiler
	warnings. */
	return 0;
   86506:	2300      	movs	r3, #0
}
   86508:	4618      	mov	r0, r3
   8650a:	bf00      	nop

0008650c <vPortClearInterruptMask>:
/*-----------------------------------------------------------*/

__attribute__(( naked )) void vPortClearInterruptMask( uint32_t ulNewMaskValue )
{
	__asm volatile													\
   8650c:	f380 8811 	msr	BASEPRI, r0
   86510:	4770      	bx	lr
   86512:	bf00      	nop

00086514 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
   86514:	f3ef 8009 	mrs	r0, PSP
   86518:	f3bf 8f6f 	isb	sy
   8651c:	4b0d      	ldr	r3, [pc, #52]	; (86554 <pxCurrentTCBConst>)
   8651e:	681a      	ldr	r2, [r3, #0]
   86520:	e920 0ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   86524:	6010      	str	r0, [r2, #0]
   86526:	e92d 4008 	stmdb	sp!, {r3, lr}
   8652a:	f04f 00a0 	mov.w	r0, #160	; 0xa0
   8652e:	f380 8811 	msr	BASEPRI, r0
   86532:	f001 f9f1 	bl	87918 <vTaskSwitchContext>
   86536:	f04f 0000 	mov.w	r0, #0
   8653a:	f380 8811 	msr	BASEPRI, r0
   8653e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   86542:	6819      	ldr	r1, [r3, #0]
   86544:	6808      	ldr	r0, [r1, #0]
   86546:	e8b0 0ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp}
   8654a:	f380 8809 	msr	PSP, r0
   8654e:	f3bf 8f6f 	isb	sy
   86552:	4770      	bx	lr

00086554 <pxCurrentTCBConst>:
   86554:	2007ac70 	.word	0x2007ac70

00086558 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )				// This is the actual subroutine that handles the Systick interrupt.
{
   86558:	b580      	push	{r7, lr}
   8655a:	af00      	add	r7, sp, #0
	/* The SysTick runs at the lowest interrupt priority, so when this interrupt
	executes all interrupts must be unmasked.  There is therefore no need to
	save and then restore the interrupt mask value as its value is already
	known. */
	( void ) portSET_INTERRUPT_MASK_FROM_ISR();
   8655c:	4b07      	ldr	r3, [pc, #28]	; (8657c <SysTick_Handler+0x24>)
   8655e:	4798      	blx	r3
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )		// xTaskIncrementTick is contained in tasks.c, it increments the tick
   86560:	4b07      	ldr	r3, [pc, #28]	; (86580 <SysTick_Handler+0x28>)
   86562:	4798      	blx	r3
   86564:	4603      	mov	r3, r0
   86566:	2b00      	cmp	r3, #0
   86568:	d003      	beq.n	86572 <SysTick_Handler+0x1a>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
   8656a:	4b06      	ldr	r3, [pc, #24]	; (86584 <SysTick_Handler+0x2c>)
   8656c:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
   86570:	601a      	str	r2, [r3, #0]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( 0 );
   86572:	2000      	movs	r0, #0
   86574:	4b04      	ldr	r3, [pc, #16]	; (86588 <SysTick_Handler+0x30>)
   86576:	4798      	blx	r3
}
   86578:	bd80      	pop	{r7, pc}
   8657a:	bf00      	nop
   8657c:	000864f9 	.word	0x000864f9
   86580:	0008779d 	.word	0x0008779d
   86584:	e000ed04 	.word	0xe000ed04
   86588:	0008650d 	.word	0x0008650d

0008658c <vPortSetupTimerInterrupt>:
/*
 * Setup the systick timer to generate the tick interrupts at the required
 * frequency.
 */
__attribute__(( weak )) void vPortSetupTimerInterrupt( void )
{
   8658c:	b480      	push	{r7}
   8658e:	af00      	add	r7, sp, #0
		ulStoppedTimerCompensation = portMISSED_COUNTS_FACTOR / ( configCPU_CLOCK_HZ / configSYSTICK_CLOCK_HZ );
	}
	#endif /* configUSE_TICKLESS_IDLE */

	/* Configure SysTick to interrupt at the requested rate. */
	portNVIC_SYSTICK_LOAD_REG = ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) - 1UL;
   86590:	4b07      	ldr	r3, [pc, #28]	; (865b0 <vPortSetupTimerInterrupt+0x24>)
   86592:	4a08      	ldr	r2, [pc, #32]	; (865b4 <vPortSetupTimerInterrupt+0x28>)
   86594:	6811      	ldr	r1, [r2, #0]
   86596:	4a08      	ldr	r2, [pc, #32]	; (865b8 <vPortSetupTimerInterrupt+0x2c>)
   86598:	fba2 0201 	umull	r0, r2, r2, r1
   8659c:	0992      	lsrs	r2, r2, #6
   8659e:	3a01      	subs	r2, #1
   865a0:	601a      	str	r2, [r3, #0]
	portNVIC_SYSTICK_CTRL_REG = ( portNVIC_SYSTICK_CLK_BIT | portNVIC_SYSTICK_INT_BIT | portNVIC_SYSTICK_ENABLE_BIT );
   865a2:	4b06      	ldr	r3, [pc, #24]	; (865bc <vPortSetupTimerInterrupt+0x30>)
   865a4:	2207      	movs	r2, #7
   865a6:	601a      	str	r2, [r3, #0]
}
   865a8:	46bd      	mov	sp, r7
   865aa:	f85d 7b04 	ldr.w	r7, [sp], #4
   865ae:	4770      	bx	lr
   865b0:	e000e014 	.word	0xe000e014
   865b4:	20070000 	.word	0x20070000
   865b8:	10624dd3 	.word	0x10624dd3
   865bc:	e000e010 	.word	0xe000e010

000865c0 <vPortValidateInterruptPriority>:
/*-----------------------------------------------------------*/

#if( configASSERT_DEFINED == 1 )

	void vPortValidateInterruptPriority( void )
	{
   865c0:	b580      	push	{r7, lr}
   865c2:	b082      	sub	sp, #8
   865c4:	af00      	add	r7, sp, #0
	uint32_t ulCurrentInterrupt;
	uint8_t ucCurrentPriority;

		/* Obtain the number of the currently executing interrupt. */
		__asm volatile( "mrs %0, ipsr" : "=r"( ulCurrentInterrupt ) );
   865c6:	f3ef 8305 	mrs	r3, IPSR
   865ca:	607b      	str	r3, [r7, #4]

		/* Is the interrupt number a user defined interrupt? */
		if( ulCurrentInterrupt >= portFIRST_USER_INTERRUPT_NUMBER )
   865cc:	687b      	ldr	r3, [r7, #4]
   865ce:	2b0f      	cmp	r3, #15
   865d0:	d90c      	bls.n	865ec <vPortValidateInterruptPriority+0x2c>
		{
			/* Look up the interrupt's priority. */
			ucCurrentPriority = pcInterruptPriorityRegisters[ ulCurrentInterrupt ];
   865d2:	4a0d      	ldr	r2, [pc, #52]	; (86608 <vPortValidateInterruptPriority+0x48>)
   865d4:	687b      	ldr	r3, [r7, #4]
   865d6:	4413      	add	r3, r2
   865d8:	781b      	ldrb	r3, [r3, #0]
   865da:	70fb      	strb	r3, [r7, #3]
			interrupt entry is as fast and simple as possible.

			The following links provide detailed information:
			http://www.freertos.org/RTOS-Cortex-M3-M4.html
			http://www.freertos.org/FAQHelp.html */
			configASSERT( ucCurrentPriority >= ucMaxSysCallPriority );
   865dc:	4b0b      	ldr	r3, [pc, #44]	; (8660c <vPortValidateInterruptPriority+0x4c>)
   865de:	781b      	ldrb	r3, [r3, #0]
   865e0:	78fa      	ldrb	r2, [r7, #3]
   865e2:	429a      	cmp	r2, r3
   865e4:	d202      	bcs.n	865ec <vPortValidateInterruptPriority+0x2c>
   865e6:	4b0a      	ldr	r3, [pc, #40]	; (86610 <vPortValidateInterruptPriority+0x50>)
   865e8:	4798      	blx	r3
   865ea:	e7fe      	b.n	865ea <vPortValidateInterruptPriority+0x2a>
		configuration then the correct setting can be achieved on all Cortex-M
		devices by calling NVIC_SetPriorityGrouping( 0 ); before starting the
		scheduler.  Note however that some vendor specific peripheral libraries
		assume a non-zero priority group setting, in which cases using a value
		of zero will result in unpredicable behaviour. */
		configASSERT( ( portAIRCR_REG & portPRIORITY_GROUP_MASK ) <= ulMaxPRIGROUPValue );
   865ec:	4b09      	ldr	r3, [pc, #36]	; (86614 <vPortValidateInterruptPriority+0x54>)
   865ee:	681b      	ldr	r3, [r3, #0]
   865f0:	f403 62e0 	and.w	r2, r3, #1792	; 0x700
   865f4:	4b08      	ldr	r3, [pc, #32]	; (86618 <vPortValidateInterruptPriority+0x58>)
   865f6:	681b      	ldr	r3, [r3, #0]
   865f8:	429a      	cmp	r2, r3
   865fa:	d902      	bls.n	86602 <vPortValidateInterruptPriority+0x42>
   865fc:	4b04      	ldr	r3, [pc, #16]	; (86610 <vPortValidateInterruptPriority+0x50>)
   865fe:	4798      	blx	r3
   86600:	e7fe      	b.n	86600 <vPortValidateInterruptPriority+0x40>
	}
   86602:	3708      	adds	r7, #8
   86604:	46bd      	mov	sp, r7
   86606:	bd80      	pop	{r7, pc}
   86608:	e000e3f0 	.word	0xe000e3f0
   8660c:	20070c50 	.word	0x20070c50
   86610:	000864f9 	.word	0x000864f9
   86614:	e000ed0c 	.word	0xe000ed0c
   86618:	20070c54 	.word	0x20070c54

0008661c <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
   8661c:	b580      	push	{r7, lr}
   8661e:	b086      	sub	sp, #24
   86620:	af00      	add	r7, sp, #0
   86622:	6078      	str	r0, [r7, #4]
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
   86624:	2300      	movs	r3, #0
   86626:	60fb      	str	r3, [r7, #12]

	vTaskSuspendAll();
   86628:	4b4f      	ldr	r3, [pc, #316]	; (86768 <pvPortMalloc+0x14c>)
   8662a:	4798      	blx	r3
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
   8662c:	4b4f      	ldr	r3, [pc, #316]	; (8676c <pvPortMalloc+0x150>)
   8662e:	681b      	ldr	r3, [r3, #0]
   86630:	2b00      	cmp	r3, #0
   86632:	d101      	bne.n	86638 <pvPortMalloc+0x1c>
		{
			prvHeapInit();
   86634:	4b4e      	ldr	r3, [pc, #312]	; (86770 <pvPortMalloc+0x154>)
   86636:	4798      	blx	r3

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
   86638:	4b4e      	ldr	r3, [pc, #312]	; (86774 <pvPortMalloc+0x158>)
   8663a:	681a      	ldr	r2, [r3, #0]
   8663c:	687b      	ldr	r3, [r7, #4]
   8663e:	4013      	ands	r3, r2
   86640:	2b00      	cmp	r3, #0
   86642:	d17d      	bne.n	86740 <pvPortMalloc+0x124>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
   86644:	687b      	ldr	r3, [r7, #4]
   86646:	2b00      	cmp	r3, #0
   86648:	d015      	beq.n	86676 <pvPortMalloc+0x5a>
			{
				xWantedSize += xHeapStructSize;
   8664a:	2308      	movs	r3, #8
   8664c:	687a      	ldr	r2, [r7, #4]
   8664e:	4413      	add	r3, r2
   86650:	607b      	str	r3, [r7, #4]

				/* Ensure that blocks are always aligned to the required number
				of bytes. */
				if( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) != 0x00 )
   86652:	687b      	ldr	r3, [r7, #4]
   86654:	f003 0307 	and.w	r3, r3, #7
   86658:	2b00      	cmp	r3, #0
   8665a:	d00c      	beq.n	86676 <pvPortMalloc+0x5a>
				{
					/* Byte alignment required. */
					xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
   8665c:	687b      	ldr	r3, [r7, #4]
   8665e:	f023 0307 	bic.w	r3, r3, #7
   86662:	3308      	adds	r3, #8
   86664:	607b      	str	r3, [r7, #4]
					configASSERT( ( xWantedSize & portBYTE_ALIGNMENT_MASK ) == 0 );
   86666:	687b      	ldr	r3, [r7, #4]
   86668:	f003 0307 	and.w	r3, r3, #7
   8666c:	2b00      	cmp	r3, #0
   8666e:	d002      	beq.n	86676 <pvPortMalloc+0x5a>
   86670:	4b41      	ldr	r3, [pc, #260]	; (86778 <pvPortMalloc+0x15c>)
   86672:	4798      	blx	r3
   86674:	e7fe      	b.n	86674 <pvPortMalloc+0x58>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
   86676:	687b      	ldr	r3, [r7, #4]
   86678:	2b00      	cmp	r3, #0
   8667a:	d061      	beq.n	86740 <pvPortMalloc+0x124>
   8667c:	4b3f      	ldr	r3, [pc, #252]	; (8677c <pvPortMalloc+0x160>)
   8667e:	681b      	ldr	r3, [r3, #0]
   86680:	687a      	ldr	r2, [r7, #4]
   86682:	429a      	cmp	r2, r3
   86684:	d85c      	bhi.n	86740 <pvPortMalloc+0x124>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
   86686:	4b3e      	ldr	r3, [pc, #248]	; (86780 <pvPortMalloc+0x164>)
   86688:	613b      	str	r3, [r7, #16]
				pxBlock = xStart.pxNextFreeBlock;
   8668a:	4b3d      	ldr	r3, [pc, #244]	; (86780 <pvPortMalloc+0x164>)
   8668c:	681b      	ldr	r3, [r3, #0]
   8668e:	617b      	str	r3, [r7, #20]
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   86690:	e004      	b.n	8669c <pvPortMalloc+0x80>
				{
					pxPreviousBlock = pxBlock;
   86692:	697b      	ldr	r3, [r7, #20]
   86694:	613b      	str	r3, [r7, #16]
					pxBlock = pxBlock->pxNextFreeBlock;
   86696:	697b      	ldr	r3, [r7, #20]
   86698:	681b      	ldr	r3, [r3, #0]
   8669a:	617b      	str	r3, [r7, #20]
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
   8669c:	697b      	ldr	r3, [r7, #20]
   8669e:	685a      	ldr	r2, [r3, #4]
   866a0:	687b      	ldr	r3, [r7, #4]
   866a2:	429a      	cmp	r2, r3
   866a4:	d203      	bcs.n	866ae <pvPortMalloc+0x92>
   866a6:	697b      	ldr	r3, [r7, #20]
   866a8:	681b      	ldr	r3, [r3, #0]
   866aa:	2b00      	cmp	r3, #0
   866ac:	d1f1      	bne.n	86692 <pvPortMalloc+0x76>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
   866ae:	4b2f      	ldr	r3, [pc, #188]	; (8676c <pvPortMalloc+0x150>)
   866b0:	681b      	ldr	r3, [r3, #0]
   866b2:	697a      	ldr	r2, [r7, #20]
   866b4:	429a      	cmp	r2, r3
   866b6:	d043      	beq.n	86740 <pvPortMalloc+0x124>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
   866b8:	693b      	ldr	r3, [r7, #16]
   866ba:	681a      	ldr	r2, [r3, #0]
   866bc:	2308      	movs	r3, #8
   866be:	4413      	add	r3, r2
   866c0:	60fb      	str	r3, [r7, #12]

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
   866c2:	697b      	ldr	r3, [r7, #20]
   866c4:	681a      	ldr	r2, [r3, #0]
   866c6:	693b      	ldr	r3, [r7, #16]
   866c8:	601a      	str	r2, [r3, #0]

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
   866ca:	697b      	ldr	r3, [r7, #20]
   866cc:	685a      	ldr	r2, [r3, #4]
   866ce:	687b      	ldr	r3, [r7, #4]
   866d0:	1ad2      	subs	r2, r2, r3
   866d2:	2308      	movs	r3, #8
   866d4:	005b      	lsls	r3, r3, #1
   866d6:	429a      	cmp	r2, r3
   866d8:	d917      	bls.n	8670a <pvPortMalloc+0xee>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
   866da:	697a      	ldr	r2, [r7, #20]
   866dc:	687b      	ldr	r3, [r7, #4]
   866de:	4413      	add	r3, r2
   866e0:	60bb      	str	r3, [r7, #8]
						configASSERT( ( ( ( uint32_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );
   866e2:	68bb      	ldr	r3, [r7, #8]
   866e4:	f003 0307 	and.w	r3, r3, #7
   866e8:	2b00      	cmp	r3, #0
   866ea:	d002      	beq.n	866f2 <pvPortMalloc+0xd6>
   866ec:	4b22      	ldr	r3, [pc, #136]	; (86778 <pvPortMalloc+0x15c>)
   866ee:	4798      	blx	r3
   866f0:	e7fe      	b.n	866f0 <pvPortMalloc+0xd4>

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
   866f2:	697b      	ldr	r3, [r7, #20]
   866f4:	685a      	ldr	r2, [r3, #4]
   866f6:	687b      	ldr	r3, [r7, #4]
   866f8:	1ad2      	subs	r2, r2, r3
   866fa:	68bb      	ldr	r3, [r7, #8]
   866fc:	605a      	str	r2, [r3, #4]
						pxBlock->xBlockSize = xWantedSize;
   866fe:	697b      	ldr	r3, [r7, #20]
   86700:	687a      	ldr	r2, [r7, #4]
   86702:	605a      	str	r2, [r3, #4]

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( ( pxNewBlockLink ) );
   86704:	68b8      	ldr	r0, [r7, #8]
   86706:	4b1f      	ldr	r3, [pc, #124]	; (86784 <pvPortMalloc+0x168>)
   86708:	4798      	blx	r3
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
   8670a:	4b1c      	ldr	r3, [pc, #112]	; (8677c <pvPortMalloc+0x160>)
   8670c:	681a      	ldr	r2, [r3, #0]
   8670e:	697b      	ldr	r3, [r7, #20]
   86710:	685b      	ldr	r3, [r3, #4]
   86712:	1ad2      	subs	r2, r2, r3
   86714:	4b19      	ldr	r3, [pc, #100]	; (8677c <pvPortMalloc+0x160>)
   86716:	601a      	str	r2, [r3, #0]

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
   86718:	4b18      	ldr	r3, [pc, #96]	; (8677c <pvPortMalloc+0x160>)
   8671a:	681a      	ldr	r2, [r3, #0]
   8671c:	4b1a      	ldr	r3, [pc, #104]	; (86788 <pvPortMalloc+0x16c>)
   8671e:	681b      	ldr	r3, [r3, #0]
   86720:	429a      	cmp	r2, r3
   86722:	d203      	bcs.n	8672c <pvPortMalloc+0x110>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
   86724:	4b15      	ldr	r3, [pc, #84]	; (8677c <pvPortMalloc+0x160>)
   86726:	681a      	ldr	r2, [r3, #0]
   86728:	4b17      	ldr	r3, [pc, #92]	; (86788 <pvPortMalloc+0x16c>)
   8672a:	601a      	str	r2, [r3, #0]
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
   8672c:	697b      	ldr	r3, [r7, #20]
   8672e:	685a      	ldr	r2, [r3, #4]
   86730:	4b10      	ldr	r3, [pc, #64]	; (86774 <pvPortMalloc+0x158>)
   86732:	681b      	ldr	r3, [r3, #0]
   86734:	431a      	orrs	r2, r3
   86736:	697b      	ldr	r3, [r7, #20]
   86738:	605a      	str	r2, [r3, #4]
					pxBlock->pxNextFreeBlock = NULL;
   8673a:	697b      	ldr	r3, [r7, #20]
   8673c:	2200      	movs	r2, #0
   8673e:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
   86740:	4b12      	ldr	r3, [pc, #72]	; (8678c <pvPortMalloc+0x170>)
   86742:	4798      	blx	r3

	#if( configUSE_MALLOC_FAILED_HOOK == 1 )
	{
		if( pvReturn == NULL )
   86744:	68fb      	ldr	r3, [r7, #12]
   86746:	2b00      	cmp	r3, #0
   86748:	d101      	bne.n	8674e <pvPortMalloc+0x132>
		{
			extern void vApplicationMallocFailedHook( void );
			vApplicationMallocFailedHook();
   8674a:	4b11      	ldr	r3, [pc, #68]	; (86790 <pvPortMalloc+0x174>)
   8674c:	4798      	blx	r3
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
   8674e:	68fb      	ldr	r3, [r7, #12]
   86750:	f003 0307 	and.w	r3, r3, #7
   86754:	2b00      	cmp	r3, #0
   86756:	d002      	beq.n	8675e <pvPortMalloc+0x142>
   86758:	4b07      	ldr	r3, [pc, #28]	; (86778 <pvPortMalloc+0x15c>)
   8675a:	4798      	blx	r3
   8675c:	e7fe      	b.n	8675c <pvPortMalloc+0x140>
	return pvReturn;
   8675e:	68fb      	ldr	r3, [r7, #12]
}
   86760:	4618      	mov	r0, r3
   86762:	3718      	adds	r7, #24
   86764:	46bd      	mov	sp, r7
   86766:	bd80      	pop	{r7, pc}
   86768:	00087631 	.word	0x00087631
   8676c:	2007ac60 	.word	0x2007ac60
   86770:	00086839 	.word	0x00086839
   86774:	2007ac6c 	.word	0x2007ac6c
   86778:	000864f9 	.word	0x000864f9
   8677c:	2007ac64 	.word	0x2007ac64
   86780:	2007ac58 	.word	0x2007ac58
   86784:	000868fd 	.word	0x000868fd
   86788:	2007ac68 	.word	0x2007ac68
   8678c:	0008764d 	.word	0x0008764d
   86790:	0008a6f1 	.word	0x0008a6f1

00086794 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
   86794:	b580      	push	{r7, lr}
   86796:	b084      	sub	sp, #16
   86798:	af00      	add	r7, sp, #0
   8679a:	6078      	str	r0, [r7, #4]
uint8_t *puc = ( uint8_t * ) pv;
   8679c:	687b      	ldr	r3, [r7, #4]
   8679e:	60fb      	str	r3, [r7, #12]
BlockLink_t *pxLink;

	if( pv != NULL )
   867a0:	687b      	ldr	r3, [r7, #4]
   867a2:	2b00      	cmp	r3, #0
   867a4:	d038      	beq.n	86818 <vPortFree+0x84>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
   867a6:	2308      	movs	r3, #8
   867a8:	425b      	negs	r3, r3
   867aa:	68fa      	ldr	r2, [r7, #12]
   867ac:	4413      	add	r3, r2
   867ae:	60fb      	str	r3, [r7, #12]

		/* This casting is to keep the compiler from issuing warnings. */
		pxLink = ( void * ) puc;
   867b0:	68fb      	ldr	r3, [r7, #12]
   867b2:	60bb      	str	r3, [r7, #8]

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
   867b4:	68bb      	ldr	r3, [r7, #8]
   867b6:	685a      	ldr	r2, [r3, #4]
   867b8:	4b19      	ldr	r3, [pc, #100]	; (86820 <vPortFree+0x8c>)
   867ba:	681b      	ldr	r3, [r3, #0]
   867bc:	4013      	ands	r3, r2
   867be:	2b00      	cmp	r3, #0
   867c0:	d102      	bne.n	867c8 <vPortFree+0x34>
   867c2:	4b18      	ldr	r3, [pc, #96]	; (86824 <vPortFree+0x90>)
   867c4:	4798      	blx	r3
   867c6:	e7fe      	b.n	867c6 <vPortFree+0x32>
		configASSERT( pxLink->pxNextFreeBlock == NULL );
   867c8:	68bb      	ldr	r3, [r7, #8]
   867ca:	681b      	ldr	r3, [r3, #0]
   867cc:	2b00      	cmp	r3, #0
   867ce:	d002      	beq.n	867d6 <vPortFree+0x42>
   867d0:	4b14      	ldr	r3, [pc, #80]	; (86824 <vPortFree+0x90>)
   867d2:	4798      	blx	r3
   867d4:	e7fe      	b.n	867d4 <vPortFree+0x40>

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
   867d6:	68bb      	ldr	r3, [r7, #8]
   867d8:	685a      	ldr	r2, [r3, #4]
   867da:	4b11      	ldr	r3, [pc, #68]	; (86820 <vPortFree+0x8c>)
   867dc:	681b      	ldr	r3, [r3, #0]
   867de:	4013      	ands	r3, r2
   867e0:	2b00      	cmp	r3, #0
   867e2:	d019      	beq.n	86818 <vPortFree+0x84>
		{
			if( pxLink->pxNextFreeBlock == NULL )
   867e4:	68bb      	ldr	r3, [r7, #8]
   867e6:	681b      	ldr	r3, [r3, #0]
   867e8:	2b00      	cmp	r3, #0
   867ea:	d115      	bne.n	86818 <vPortFree+0x84>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
   867ec:	68bb      	ldr	r3, [r7, #8]
   867ee:	685a      	ldr	r2, [r3, #4]
   867f0:	4b0b      	ldr	r3, [pc, #44]	; (86820 <vPortFree+0x8c>)
   867f2:	681b      	ldr	r3, [r3, #0]
   867f4:	43db      	mvns	r3, r3
   867f6:	401a      	ands	r2, r3
   867f8:	68bb      	ldr	r3, [r7, #8]
   867fa:	605a      	str	r2, [r3, #4]

				vTaskSuspendAll();
   867fc:	4b0a      	ldr	r3, [pc, #40]	; (86828 <vPortFree+0x94>)
   867fe:	4798      	blx	r3
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
   86800:	68bb      	ldr	r3, [r7, #8]
   86802:	685a      	ldr	r2, [r3, #4]
   86804:	4b09      	ldr	r3, [pc, #36]	; (8682c <vPortFree+0x98>)
   86806:	681b      	ldr	r3, [r3, #0]
   86808:	441a      	add	r2, r3
   8680a:	4b08      	ldr	r3, [pc, #32]	; (8682c <vPortFree+0x98>)
   8680c:	601a      	str	r2, [r3, #0]
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
   8680e:	68b8      	ldr	r0, [r7, #8]
   86810:	4b07      	ldr	r3, [pc, #28]	; (86830 <vPortFree+0x9c>)
   86812:	4798      	blx	r3
				}
				( void ) xTaskResumeAll();
   86814:	4b07      	ldr	r3, [pc, #28]	; (86834 <vPortFree+0xa0>)
   86816:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
   86818:	3710      	adds	r7, #16
   8681a:	46bd      	mov	sp, r7
   8681c:	bd80      	pop	{r7, pc}
   8681e:	bf00      	nop
   86820:	2007ac6c 	.word	0x2007ac6c
   86824:	000864f9 	.word	0x000864f9
   86828:	00087631 	.word	0x00087631
   8682c:	2007ac64 	.word	0x2007ac64
   86830:	000868fd 	.word	0x000868fd
   86834:	0008764d 	.word	0x0008764d

00086838 <prvHeapInit>:
	/* This just exists to keep the linker quiet. */
}
/*-----------------------------------------------------------*/

static void prvHeapInit( void )
{
   86838:	b480      	push	{r7}
   8683a:	b085      	sub	sp, #20
   8683c:	af00      	add	r7, sp, #0
BlockLink_t *pxFirstFreeBlock;
uint8_t *pucAlignedHeap;
uint32_t ulAddress;
size_t xTotalHeapSize = configTOTAL_HEAP_SIZE;
   8683e:	f44f 4320 	mov.w	r3, #40960	; 0xa000
   86842:	60bb      	str	r3, [r7, #8]

	/* Ensure the heap starts on a correctly aligned boundary. */
	ulAddress = ( uint32_t ) ucHeap;
   86844:	4b27      	ldr	r3, [pc, #156]	; (868e4 <prvHeapInit+0xac>)
   86846:	60fb      	str	r3, [r7, #12]

	if( ( ulAddress & portBYTE_ALIGNMENT_MASK ) != 0 )
   86848:	68fb      	ldr	r3, [r7, #12]
   8684a:	f003 0307 	and.w	r3, r3, #7
   8684e:	2b00      	cmp	r3, #0
   86850:	d00c      	beq.n	8686c <prvHeapInit+0x34>
	{
		ulAddress += ( portBYTE_ALIGNMENT - 1 );
   86852:	68fb      	ldr	r3, [r7, #12]
   86854:	3307      	adds	r3, #7
   86856:	60fb      	str	r3, [r7, #12]
		ulAddress &= ~portBYTE_ALIGNMENT_MASK;
   86858:	68fb      	ldr	r3, [r7, #12]
   8685a:	f023 0307 	bic.w	r3, r3, #7
   8685e:	60fb      	str	r3, [r7, #12]
		xTotalHeapSize -= ulAddress - ( uint32_t ) ucHeap;
   86860:	68ba      	ldr	r2, [r7, #8]
   86862:	68fb      	ldr	r3, [r7, #12]
   86864:	1ad2      	subs	r2, r2, r3
   86866:	4b1f      	ldr	r3, [pc, #124]	; (868e4 <prvHeapInit+0xac>)
   86868:	4413      	add	r3, r2
   8686a:	60bb      	str	r3, [r7, #8]
	}

	pucAlignedHeap = ( uint8_t * ) ulAddress;
   8686c:	68fb      	ldr	r3, [r7, #12]
   8686e:	607b      	str	r3, [r7, #4]

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
   86870:	4b1d      	ldr	r3, [pc, #116]	; (868e8 <prvHeapInit+0xb0>)
   86872:	687a      	ldr	r2, [r7, #4]
   86874:	601a      	str	r2, [r3, #0]
	xStart.xBlockSize = ( size_t ) 0;
   86876:	4b1c      	ldr	r3, [pc, #112]	; (868e8 <prvHeapInit+0xb0>)
   86878:	2200      	movs	r2, #0
   8687a:	605a      	str	r2, [r3, #4]

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	ulAddress = ( ( uint32_t ) pucAlignedHeap ) + xTotalHeapSize;
   8687c:	687a      	ldr	r2, [r7, #4]
   8687e:	68bb      	ldr	r3, [r7, #8]
   86880:	4413      	add	r3, r2
   86882:	60fb      	str	r3, [r7, #12]
	ulAddress -= xHeapStructSize;
   86884:	2308      	movs	r3, #8
   86886:	68fa      	ldr	r2, [r7, #12]
   86888:	1ad3      	subs	r3, r2, r3
   8688a:	60fb      	str	r3, [r7, #12]
	ulAddress &= ~portBYTE_ALIGNMENT_MASK;
   8688c:	68fb      	ldr	r3, [r7, #12]
   8688e:	f023 0307 	bic.w	r3, r3, #7
   86892:	60fb      	str	r3, [r7, #12]
	pxEnd = ( void * ) ulAddress;
   86894:	68fa      	ldr	r2, [r7, #12]
   86896:	4b15      	ldr	r3, [pc, #84]	; (868ec <prvHeapInit+0xb4>)
   86898:	601a      	str	r2, [r3, #0]
	pxEnd->xBlockSize = 0;
   8689a:	4b14      	ldr	r3, [pc, #80]	; (868ec <prvHeapInit+0xb4>)
   8689c:	681b      	ldr	r3, [r3, #0]
   8689e:	2200      	movs	r2, #0
   868a0:	605a      	str	r2, [r3, #4]
	pxEnd->pxNextFreeBlock = NULL;
   868a2:	4b12      	ldr	r3, [pc, #72]	; (868ec <prvHeapInit+0xb4>)
   868a4:	681b      	ldr	r3, [r3, #0]
   868a6:	2200      	movs	r2, #0
   868a8:	601a      	str	r2, [r3, #0]

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
   868aa:	687b      	ldr	r3, [r7, #4]
   868ac:	603b      	str	r3, [r7, #0]
	pxFirstFreeBlock->xBlockSize = ulAddress - ( uint32_t ) pxFirstFreeBlock;
   868ae:	683b      	ldr	r3, [r7, #0]
   868b0:	68fa      	ldr	r2, [r7, #12]
   868b2:	1ad2      	subs	r2, r2, r3
   868b4:	683b      	ldr	r3, [r7, #0]
   868b6:	605a      	str	r2, [r3, #4]
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
   868b8:	4b0c      	ldr	r3, [pc, #48]	; (868ec <prvHeapInit+0xb4>)
   868ba:	681a      	ldr	r2, [r3, #0]
   868bc:	683b      	ldr	r3, [r7, #0]
   868be:	601a      	str	r2, [r3, #0]

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   868c0:	683b      	ldr	r3, [r7, #0]
   868c2:	685a      	ldr	r2, [r3, #4]
   868c4:	4b0a      	ldr	r3, [pc, #40]	; (868f0 <prvHeapInit+0xb8>)
   868c6:	601a      	str	r2, [r3, #0]
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
   868c8:	683b      	ldr	r3, [r7, #0]
   868ca:	685a      	ldr	r2, [r3, #4]
   868cc:	4b09      	ldr	r3, [pc, #36]	; (868f4 <prvHeapInit+0xbc>)
   868ce:	601a      	str	r2, [r3, #0]

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
   868d0:	4b09      	ldr	r3, [pc, #36]	; (868f8 <prvHeapInit+0xc0>)
   868d2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
   868d6:	601a      	str	r2, [r3, #0]
}
   868d8:	3714      	adds	r7, #20
   868da:	46bd      	mov	sp, r7
   868dc:	f85d 7b04 	ldr.w	r7, [sp], #4
   868e0:	4770      	bx	lr
   868e2:	bf00      	nop
   868e4:	20070c58 	.word	0x20070c58
   868e8:	2007ac58 	.word	0x2007ac58
   868ec:	2007ac60 	.word	0x2007ac60
   868f0:	2007ac68 	.word	0x2007ac68
   868f4:	2007ac64 	.word	0x2007ac64
   868f8:	2007ac6c 	.word	0x2007ac6c

000868fc <prvInsertBlockIntoFreeList>:
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
   868fc:	b480      	push	{r7}
   868fe:	b085      	sub	sp, #20
   86900:	af00      	add	r7, sp, #0
   86902:	6078      	str	r0, [r7, #4]
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
   86904:	4b27      	ldr	r3, [pc, #156]	; (869a4 <prvInsertBlockIntoFreeList+0xa8>)
   86906:	60fb      	str	r3, [r7, #12]
   86908:	e002      	b.n	86910 <prvInsertBlockIntoFreeList+0x14>
   8690a:	68fb      	ldr	r3, [r7, #12]
   8690c:	681b      	ldr	r3, [r3, #0]
   8690e:	60fb      	str	r3, [r7, #12]
   86910:	68fb      	ldr	r3, [r7, #12]
   86912:	681a      	ldr	r2, [r3, #0]
   86914:	687b      	ldr	r3, [r7, #4]
   86916:	429a      	cmp	r2, r3
   86918:	d3f7      	bcc.n	8690a <prvInsertBlockIntoFreeList+0xe>
		/* Nothing to do here, just iterate to the right position. */
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
   8691a:	68fb      	ldr	r3, [r7, #12]
   8691c:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
   8691e:	68fb      	ldr	r3, [r7, #12]
   86920:	685b      	ldr	r3, [r3, #4]
   86922:	68ba      	ldr	r2, [r7, #8]
   86924:	441a      	add	r2, r3
   86926:	687b      	ldr	r3, [r7, #4]
   86928:	429a      	cmp	r2, r3
   8692a:	d108      	bne.n	8693e <prvInsertBlockIntoFreeList+0x42>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
   8692c:	68fb      	ldr	r3, [r7, #12]
   8692e:	685a      	ldr	r2, [r3, #4]
   86930:	687b      	ldr	r3, [r7, #4]
   86932:	685b      	ldr	r3, [r3, #4]
   86934:	441a      	add	r2, r3
   86936:	68fb      	ldr	r3, [r7, #12]
   86938:	605a      	str	r2, [r3, #4]
		pxBlockToInsert = pxIterator;
   8693a:	68fb      	ldr	r3, [r7, #12]
   8693c:	607b      	str	r3, [r7, #4]
		mtCOVERAGE_TEST_MARKER();
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
   8693e:	687b      	ldr	r3, [r7, #4]
   86940:	60bb      	str	r3, [r7, #8]
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
   86942:	687b      	ldr	r3, [r7, #4]
   86944:	685b      	ldr	r3, [r3, #4]
   86946:	68ba      	ldr	r2, [r7, #8]
   86948:	441a      	add	r2, r3
   8694a:	68fb      	ldr	r3, [r7, #12]
   8694c:	681b      	ldr	r3, [r3, #0]
   8694e:	429a      	cmp	r2, r3
   86950:	d118      	bne.n	86984 <prvInsertBlockIntoFreeList+0x88>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
   86952:	68fb      	ldr	r3, [r7, #12]
   86954:	681a      	ldr	r2, [r3, #0]
   86956:	4b14      	ldr	r3, [pc, #80]	; (869a8 <prvInsertBlockIntoFreeList+0xac>)
   86958:	681b      	ldr	r3, [r3, #0]
   8695a:	429a      	cmp	r2, r3
   8695c:	d00d      	beq.n	8697a <prvInsertBlockIntoFreeList+0x7e>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
   8695e:	687b      	ldr	r3, [r7, #4]
   86960:	685a      	ldr	r2, [r3, #4]
   86962:	68fb      	ldr	r3, [r7, #12]
   86964:	681b      	ldr	r3, [r3, #0]
   86966:	685b      	ldr	r3, [r3, #4]
   86968:	441a      	add	r2, r3
   8696a:	687b      	ldr	r3, [r7, #4]
   8696c:	605a      	str	r2, [r3, #4]
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
   8696e:	68fb      	ldr	r3, [r7, #12]
   86970:	681b      	ldr	r3, [r3, #0]
   86972:	681a      	ldr	r2, [r3, #0]
   86974:	687b      	ldr	r3, [r7, #4]
   86976:	601a      	str	r2, [r3, #0]
   86978:	e008      	b.n	8698c <prvInsertBlockIntoFreeList+0x90>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
   8697a:	4b0b      	ldr	r3, [pc, #44]	; (869a8 <prvInsertBlockIntoFreeList+0xac>)
   8697c:	681a      	ldr	r2, [r3, #0]
   8697e:	687b      	ldr	r3, [r7, #4]
   86980:	601a      	str	r2, [r3, #0]
   86982:	e003      	b.n	8698c <prvInsertBlockIntoFreeList+0x90>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
   86984:	68fb      	ldr	r3, [r7, #12]
   86986:	681a      	ldr	r2, [r3, #0]
   86988:	687b      	ldr	r3, [r7, #4]
   8698a:	601a      	str	r2, [r3, #0]

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
   8698c:	68fa      	ldr	r2, [r7, #12]
   8698e:	687b      	ldr	r3, [r7, #4]
   86990:	429a      	cmp	r2, r3
   86992:	d002      	beq.n	8699a <prvInsertBlockIntoFreeList+0x9e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
   86994:	68fb      	ldr	r3, [r7, #12]
   86996:	687a      	ldr	r2, [r7, #4]
   86998:	601a      	str	r2, [r3, #0]
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
   8699a:	3714      	adds	r7, #20
   8699c:	46bd      	mov	sp, r7
   8699e:	f85d 7b04 	ldr.w	r7, [sp], #4
   869a2:	4770      	bx	lr
   869a4:	2007ac58 	.word	0x2007ac58
   869a8:	2007ac60 	.word	0x2007ac60

000869ac <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
   869ac:	b580      	push	{r7, lr}
   869ae:	b084      	sub	sp, #16
   869b0:	af00      	add	r7, sp, #0
   869b2:	6078      	str	r0, [r7, #4]
   869b4:	6039      	str	r1, [r7, #0]
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   869b6:	687b      	ldr	r3, [r7, #4]
   869b8:	60fb      	str	r3, [r7, #12]

	configASSERT( pxQueue );
   869ba:	68fb      	ldr	r3, [r7, #12]
   869bc:	2b00      	cmp	r3, #0
   869be:	d102      	bne.n	869c6 <xQueueGenericReset+0x1a>
   869c0:	4b26      	ldr	r3, [pc, #152]	; (86a5c <xQueueGenericReset+0xb0>)
   869c2:	4798      	blx	r3
   869c4:	e7fe      	b.n	869c4 <xQueueGenericReset+0x18>

	taskENTER_CRITICAL();
   869c6:	4b26      	ldr	r3, [pc, #152]	; (86a60 <xQueueGenericReset+0xb4>)
   869c8:	4798      	blx	r3
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
   869ca:	68fb      	ldr	r3, [r7, #12]
   869cc:	681a      	ldr	r2, [r3, #0]
   869ce:	68fb      	ldr	r3, [r7, #12]
   869d0:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   869d2:	68f9      	ldr	r1, [r7, #12]
   869d4:	6c09      	ldr	r1, [r1, #64]	; 0x40
   869d6:	fb01 f303 	mul.w	r3, r1, r3
   869da:	441a      	add	r2, r3
   869dc:	68fb      	ldr	r3, [r7, #12]
   869de:	605a      	str	r2, [r3, #4]
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
   869e0:	68fb      	ldr	r3, [r7, #12]
   869e2:	2200      	movs	r2, #0
   869e4:	639a      	str	r2, [r3, #56]	; 0x38
		pxQueue->pcWriteTo = pxQueue->pcHead;
   869e6:	68fb      	ldr	r3, [r7, #12]
   869e8:	681a      	ldr	r2, [r3, #0]
   869ea:	68fb      	ldr	r3, [r7, #12]
   869ec:	609a      	str	r2, [r3, #8]
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
   869ee:	68fb      	ldr	r3, [r7, #12]
   869f0:	681a      	ldr	r2, [r3, #0]
   869f2:	68fb      	ldr	r3, [r7, #12]
   869f4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   869f6:	3b01      	subs	r3, #1
   869f8:	68f9      	ldr	r1, [r7, #12]
   869fa:	6c09      	ldr	r1, [r1, #64]	; 0x40
   869fc:	fb01 f303 	mul.w	r3, r1, r3
   86a00:	441a      	add	r2, r3
   86a02:	68fb      	ldr	r3, [r7, #12]
   86a04:	60da      	str	r2, [r3, #12]
		pxQueue->xRxLock = queueUNLOCKED;
   86a06:	68fb      	ldr	r3, [r7, #12]
   86a08:	f04f 32ff 	mov.w	r2, #4294967295
   86a0c:	645a      	str	r2, [r3, #68]	; 0x44
		pxQueue->xTxLock = queueUNLOCKED;
   86a0e:	68fb      	ldr	r3, [r7, #12]
   86a10:	f04f 32ff 	mov.w	r2, #4294967295
   86a14:	649a      	str	r2, [r3, #72]	; 0x48

		if( xNewQueue == pdFALSE )
   86a16:	683b      	ldr	r3, [r7, #0]
   86a18:	2b00      	cmp	r3, #0
   86a1a:	d10e      	bne.n	86a3a <xQueueGenericReset+0x8e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   86a1c:	68fb      	ldr	r3, [r7, #12]
   86a1e:	691b      	ldr	r3, [r3, #16]
   86a20:	2b00      	cmp	r3, #0
   86a22:	d014      	beq.n	86a4e <xQueueGenericReset+0xa2>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   86a24:	68fb      	ldr	r3, [r7, #12]
   86a26:	3310      	adds	r3, #16
   86a28:	4618      	mov	r0, r3
   86a2a:	4b0e      	ldr	r3, [pc, #56]	; (86a64 <xQueueGenericReset+0xb8>)
   86a2c:	4798      	blx	r3
   86a2e:	4603      	mov	r3, r0
   86a30:	2b01      	cmp	r3, #1
   86a32:	d10c      	bne.n	86a4e <xQueueGenericReset+0xa2>
				{
					queueYIELD_IF_USING_PREEMPTION();
   86a34:	4b0c      	ldr	r3, [pc, #48]	; (86a68 <xQueueGenericReset+0xbc>)
   86a36:	4798      	blx	r3
   86a38:	e009      	b.n	86a4e <xQueueGenericReset+0xa2>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
   86a3a:	68fb      	ldr	r3, [r7, #12]
   86a3c:	3310      	adds	r3, #16
   86a3e:	4618      	mov	r0, r3
   86a40:	4b0a      	ldr	r3, [pc, #40]	; (86a6c <xQueueGenericReset+0xc0>)
   86a42:	4798      	blx	r3
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
   86a44:	68fb      	ldr	r3, [r7, #12]
   86a46:	3324      	adds	r3, #36	; 0x24
   86a48:	4618      	mov	r0, r3
   86a4a:	4b08      	ldr	r3, [pc, #32]	; (86a6c <xQueueGenericReset+0xc0>)
   86a4c:	4798      	blx	r3
		}
	}
	taskEXIT_CRITICAL();
   86a4e:	4b08      	ldr	r3, [pc, #32]	; (86a70 <xQueueGenericReset+0xc4>)
   86a50:	4798      	blx	r3

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
   86a52:	2301      	movs	r3, #1
}
   86a54:	4618      	mov	r0, r3
   86a56:	3710      	adds	r7, #16
   86a58:	46bd      	mov	sp, r7
   86a5a:	bd80      	pop	{r7, pc}
   86a5c:	000864f9 	.word	0x000864f9
   86a60:	0008647d 	.word	0x0008647d
   86a64:	00087b35 	.word	0x00087b35
   86a68:	0008645d 	.word	0x0008645d
   86a6c:	00086171 	.word	0x00086171
   86a70:	000864c1 	.word	0x000864c1

00086a74 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
   86a74:	b580      	push	{r7, lr}
   86a76:	b088      	sub	sp, #32
   86a78:	af00      	add	r7, sp, #0
   86a7a:	60f8      	str	r0, [r7, #12]
   86a7c:	60b9      	str	r1, [r7, #8]
   86a7e:	4613      	mov	r3, r2
   86a80:	71fb      	strb	r3, [r7, #7]
Queue_t *pxNewQueue;
size_t xQueueSizeInBytes;
QueueHandle_t xReturn = NULL;
   86a82:	2300      	movs	r3, #0
   86a84:	61fb      	str	r3, [r7, #28]
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( UBaseType_t ) 0 )
   86a86:	68fb      	ldr	r3, [r7, #12]
   86a88:	2b00      	cmp	r3, #0
   86a8a:	d026      	beq.n	86ada <xQueueGenericCreate+0x66>
	{
		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) );
   86a8c:	204c      	movs	r0, #76	; 0x4c
   86a8e:	4b18      	ldr	r3, [pc, #96]	; (86af0 <xQueueGenericCreate+0x7c>)
   86a90:	4798      	blx	r3
   86a92:	61b8      	str	r0, [r7, #24]
		if( pxNewQueue != NULL )
   86a94:	69bb      	ldr	r3, [r7, #24]
   86a96:	2b00      	cmp	r3, #0
   86a98:	d01f      	beq.n	86ada <xQueueGenericCreate+0x66>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   86a9a:	68fb      	ldr	r3, [r7, #12]
   86a9c:	68ba      	ldr	r2, [r7, #8]
   86a9e:	fb02 f303 	mul.w	r3, r2, r3
   86aa2:	3301      	adds	r3, #1
   86aa4:	617b      	str	r3, [r7, #20]

			pxNewQueue->pcHead = ( int8_t * ) pvPortMalloc( xQueueSizeInBytes );
   86aa6:	6978      	ldr	r0, [r7, #20]
   86aa8:	4b11      	ldr	r3, [pc, #68]	; (86af0 <xQueueGenericCreate+0x7c>)
   86aaa:	4798      	blx	r3
   86aac:	4602      	mov	r2, r0
   86aae:	69bb      	ldr	r3, [r7, #24]
   86ab0:	601a      	str	r2, [r3, #0]
			if( pxNewQueue->pcHead != NULL )
   86ab2:	69bb      	ldr	r3, [r7, #24]
   86ab4:	681b      	ldr	r3, [r3, #0]
   86ab6:	2b00      	cmp	r3, #0
   86ab8:	d00c      	beq.n	86ad4 <xQueueGenericCreate+0x60>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
   86aba:	69bb      	ldr	r3, [r7, #24]
   86abc:	68fa      	ldr	r2, [r7, #12]
   86abe:	63da      	str	r2, [r3, #60]	; 0x3c
				pxNewQueue->uxItemSize = uxItemSize;
   86ac0:	69bb      	ldr	r3, [r7, #24]
   86ac2:	68ba      	ldr	r2, [r7, #8]
   86ac4:	641a      	str	r2, [r3, #64]	; 0x40
				( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
   86ac6:	69b8      	ldr	r0, [r7, #24]
   86ac8:	2101      	movs	r1, #1
   86aca:	4b0a      	ldr	r3, [pc, #40]	; (86af4 <xQueueGenericCreate+0x80>)
   86acc:	4798      	blx	r3
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
   86ace:	69bb      	ldr	r3, [r7, #24]
   86ad0:	61fb      	str	r3, [r7, #28]
   86ad2:	e002      	b.n	86ada <xQueueGenericCreate+0x66>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
   86ad4:	69b8      	ldr	r0, [r7, #24]
   86ad6:	4b08      	ldr	r3, [pc, #32]	; (86af8 <xQueueGenericCreate+0x84>)
   86ad8:	4798      	blx	r3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
   86ada:	69fb      	ldr	r3, [r7, #28]
   86adc:	2b00      	cmp	r3, #0
   86ade:	d102      	bne.n	86ae6 <xQueueGenericCreate+0x72>
   86ae0:	4b06      	ldr	r3, [pc, #24]	; (86afc <xQueueGenericCreate+0x88>)
   86ae2:	4798      	blx	r3
   86ae4:	e7fe      	b.n	86ae4 <xQueueGenericCreate+0x70>

	return xReturn;
   86ae6:	69fb      	ldr	r3, [r7, #28]
}
   86ae8:	4618      	mov	r0, r3
   86aea:	3720      	adds	r7, #32
   86aec:	46bd      	mov	sp, r7
   86aee:	bd80      	pop	{r7, pc}
   86af0:	0008661d 	.word	0x0008661d
   86af4:	000869ad 	.word	0x000869ad
   86af8:	00086795 	.word	0x00086795
   86afc:	000864f9 	.word	0x000864f9

00086b00 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
   86b00:	b580      	push	{r7, lr}
   86b02:	b08a      	sub	sp, #40	; 0x28
   86b04:	af00      	add	r7, sp, #0
   86b06:	60f8      	str	r0, [r7, #12]
   86b08:	60b9      	str	r1, [r7, #8]
   86b0a:	607a      	str	r2, [r7, #4]
   86b0c:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
   86b0e:	2300      	movs	r3, #0
   86b10:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   86b12:	68fb      	ldr	r3, [r7, #12]
   86b14:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
   86b16:	6a3b      	ldr	r3, [r7, #32]
   86b18:	2b00      	cmp	r3, #0
   86b1a:	d102      	bne.n	86b22 <xQueueGenericSend+0x22>
   86b1c:	4b5b      	ldr	r3, [pc, #364]	; (86c8c <xQueueGenericSend+0x18c>)
   86b1e:	4798      	blx	r3
   86b20:	e7fe      	b.n	86b20 <xQueueGenericSend+0x20>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   86b22:	68bb      	ldr	r3, [r7, #8]
   86b24:	2b00      	cmp	r3, #0
   86b26:	d103      	bne.n	86b30 <xQueueGenericSend+0x30>
   86b28:	6a3b      	ldr	r3, [r7, #32]
   86b2a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   86b2c:	2b00      	cmp	r3, #0
   86b2e:	d101      	bne.n	86b34 <xQueueGenericSend+0x34>
   86b30:	2301      	movs	r3, #1
   86b32:	e000      	b.n	86b36 <xQueueGenericSend+0x36>
   86b34:	2300      	movs	r3, #0
   86b36:	2b00      	cmp	r3, #0
   86b38:	d102      	bne.n	86b40 <xQueueGenericSend+0x40>
   86b3a:	4b54      	ldr	r3, [pc, #336]	; (86c8c <xQueueGenericSend+0x18c>)
   86b3c:	4798      	blx	r3
   86b3e:	e7fe      	b.n	86b3e <xQueueGenericSend+0x3e>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   86b40:	683b      	ldr	r3, [r7, #0]
   86b42:	2b02      	cmp	r3, #2
   86b44:	d103      	bne.n	86b4e <xQueueGenericSend+0x4e>
   86b46:	6a3b      	ldr	r3, [r7, #32]
   86b48:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   86b4a:	2b01      	cmp	r3, #1
   86b4c:	d101      	bne.n	86b52 <xQueueGenericSend+0x52>
   86b4e:	2301      	movs	r3, #1
   86b50:	e000      	b.n	86b54 <xQueueGenericSend+0x54>
   86b52:	2300      	movs	r3, #0
   86b54:	2b00      	cmp	r3, #0
   86b56:	d102      	bne.n	86b5e <xQueueGenericSend+0x5e>
   86b58:	4b4c      	ldr	r3, [pc, #304]	; (86c8c <xQueueGenericSend+0x18c>)
   86b5a:	4798      	blx	r3
   86b5c:	e7fe      	b.n	86b5c <xQueueGenericSend+0x5c>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   86b5e:	4b4c      	ldr	r3, [pc, #304]	; (86c90 <xQueueGenericSend+0x190>)
   86b60:	4798      	blx	r3
   86b62:	4603      	mov	r3, r0
   86b64:	2b00      	cmp	r3, #0
   86b66:	d102      	bne.n	86b6e <xQueueGenericSend+0x6e>
   86b68:	687b      	ldr	r3, [r7, #4]
   86b6a:	2b00      	cmp	r3, #0
   86b6c:	d101      	bne.n	86b72 <xQueueGenericSend+0x72>
   86b6e:	2301      	movs	r3, #1
   86b70:	e000      	b.n	86b74 <xQueueGenericSend+0x74>
   86b72:	2300      	movs	r3, #0
   86b74:	2b00      	cmp	r3, #0
   86b76:	d102      	bne.n	86b7e <xQueueGenericSend+0x7e>
   86b78:	4b44      	ldr	r3, [pc, #272]	; (86c8c <xQueueGenericSend+0x18c>)
   86b7a:	4798      	blx	r3
   86b7c:	e7fe      	b.n	86b7c <xQueueGenericSend+0x7c>
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
   86b7e:	4b45      	ldr	r3, [pc, #276]	; (86c94 <xQueueGenericSend+0x194>)
   86b80:	4798      	blx	r3
		{
			/* Is there room on the queue now?  The running task must be
			the highest priority task wanting to access the queue.  If
			the head item in the queue is to be overwritten then it does
			not matter if the queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   86b82:	6a3b      	ldr	r3, [r7, #32]
   86b84:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   86b86:	6a3b      	ldr	r3, [r7, #32]
   86b88:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   86b8a:	429a      	cmp	r2, r3
   86b8c:	d302      	bcc.n	86b94 <xQueueGenericSend+0x94>
   86b8e:	683b      	ldr	r3, [r7, #0]
   86b90:	2b02      	cmp	r3, #2
   86b92:	d11d      	bne.n	86bd0 <xQueueGenericSend+0xd0>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
   86b94:	6a38      	ldr	r0, [r7, #32]
   86b96:	68b9      	ldr	r1, [r7, #8]
   86b98:	683a      	ldr	r2, [r7, #0]
   86b9a:	4b3f      	ldr	r3, [pc, #252]	; (86c98 <xQueueGenericSend+0x198>)
   86b9c:	4798      	blx	r3
   86b9e:	61f8      	str	r0, [r7, #28]
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   86ba0:	6a3b      	ldr	r3, [r7, #32]
   86ba2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   86ba4:	2b00      	cmp	r3, #0
   86ba6:	d00a      	beq.n	86bbe <xQueueGenericSend+0xbe>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
   86ba8:	6a3b      	ldr	r3, [r7, #32]
   86baa:	3324      	adds	r3, #36	; 0x24
   86bac:	4618      	mov	r0, r3
   86bae:	4b3b      	ldr	r3, [pc, #236]	; (86c9c <xQueueGenericSend+0x19c>)
   86bb0:	4798      	blx	r3
   86bb2:	4603      	mov	r3, r0
   86bb4:	2b01      	cmp	r3, #1
   86bb6:	d107      	bne.n	86bc8 <xQueueGenericSend+0xc8>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
   86bb8:	4b39      	ldr	r3, [pc, #228]	; (86ca0 <xQueueGenericSend+0x1a0>)
   86bba:	4798      	blx	r3
   86bbc:	e004      	b.n	86bc8 <xQueueGenericSend+0xc8>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
   86bbe:	69fb      	ldr	r3, [r7, #28]
   86bc0:	2b00      	cmp	r3, #0
   86bc2:	d001      	beq.n	86bc8 <xQueueGenericSend+0xc8>
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
   86bc4:	4b36      	ldr	r3, [pc, #216]	; (86ca0 <xQueueGenericSend+0x1a0>)
   86bc6:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
   86bc8:	4b36      	ldr	r3, [pc, #216]	; (86ca4 <xQueueGenericSend+0x1a4>)
   86bca:	4798      	blx	r3
				return pdPASS;
   86bcc:	2301      	movs	r3, #1
   86bce:	e059      	b.n	86c84 <xQueueGenericSend+0x184>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   86bd0:	687b      	ldr	r3, [r7, #4]
   86bd2:	2b00      	cmp	r3, #0
   86bd4:	d103      	bne.n	86bde <xQueueGenericSend+0xde>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   86bd6:	4b33      	ldr	r3, [pc, #204]	; (86ca4 <xQueueGenericSend+0x1a4>)
   86bd8:	4798      	blx	r3

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
   86bda:	2300      	movs	r3, #0
   86bdc:	e052      	b.n	86c84 <xQueueGenericSend+0x184>
				}
				else if( xEntryTimeSet == pdFALSE )
   86bde:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   86be0:	2b00      	cmp	r3, #0
   86be2:	d106      	bne.n	86bf2 <xQueueGenericSend+0xf2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   86be4:	f107 0314 	add.w	r3, r7, #20
   86be8:	4618      	mov	r0, r3
   86bea:	4b2f      	ldr	r3, [pc, #188]	; (86ca8 <xQueueGenericSend+0x1a8>)
   86bec:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
   86bee:	2301      	movs	r3, #1
   86bf0:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   86bf2:	4b2c      	ldr	r3, [pc, #176]	; (86ca4 <xQueueGenericSend+0x1a4>)
   86bf4:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   86bf6:	4b2d      	ldr	r3, [pc, #180]	; (86cac <xQueueGenericSend+0x1ac>)
   86bf8:	4798      	blx	r3
		prvLockQueue( pxQueue );
   86bfa:	4b26      	ldr	r3, [pc, #152]	; (86c94 <xQueueGenericSend+0x194>)
   86bfc:	4798      	blx	r3
   86bfe:	6a3b      	ldr	r3, [r7, #32]
   86c00:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   86c02:	f1b3 3fff 	cmp.w	r3, #4294967295
   86c06:	d102      	bne.n	86c0e <xQueueGenericSend+0x10e>
   86c08:	6a3b      	ldr	r3, [r7, #32]
   86c0a:	2200      	movs	r2, #0
   86c0c:	645a      	str	r2, [r3, #68]	; 0x44
   86c0e:	6a3b      	ldr	r3, [r7, #32]
   86c10:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   86c12:	f1b3 3fff 	cmp.w	r3, #4294967295
   86c16:	d102      	bne.n	86c1e <xQueueGenericSend+0x11e>
   86c18:	6a3b      	ldr	r3, [r7, #32]
   86c1a:	2200      	movs	r2, #0
   86c1c:	649a      	str	r2, [r3, #72]	; 0x48
   86c1e:	4b21      	ldr	r3, [pc, #132]	; (86ca4 <xQueueGenericSend+0x1a4>)
   86c20:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   86c22:	f107 0214 	add.w	r2, r7, #20
   86c26:	1d3b      	adds	r3, r7, #4
   86c28:	4610      	mov	r0, r2
   86c2a:	4619      	mov	r1, r3
   86c2c:	4b20      	ldr	r3, [pc, #128]	; (86cb0 <xQueueGenericSend+0x1b0>)
   86c2e:	4798      	blx	r3
   86c30:	4603      	mov	r3, r0
   86c32:	2b00      	cmp	r3, #0
   86c34:	d11e      	bne.n	86c74 <xQueueGenericSend+0x174>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
   86c36:	6a38      	ldr	r0, [r7, #32]
   86c38:	4b1e      	ldr	r3, [pc, #120]	; (86cb4 <xQueueGenericSend+0x1b4>)
   86c3a:	4798      	blx	r3
   86c3c:	4603      	mov	r3, r0
   86c3e:	2b00      	cmp	r3, #0
   86c40:	d012      	beq.n	86c68 <xQueueGenericSend+0x168>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
   86c42:	6a3b      	ldr	r3, [r7, #32]
   86c44:	f103 0210 	add.w	r2, r3, #16
   86c48:	687b      	ldr	r3, [r7, #4]
   86c4a:	4610      	mov	r0, r2
   86c4c:	4619      	mov	r1, r3
   86c4e:	4b1a      	ldr	r3, [pc, #104]	; (86cb8 <xQueueGenericSend+0x1b8>)
   86c50:	4798      	blx	r3
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
   86c52:	6a38      	ldr	r0, [r7, #32]
   86c54:	4b19      	ldr	r3, [pc, #100]	; (86cbc <xQueueGenericSend+0x1bc>)
   86c56:	4798      	blx	r3
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
   86c58:	4b19      	ldr	r3, [pc, #100]	; (86cc0 <xQueueGenericSend+0x1c0>)
   86c5a:	4798      	blx	r3
   86c5c:	4603      	mov	r3, r0
   86c5e:	2b00      	cmp	r3, #0
   86c60:	d10f      	bne.n	86c82 <xQueueGenericSend+0x182>
				{
					portYIELD_WITHIN_API();
   86c62:	4b0f      	ldr	r3, [pc, #60]	; (86ca0 <xQueueGenericSend+0x1a0>)
   86c64:	4798      	blx	r3
   86c66:	e00c      	b.n	86c82 <xQueueGenericSend+0x182>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   86c68:	6a38      	ldr	r0, [r7, #32]
   86c6a:	4b14      	ldr	r3, [pc, #80]	; (86cbc <xQueueGenericSend+0x1bc>)
   86c6c:	4798      	blx	r3
				( void ) xTaskResumeAll();
   86c6e:	4b14      	ldr	r3, [pc, #80]	; (86cc0 <xQueueGenericSend+0x1c0>)
   86c70:	4798      	blx	r3
			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
   86c72:	e784      	b.n	86b7e <xQueueGenericSend+0x7e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
   86c74:	6a38      	ldr	r0, [r7, #32]
   86c76:	4b11      	ldr	r3, [pc, #68]	; (86cbc <xQueueGenericSend+0x1bc>)
   86c78:	4798      	blx	r3
			( void ) xTaskResumeAll();
   86c7a:	4b11      	ldr	r3, [pc, #68]	; (86cc0 <xQueueGenericSend+0x1c0>)
   86c7c:	4798      	blx	r3

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
   86c7e:	2300      	movs	r3, #0
   86c80:	e000      	b.n	86c84 <xQueueGenericSend+0x184>
		}
	}
   86c82:	e77c      	b.n	86b7e <xQueueGenericSend+0x7e>
}
   86c84:	4618      	mov	r0, r3
   86c86:	3728      	adds	r7, #40	; 0x28
   86c88:	46bd      	mov	sp, r7
   86c8a:	bd80      	pop	{r7, pc}
   86c8c:	000864f9 	.word	0x000864f9
   86c90:	0008800d 	.word	0x0008800d
   86c94:	0008647d 	.word	0x0008647d
   86c98:	00087085 	.word	0x00087085
   86c9c:	00087b35 	.word	0x00087b35
   86ca0:	0008645d 	.word	0x0008645d
   86ca4:	000864c1 	.word	0x000864c1
   86ca8:	00087bf5 	.word	0x00087bf5
   86cac:	00087631 	.word	0x00087631
   86cb0:	00087c2d 	.word	0x00087c2d
   86cb4:	00087295 	.word	0x00087295
   86cb8:	00087a15 	.word	0x00087a15
   86cbc:	000871b9 	.word	0x000871b9
   86cc0:	0008764d 	.word	0x0008764d

00086cc4 <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
{
   86cc4:	b580      	push	{r7, lr}
   86cc6:	b088      	sub	sp, #32
   86cc8:	af00      	add	r7, sp, #0
   86cca:	60f8      	str	r0, [r7, #12]
   86ccc:	60b9      	str	r1, [r7, #8]
   86cce:	607a      	str	r2, [r7, #4]
   86cd0:	603b      	str	r3, [r7, #0]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   86cd2:	68fb      	ldr	r3, [r7, #12]
   86cd4:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
   86cd6:	69bb      	ldr	r3, [r7, #24]
   86cd8:	2b00      	cmp	r3, #0
   86cda:	d102      	bne.n	86ce2 <xQueueGenericSendFromISR+0x1e>
   86cdc:	4b33      	ldr	r3, [pc, #204]	; (86dac <xQueueGenericSendFromISR+0xe8>)
   86cde:	4798      	blx	r3
   86ce0:	e7fe      	b.n	86ce0 <xQueueGenericSendFromISR+0x1c>
	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   86ce2:	68bb      	ldr	r3, [r7, #8]
   86ce4:	2b00      	cmp	r3, #0
   86ce6:	d103      	bne.n	86cf0 <xQueueGenericSendFromISR+0x2c>
   86ce8:	69bb      	ldr	r3, [r7, #24]
   86cea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   86cec:	2b00      	cmp	r3, #0
   86cee:	d101      	bne.n	86cf4 <xQueueGenericSendFromISR+0x30>
   86cf0:	2301      	movs	r3, #1
   86cf2:	e000      	b.n	86cf6 <xQueueGenericSendFromISR+0x32>
   86cf4:	2300      	movs	r3, #0
   86cf6:	2b00      	cmp	r3, #0
   86cf8:	d102      	bne.n	86d00 <xQueueGenericSendFromISR+0x3c>
   86cfa:	4b2c      	ldr	r3, [pc, #176]	; (86dac <xQueueGenericSendFromISR+0xe8>)
   86cfc:	4798      	blx	r3
   86cfe:	e7fe      	b.n	86cfe <xQueueGenericSendFromISR+0x3a>
	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
   86d00:	683b      	ldr	r3, [r7, #0]
   86d02:	2b02      	cmp	r3, #2
   86d04:	d103      	bne.n	86d0e <xQueueGenericSendFromISR+0x4a>
   86d06:	69bb      	ldr	r3, [r7, #24]
   86d08:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   86d0a:	2b01      	cmp	r3, #1
   86d0c:	d101      	bne.n	86d12 <xQueueGenericSendFromISR+0x4e>
   86d0e:	2301      	movs	r3, #1
   86d10:	e000      	b.n	86d14 <xQueueGenericSendFromISR+0x50>
   86d12:	2300      	movs	r3, #0
   86d14:	2b00      	cmp	r3, #0
   86d16:	d102      	bne.n	86d1e <xQueueGenericSendFromISR+0x5a>
   86d18:	4b24      	ldr	r3, [pc, #144]	; (86dac <xQueueGenericSendFromISR+0xe8>)
   86d1a:	4798      	blx	r3
   86d1c:	e7fe      	b.n	86d1c <xQueueGenericSendFromISR+0x58>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   86d1e:	4b24      	ldr	r3, [pc, #144]	; (86db0 <xQueueGenericSendFromISR+0xec>)
   86d20:	4798      	blx	r3
	/* Similar to xQueueGenericSend, except without blocking if there is no room
	in the queue.  Also don't directly wake a task that was blocked on a queue
	read, instead return a flag to say whether a context switch is required or
	not (i.e. has a task with a higher priority than us been woken by this
	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   86d22:	4b22      	ldr	r3, [pc, #136]	; (86dac <xQueueGenericSendFromISR+0xe8>)
   86d24:	4798      	blx	r3
   86d26:	6178      	str	r0, [r7, #20]
	{
		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
   86d28:	69bb      	ldr	r3, [r7, #24]
   86d2a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   86d2c:	69bb      	ldr	r3, [r7, #24]
   86d2e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   86d30:	429a      	cmp	r2, r3
   86d32:	d302      	bcc.n	86d3a <xQueueGenericSendFromISR+0x76>
   86d34:	683b      	ldr	r3, [r7, #0]
   86d36:	2b02      	cmp	r3, #2
   86d38:	d12d      	bne.n	86d96 <xQueueGenericSendFromISR+0xd2>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			if( prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ) != pdFALSE )
   86d3a:	69b8      	ldr	r0, [r7, #24]
   86d3c:	68b9      	ldr	r1, [r7, #8]
   86d3e:	683a      	ldr	r2, [r7, #0]
   86d40:	4b1c      	ldr	r3, [pc, #112]	; (86db4 <xQueueGenericSendFromISR+0xf0>)
   86d42:	4798      	blx	r3
   86d44:	4603      	mov	r3, r0
   86d46:	2b00      	cmp	r3, #0
   86d48:	d005      	beq.n	86d56 <xQueueGenericSendFromISR+0x92>
			{
				/* This is a special case that can only be executed if a task
				holds multiple mutexes and then gives the mutexes back in an
				order that is different to that in which they were taken. */
				if( pxHigherPriorityTaskWoken != NULL )
   86d4a:	687b      	ldr	r3, [r7, #4]
   86d4c:	2b00      	cmp	r3, #0
   86d4e:	d002      	beq.n	86d56 <xQueueGenericSendFromISR+0x92>
				{
					*pxHigherPriorityTaskWoken = pdTRUE;
   86d50:	687b      	ldr	r3, [r7, #4]
   86d52:	2201      	movs	r2, #1
   86d54:	601a      	str	r2, [r3, #0]
				}
			}

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
   86d56:	69bb      	ldr	r3, [r7, #24]
   86d58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   86d5a:	f1b3 3fff 	cmp.w	r3, #4294967295
   86d5e:	d112      	bne.n	86d86 <xQueueGenericSendFromISR+0xc2>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   86d60:	69bb      	ldr	r3, [r7, #24]
   86d62:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   86d64:	2b00      	cmp	r3, #0
   86d66:	d013      	beq.n	86d90 <xQueueGenericSendFromISR+0xcc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   86d68:	69bb      	ldr	r3, [r7, #24]
   86d6a:	3324      	adds	r3, #36	; 0x24
   86d6c:	4618      	mov	r0, r3
   86d6e:	4b12      	ldr	r3, [pc, #72]	; (86db8 <xQueueGenericSendFromISR+0xf4>)
   86d70:	4798      	blx	r3
   86d72:	4603      	mov	r3, r0
   86d74:	2b00      	cmp	r3, #0
   86d76:	d00b      	beq.n	86d90 <xQueueGenericSendFromISR+0xcc>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
   86d78:	687b      	ldr	r3, [r7, #4]
   86d7a:	2b00      	cmp	r3, #0
   86d7c:	d008      	beq.n	86d90 <xQueueGenericSendFromISR+0xcc>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
   86d7e:	687b      	ldr	r3, [r7, #4]
   86d80:	2201      	movs	r2, #1
   86d82:	601a      	str	r2, [r3, #0]
   86d84:	e004      	b.n	86d90 <xQueueGenericSendFromISR+0xcc>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
   86d86:	69bb      	ldr	r3, [r7, #24]
   86d88:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   86d8a:	1c5a      	adds	r2, r3, #1
   86d8c:	69bb      	ldr	r3, [r7, #24]
   86d8e:	649a      	str	r2, [r3, #72]	; 0x48
			}

			xReturn = pdPASS;
   86d90:	2301      	movs	r3, #1
   86d92:	61fb      	str	r3, [r7, #28]
   86d94:	e001      	b.n	86d9a <xQueueGenericSendFromISR+0xd6>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
   86d96:	2300      	movs	r3, #0
   86d98:	61fb      	str	r3, [r7, #28]
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   86d9a:	6978      	ldr	r0, [r7, #20]
   86d9c:	4b07      	ldr	r3, [pc, #28]	; (86dbc <xQueueGenericSendFromISR+0xf8>)
   86d9e:	4798      	blx	r3

	return xReturn;
   86da0:	69fb      	ldr	r3, [r7, #28]
}
   86da2:	4618      	mov	r0, r3
   86da4:	3720      	adds	r7, #32
   86da6:	46bd      	mov	sp, r7
   86da8:	bd80      	pop	{r7, pc}
   86daa:	bf00      	nop
   86dac:	000864f9 	.word	0x000864f9
   86db0:	000865c1 	.word	0x000865c1
   86db4:	00087085 	.word	0x00087085
   86db8:	00087b35 	.word	0x00087b35
   86dbc:	0008650d 	.word	0x0008650d

00086dc0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
   86dc0:	b580      	push	{r7, lr}
   86dc2:	b08a      	sub	sp, #40	; 0x28
   86dc4:	af00      	add	r7, sp, #0
   86dc6:	60f8      	str	r0, [r7, #12]
   86dc8:	60b9      	str	r1, [r7, #8]
   86dca:	607a      	str	r2, [r7, #4]
   86dcc:	603b      	str	r3, [r7, #0]
BaseType_t xEntryTimeSet = pdFALSE;
   86dce:	2300      	movs	r3, #0
   86dd0:	627b      	str	r3, [r7, #36]	; 0x24
TimeOut_t xTimeOut;
int8_t *pcOriginalReadPosition;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   86dd2:	68fb      	ldr	r3, [r7, #12]
   86dd4:	623b      	str	r3, [r7, #32]

	configASSERT( pxQueue );
   86dd6:	6a3b      	ldr	r3, [r7, #32]
   86dd8:	2b00      	cmp	r3, #0
   86dda:	d102      	bne.n	86de2 <xQueueGenericReceive+0x22>
   86ddc:	4b67      	ldr	r3, [pc, #412]	; (86f7c <xQueueGenericReceive+0x1bc>)
   86dde:	4798      	blx	r3
   86de0:	e7fe      	b.n	86de0 <xQueueGenericReceive+0x20>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   86de2:	68bb      	ldr	r3, [r7, #8]
   86de4:	2b00      	cmp	r3, #0
   86de6:	d103      	bne.n	86df0 <xQueueGenericReceive+0x30>
   86de8:	6a3b      	ldr	r3, [r7, #32]
   86dea:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   86dec:	2b00      	cmp	r3, #0
   86dee:	d101      	bne.n	86df4 <xQueueGenericReceive+0x34>
   86df0:	2301      	movs	r3, #1
   86df2:	e000      	b.n	86df6 <xQueueGenericReceive+0x36>
   86df4:	2300      	movs	r3, #0
   86df6:	2b00      	cmp	r3, #0
   86df8:	d102      	bne.n	86e00 <xQueueGenericReceive+0x40>
   86dfa:	4b60      	ldr	r3, [pc, #384]	; (86f7c <xQueueGenericReceive+0x1bc>)
   86dfc:	4798      	blx	r3
   86dfe:	e7fe      	b.n	86dfe <xQueueGenericReceive+0x3e>
	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
	{
		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
   86e00:	4b5f      	ldr	r3, [pc, #380]	; (86f80 <xQueueGenericReceive+0x1c0>)
   86e02:	4798      	blx	r3
   86e04:	4603      	mov	r3, r0
   86e06:	2b00      	cmp	r3, #0
   86e08:	d102      	bne.n	86e10 <xQueueGenericReceive+0x50>
   86e0a:	687b      	ldr	r3, [r7, #4]
   86e0c:	2b00      	cmp	r3, #0
   86e0e:	d101      	bne.n	86e14 <xQueueGenericReceive+0x54>
   86e10:	2301      	movs	r3, #1
   86e12:	e000      	b.n	86e16 <xQueueGenericReceive+0x56>
   86e14:	2300      	movs	r3, #0
   86e16:	2b00      	cmp	r3, #0
   86e18:	d102      	bne.n	86e20 <xQueueGenericReceive+0x60>
   86e1a:	4b58      	ldr	r3, [pc, #352]	; (86f7c <xQueueGenericReceive+0x1bc>)
   86e1c:	4798      	blx	r3
   86e1e:	e7fe      	b.n	86e1e <xQueueGenericReceive+0x5e>
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
   86e20:	4b58      	ldr	r3, [pc, #352]	; (86f84 <xQueueGenericReceive+0x1c4>)
   86e22:	4798      	blx	r3
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   86e24:	6a3b      	ldr	r3, [r7, #32]
   86e26:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   86e28:	2b00      	cmp	r3, #0
   86e2a:	d03b      	beq.n	86ea4 <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
   86e2c:	6a3b      	ldr	r3, [r7, #32]
   86e2e:	68db      	ldr	r3, [r3, #12]
   86e30:	61fb      	str	r3, [r7, #28]

				prvCopyDataFromQueue( pxQueue, pvBuffer );
   86e32:	6a38      	ldr	r0, [r7, #32]
   86e34:	68b9      	ldr	r1, [r7, #8]
   86e36:	4b54      	ldr	r3, [pc, #336]	; (86f88 <xQueueGenericReceive+0x1c8>)
   86e38:	4798      	blx	r3

				if( xJustPeeking == pdFALSE )
   86e3a:	683b      	ldr	r3, [r7, #0]
   86e3c:	2b00      	cmp	r3, #0
   86e3e:	d11c      	bne.n	86e7a <xQueueGenericReceive+0xba>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
   86e40:	6a3b      	ldr	r3, [r7, #32]
   86e42:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   86e44:	1e5a      	subs	r2, r3, #1
   86e46:	6a3b      	ldr	r3, [r7, #32]
   86e48:	639a      	str	r2, [r3, #56]	; 0x38

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   86e4a:	6a3b      	ldr	r3, [r7, #32]
   86e4c:	681b      	ldr	r3, [r3, #0]
   86e4e:	2b00      	cmp	r3, #0
   86e50:	d104      	bne.n	86e5c <xQueueGenericReceive+0x9c>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
   86e52:	4b4e      	ldr	r3, [pc, #312]	; (86f8c <xQueueGenericReceive+0x1cc>)
   86e54:	4798      	blx	r3
   86e56:	4602      	mov	r2, r0
   86e58:	6a3b      	ldr	r3, [r7, #32]
   86e5a:	605a      	str	r2, [r3, #4]
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   86e5c:	6a3b      	ldr	r3, [r7, #32]
   86e5e:	691b      	ldr	r3, [r3, #16]
   86e60:	2b00      	cmp	r3, #0
   86e62:	d01b      	beq.n	86e9c <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
   86e64:	6a3b      	ldr	r3, [r7, #32]
   86e66:	3310      	adds	r3, #16
   86e68:	4618      	mov	r0, r3
   86e6a:	4b49      	ldr	r3, [pc, #292]	; (86f90 <xQueueGenericReceive+0x1d0>)
   86e6c:	4798      	blx	r3
   86e6e:	4603      	mov	r3, r0
   86e70:	2b01      	cmp	r3, #1
   86e72:	d113      	bne.n	86e9c <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
   86e74:	4b47      	ldr	r3, [pc, #284]	; (86f94 <xQueueGenericReceive+0x1d4>)
   86e76:	4798      	blx	r3
   86e78:	e010      	b.n	86e9c <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
   86e7a:	6a3b      	ldr	r3, [r7, #32]
   86e7c:	69fa      	ldr	r2, [r7, #28]
   86e7e:	60da      	str	r2, [r3, #12]

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   86e80:	6a3b      	ldr	r3, [r7, #32]
   86e82:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   86e84:	2b00      	cmp	r3, #0
   86e86:	d009      	beq.n	86e9c <xQueueGenericReceive+0xdc>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   86e88:	6a3b      	ldr	r3, [r7, #32]
   86e8a:	3324      	adds	r3, #36	; 0x24
   86e8c:	4618      	mov	r0, r3
   86e8e:	4b40      	ldr	r3, [pc, #256]	; (86f90 <xQueueGenericReceive+0x1d0>)
   86e90:	4798      	blx	r3
   86e92:	4603      	mov	r3, r0
   86e94:	2b00      	cmp	r3, #0
   86e96:	d001      	beq.n	86e9c <xQueueGenericReceive+0xdc>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
   86e98:	4b3e      	ldr	r3, [pc, #248]	; (86f94 <xQueueGenericReceive+0x1d4>)
   86e9a:	4798      	blx	r3
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
   86e9c:	4b3e      	ldr	r3, [pc, #248]	; (86f98 <xQueueGenericReceive+0x1d8>)
   86e9e:	4798      	blx	r3
				return pdPASS;
   86ea0:	2301      	movs	r3, #1
   86ea2:	e066      	b.n	86f72 <xQueueGenericReceive+0x1b2>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
   86ea4:	687b      	ldr	r3, [r7, #4]
   86ea6:	2b00      	cmp	r3, #0
   86ea8:	d103      	bne.n	86eb2 <xQueueGenericReceive+0xf2>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
   86eaa:	4b3b      	ldr	r3, [pc, #236]	; (86f98 <xQueueGenericReceive+0x1d8>)
   86eac:	4798      	blx	r3
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
   86eae:	2300      	movs	r3, #0
   86eb0:	e05f      	b.n	86f72 <xQueueGenericReceive+0x1b2>
				}
				else if( xEntryTimeSet == pdFALSE )
   86eb2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
   86eb4:	2b00      	cmp	r3, #0
   86eb6:	d106      	bne.n	86ec6 <xQueueGenericReceive+0x106>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
   86eb8:	f107 0314 	add.w	r3, r7, #20
   86ebc:	4618      	mov	r0, r3
   86ebe:	4b37      	ldr	r3, [pc, #220]	; (86f9c <xQueueGenericReceive+0x1dc>)
   86ec0:	4798      	blx	r3
					xEntryTimeSet = pdTRUE;
   86ec2:	2301      	movs	r3, #1
   86ec4:	627b      	str	r3, [r7, #36]	; 0x24
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
   86ec6:	4b34      	ldr	r3, [pc, #208]	; (86f98 <xQueueGenericReceive+0x1d8>)
   86ec8:	4798      	blx	r3

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
   86eca:	4b35      	ldr	r3, [pc, #212]	; (86fa0 <xQueueGenericReceive+0x1e0>)
   86ecc:	4798      	blx	r3
		prvLockQueue( pxQueue );
   86ece:	4b2d      	ldr	r3, [pc, #180]	; (86f84 <xQueueGenericReceive+0x1c4>)
   86ed0:	4798      	blx	r3
   86ed2:	6a3b      	ldr	r3, [r7, #32]
   86ed4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   86ed6:	f1b3 3fff 	cmp.w	r3, #4294967295
   86eda:	d102      	bne.n	86ee2 <xQueueGenericReceive+0x122>
   86edc:	6a3b      	ldr	r3, [r7, #32]
   86ede:	2200      	movs	r2, #0
   86ee0:	645a      	str	r2, [r3, #68]	; 0x44
   86ee2:	6a3b      	ldr	r3, [r7, #32]
   86ee4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   86ee6:	f1b3 3fff 	cmp.w	r3, #4294967295
   86eea:	d102      	bne.n	86ef2 <xQueueGenericReceive+0x132>
   86eec:	6a3b      	ldr	r3, [r7, #32]
   86eee:	2200      	movs	r2, #0
   86ef0:	649a      	str	r2, [r3, #72]	; 0x48
   86ef2:	4b29      	ldr	r3, [pc, #164]	; (86f98 <xQueueGenericReceive+0x1d8>)
   86ef4:	4798      	blx	r3

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
   86ef6:	f107 0214 	add.w	r2, r7, #20
   86efa:	1d3b      	adds	r3, r7, #4
   86efc:	4610      	mov	r0, r2
   86efe:	4619      	mov	r1, r3
   86f00:	4b28      	ldr	r3, [pc, #160]	; (86fa4 <xQueueGenericReceive+0x1e4>)
   86f02:	4798      	blx	r3
   86f04:	4603      	mov	r3, r0
   86f06:	2b00      	cmp	r3, #0
   86f08:	d12b      	bne.n	86f62 <xQueueGenericReceive+0x1a2>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
   86f0a:	6a38      	ldr	r0, [r7, #32]
   86f0c:	4b26      	ldr	r3, [pc, #152]	; (86fa8 <xQueueGenericReceive+0x1e8>)
   86f0e:	4798      	blx	r3
   86f10:	4603      	mov	r3, r0
   86f12:	2b00      	cmp	r3, #0
   86f14:	d01f      	beq.n	86f56 <xQueueGenericReceive+0x196>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   86f16:	6a3b      	ldr	r3, [r7, #32]
   86f18:	681b      	ldr	r3, [r3, #0]
   86f1a:	2b00      	cmp	r3, #0
   86f1c:	d108      	bne.n	86f30 <xQueueGenericReceive+0x170>
					{
						taskENTER_CRITICAL();
   86f1e:	4b19      	ldr	r3, [pc, #100]	; (86f84 <xQueueGenericReceive+0x1c4>)
   86f20:	4798      	blx	r3
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
   86f22:	6a3b      	ldr	r3, [r7, #32]
   86f24:	685b      	ldr	r3, [r3, #4]
   86f26:	4618      	mov	r0, r3
   86f28:	4b20      	ldr	r3, [pc, #128]	; (86fac <xQueueGenericReceive+0x1ec>)
   86f2a:	4798      	blx	r3
						}
						taskEXIT_CRITICAL();
   86f2c:	4b1a      	ldr	r3, [pc, #104]	; (86f98 <xQueueGenericReceive+0x1d8>)
   86f2e:	4798      	blx	r3
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   86f30:	6a3b      	ldr	r3, [r7, #32]
   86f32:	f103 0224 	add.w	r2, r3, #36	; 0x24
   86f36:	687b      	ldr	r3, [r7, #4]
   86f38:	4610      	mov	r0, r2
   86f3a:	4619      	mov	r1, r3
   86f3c:	4b1c      	ldr	r3, [pc, #112]	; (86fb0 <xQueueGenericReceive+0x1f0>)
   86f3e:	4798      	blx	r3
				prvUnlockQueue( pxQueue );
   86f40:	6a38      	ldr	r0, [r7, #32]
   86f42:	4b1c      	ldr	r3, [pc, #112]	; (86fb4 <xQueueGenericReceive+0x1f4>)
   86f44:	4798      	blx	r3
				if( xTaskResumeAll() == pdFALSE )
   86f46:	4b1c      	ldr	r3, [pc, #112]	; (86fb8 <xQueueGenericReceive+0x1f8>)
   86f48:	4798      	blx	r3
   86f4a:	4603      	mov	r3, r0
   86f4c:	2b00      	cmp	r3, #0
   86f4e:	d10f      	bne.n	86f70 <xQueueGenericReceive+0x1b0>
				{
					portYIELD_WITHIN_API();
   86f50:	4b10      	ldr	r3, [pc, #64]	; (86f94 <xQueueGenericReceive+0x1d4>)
   86f52:	4798      	blx	r3
   86f54:	e00c      	b.n	86f70 <xQueueGenericReceive+0x1b0>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
   86f56:	6a38      	ldr	r0, [r7, #32]
   86f58:	4b16      	ldr	r3, [pc, #88]	; (86fb4 <xQueueGenericReceive+0x1f4>)
   86f5a:	4798      	blx	r3
				( void ) xTaskResumeAll();
   86f5c:	4b16      	ldr	r3, [pc, #88]	; (86fb8 <xQueueGenericReceive+0x1f8>)
   86f5e:	4798      	blx	r3
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
   86f60:	e75e      	b.n	86e20 <xQueueGenericReceive+0x60>
				( void ) xTaskResumeAll();
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
   86f62:	6a38      	ldr	r0, [r7, #32]
   86f64:	4b13      	ldr	r3, [pc, #76]	; (86fb4 <xQueueGenericReceive+0x1f4>)
   86f66:	4798      	blx	r3
			( void ) xTaskResumeAll();
   86f68:	4b13      	ldr	r3, [pc, #76]	; (86fb8 <xQueueGenericReceive+0x1f8>)
   86f6a:	4798      	blx	r3
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
   86f6c:	2300      	movs	r3, #0
   86f6e:	e000      	b.n	86f72 <xQueueGenericReceive+0x1b2>
		}
	}
   86f70:	e756      	b.n	86e20 <xQueueGenericReceive+0x60>
}
   86f72:	4618      	mov	r0, r3
   86f74:	3728      	adds	r7, #40	; 0x28
   86f76:	46bd      	mov	sp, r7
   86f78:	bd80      	pop	{r7, pc}
   86f7a:	bf00      	nop
   86f7c:	000864f9 	.word	0x000864f9
   86f80:	0008800d 	.word	0x0008800d
   86f84:	0008647d 	.word	0x0008647d
   86f88:	00087169 	.word	0x00087169
   86f8c:	00088221 	.word	0x00088221
   86f90:	00087b35 	.word	0x00087b35
   86f94:	0008645d 	.word	0x0008645d
   86f98:	000864c1 	.word	0x000864c1
   86f9c:	00087bf5 	.word	0x00087bf5
   86fa0:	00087631 	.word	0x00087631
   86fa4:	00087c2d 	.word	0x00087c2d
   86fa8:	00087261 	.word	0x00087261
   86fac:	00088049 	.word	0x00088049
   86fb0:	00087a15 	.word	0x00087a15
   86fb4:	000871b9 	.word	0x000871b9
   86fb8:	0008764d 	.word	0x0008764d

00086fbc <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
{
   86fbc:	b580      	push	{r7, lr}
   86fbe:	b088      	sub	sp, #32
   86fc0:	af00      	add	r7, sp, #0
   86fc2:	60f8      	str	r0, [r7, #12]
   86fc4:	60b9      	str	r1, [r7, #8]
   86fc6:	607a      	str	r2, [r7, #4]
BaseType_t xReturn;
UBaseType_t uxSavedInterruptStatus;
Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   86fc8:	68fb      	ldr	r3, [r7, #12]
   86fca:	61bb      	str	r3, [r7, #24]

	configASSERT( pxQueue );
   86fcc:	69bb      	ldr	r3, [r7, #24]
   86fce:	2b00      	cmp	r3, #0
   86fd0:	d102      	bne.n	86fd8 <xQueueReceiveFromISR+0x1c>
   86fd2:	4b27      	ldr	r3, [pc, #156]	; (87070 <xQueueReceiveFromISR+0xb4>)
   86fd4:	4798      	blx	r3
   86fd6:	e7fe      	b.n	86fd6 <xQueueReceiveFromISR+0x1a>
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
   86fd8:	68bb      	ldr	r3, [r7, #8]
   86fda:	2b00      	cmp	r3, #0
   86fdc:	d103      	bne.n	86fe6 <xQueueReceiveFromISR+0x2a>
   86fde:	69bb      	ldr	r3, [r7, #24]
   86fe0:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   86fe2:	2b00      	cmp	r3, #0
   86fe4:	d101      	bne.n	86fea <xQueueReceiveFromISR+0x2e>
   86fe6:	2301      	movs	r3, #1
   86fe8:	e000      	b.n	86fec <xQueueReceiveFromISR+0x30>
   86fea:	2300      	movs	r3, #0
   86fec:	2b00      	cmp	r3, #0
   86fee:	d102      	bne.n	86ff6 <xQueueReceiveFromISR+0x3a>
   86ff0:	4b1f      	ldr	r3, [pc, #124]	; (87070 <xQueueReceiveFromISR+0xb4>)
   86ff2:	4798      	blx	r3
   86ff4:	e7fe      	b.n	86ff4 <xQueueReceiveFromISR+0x38>
	that have been assigned a priority at or (logically) below the maximum
	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
	safe API to ensure interrupt entry is as fast and as simple as possible.
	More information (albeit Cortex-M specific) is provided on the following
	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
   86ff6:	4b1f      	ldr	r3, [pc, #124]	; (87074 <xQueueReceiveFromISR+0xb8>)
   86ff8:	4798      	blx	r3

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
   86ffa:	4b1d      	ldr	r3, [pc, #116]	; (87070 <xQueueReceiveFromISR+0xb4>)
   86ffc:	4798      	blx	r3
   86ffe:	6178      	str	r0, [r7, #20]
	{
		/* Cannot block in an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   87000:	69bb      	ldr	r3, [r7, #24]
   87002:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   87004:	2b00      	cmp	r3, #0
   87006:	d028      	beq.n	8705a <xQueueReceiveFromISR+0x9e>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
   87008:	69b8      	ldr	r0, [r7, #24]
   8700a:	68b9      	ldr	r1, [r7, #8]
   8700c:	4b1a      	ldr	r3, [pc, #104]	; (87078 <xQueueReceiveFromISR+0xbc>)
   8700e:	4798      	blx	r3
			--( pxQueue->uxMessagesWaiting );
   87010:	69bb      	ldr	r3, [r7, #24]
   87012:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   87014:	1e5a      	subs	r2, r3, #1
   87016:	69bb      	ldr	r3, [r7, #24]
   87018:	639a      	str	r2, [r3, #56]	; 0x38

			/* If the queue is locked the event list will not be modified.
			Instead update the lock count so the task that unlocks the queue
			will know that an ISR has removed data while the queue was
			locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
   8701a:	69bb      	ldr	r3, [r7, #24]
   8701c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8701e:	f1b3 3fff 	cmp.w	r3, #4294967295
   87022:	d112      	bne.n	8704a <xQueueReceiveFromISR+0x8e>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   87024:	69bb      	ldr	r3, [r7, #24]
   87026:	691b      	ldr	r3, [r3, #16]
   87028:	2b00      	cmp	r3, #0
   8702a:	d013      	beq.n	87054 <xQueueReceiveFromISR+0x98>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   8702c:	69bb      	ldr	r3, [r7, #24]
   8702e:	3310      	adds	r3, #16
   87030:	4618      	mov	r0, r3
   87032:	4b12      	ldr	r3, [pc, #72]	; (8707c <xQueueReceiveFromISR+0xc0>)
   87034:	4798      	blx	r3
   87036:	4603      	mov	r3, r0
   87038:	2b00      	cmp	r3, #0
   8703a:	d00b      	beq.n	87054 <xQueueReceiveFromISR+0x98>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
   8703c:	687b      	ldr	r3, [r7, #4]
   8703e:	2b00      	cmp	r3, #0
   87040:	d008      	beq.n	87054 <xQueueReceiveFromISR+0x98>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
   87042:	687b      	ldr	r3, [r7, #4]
   87044:	2201      	movs	r2, #1
   87046:	601a      	str	r2, [r3, #0]
   87048:	e004      	b.n	87054 <xQueueReceiveFromISR+0x98>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
   8704a:	69bb      	ldr	r3, [r7, #24]
   8704c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8704e:	1c5a      	adds	r2, r3, #1
   87050:	69bb      	ldr	r3, [r7, #24]
   87052:	645a      	str	r2, [r3, #68]	; 0x44
			}

			xReturn = pdPASS;
   87054:	2301      	movs	r3, #1
   87056:	61fb      	str	r3, [r7, #28]
   87058:	e001      	b.n	8705e <xQueueReceiveFromISR+0xa2>
		}
		else
		{
			xReturn = pdFAIL;
   8705a:	2300      	movs	r3, #0
   8705c:	61fb      	str	r3, [r7, #28]
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
   8705e:	6978      	ldr	r0, [r7, #20]
   87060:	4b07      	ldr	r3, [pc, #28]	; (87080 <xQueueReceiveFromISR+0xc4>)
   87062:	4798      	blx	r3

	return xReturn;
   87064:	69fb      	ldr	r3, [r7, #28]
}
   87066:	4618      	mov	r0, r3
   87068:	3720      	adds	r7, #32
   8706a:	46bd      	mov	sp, r7
   8706c:	bd80      	pop	{r7, pc}
   8706e:	bf00      	nop
   87070:	000864f9 	.word	0x000864f9
   87074:	000865c1 	.word	0x000865c1
   87078:	00087169 	.word	0x00087169
   8707c:	00087b35 	.word	0x00087b35
   87080:	0008650d 	.word	0x0008650d

00087084 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
   87084:	b580      	push	{r7, lr}
   87086:	b086      	sub	sp, #24
   87088:	af00      	add	r7, sp, #0
   8708a:	60f8      	str	r0, [r7, #12]
   8708c:	60b9      	str	r1, [r7, #8]
   8708e:	607a      	str	r2, [r7, #4]
BaseType_t xReturn = pdFALSE;
   87090:	2300      	movs	r3, #0
   87092:	617b      	str	r3, [r7, #20]

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
   87094:	68fb      	ldr	r3, [r7, #12]
   87096:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   87098:	2b00      	cmp	r3, #0
   8709a:	d10d      	bne.n	870b8 <prvCopyDataToQueue+0x34>
	{
		#if ( configUSE_MUTEXES == 1 )
		{
			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
   8709c:	68fb      	ldr	r3, [r7, #12]
   8709e:	681b      	ldr	r3, [r3, #0]
   870a0:	2b00      	cmp	r3, #0
   870a2:	d152      	bne.n	8714a <prvCopyDataToQueue+0xc6>
			{
				/* The mutex is no longer being held. */
				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
   870a4:	68fb      	ldr	r3, [r7, #12]
   870a6:	685b      	ldr	r3, [r3, #4]
   870a8:	4618      	mov	r0, r3
   870aa:	4b2d      	ldr	r3, [pc, #180]	; (87160 <prvCopyDataToQueue+0xdc>)
   870ac:	4798      	blx	r3
   870ae:	6178      	str	r0, [r7, #20]
				pxQueue->pxMutexHolder = NULL;
   870b0:	68fb      	ldr	r3, [r7, #12]
   870b2:	2200      	movs	r2, #0
   870b4:	605a      	str	r2, [r3, #4]
   870b6:	e048      	b.n	8714a <prvCopyDataToQueue+0xc6>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
   870b8:	687b      	ldr	r3, [r7, #4]
   870ba:	2b00      	cmp	r3, #0
   870bc:	d11a      	bne.n	870f4 <prvCopyDataToQueue+0x70>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
   870be:	68fb      	ldr	r3, [r7, #12]
   870c0:	689a      	ldr	r2, [r3, #8]
   870c2:	68fb      	ldr	r3, [r7, #12]
   870c4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   870c6:	4610      	mov	r0, r2
   870c8:	68b9      	ldr	r1, [r7, #8]
   870ca:	461a      	mov	r2, r3
   870cc:	4b25      	ldr	r3, [pc, #148]	; (87164 <prvCopyDataToQueue+0xe0>)
   870ce:	4798      	blx	r3
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
   870d0:	68fb      	ldr	r3, [r7, #12]
   870d2:	689a      	ldr	r2, [r3, #8]
   870d4:	68fb      	ldr	r3, [r7, #12]
   870d6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   870d8:	441a      	add	r2, r3
   870da:	68fb      	ldr	r3, [r7, #12]
   870dc:	609a      	str	r2, [r3, #8]
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   870de:	68fb      	ldr	r3, [r7, #12]
   870e0:	689a      	ldr	r2, [r3, #8]
   870e2:	68fb      	ldr	r3, [r7, #12]
   870e4:	685b      	ldr	r3, [r3, #4]
   870e6:	429a      	cmp	r2, r3
   870e8:	d32f      	bcc.n	8714a <prvCopyDataToQueue+0xc6>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
   870ea:	68fb      	ldr	r3, [r7, #12]
   870ec:	681a      	ldr	r2, [r3, #0]
   870ee:	68fb      	ldr	r3, [r7, #12]
   870f0:	609a      	str	r2, [r3, #8]
   870f2:	e02a      	b.n	8714a <prvCopyDataToQueue+0xc6>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   870f4:	68fb      	ldr	r3, [r7, #12]
   870f6:	68da      	ldr	r2, [r3, #12]
   870f8:	68fb      	ldr	r3, [r7, #12]
   870fa:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   870fc:	4610      	mov	r0, r2
   870fe:	68b9      	ldr	r1, [r7, #8]
   87100:	461a      	mov	r2, r3
   87102:	4b18      	ldr	r3, [pc, #96]	; (87164 <prvCopyDataToQueue+0xe0>)
   87104:	4798      	blx	r3
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
   87106:	68fb      	ldr	r3, [r7, #12]
   87108:	68da      	ldr	r2, [r3, #12]
   8710a:	68fb      	ldr	r3, [r7, #12]
   8710c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8710e:	425b      	negs	r3, r3
   87110:	441a      	add	r2, r3
   87112:	68fb      	ldr	r3, [r7, #12]
   87114:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
   87116:	68fb      	ldr	r3, [r7, #12]
   87118:	68da      	ldr	r2, [r3, #12]
   8711a:	68fb      	ldr	r3, [r7, #12]
   8711c:	681b      	ldr	r3, [r3, #0]
   8711e:	429a      	cmp	r2, r3
   87120:	d207      	bcs.n	87132 <prvCopyDataToQueue+0xae>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
   87122:	68fb      	ldr	r3, [r7, #12]
   87124:	685a      	ldr	r2, [r3, #4]
   87126:	68fb      	ldr	r3, [r7, #12]
   87128:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   8712a:	425b      	negs	r3, r3
   8712c:	441a      	add	r2, r3
   8712e:	68fb      	ldr	r3, [r7, #12]
   87130:	60da      	str	r2, [r3, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
   87132:	687b      	ldr	r3, [r7, #4]
   87134:	2b02      	cmp	r3, #2
   87136:	d108      	bne.n	8714a <prvCopyDataToQueue+0xc6>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
   87138:	68fb      	ldr	r3, [r7, #12]
   8713a:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8713c:	2b00      	cmp	r3, #0
   8713e:	d004      	beq.n	8714a <prvCopyDataToQueue+0xc6>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
   87140:	68fb      	ldr	r3, [r7, #12]
   87142:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   87144:	1e5a      	subs	r2, r3, #1
   87146:	68fb      	ldr	r3, [r7, #12]
   87148:	639a      	str	r2, [r3, #56]	; 0x38
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
   8714a:	68fb      	ldr	r3, [r7, #12]
   8714c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   8714e:	1c5a      	adds	r2, r3, #1
   87150:	68fb      	ldr	r3, [r7, #12]
   87152:	639a      	str	r2, [r3, #56]	; 0x38

	return xReturn;
   87154:	697b      	ldr	r3, [r7, #20]
}
   87156:	4618      	mov	r0, r3
   87158:	3718      	adds	r7, #24
   8715a:	46bd      	mov	sp, r7
   8715c:	bd80      	pop	{r7, pc}
   8715e:	bf00      	nop
   87160:	0008813d 	.word	0x0008813d
   87164:	0008adb5 	.word	0x0008adb5

00087168 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
   87168:	b580      	push	{r7, lr}
   8716a:	b082      	sub	sp, #8
   8716c:	af00      	add	r7, sp, #0
   8716e:	6078      	str	r0, [r7, #4]
   87170:	6039      	str	r1, [r7, #0]
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
   87172:	687b      	ldr	r3, [r7, #4]
   87174:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   87176:	2b00      	cmp	r3, #0
   87178:	d019      	beq.n	871ae <prvCopyDataFromQueue+0x46>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
   8717a:	687b      	ldr	r3, [r7, #4]
   8717c:	68da      	ldr	r2, [r3, #12]
   8717e:	687b      	ldr	r3, [r7, #4]
   87180:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   87182:	441a      	add	r2, r3
   87184:	687b      	ldr	r3, [r7, #4]
   87186:	60da      	str	r2, [r3, #12]
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
   87188:	687b      	ldr	r3, [r7, #4]
   8718a:	68da      	ldr	r2, [r3, #12]
   8718c:	687b      	ldr	r3, [r7, #4]
   8718e:	685b      	ldr	r3, [r3, #4]
   87190:	429a      	cmp	r2, r3
   87192:	d303      	bcc.n	8719c <prvCopyDataFromQueue+0x34>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
   87194:	687b      	ldr	r3, [r7, #4]
   87196:	681a      	ldr	r2, [r3, #0]
   87198:	687b      	ldr	r3, [r7, #4]
   8719a:	60da      	str	r2, [r3, #12]
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
   8719c:	687b      	ldr	r3, [r7, #4]
   8719e:	68da      	ldr	r2, [r3, #12]
   871a0:	687b      	ldr	r3, [r7, #4]
   871a2:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   871a4:	6838      	ldr	r0, [r7, #0]
   871a6:	4611      	mov	r1, r2
   871a8:	461a      	mov	r2, r3
   871aa:	4b02      	ldr	r3, [pc, #8]	; (871b4 <prvCopyDataFromQueue+0x4c>)
   871ac:	4798      	blx	r3
	}
}
   871ae:	3708      	adds	r7, #8
   871b0:	46bd      	mov	sp, r7
   871b2:	bd80      	pop	{r7, pc}
   871b4:	0008adb5 	.word	0x0008adb5

000871b8 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
   871b8:	b580      	push	{r7, lr}
   871ba:	b082      	sub	sp, #8
   871bc:	af00      	add	r7, sp, #0
   871be:	6078      	str	r0, [r7, #4]

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
   871c0:	4b23      	ldr	r3, [pc, #140]	; (87250 <prvUnlockQueue+0x98>)
   871c2:	4798      	blx	r3
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   871c4:	e014      	b.n	871f0 <prvUnlockQueue+0x38>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
   871c6:	687b      	ldr	r3, [r7, #4]
   871c8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   871ca:	2b00      	cmp	r3, #0
   871cc:	d00a      	beq.n	871e4 <prvUnlockQueue+0x2c>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
   871ce:	687b      	ldr	r3, [r7, #4]
   871d0:	3324      	adds	r3, #36	; 0x24
   871d2:	4618      	mov	r0, r3
   871d4:	4b1f      	ldr	r3, [pc, #124]	; (87254 <prvUnlockQueue+0x9c>)
   871d6:	4798      	blx	r3
   871d8:	4603      	mov	r3, r0
   871da:	2b00      	cmp	r3, #0
   871dc:	d003      	beq.n	871e6 <prvUnlockQueue+0x2e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
   871de:	4b1e      	ldr	r3, [pc, #120]	; (87258 <prvUnlockQueue+0xa0>)
   871e0:	4798      	blx	r3
   871e2:	e000      	b.n	871e6 <prvUnlockQueue+0x2e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				else
				{
					break;
   871e4:	e008      	b.n	871f8 <prvUnlockQueue+0x40>
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
   871e6:	687b      	ldr	r3, [r7, #4]
   871e8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   871ea:	1e5a      	subs	r2, r3, #1
   871ec:	687b      	ldr	r3, [r7, #4]
   871ee:	649a      	str	r2, [r3, #72]	; 0x48
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
   871f0:	687b      	ldr	r3, [r7, #4]
   871f2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   871f4:	2b00      	cmp	r3, #0
   871f6:	dce6      	bgt.n	871c6 <prvUnlockQueue+0xe>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
   871f8:	687b      	ldr	r3, [r7, #4]
   871fa:	f04f 32ff 	mov.w	r2, #4294967295
   871fe:	649a      	str	r2, [r3, #72]	; 0x48
	}
	taskEXIT_CRITICAL();
   87200:	4b16      	ldr	r3, [pc, #88]	; (8725c <prvUnlockQueue+0xa4>)
   87202:	4798      	blx	r3

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
   87204:	4b12      	ldr	r3, [pc, #72]	; (87250 <prvUnlockQueue+0x98>)
   87206:	4798      	blx	r3
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   87208:	e014      	b.n	87234 <prvUnlockQueue+0x7c>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
   8720a:	687b      	ldr	r3, [r7, #4]
   8720c:	691b      	ldr	r3, [r3, #16]
   8720e:	2b00      	cmp	r3, #0
   87210:	d00f      	beq.n	87232 <prvUnlockQueue+0x7a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
   87212:	687b      	ldr	r3, [r7, #4]
   87214:	3310      	adds	r3, #16
   87216:	4618      	mov	r0, r3
   87218:	4b0e      	ldr	r3, [pc, #56]	; (87254 <prvUnlockQueue+0x9c>)
   8721a:	4798      	blx	r3
   8721c:	4603      	mov	r3, r0
   8721e:	2b00      	cmp	r3, #0
   87220:	d001      	beq.n	87226 <prvUnlockQueue+0x6e>
				{
					vTaskMissedYield();
   87222:	4b0d      	ldr	r3, [pc, #52]	; (87258 <prvUnlockQueue+0xa0>)
   87224:	4798      	blx	r3
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
   87226:	687b      	ldr	r3, [r7, #4]
   87228:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8722a:	1e5a      	subs	r2, r3, #1
   8722c:	687b      	ldr	r3, [r7, #4]
   8722e:	645a      	str	r2, [r3, #68]	; 0x44
   87230:	e000      	b.n	87234 <prvUnlockQueue+0x7c>
			}
			else
			{
				break;
   87232:	e003      	b.n	8723c <prvUnlockQueue+0x84>
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
   87234:	687b      	ldr	r3, [r7, #4]
   87236:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   87238:	2b00      	cmp	r3, #0
   8723a:	dce6      	bgt.n	8720a <prvUnlockQueue+0x52>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
   8723c:	687b      	ldr	r3, [r7, #4]
   8723e:	f04f 32ff 	mov.w	r2, #4294967295
   87242:	645a      	str	r2, [r3, #68]	; 0x44
	}
	taskEXIT_CRITICAL();
   87244:	4b05      	ldr	r3, [pc, #20]	; (8725c <prvUnlockQueue+0xa4>)
   87246:	4798      	blx	r3
}
   87248:	3708      	adds	r7, #8
   8724a:	46bd      	mov	sp, r7
   8724c:	bd80      	pop	{r7, pc}
   8724e:	bf00      	nop
   87250:	0008647d 	.word	0x0008647d
   87254:	00087b35 	.word	0x00087b35
   87258:	00087cdd 	.word	0x00087cdd
   8725c:	000864c1 	.word	0x000864c1

00087260 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
   87260:	b580      	push	{r7, lr}
   87262:	b084      	sub	sp, #16
   87264:	af00      	add	r7, sp, #0
   87266:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   87268:	4b08      	ldr	r3, [pc, #32]	; (8728c <prvIsQueueEmpty+0x2c>)
   8726a:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
   8726c:	687b      	ldr	r3, [r7, #4]
   8726e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   87270:	2b00      	cmp	r3, #0
   87272:	d102      	bne.n	8727a <prvIsQueueEmpty+0x1a>
		{
			xReturn = pdTRUE;
   87274:	2301      	movs	r3, #1
   87276:	60fb      	str	r3, [r7, #12]
   87278:	e001      	b.n	8727e <prvIsQueueEmpty+0x1e>
		}
		else
		{
			xReturn = pdFALSE;
   8727a:	2300      	movs	r3, #0
   8727c:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   8727e:	4b04      	ldr	r3, [pc, #16]	; (87290 <prvIsQueueEmpty+0x30>)
   87280:	4798      	blx	r3

	return xReturn;
   87282:	68fb      	ldr	r3, [r7, #12]
}
   87284:	4618      	mov	r0, r3
   87286:	3710      	adds	r7, #16
   87288:	46bd      	mov	sp, r7
   8728a:	bd80      	pop	{r7, pc}
   8728c:	0008647d 	.word	0x0008647d
   87290:	000864c1 	.word	0x000864c1

00087294 <prvIsQueueFull>:
	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
/*-----------------------------------------------------------*/

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
   87294:	b580      	push	{r7, lr}
   87296:	b084      	sub	sp, #16
   87298:	af00      	add	r7, sp, #0
   8729a:	6078      	str	r0, [r7, #4]
BaseType_t xReturn;

	taskENTER_CRITICAL();
   8729c:	4b09      	ldr	r3, [pc, #36]	; (872c4 <prvIsQueueFull+0x30>)
   8729e:	4798      	blx	r3
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
   872a0:	687b      	ldr	r3, [r7, #4]
   872a2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
   872a4:	687b      	ldr	r3, [r7, #4]
   872a6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
   872a8:	429a      	cmp	r2, r3
   872aa:	d102      	bne.n	872b2 <prvIsQueueFull+0x1e>
		{
			xReturn = pdTRUE;
   872ac:	2301      	movs	r3, #1
   872ae:	60fb      	str	r3, [r7, #12]
   872b0:	e001      	b.n	872b6 <prvIsQueueFull+0x22>
		}
		else
		{
			xReturn = pdFALSE;
   872b2:	2300      	movs	r3, #0
   872b4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   872b6:	4b04      	ldr	r3, [pc, #16]	; (872c8 <prvIsQueueFull+0x34>)
   872b8:	4798      	blx	r3

	return xReturn;
   872ba:	68fb      	ldr	r3, [r7, #12]
}
   872bc:	4618      	mov	r0, r3
   872be:	3710      	adds	r7, #16
   872c0:	46bd      	mov	sp, r7
   872c2:	bd80      	pop	{r7, pc}
   872c4:	0008647d 	.word	0x0008647d
   872c8:	000864c1 	.word	0x000864c1

000872cc <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait )
	{
   872cc:	b580      	push	{r7, lr}
   872ce:	b084      	sub	sp, #16
   872d0:	af00      	add	r7, sp, #0
   872d2:	6078      	str	r0, [r7, #4]
   872d4:	6039      	str	r1, [r7, #0]
	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
   872d6:	687b      	ldr	r3, [r7, #4]
   872d8:	60fb      	str	r3, [r7, #12]
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
   872da:	4b12      	ldr	r3, [pc, #72]	; (87324 <vQueueWaitForMessageRestricted+0x58>)
   872dc:	4798      	blx	r3
   872de:	68fb      	ldr	r3, [r7, #12]
   872e0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   872e2:	f1b3 3fff 	cmp.w	r3, #4294967295
   872e6:	d102      	bne.n	872ee <vQueueWaitForMessageRestricted+0x22>
   872e8:	68fb      	ldr	r3, [r7, #12]
   872ea:	2200      	movs	r2, #0
   872ec:	645a      	str	r2, [r3, #68]	; 0x44
   872ee:	68fb      	ldr	r3, [r7, #12]
   872f0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
   872f2:	f1b3 3fff 	cmp.w	r3, #4294967295
   872f6:	d102      	bne.n	872fe <vQueueWaitForMessageRestricted+0x32>
   872f8:	68fb      	ldr	r3, [r7, #12]
   872fa:	2200      	movs	r2, #0
   872fc:	649a      	str	r2, [r3, #72]	; 0x48
   872fe:	4b0a      	ldr	r3, [pc, #40]	; (87328 <vQueueWaitForMessageRestricted+0x5c>)
   87300:	4798      	blx	r3
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
   87302:	68fb      	ldr	r3, [r7, #12]
   87304:	6b9b      	ldr	r3, [r3, #56]	; 0x38
   87306:	2b00      	cmp	r3, #0
   87308:	d105      	bne.n	87316 <vQueueWaitForMessageRestricted+0x4a>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
   8730a:	68fb      	ldr	r3, [r7, #12]
   8730c:	3324      	adds	r3, #36	; 0x24
   8730e:	4618      	mov	r0, r3
   87310:	6839      	ldr	r1, [r7, #0]
   87312:	4b06      	ldr	r3, [pc, #24]	; (8732c <vQueueWaitForMessageRestricted+0x60>)
   87314:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
   87316:	68f8      	ldr	r0, [r7, #12]
   87318:	4b05      	ldr	r3, [pc, #20]	; (87330 <vQueueWaitForMessageRestricted+0x64>)
   8731a:	4798      	blx	r3
	}
   8731c:	3710      	adds	r7, #16
   8731e:	46bd      	mov	sp, r7
   87320:	bd80      	pop	{r7, pc}
   87322:	bf00      	nop
   87324:	0008647d 	.word	0x0008647d
   87328:	000864c1 	.word	0x000864c1
   8732c:	00087ab5 	.word	0x00087ab5
   87330:	000871b9 	.word	0x000871b9

00087334 <xTaskGenericCreate>:
static void prvResetNextTaskUnblockTime( void );

/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   87334:	b590      	push	{r4, r7, lr}
   87336:	b08b      	sub	sp, #44	; 0x2c
   87338:	af02      	add	r7, sp, #8
   8733a:	60f8      	str	r0, [r7, #12]
   8733c:	60b9      	str	r1, [r7, #8]
   8733e:	603b      	str	r3, [r7, #0]
   87340:	4613      	mov	r3, r2
   87342:	80fb      	strh	r3, [r7, #6]
BaseType_t xReturn;
TCB_t * pxNewTCB;

	configASSERT( pxTaskCode );
   87344:	68fb      	ldr	r3, [r7, #12]
   87346:	2b00      	cmp	r3, #0
   87348:	d102      	bne.n	87350 <xTaskGenericCreate+0x1c>
   8734a:	4b4b      	ldr	r3, [pc, #300]	; (87478 <xTaskGenericCreate+0x144>)
   8734c:	4798      	blx	r3
   8734e:	e7fe      	b.n	8734e <xTaskGenericCreate+0x1a>
	configASSERT( ( ( uxPriority & ( ~portPRIVILEGE_BIT ) ) < configMAX_PRIORITIES ) );
   87350:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   87352:	2b04      	cmp	r3, #4
   87354:	d902      	bls.n	8735c <xTaskGenericCreate+0x28>
   87356:	4b48      	ldr	r3, [pc, #288]	; (87478 <xTaskGenericCreate+0x144>)
   87358:	4798      	blx	r3
   8735a:	e7fe      	b.n	8735a <xTaskGenericCreate+0x26>

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
   8735c:	88fb      	ldrh	r3, [r7, #6]
   8735e:	4618      	mov	r0, r3
   87360:	6bb9      	ldr	r1, [r7, #56]	; 0x38
   87362:	4b46      	ldr	r3, [pc, #280]	; (8747c <xTaskGenericCreate+0x148>)
   87364:	4798      	blx	r3
   87366:	61b8      	str	r0, [r7, #24]

	if( pxNewTCB != NULL )
   87368:	69bb      	ldr	r3, [r7, #24]
   8736a:	2b00      	cmp	r3, #0
   8736c:	d06d      	beq.n	8744a <xTaskGenericCreate+0x116>
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
   8736e:	69bb      	ldr	r3, [r7, #24]
   87370:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   87372:	88fb      	ldrh	r3, [r7, #6]
   87374:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
   87378:	3b01      	subs	r3, #1
   8737a:	009b      	lsls	r3, r3, #2
   8737c:	4413      	add	r3, r2
   8737e:	617b      	str	r3, [r7, #20]
			pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK  ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
   87380:	697b      	ldr	r3, [r7, #20]
   87382:	f023 0307 	bic.w	r3, r3, #7
   87386:	617b      	str	r3, [r7, #20]

			/* Check the alignment of the calculated top of stack is correct. */
			configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
   87388:	697b      	ldr	r3, [r7, #20]
   8738a:	f003 0307 	and.w	r3, r3, #7
   8738e:	2b00      	cmp	r3, #0
   87390:	d002      	beq.n	87398 <xTaskGenericCreate+0x64>
   87392:	4b39      	ldr	r3, [pc, #228]	; (87478 <xTaskGenericCreate+0x144>)
   87394:	4798      	blx	r3
   87396:	e7fe      	b.n	87396 <xTaskGenericCreate+0x62>
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif /* portSTACK_GROWTH */

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
   87398:	88fb      	ldrh	r3, [r7, #6]
   8739a:	9300      	str	r3, [sp, #0]
   8739c:	69b8      	ldr	r0, [r7, #24]
   8739e:	68b9      	ldr	r1, [r7, #8]
   873a0:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   873a2:	6bfb      	ldr	r3, [r7, #60]	; 0x3c
   873a4:	4c36      	ldr	r4, [pc, #216]	; (87480 <xTaskGenericCreate+0x14c>)
   873a6:	47a0      	blx	r4
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
   873a8:	6978      	ldr	r0, [r7, #20]
   873aa:	68f9      	ldr	r1, [r7, #12]
   873ac:	683a      	ldr	r2, [r7, #0]
   873ae:	4b35      	ldr	r3, [pc, #212]	; (87484 <xTaskGenericCreate+0x150>)
   873b0:	4798      	blx	r3
   873b2:	4602      	mov	r2, r0
   873b4:	69bb      	ldr	r3, [r7, #24]
   873b6:	601a      	str	r2, [r3, #0]
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
   873b8:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   873ba:	2b00      	cmp	r3, #0
   873bc:	d002      	beq.n	873c4 <xTaskGenericCreate+0x90>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
   873be:	6b7b      	ldr	r3, [r7, #52]	; 0x34
   873c0:	69ba      	ldr	r2, [r7, #24]
   873c2:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
   873c4:	4b30      	ldr	r3, [pc, #192]	; (87488 <xTaskGenericCreate+0x154>)
   873c6:	4798      	blx	r3
		{
			uxCurrentNumberOfTasks++;
   873c8:	4b30      	ldr	r3, [pc, #192]	; (8748c <xTaskGenericCreate+0x158>)
   873ca:	681b      	ldr	r3, [r3, #0]
   873cc:	1c5a      	adds	r2, r3, #1
   873ce:	4b2f      	ldr	r3, [pc, #188]	; (8748c <xTaskGenericCreate+0x158>)
   873d0:	601a      	str	r2, [r3, #0]
			if( pxCurrentTCB == NULL )
   873d2:	4b2f      	ldr	r3, [pc, #188]	; (87490 <xTaskGenericCreate+0x15c>)
   873d4:	681b      	ldr	r3, [r3, #0]
   873d6:	2b00      	cmp	r3, #0
   873d8:	d109      	bne.n	873ee <xTaskGenericCreate+0xba>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
   873da:	4b2d      	ldr	r3, [pc, #180]	; (87490 <xTaskGenericCreate+0x15c>)
   873dc:	69ba      	ldr	r2, [r7, #24]
   873de:	601a      	str	r2, [r3, #0]

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
   873e0:	4b2a      	ldr	r3, [pc, #168]	; (8748c <xTaskGenericCreate+0x158>)
   873e2:	681b      	ldr	r3, [r3, #0]
   873e4:	2b01      	cmp	r3, #1
   873e6:	d10f      	bne.n	87408 <xTaskGenericCreate+0xd4>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
   873e8:	4b2a      	ldr	r3, [pc, #168]	; (87494 <xTaskGenericCreate+0x160>)
   873ea:	4798      	blx	r3
   873ec:	e00c      	b.n	87408 <xTaskGenericCreate+0xd4>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
   873ee:	4b2a      	ldr	r3, [pc, #168]	; (87498 <xTaskGenericCreate+0x164>)
   873f0:	681b      	ldr	r3, [r3, #0]
   873f2:	2b00      	cmp	r3, #0
   873f4:	d108      	bne.n	87408 <xTaskGenericCreate+0xd4>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
   873f6:	4b26      	ldr	r3, [pc, #152]	; (87490 <xTaskGenericCreate+0x15c>)
   873f8:	681b      	ldr	r3, [r3, #0]
   873fa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   873fc:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   873fe:	429a      	cmp	r2, r3
   87400:	d802      	bhi.n	87408 <xTaskGenericCreate+0xd4>
					{
						pxCurrentTCB = pxNewTCB;
   87402:	4b23      	ldr	r3, [pc, #140]	; (87490 <xTaskGenericCreate+0x15c>)
   87404:	69ba      	ldr	r2, [r7, #24]
   87406:	601a      	str	r2, [r3, #0]
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
   87408:	4b24      	ldr	r3, [pc, #144]	; (8749c <xTaskGenericCreate+0x168>)
   8740a:	681b      	ldr	r3, [r3, #0]
   8740c:	1c5a      	adds	r2, r3, #1
   8740e:	4b23      	ldr	r3, [pc, #140]	; (8749c <xTaskGenericCreate+0x168>)
   87410:	601a      	str	r2, [r3, #0]
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
   87412:	69bb      	ldr	r3, [r7, #24]
   87414:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87416:	2201      	movs	r2, #1
   87418:	409a      	lsls	r2, r3
   8741a:	4b21      	ldr	r3, [pc, #132]	; (874a0 <xTaskGenericCreate+0x16c>)
   8741c:	681b      	ldr	r3, [r3, #0]
   8741e:	431a      	orrs	r2, r3
   87420:	4b1f      	ldr	r3, [pc, #124]	; (874a0 <xTaskGenericCreate+0x16c>)
   87422:	601a      	str	r2, [r3, #0]
   87424:	69bb      	ldr	r3, [r7, #24]
   87426:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   87428:	4613      	mov	r3, r2
   8742a:	009b      	lsls	r3, r3, #2
   8742c:	4413      	add	r3, r2
   8742e:	009b      	lsls	r3, r3, #2
   87430:	4a1c      	ldr	r2, [pc, #112]	; (874a4 <xTaskGenericCreate+0x170>)
   87432:	441a      	add	r2, r3
   87434:	69bb      	ldr	r3, [r7, #24]
   87436:	3304      	adds	r3, #4
   87438:	4610      	mov	r0, r2
   8743a:	4619      	mov	r1, r3
   8743c:	4b1a      	ldr	r3, [pc, #104]	; (874a8 <xTaskGenericCreate+0x174>)
   8743e:	4798      	blx	r3

			xReturn = pdPASS;
   87440:	2301      	movs	r3, #1
   87442:	61fb      	str	r3, [r7, #28]
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
   87444:	4b19      	ldr	r3, [pc, #100]	; (874ac <xTaskGenericCreate+0x178>)
   87446:	4798      	blx	r3
   87448:	e002      	b.n	87450 <xTaskGenericCreate+0x11c>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
   8744a:	f04f 33ff 	mov.w	r3, #4294967295
   8744e:	61fb      	str	r3, [r7, #28]
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
   87450:	69fb      	ldr	r3, [r7, #28]
   87452:	2b01      	cmp	r3, #1
   87454:	d10b      	bne.n	8746e <xTaskGenericCreate+0x13a>
	{
		if( xSchedulerRunning != pdFALSE )
   87456:	4b10      	ldr	r3, [pc, #64]	; (87498 <xTaskGenericCreate+0x164>)
   87458:	681b      	ldr	r3, [r3, #0]
   8745a:	2b00      	cmp	r3, #0
   8745c:	d007      	beq.n	8746e <xTaskGenericCreate+0x13a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
   8745e:	4b0c      	ldr	r3, [pc, #48]	; (87490 <xTaskGenericCreate+0x15c>)
   87460:	681b      	ldr	r3, [r3, #0]
   87462:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   87464:	6b3b      	ldr	r3, [r7, #48]	; 0x30
   87466:	429a      	cmp	r2, r3
   87468:	d201      	bcs.n	8746e <xTaskGenericCreate+0x13a>
			{
				taskYIELD_IF_USING_PREEMPTION();
   8746a:	4b11      	ldr	r3, [pc, #68]	; (874b0 <xTaskGenericCreate+0x17c>)
   8746c:	4798      	blx	r3
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
   8746e:	69fb      	ldr	r3, [r7, #28]
}
   87470:	4618      	mov	r0, r3
   87472:	3724      	adds	r7, #36	; 0x24
   87474:	46bd      	mov	sp, r7
   87476:	bd90      	pop	{r4, r7, pc}
   87478:	000864f9 	.word	0x000864f9
   8747c:	00087f31 	.word	0x00087f31
   87480:	00087d1d 	.word	0x00087d1d
   87484:	000862d5 	.word	0x000862d5
   87488:	0008647d 	.word	0x0008647d
   8748c:	2007ad48 	.word	0x2007ad48
   87490:	2007ac70 	.word	0x2007ac70
   87494:	00087db5 	.word	0x00087db5
   87498:	2007ad54 	.word	0x2007ad54
   8749c:	2007ad64 	.word	0x2007ad64
   874a0:	2007ad50 	.word	0x2007ad50
   874a4:	2007ac74 	.word	0x2007ac74
   874a8:	000861c9 	.word	0x000861c9
   874ac:	000864c1 	.word	0x000864c1
   874b0:	0008645d 	.word	0x0008645d

000874b4 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
   874b4:	b580      	push	{r7, lr}
   874b6:	b086      	sub	sp, #24
   874b8:	af00      	add	r7, sp, #0
   874ba:	6078      	str	r0, [r7, #4]
   874bc:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
   874be:	2300      	movs	r3, #0
   874c0:	617b      	str	r3, [r7, #20]

		configASSERT( pxPreviousWakeTime );
   874c2:	687b      	ldr	r3, [r7, #4]
   874c4:	2b00      	cmp	r3, #0
   874c6:	d102      	bne.n	874ce <vTaskDelayUntil+0x1a>
   874c8:	4b2f      	ldr	r3, [pc, #188]	; (87588 <vTaskDelayUntil+0xd4>)
   874ca:	4798      	blx	r3
   874cc:	e7fe      	b.n	874cc <vTaskDelayUntil+0x18>
		configASSERT( ( xTimeIncrement > 0U ) );
   874ce:	683b      	ldr	r3, [r7, #0]
   874d0:	2b00      	cmp	r3, #0
   874d2:	d102      	bne.n	874da <vTaskDelayUntil+0x26>
   874d4:	4b2c      	ldr	r3, [pc, #176]	; (87588 <vTaskDelayUntil+0xd4>)
   874d6:	4798      	blx	r3
   874d8:	e7fe      	b.n	874d8 <vTaskDelayUntil+0x24>
		configASSERT( uxSchedulerSuspended == 0 );
   874da:	4b2c      	ldr	r3, [pc, #176]	; (8758c <vTaskDelayUntil+0xd8>)
   874dc:	681b      	ldr	r3, [r3, #0]
   874de:	2b00      	cmp	r3, #0
   874e0:	d002      	beq.n	874e8 <vTaskDelayUntil+0x34>
   874e2:	4b29      	ldr	r3, [pc, #164]	; (87588 <vTaskDelayUntil+0xd4>)
   874e4:	4798      	blx	r3
   874e6:	e7fe      	b.n	874e6 <vTaskDelayUntil+0x32>

		vTaskSuspendAll();
   874e8:	4b29      	ldr	r3, [pc, #164]	; (87590 <vTaskDelayUntil+0xdc>)
   874ea:	4798      	blx	r3
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
   874ec:	4b29      	ldr	r3, [pc, #164]	; (87594 <vTaskDelayUntil+0xe0>)
   874ee:	681b      	ldr	r3, [r3, #0]
   874f0:	613b      	str	r3, [r7, #16]

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
   874f2:	687b      	ldr	r3, [r7, #4]
   874f4:	681a      	ldr	r2, [r3, #0]
   874f6:	683b      	ldr	r3, [r7, #0]
   874f8:	4413      	add	r3, r2
   874fa:	60fb      	str	r3, [r7, #12]

			if( xConstTickCount < *pxPreviousWakeTime )
   874fc:	687b      	ldr	r3, [r7, #4]
   874fe:	681a      	ldr	r2, [r3, #0]
   87500:	693b      	ldr	r3, [r7, #16]
   87502:	429a      	cmp	r2, r3
   87504:	d90b      	bls.n	8751e <vTaskDelayUntil+0x6a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
   87506:	687b      	ldr	r3, [r7, #4]
   87508:	681a      	ldr	r2, [r3, #0]
   8750a:	68fb      	ldr	r3, [r7, #12]
   8750c:	429a      	cmp	r2, r3
   8750e:	d911      	bls.n	87534 <vTaskDelayUntil+0x80>
   87510:	68fa      	ldr	r2, [r7, #12]
   87512:	693b      	ldr	r3, [r7, #16]
   87514:	429a      	cmp	r2, r3
   87516:	d90d      	bls.n	87534 <vTaskDelayUntil+0x80>
				{
					xShouldDelay = pdTRUE;
   87518:	2301      	movs	r3, #1
   8751a:	617b      	str	r3, [r7, #20]
   8751c:	e00a      	b.n	87534 <vTaskDelayUntil+0x80>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
   8751e:	687b      	ldr	r3, [r7, #4]
   87520:	681a      	ldr	r2, [r3, #0]
   87522:	68fb      	ldr	r3, [r7, #12]
   87524:	429a      	cmp	r2, r3
   87526:	d803      	bhi.n	87530 <vTaskDelayUntil+0x7c>
   87528:	68fa      	ldr	r2, [r7, #12]
   8752a:	693b      	ldr	r3, [r7, #16]
   8752c:	429a      	cmp	r2, r3
   8752e:	d901      	bls.n	87534 <vTaskDelayUntil+0x80>
				{
					xShouldDelay = pdTRUE;
   87530:	2301      	movs	r3, #1
   87532:	617b      	str	r3, [r7, #20]
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
   87534:	687b      	ldr	r3, [r7, #4]
   87536:	68fa      	ldr	r2, [r7, #12]
   87538:	601a      	str	r2, [r3, #0]

			if( xShouldDelay != pdFALSE )
   8753a:	697b      	ldr	r3, [r7, #20]
   8753c:	2b00      	cmp	r3, #0
   8753e:	d017      	beq.n	87570 <vTaskDelayUntil+0xbc>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   87540:	4b15      	ldr	r3, [pc, #84]	; (87598 <vTaskDelayUntil+0xe4>)
   87542:	681b      	ldr	r3, [r3, #0]
   87544:	3304      	adds	r3, #4
   87546:	4618      	mov	r0, r3
   87548:	4b14      	ldr	r3, [pc, #80]	; (8759c <vTaskDelayUntil+0xe8>)
   8754a:	4798      	blx	r3
   8754c:	4603      	mov	r3, r0
   8754e:	2b00      	cmp	r3, #0
   87550:	d10b      	bne.n	8756a <vTaskDelayUntil+0xb6>
				{
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   87552:	4b11      	ldr	r3, [pc, #68]	; (87598 <vTaskDelayUntil+0xe4>)
   87554:	681b      	ldr	r3, [r3, #0]
   87556:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87558:	2201      	movs	r2, #1
   8755a:	fa02 f303 	lsl.w	r3, r2, r3
   8755e:	43da      	mvns	r2, r3
   87560:	4b0f      	ldr	r3, [pc, #60]	; (875a0 <vTaskDelayUntil+0xec>)
   87562:	681b      	ldr	r3, [r3, #0]
   87564:	401a      	ands	r2, r3
   87566:	4b0e      	ldr	r3, [pc, #56]	; (875a0 <vTaskDelayUntil+0xec>)
   87568:	601a      	str	r2, [r3, #0]
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
   8756a:	68f8      	ldr	r0, [r7, #12]
   8756c:	4b0d      	ldr	r3, [pc, #52]	; (875a4 <vTaskDelayUntil+0xf0>)
   8756e:	4798      	blx	r3
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
   87570:	4b0d      	ldr	r3, [pc, #52]	; (875a8 <vTaskDelayUntil+0xf4>)
   87572:	4798      	blx	r3
   87574:	60b8      	str	r0, [r7, #8]

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
   87576:	68bb      	ldr	r3, [r7, #8]
   87578:	2b00      	cmp	r3, #0
   8757a:	d101      	bne.n	87580 <vTaskDelayUntil+0xcc>
		{
			portYIELD_WITHIN_API();
   8757c:	4b0b      	ldr	r3, [pc, #44]	; (875ac <vTaskDelayUntil+0xf8>)
   8757e:	4798      	blx	r3
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   87580:	3718      	adds	r7, #24
   87582:	46bd      	mov	sp, r7
   87584:	bd80      	pop	{r7, pc}
   87586:	bf00      	nop
   87588:	000864f9 	.word	0x000864f9
   8758c:	2007ad68 	.word	0x2007ad68
   87590:	00087631 	.word	0x00087631
   87594:	2007ad4c 	.word	0x2007ad4c
   87598:	2007ac70 	.word	0x2007ac70
   8759c:	00086281 	.word	0x00086281
   875a0:	2007ad50 	.word	0x2007ad50
   875a4:	00087ec1 	.word	0x00087ec1
   875a8:	0008764d 	.word	0x0008764d
   875ac:	0008645d 	.word	0x0008645d

000875b0 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
   875b0:	b590      	push	{r4, r7, lr}
   875b2:	b087      	sub	sp, #28
   875b4:	af04      	add	r7, sp, #16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
   875b6:	2300      	movs	r3, #0
   875b8:	9300      	str	r3, [sp, #0]
   875ba:	2300      	movs	r3, #0
   875bc:	9301      	str	r3, [sp, #4]
   875be:	2300      	movs	r3, #0
   875c0:	9302      	str	r3, [sp, #8]
   875c2:	2300      	movs	r3, #0
   875c4:	9303      	str	r3, [sp, #12]
   875c6:	4812      	ldr	r0, [pc, #72]	; (87610 <vTaskStartScheduler+0x60>)
   875c8:	4912      	ldr	r1, [pc, #72]	; (87614 <vTaskStartScheduler+0x64>)
   875ca:	2282      	movs	r2, #130	; 0x82
   875cc:	2300      	movs	r3, #0
   875ce:	4c12      	ldr	r4, [pc, #72]	; (87618 <vTaskStartScheduler+0x68>)
   875d0:	47a0      	blx	r4
   875d2:	6078      	str	r0, [r7, #4]
	}
	#endif /* INCLUDE_xTaskGetIdleTaskHandle */

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
   875d4:	687b      	ldr	r3, [r7, #4]
   875d6:	2b01      	cmp	r3, #1
   875d8:	d102      	bne.n	875e0 <vTaskStartScheduler+0x30>
		{
			xReturn = xTimerCreateTimerTask();
   875da:	4b10      	ldr	r3, [pc, #64]	; (8761c <vTaskStartScheduler+0x6c>)
   875dc:	4798      	blx	r3
   875de:	6078      	str	r0, [r7, #4]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
   875e0:	687b      	ldr	r3, [r7, #4]
   875e2:	2b01      	cmp	r3, #1
   875e4:	d10a      	bne.n	875fc <vTaskStartScheduler+0x4c>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
   875e6:	4b0e      	ldr	r3, [pc, #56]	; (87620 <vTaskStartScheduler+0x70>)
   875e8:	4798      	blx	r3
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xSchedulerRunning = pdTRUE;
   875ea:	4b0e      	ldr	r3, [pc, #56]	; (87624 <vTaskStartScheduler+0x74>)
   875ec:	2201      	movs	r2, #1
   875ee:	601a      	str	r2, [r3, #0]
		xTickCount = ( TickType_t ) 0U;
   875f0:	4b0d      	ldr	r3, [pc, #52]	; (87628 <vTaskStartScheduler+0x78>)
   875f2:	2200      	movs	r2, #0
   875f4:	601a      	str	r2, [r3, #0]
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
   875f6:	4b0d      	ldr	r3, [pc, #52]	; (8762c <vTaskStartScheduler+0x7c>)
   875f8:	4798      	blx	r3
   875fa:	e005      	b.n	87608 <vTaskStartScheduler+0x58>
	else
	{
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
   875fc:	687b      	ldr	r3, [r7, #4]
   875fe:	2b00      	cmp	r3, #0
   87600:	d102      	bne.n	87608 <vTaskStartScheduler+0x58>
   87602:	4b07      	ldr	r3, [pc, #28]	; (87620 <vTaskStartScheduler+0x70>)
   87604:	4798      	blx	r3
   87606:	e7fe      	b.n	87606 <vTaskStartScheduler+0x56>
	}
}
   87608:	370c      	adds	r7, #12
   8760a:	46bd      	mov	sp, r7
   8760c:	bd90      	pop	{r4, r7, pc}
   8760e:	bf00      	nop
   87610:	00087cf5 	.word	0x00087cf5
   87614:	0008b16c 	.word	0x0008b16c
   87618:	00087335 	.word	0x00087335
   8761c:	00088249 	.word	0x00088249
   87620:	000864f9 	.word	0x000864f9
   87624:	2007ad54 	.word	0x2007ad54
   87628:	2007ad4c 	.word	0x2007ad4c
   8762c:	00086395 	.word	0x00086395

00087630 <vTaskSuspendAll>:
	vPortEndScheduler();
}
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
   87630:	b480      	push	{r7}
   87632:	af00      	add	r7, sp, #0
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
   87634:	4b04      	ldr	r3, [pc, #16]	; (87648 <vTaskSuspendAll+0x18>)
   87636:	681b      	ldr	r3, [r3, #0]
   87638:	1c5a      	adds	r2, r3, #1
   8763a:	4b03      	ldr	r3, [pc, #12]	; (87648 <vTaskSuspendAll+0x18>)
   8763c:	601a      	str	r2, [r3, #0]
}
   8763e:	46bd      	mov	sp, r7
   87640:	f85d 7b04 	ldr.w	r7, [sp], #4
   87644:	4770      	bx	lr
   87646:	bf00      	nop
   87648:	2007ad68 	.word	0x2007ad68

0008764c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
   8764c:	b580      	push	{r7, lr}
   8764e:	b082      	sub	sp, #8
   87650:	af00      	add	r7, sp, #0
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
   87652:	2300      	movs	r3, #0
   87654:	607b      	str	r3, [r7, #4]

	/* If uxSchedulerSuspended is zero then this function does not match a
	previous call to vTaskSuspendAll(). */
	configASSERT( uxSchedulerSuspended );
   87656:	4b37      	ldr	r3, [pc, #220]	; (87734 <xTaskResumeAll+0xe8>)
   87658:	681b      	ldr	r3, [r3, #0]
   8765a:	2b00      	cmp	r3, #0
   8765c:	d102      	bne.n	87664 <xTaskResumeAll+0x18>
   8765e:	4b36      	ldr	r3, [pc, #216]	; (87738 <xTaskResumeAll+0xec>)
   87660:	4798      	blx	r3
   87662:	e7fe      	b.n	87662 <xTaskResumeAll+0x16>
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
   87664:	4b35      	ldr	r3, [pc, #212]	; (8773c <xTaskResumeAll+0xf0>)
   87666:	4798      	blx	r3
	{
		--uxSchedulerSuspended;
   87668:	4b32      	ldr	r3, [pc, #200]	; (87734 <xTaskResumeAll+0xe8>)
   8766a:	681b      	ldr	r3, [r3, #0]
   8766c:	1e5a      	subs	r2, r3, #1
   8766e:	4b31      	ldr	r3, [pc, #196]	; (87734 <xTaskResumeAll+0xe8>)
   87670:	601a      	str	r2, [r3, #0]

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   87672:	4b30      	ldr	r3, [pc, #192]	; (87734 <xTaskResumeAll+0xe8>)
   87674:	681b      	ldr	r3, [r3, #0]
   87676:	2b00      	cmp	r3, #0
   87678:	d155      	bne.n	87726 <xTaskResumeAll+0xda>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
   8767a:	4b31      	ldr	r3, [pc, #196]	; (87740 <xTaskResumeAll+0xf4>)
   8767c:	681b      	ldr	r3, [r3, #0]
   8767e:	2b00      	cmp	r3, #0
   87680:	d051      	beq.n	87726 <xTaskResumeAll+0xda>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   87682:	e02e      	b.n	876e2 <xTaskResumeAll+0x96>
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
   87684:	4b2f      	ldr	r3, [pc, #188]	; (87744 <xTaskResumeAll+0xf8>)
   87686:	68db      	ldr	r3, [r3, #12]
   87688:	68db      	ldr	r3, [r3, #12]
   8768a:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   8768c:	683b      	ldr	r3, [r7, #0]
   8768e:	3318      	adds	r3, #24
   87690:	4618      	mov	r0, r3
   87692:	4b2d      	ldr	r3, [pc, #180]	; (87748 <xTaskResumeAll+0xfc>)
   87694:	4798      	blx	r3
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   87696:	683b      	ldr	r3, [r7, #0]
   87698:	3304      	adds	r3, #4
   8769a:	4618      	mov	r0, r3
   8769c:	4b2a      	ldr	r3, [pc, #168]	; (87748 <xTaskResumeAll+0xfc>)
   8769e:	4798      	blx	r3
					prvAddTaskToReadyList( pxTCB );
   876a0:	683b      	ldr	r3, [r7, #0]
   876a2:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   876a4:	2201      	movs	r2, #1
   876a6:	409a      	lsls	r2, r3
   876a8:	4b28      	ldr	r3, [pc, #160]	; (8774c <xTaskResumeAll+0x100>)
   876aa:	681b      	ldr	r3, [r3, #0]
   876ac:	431a      	orrs	r2, r3
   876ae:	4b27      	ldr	r3, [pc, #156]	; (8774c <xTaskResumeAll+0x100>)
   876b0:	601a      	str	r2, [r3, #0]
   876b2:	683b      	ldr	r3, [r7, #0]
   876b4:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   876b6:	4613      	mov	r3, r2
   876b8:	009b      	lsls	r3, r3, #2
   876ba:	4413      	add	r3, r2
   876bc:	009b      	lsls	r3, r3, #2
   876be:	4a24      	ldr	r2, [pc, #144]	; (87750 <xTaskResumeAll+0x104>)
   876c0:	441a      	add	r2, r3
   876c2:	683b      	ldr	r3, [r7, #0]
   876c4:	3304      	adds	r3, #4
   876c6:	4610      	mov	r0, r2
   876c8:	4619      	mov	r1, r3
   876ca:	4b22      	ldr	r3, [pc, #136]	; (87754 <xTaskResumeAll+0x108>)
   876cc:	4798      	blx	r3

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   876ce:	683b      	ldr	r3, [r7, #0]
   876d0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   876d2:	4b21      	ldr	r3, [pc, #132]	; (87758 <xTaskResumeAll+0x10c>)
   876d4:	681b      	ldr	r3, [r3, #0]
   876d6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   876d8:	429a      	cmp	r2, r3
   876da:	d302      	bcc.n	876e2 <xTaskResumeAll+0x96>
					{
						xYieldPending = pdTRUE;
   876dc:	4b1f      	ldr	r3, [pc, #124]	; (8775c <xTaskResumeAll+0x110>)
   876de:	2201      	movs	r2, #1
   876e0:	601a      	str	r2, [r3, #0]
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
   876e2:	4b18      	ldr	r3, [pc, #96]	; (87744 <xTaskResumeAll+0xf8>)
   876e4:	681b      	ldr	r3, [r3, #0]
   876e6:	2b00      	cmp	r3, #0
   876e8:	d1cc      	bne.n	87684 <xTaskResumeAll+0x38>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
   876ea:	4b1d      	ldr	r3, [pc, #116]	; (87760 <xTaskResumeAll+0x114>)
   876ec:	681b      	ldr	r3, [r3, #0]
   876ee:	2b00      	cmp	r3, #0
   876f0:	d011      	beq.n	87716 <xTaskResumeAll+0xca>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
   876f2:	e00c      	b.n	8770e <xTaskResumeAll+0xc2>
					{
						if( xTaskIncrementTick() != pdFALSE )
   876f4:	4b1b      	ldr	r3, [pc, #108]	; (87764 <xTaskResumeAll+0x118>)
   876f6:	4798      	blx	r3
   876f8:	4603      	mov	r3, r0
   876fa:	2b00      	cmp	r3, #0
   876fc:	d002      	beq.n	87704 <xTaskResumeAll+0xb8>
						{
							xYieldPending = pdTRUE;
   876fe:	4b17      	ldr	r3, [pc, #92]	; (8775c <xTaskResumeAll+0x110>)
   87700:	2201      	movs	r2, #1
   87702:	601a      	str	r2, [r3, #0]
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
   87704:	4b16      	ldr	r3, [pc, #88]	; (87760 <xTaskResumeAll+0x114>)
   87706:	681b      	ldr	r3, [r3, #0]
   87708:	1e5a      	subs	r2, r3, #1
   8770a:	4b15      	ldr	r3, [pc, #84]	; (87760 <xTaskResumeAll+0x114>)
   8770c:	601a      	str	r2, [r3, #0]
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
   8770e:	4b14      	ldr	r3, [pc, #80]	; (87760 <xTaskResumeAll+0x114>)
   87710:	681b      	ldr	r3, [r3, #0]
   87712:	2b00      	cmp	r3, #0
   87714:	d1ee      	bne.n	876f4 <xTaskResumeAll+0xa8>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
   87716:	4b11      	ldr	r3, [pc, #68]	; (8775c <xTaskResumeAll+0x110>)
   87718:	681b      	ldr	r3, [r3, #0]
   8771a:	2b01      	cmp	r3, #1
   8771c:	d103      	bne.n	87726 <xTaskResumeAll+0xda>
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
   8771e:	2301      	movs	r3, #1
   87720:	607b      	str	r3, [r7, #4]
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
   87722:	4b11      	ldr	r3, [pc, #68]	; (87768 <xTaskResumeAll+0x11c>)
   87724:	4798      	blx	r3
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   87726:	4b11      	ldr	r3, [pc, #68]	; (8776c <xTaskResumeAll+0x120>)
   87728:	4798      	blx	r3

	return xAlreadyYielded;
   8772a:	687b      	ldr	r3, [r7, #4]
}
   8772c:	4618      	mov	r0, r3
   8772e:	3708      	adds	r7, #8
   87730:	46bd      	mov	sp, r7
   87732:	bd80      	pop	{r7, pc}
   87734:	2007ad68 	.word	0x2007ad68
   87738:	000864f9 	.word	0x000864f9
   8773c:	0008647d 	.word	0x0008647d
   87740:	2007ad48 	.word	0x2007ad48
   87744:	2007ad08 	.word	0x2007ad08
   87748:	00086281 	.word	0x00086281
   8774c:	2007ad50 	.word	0x2007ad50
   87750:	2007ac74 	.word	0x2007ac74
   87754:	000861c9 	.word	0x000861c9
   87758:	2007ac70 	.word	0x2007ac70
   8775c:	2007ad5c 	.word	0x2007ad5c
   87760:	2007ad58 	.word	0x2007ad58
   87764:	0008779d 	.word	0x0008779d
   87768:	0008645d 	.word	0x0008645d
   8776c:	000864c1 	.word	0x000864c1

00087770 <xTaskGetTickCount>:
/*-----------------------------------------------------------*/

TickType_t xTaskGetTickCount( void )
{
   87770:	b580      	push	{r7, lr}
   87772:	b082      	sub	sp, #8
   87774:	af00      	add	r7, sp, #0
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
   87776:	4b06      	ldr	r3, [pc, #24]	; (87790 <xTaskGetTickCount+0x20>)
   87778:	4798      	blx	r3
	{
		xTicks = xTickCount;
   8777a:	4b06      	ldr	r3, [pc, #24]	; (87794 <xTaskGetTickCount+0x24>)
   8777c:	681b      	ldr	r3, [r3, #0]
   8777e:	607b      	str	r3, [r7, #4]
	}
	taskEXIT_CRITICAL();
   87780:	4b05      	ldr	r3, [pc, #20]	; (87798 <xTaskGetTickCount+0x28>)
   87782:	4798      	blx	r3

	return xTicks;
   87784:	687b      	ldr	r3, [r7, #4]
}
   87786:	4618      	mov	r0, r3
   87788:	3708      	adds	r7, #8
   8778a:	46bd      	mov	sp, r7
   8778c:	bd80      	pop	{r7, pc}
   8778e:	bf00      	nop
   87790:	0008647d 	.word	0x0008647d
   87794:	2007ad4c 	.word	0x2007ad4c
   87798:	000864c1 	.word	0x000864c1

0008779c <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
   8779c:	b580      	push	{r7, lr}
   8779e:	b086      	sub	sp, #24
   877a0:	af00      	add	r7, sp, #0
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
   877a2:	2300      	movs	r3, #0
   877a4:	617b      	str	r3, [r7, #20]

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   877a6:	4b4d      	ldr	r3, [pc, #308]	; (878dc <xTaskIncrementTick+0x140>)
   877a8:	681b      	ldr	r3, [r3, #0]
   877aa:	2b00      	cmp	r3, #0
   877ac:	f040 8086 	bne.w	878bc <xTaskIncrementTick+0x120>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
   877b0:	4b4b      	ldr	r3, [pc, #300]	; (878e0 <xTaskIncrementTick+0x144>)
   877b2:	681b      	ldr	r3, [r3, #0]
   877b4:	1c5a      	adds	r2, r3, #1
   877b6:	4b4a      	ldr	r3, [pc, #296]	; (878e0 <xTaskIncrementTick+0x144>)
   877b8:	601a      	str	r2, [r3, #0]

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
   877ba:	4b49      	ldr	r3, [pc, #292]	; (878e0 <xTaskIncrementTick+0x144>)
   877bc:	681b      	ldr	r3, [r3, #0]
   877be:	613b      	str	r3, [r7, #16]

			if( xConstTickCount == ( TickType_t ) 0U )
   877c0:	693b      	ldr	r3, [r7, #16]
   877c2:	2b00      	cmp	r3, #0
   877c4:	d118      	bne.n	877f8 <xTaskIncrementTick+0x5c>
			{
				taskSWITCH_DELAYED_LISTS();
   877c6:	4b47      	ldr	r3, [pc, #284]	; (878e4 <xTaskIncrementTick+0x148>)
   877c8:	681b      	ldr	r3, [r3, #0]
   877ca:	681b      	ldr	r3, [r3, #0]
   877cc:	2b00      	cmp	r3, #0
   877ce:	d002      	beq.n	877d6 <xTaskIncrementTick+0x3a>
   877d0:	4b45      	ldr	r3, [pc, #276]	; (878e8 <xTaskIncrementTick+0x14c>)
   877d2:	4798      	blx	r3
   877d4:	e7fe      	b.n	877d4 <xTaskIncrementTick+0x38>
   877d6:	4b43      	ldr	r3, [pc, #268]	; (878e4 <xTaskIncrementTick+0x148>)
   877d8:	681b      	ldr	r3, [r3, #0]
   877da:	60fb      	str	r3, [r7, #12]
   877dc:	4b43      	ldr	r3, [pc, #268]	; (878ec <xTaskIncrementTick+0x150>)
   877de:	681a      	ldr	r2, [r3, #0]
   877e0:	4b40      	ldr	r3, [pc, #256]	; (878e4 <xTaskIncrementTick+0x148>)
   877e2:	601a      	str	r2, [r3, #0]
   877e4:	4b41      	ldr	r3, [pc, #260]	; (878ec <xTaskIncrementTick+0x150>)
   877e6:	68fa      	ldr	r2, [r7, #12]
   877e8:	601a      	str	r2, [r3, #0]
   877ea:	4b41      	ldr	r3, [pc, #260]	; (878f0 <xTaskIncrementTick+0x154>)
   877ec:	681b      	ldr	r3, [r3, #0]
   877ee:	1c5a      	adds	r2, r3, #1
   877f0:	4b3f      	ldr	r3, [pc, #252]	; (878f0 <xTaskIncrementTick+0x154>)
   877f2:	601a      	str	r2, [r3, #0]
   877f4:	4b3f      	ldr	r3, [pc, #252]	; (878f4 <xTaskIncrementTick+0x158>)
   877f6:	4798      	blx	r3

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further	down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
   877f8:	4b3f      	ldr	r3, [pc, #252]	; (878f8 <xTaskIncrementTick+0x15c>)
   877fa:	681b      	ldr	r3, [r3, #0]
   877fc:	693a      	ldr	r2, [r7, #16]
   877fe:	429a      	cmp	r2, r3
   87800:	d34d      	bcc.n	8789e <xTaskIncrementTick+0x102>
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   87802:	4b38      	ldr	r3, [pc, #224]	; (878e4 <xTaskIncrementTick+0x148>)
   87804:	681b      	ldr	r3, [r3, #0]
   87806:	681b      	ldr	r3, [r3, #0]
   87808:	2b00      	cmp	r3, #0
   8780a:	d101      	bne.n	87810 <xTaskIncrementTick+0x74>
   8780c:	2301      	movs	r3, #1
   8780e:	e000      	b.n	87812 <xTaskIncrementTick+0x76>
   87810:	2300      	movs	r3, #0
   87812:	2b00      	cmp	r3, #0
   87814:	d004      	beq.n	87820 <xTaskIncrementTick+0x84>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
   87816:	4b38      	ldr	r3, [pc, #224]	; (878f8 <xTaskIncrementTick+0x15c>)
   87818:	f04f 32ff 	mov.w	r2, #4294967295
   8781c:	601a      	str	r2, [r3, #0]
						break;
   8781e:	e03e      	b.n	8789e <xTaskIncrementTick+0x102>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   87820:	4b30      	ldr	r3, [pc, #192]	; (878e4 <xTaskIncrementTick+0x148>)
   87822:	681b      	ldr	r3, [r3, #0]
   87824:	68db      	ldr	r3, [r3, #12]
   87826:	68db      	ldr	r3, [r3, #12]
   87828:	60bb      	str	r3, [r7, #8]
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
   8782a:	68bb      	ldr	r3, [r7, #8]
   8782c:	685b      	ldr	r3, [r3, #4]
   8782e:	607b      	str	r3, [r7, #4]

						if( xConstTickCount < xItemValue )
   87830:	693a      	ldr	r2, [r7, #16]
   87832:	687b      	ldr	r3, [r7, #4]
   87834:	429a      	cmp	r2, r3
   87836:	d203      	bcs.n	87840 <xTaskIncrementTick+0xa4>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
   87838:	4b2f      	ldr	r3, [pc, #188]	; (878f8 <xTaskIncrementTick+0x15c>)
   8783a:	687a      	ldr	r2, [r7, #4]
   8783c:	601a      	str	r2, [r3, #0]
							break;
   8783e:	e02e      	b.n	8789e <xTaskIncrementTick+0x102>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   87840:	68bb      	ldr	r3, [r7, #8]
   87842:	3304      	adds	r3, #4
   87844:	4618      	mov	r0, r3
   87846:	4b2d      	ldr	r3, [pc, #180]	; (878fc <xTaskIncrementTick+0x160>)
   87848:	4798      	blx	r3

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
   8784a:	68bb      	ldr	r3, [r7, #8]
   8784c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
   8784e:	2b00      	cmp	r3, #0
   87850:	d004      	beq.n	8785c <xTaskIncrementTick+0xc0>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
   87852:	68bb      	ldr	r3, [r7, #8]
   87854:	3318      	adds	r3, #24
   87856:	4618      	mov	r0, r3
   87858:	4b28      	ldr	r3, [pc, #160]	; (878fc <xTaskIncrementTick+0x160>)
   8785a:	4798      	blx	r3
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
   8785c:	68bb      	ldr	r3, [r7, #8]
   8785e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87860:	2201      	movs	r2, #1
   87862:	409a      	lsls	r2, r3
   87864:	4b26      	ldr	r3, [pc, #152]	; (87900 <xTaskIncrementTick+0x164>)
   87866:	681b      	ldr	r3, [r3, #0]
   87868:	431a      	orrs	r2, r3
   8786a:	4b25      	ldr	r3, [pc, #148]	; (87900 <xTaskIncrementTick+0x164>)
   8786c:	601a      	str	r2, [r3, #0]
   8786e:	68bb      	ldr	r3, [r7, #8]
   87870:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   87872:	4613      	mov	r3, r2
   87874:	009b      	lsls	r3, r3, #2
   87876:	4413      	add	r3, r2
   87878:	009b      	lsls	r3, r3, #2
   8787a:	4a22      	ldr	r2, [pc, #136]	; (87904 <xTaskIncrementTick+0x168>)
   8787c:	441a      	add	r2, r3
   8787e:	68bb      	ldr	r3, [r7, #8]
   87880:	3304      	adds	r3, #4
   87882:	4610      	mov	r0, r2
   87884:	4619      	mov	r1, r3
   87886:	4b20      	ldr	r3, [pc, #128]	; (87908 <xTaskIncrementTick+0x16c>)
   87888:	4798      	blx	r3
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
   8788a:	68bb      	ldr	r3, [r7, #8]
   8788c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8788e:	4b1f      	ldr	r3, [pc, #124]	; (8790c <xTaskIncrementTick+0x170>)
   87890:	681b      	ldr	r3, [r3, #0]
   87892:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87894:	429a      	cmp	r2, r3
   87896:	d301      	bcc.n	8789c <xTaskIncrementTick+0x100>
							{
								xSwitchRequired = pdTRUE;
   87898:	2301      	movs	r3, #1
   8789a:	617b      	str	r3, [r7, #20]
								mtCOVERAGE_TEST_MARKER();
							}
						}
						#endif /* configUSE_PREEMPTION */
					}
				}
   8789c:	e7b1      	b.n	87802 <xTaskIncrementTick+0x66>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
   8789e:	4b1b      	ldr	r3, [pc, #108]	; (8790c <xTaskIncrementTick+0x170>)
   878a0:	681b      	ldr	r3, [r3, #0]
   878a2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   878a4:	4917      	ldr	r1, [pc, #92]	; (87904 <xTaskIncrementTick+0x168>)
   878a6:	4613      	mov	r3, r2
   878a8:	009b      	lsls	r3, r3, #2
   878aa:	4413      	add	r3, r2
   878ac:	009b      	lsls	r3, r3, #2
   878ae:	440b      	add	r3, r1
   878b0:	681b      	ldr	r3, [r3, #0]
   878b2:	2b01      	cmp	r3, #1
   878b4:	d907      	bls.n	878c6 <xTaskIncrementTick+0x12a>
			{
				xSwitchRequired = pdTRUE;
   878b6:	2301      	movs	r3, #1
   878b8:	617b      	str	r3, [r7, #20]
   878ba:	e004      	b.n	878c6 <xTaskIncrementTick+0x12a>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
   878bc:	4b14      	ldr	r3, [pc, #80]	; (87910 <xTaskIncrementTick+0x174>)
   878be:	681b      	ldr	r3, [r3, #0]
   878c0:	1c5a      	adds	r2, r3, #1
   878c2:	4b13      	ldr	r3, [pc, #76]	; (87910 <xTaskIncrementTick+0x174>)
   878c4:	601a      	str	r2, [r3, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
   878c6:	4b13      	ldr	r3, [pc, #76]	; (87914 <xTaskIncrementTick+0x178>)
   878c8:	681b      	ldr	r3, [r3, #0]
   878ca:	2b00      	cmp	r3, #0
   878cc:	d001      	beq.n	878d2 <xTaskIncrementTick+0x136>
		{
			xSwitchRequired = pdTRUE;
   878ce:	2301      	movs	r3, #1
   878d0:	617b      	str	r3, [r7, #20]
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
   878d2:	697b      	ldr	r3, [r7, #20]
}
   878d4:	4618      	mov	r0, r3
   878d6:	3718      	adds	r7, #24
   878d8:	46bd      	mov	sp, r7
   878da:	bd80      	pop	{r7, pc}
   878dc:	2007ad68 	.word	0x2007ad68
   878e0:	2007ad4c 	.word	0x2007ad4c
   878e4:	2007ad00 	.word	0x2007ad00
   878e8:	000864f9 	.word	0x000864f9
   878ec:	2007ad04 	.word	0x2007ad04
   878f0:	2007ad60 	.word	0x2007ad60
   878f4:	00087fc5 	.word	0x00087fc5
   878f8:	20070008 	.word	0x20070008
   878fc:	00086281 	.word	0x00086281
   87900:	2007ad50 	.word	0x2007ad50
   87904:	2007ac74 	.word	0x2007ac74
   87908:	000861c9 	.word	0x000861c9
   8790c:	2007ac70 	.word	0x2007ac70
   87910:	2007ad58 	.word	0x2007ad58
   87914:	2007ad5c 	.word	0x2007ad5c

00087918 <vTaskSwitchContext>:

#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
   87918:	b580      	push	{r7, lr}
   8791a:	b084      	sub	sp, #16
   8791c:	af00      	add	r7, sp, #0
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
   8791e:	4b34      	ldr	r3, [pc, #208]	; (879f0 <vTaskSwitchContext+0xd8>)
   87920:	681b      	ldr	r3, [r3, #0]
   87922:	2b00      	cmp	r3, #0
   87924:	d003      	beq.n	8792e <vTaskSwitchContext+0x16>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
   87926:	4b33      	ldr	r3, [pc, #204]	; (879f4 <vTaskSwitchContext+0xdc>)
   87928:	2201      	movs	r2, #1
   8792a:	601a      	str	r2, [r3, #0]
   8792c:	e05c      	b.n	879e8 <vTaskSwitchContext+0xd0>
	}
	else
	{
		xYieldPending = pdFALSE;
   8792e:	4b31      	ldr	r3, [pc, #196]	; (879f4 <vTaskSwitchContext+0xdc>)
   87930:	2200      	movs	r2, #0
   87932:	601a      	str	r2, [r3, #0]
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
   87934:	4b30      	ldr	r3, [pc, #192]	; (879f8 <vTaskSwitchContext+0xe0>)
   87936:	681b      	ldr	r3, [r3, #0]
   87938:	681a      	ldr	r2, [r3, #0]
   8793a:	4b2f      	ldr	r3, [pc, #188]	; (879f8 <vTaskSwitchContext+0xe0>)
   8793c:	681b      	ldr	r3, [r3, #0]
   8793e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   87940:	429a      	cmp	r2, r3
   87942:	d808      	bhi.n	87956 <vTaskSwitchContext+0x3e>
   87944:	4b2c      	ldr	r3, [pc, #176]	; (879f8 <vTaskSwitchContext+0xe0>)
   87946:	681a      	ldr	r2, [r3, #0]
   87948:	4b2b      	ldr	r3, [pc, #172]	; (879f8 <vTaskSwitchContext+0xe0>)
   8794a:	681b      	ldr	r3, [r3, #0]
   8794c:	3334      	adds	r3, #52	; 0x34
   8794e:	4610      	mov	r0, r2
   87950:	4619      	mov	r1, r3
   87952:	4b2a      	ldr	r3, [pc, #168]	; (879fc <vTaskSwitchContext+0xe4>)
   87954:	4798      	blx	r3
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
   87956:	4b28      	ldr	r3, [pc, #160]	; (879f8 <vTaskSwitchContext+0xe0>)
   87958:	681b      	ldr	r3, [r3, #0]
   8795a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   8795c:	4618      	mov	r0, r3
   8795e:	4928      	ldr	r1, [pc, #160]	; (87a00 <vTaskSwitchContext+0xe8>)
   87960:	2214      	movs	r2, #20
   87962:	4b28      	ldr	r3, [pc, #160]	; (87a04 <vTaskSwitchContext+0xec>)
   87964:	4798      	blx	r3
   87966:	4603      	mov	r3, r0
   87968:	2b00      	cmp	r3, #0
   8796a:	d008      	beq.n	8797e <vTaskSwitchContext+0x66>
   8796c:	4b22      	ldr	r3, [pc, #136]	; (879f8 <vTaskSwitchContext+0xe0>)
   8796e:	681a      	ldr	r2, [r3, #0]
   87970:	4b21      	ldr	r3, [pc, #132]	; (879f8 <vTaskSwitchContext+0xe0>)
   87972:	681b      	ldr	r3, [r3, #0]
   87974:	3334      	adds	r3, #52	; 0x34
   87976:	4610      	mov	r0, r2
   87978:	4619      	mov	r1, r3
   8797a:	4b20      	ldr	r3, [pc, #128]	; (879fc <vTaskSwitchContext+0xe4>)
   8797c:	4798      	blx	r3

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
   8797e:	4b22      	ldr	r3, [pc, #136]	; (87a08 <vTaskSwitchContext+0xf0>)
   87980:	681b      	ldr	r3, [r3, #0]
   87982:	607b      	str	r3, [r7, #4]
	/* Generic helper function. */
	__attribute__( ( always_inline ) ) static inline uint8_t ucPortCountLeadingZeros( uint32_t ulBitmap )
	{
	uint8_t ucReturn;

		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) );
   87984:	687b      	ldr	r3, [r7, #4]
   87986:	fab3 f383 	clz	r3, r3
   8798a:	70fb      	strb	r3, [r7, #3]
		return ucReturn;
   8798c:	78fb      	ldrb	r3, [r7, #3]
   8798e:	f1c3 031f 	rsb	r3, r3, #31
   87992:	60fb      	str	r3, [r7, #12]
   87994:	491d      	ldr	r1, [pc, #116]	; (87a0c <vTaskSwitchContext+0xf4>)
   87996:	68fa      	ldr	r2, [r7, #12]
   87998:	4613      	mov	r3, r2
   8799a:	009b      	lsls	r3, r3, #2
   8799c:	4413      	add	r3, r2
   8799e:	009b      	lsls	r3, r3, #2
   879a0:	440b      	add	r3, r1
   879a2:	681b      	ldr	r3, [r3, #0]
   879a4:	2b00      	cmp	r3, #0
   879a6:	d102      	bne.n	879ae <vTaskSwitchContext+0x96>
   879a8:	4b19      	ldr	r3, [pc, #100]	; (87a10 <vTaskSwitchContext+0xf8>)
   879aa:	4798      	blx	r3
   879ac:	e7fe      	b.n	879ac <vTaskSwitchContext+0x94>
   879ae:	68fa      	ldr	r2, [r7, #12]
   879b0:	4613      	mov	r3, r2
   879b2:	009b      	lsls	r3, r3, #2
   879b4:	4413      	add	r3, r2
   879b6:	009b      	lsls	r3, r3, #2
   879b8:	4a14      	ldr	r2, [pc, #80]	; (87a0c <vTaskSwitchContext+0xf4>)
   879ba:	4413      	add	r3, r2
   879bc:	60bb      	str	r3, [r7, #8]
   879be:	68bb      	ldr	r3, [r7, #8]
   879c0:	685b      	ldr	r3, [r3, #4]
   879c2:	685a      	ldr	r2, [r3, #4]
   879c4:	68bb      	ldr	r3, [r7, #8]
   879c6:	605a      	str	r2, [r3, #4]
   879c8:	68bb      	ldr	r3, [r7, #8]
   879ca:	685a      	ldr	r2, [r3, #4]
   879cc:	68bb      	ldr	r3, [r7, #8]
   879ce:	3308      	adds	r3, #8
   879d0:	429a      	cmp	r2, r3
   879d2:	d104      	bne.n	879de <vTaskSwitchContext+0xc6>
   879d4:	68bb      	ldr	r3, [r7, #8]
   879d6:	685b      	ldr	r3, [r3, #4]
   879d8:	685a      	ldr	r2, [r3, #4]
   879da:	68bb      	ldr	r3, [r7, #8]
   879dc:	605a      	str	r2, [r3, #4]
   879de:	68bb      	ldr	r3, [r7, #8]
   879e0:	685b      	ldr	r3, [r3, #4]
   879e2:	68da      	ldr	r2, [r3, #12]
   879e4:	4b04      	ldr	r3, [pc, #16]	; (879f8 <vTaskSwitchContext+0xe0>)
   879e6:	601a      	str	r2, [r3, #0]
			structure specific to this task. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
	}
}
   879e8:	3710      	adds	r7, #16
   879ea:	46bd      	mov	sp, r7
   879ec:	bd80      	pop	{r7, pc}
   879ee:	bf00      	nop
   879f0:	2007ad68 	.word	0x2007ad68
   879f4:	2007ad5c 	.word	0x2007ad5c
   879f8:	2007ac70 	.word	0x2007ac70
   879fc:	0008a701 	.word	0x0008a701
   87a00:	0008b174 	.word	0x0008b174
   87a04:	0008ad4d 	.word	0x0008ad4d
   87a08:	2007ad50 	.word	0x2007ad50
   87a0c:	2007ac74 	.word	0x2007ac74
   87a10:	000864f9 	.word	0x000864f9

00087a14 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
   87a14:	b580      	push	{r7, lr}
   87a16:	b084      	sub	sp, #16
   87a18:	af00      	add	r7, sp, #0
   87a1a:	6078      	str	r0, [r7, #4]
   87a1c:	6039      	str	r1, [r7, #0]
TickType_t xTimeToWake;

	configASSERT( pxEventList );
   87a1e:	687b      	ldr	r3, [r7, #4]
   87a20:	2b00      	cmp	r3, #0
   87a22:	d102      	bne.n	87a2a <vTaskPlaceOnEventList+0x16>
   87a24:	4b1a      	ldr	r3, [pc, #104]	; (87a90 <vTaskPlaceOnEventList+0x7c>)
   87a26:	4798      	blx	r3
   87a28:	e7fe      	b.n	87a28 <vTaskPlaceOnEventList+0x14>

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   87a2a:	4b1a      	ldr	r3, [pc, #104]	; (87a94 <vTaskPlaceOnEventList+0x80>)
   87a2c:	681b      	ldr	r3, [r3, #0]
   87a2e:	3318      	adds	r3, #24
   87a30:	6878      	ldr	r0, [r7, #4]
   87a32:	4619      	mov	r1, r3
   87a34:	4b18      	ldr	r3, [pc, #96]	; (87a98 <vTaskPlaceOnEventList+0x84>)
   87a36:	4798      	blx	r3

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   87a38:	4b16      	ldr	r3, [pc, #88]	; (87a94 <vTaskPlaceOnEventList+0x80>)
   87a3a:	681b      	ldr	r3, [r3, #0]
   87a3c:	3304      	adds	r3, #4
   87a3e:	4618      	mov	r0, r3
   87a40:	4b16      	ldr	r3, [pc, #88]	; (87a9c <vTaskPlaceOnEventList+0x88>)
   87a42:	4798      	blx	r3
   87a44:	4603      	mov	r3, r0
   87a46:	2b00      	cmp	r3, #0
   87a48:	d10b      	bne.n	87a62 <vTaskPlaceOnEventList+0x4e>
	{
		/* The current task must be in a ready list, so there is no need to
		check, and the port reset macro can be called directly. */
		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   87a4a:	4b12      	ldr	r3, [pc, #72]	; (87a94 <vTaskPlaceOnEventList+0x80>)
   87a4c:	681b      	ldr	r3, [r3, #0]
   87a4e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87a50:	2201      	movs	r2, #1
   87a52:	fa02 f303 	lsl.w	r3, r2, r3
   87a56:	43da      	mvns	r2, r3
   87a58:	4b11      	ldr	r3, [pc, #68]	; (87aa0 <vTaskPlaceOnEventList+0x8c>)
   87a5a:	681b      	ldr	r3, [r3, #0]
   87a5c:	401a      	ands	r2, r3
   87a5e:	4b10      	ldr	r3, [pc, #64]	; (87aa0 <vTaskPlaceOnEventList+0x8c>)
   87a60:	601a      	str	r2, [r3, #0]
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
   87a62:	683b      	ldr	r3, [r7, #0]
   87a64:	f1b3 3fff 	cmp.w	r3, #4294967295
   87a68:	d107      	bne.n	87a7a <vTaskPlaceOnEventList+0x66>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   87a6a:	4b0a      	ldr	r3, [pc, #40]	; (87a94 <vTaskPlaceOnEventList+0x80>)
   87a6c:	681b      	ldr	r3, [r3, #0]
   87a6e:	3304      	adds	r3, #4
   87a70:	480c      	ldr	r0, [pc, #48]	; (87aa4 <vTaskPlaceOnEventList+0x90>)
   87a72:	4619      	mov	r1, r3
   87a74:	4b0c      	ldr	r3, [pc, #48]	; (87aa8 <vTaskPlaceOnEventList+0x94>)
   87a76:	4798      	blx	r3
   87a78:	e007      	b.n	87a8a <vTaskPlaceOnEventList+0x76>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
   87a7a:	4b0c      	ldr	r3, [pc, #48]	; (87aac <vTaskPlaceOnEventList+0x98>)
   87a7c:	681a      	ldr	r2, [r3, #0]
   87a7e:	683b      	ldr	r3, [r7, #0]
   87a80:	4413      	add	r3, r2
   87a82:	60fb      	str	r3, [r7, #12]
			prvAddCurrentTaskToDelayedList( xTimeToWake );
   87a84:	68f8      	ldr	r0, [r7, #12]
   87a86:	4b0a      	ldr	r3, [pc, #40]	; (87ab0 <vTaskPlaceOnEventList+0x9c>)
   87a88:	4798      	blx	r3
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
   87a8a:	3710      	adds	r7, #16
   87a8c:	46bd      	mov	sp, r7
   87a8e:	bd80      	pop	{r7, pc}
   87a90:	000864f9 	.word	0x000864f9
   87a94:	2007ac70 	.word	0x2007ac70
   87a98:	00086211 	.word	0x00086211
   87a9c:	00086281 	.word	0x00086281
   87aa0:	2007ad50 	.word	0x2007ad50
   87aa4:	2007ad34 	.word	0x2007ad34
   87aa8:	000861c9 	.word	0x000861c9
   87aac:	2007ad4c 	.word	0x2007ad4c
   87ab0:	00087ec1 	.word	0x00087ec1

00087ab4 <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( List_t * const pxEventList, const TickType_t xTicksToWait )
	{
   87ab4:	b580      	push	{r7, lr}
   87ab6:	b084      	sub	sp, #16
   87ab8:	af00      	add	r7, sp, #0
   87aba:	6078      	str	r0, [r7, #4]
   87abc:	6039      	str	r1, [r7, #0]
	TickType_t xTimeToWake;

		configASSERT( pxEventList );
   87abe:	687b      	ldr	r3, [r7, #4]
   87ac0:	2b00      	cmp	r3, #0
   87ac2:	d102      	bne.n	87aca <vTaskPlaceOnEventListRestricted+0x16>
   87ac4:	4b14      	ldr	r3, [pc, #80]	; (87b18 <vTaskPlaceOnEventListRestricted+0x64>)
   87ac6:	4798      	blx	r3
   87ac8:	e7fe      	b.n	87ac8 <vTaskPlaceOnEventListRestricted+0x14>

		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
   87aca:	4b14      	ldr	r3, [pc, #80]	; (87b1c <vTaskPlaceOnEventListRestricted+0x68>)
   87acc:	681b      	ldr	r3, [r3, #0]
   87ace:	3318      	adds	r3, #24
   87ad0:	6878      	ldr	r0, [r7, #4]
   87ad2:	4619      	mov	r1, r3
   87ad4:	4b12      	ldr	r3, [pc, #72]	; (87b20 <vTaskPlaceOnEventListRestricted+0x6c>)
   87ad6:	4798      	blx	r3

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   87ad8:	4b10      	ldr	r3, [pc, #64]	; (87b1c <vTaskPlaceOnEventListRestricted+0x68>)
   87ada:	681b      	ldr	r3, [r3, #0]
   87adc:	3304      	adds	r3, #4
   87ade:	4618      	mov	r0, r3
   87ae0:	4b10      	ldr	r3, [pc, #64]	; (87b24 <vTaskPlaceOnEventListRestricted+0x70>)
   87ae2:	4798      	blx	r3
   87ae4:	4603      	mov	r3, r0
   87ae6:	2b00      	cmp	r3, #0
   87ae8:	d10b      	bne.n	87b02 <vTaskPlaceOnEventListRestricted+0x4e>
		{
			/* The current task must be in a ready list, so there is no need to
			check, and the port reset macro can be called directly. */
			portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
   87aea:	4b0c      	ldr	r3, [pc, #48]	; (87b1c <vTaskPlaceOnEventListRestricted+0x68>)
   87aec:	681b      	ldr	r3, [r3, #0]
   87aee:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87af0:	2201      	movs	r2, #1
   87af2:	fa02 f303 	lsl.w	r3, r2, r3
   87af6:	43da      	mvns	r2, r3
   87af8:	4b0b      	ldr	r3, [pc, #44]	; (87b28 <vTaskPlaceOnEventListRestricted+0x74>)
   87afa:	681b      	ldr	r3, [r3, #0]
   87afc:	401a      	ands	r2, r3
   87afe:	4b0a      	ldr	r3, [pc, #40]	; (87b28 <vTaskPlaceOnEventListRestricted+0x74>)
   87b00:	601a      	str	r2, [r3, #0]
			mtCOVERAGE_TEST_MARKER();
		}

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
   87b02:	4b0a      	ldr	r3, [pc, #40]	; (87b2c <vTaskPlaceOnEventListRestricted+0x78>)
   87b04:	681a      	ldr	r2, [r3, #0]
   87b06:	683b      	ldr	r3, [r7, #0]
   87b08:	4413      	add	r3, r2
   87b0a:	60fb      	str	r3, [r7, #12]

		traceTASK_DELAY_UNTIL();
		prvAddCurrentTaskToDelayedList( xTimeToWake );
   87b0c:	68f8      	ldr	r0, [r7, #12]
   87b0e:	4b08      	ldr	r3, [pc, #32]	; (87b30 <vTaskPlaceOnEventListRestricted+0x7c>)
   87b10:	4798      	blx	r3
	}
   87b12:	3710      	adds	r7, #16
   87b14:	46bd      	mov	sp, r7
   87b16:	bd80      	pop	{r7, pc}
   87b18:	000864f9 	.word	0x000864f9
   87b1c:	2007ac70 	.word	0x2007ac70
   87b20:	000861c9 	.word	0x000861c9
   87b24:	00086281 	.word	0x00086281
   87b28:	2007ad50 	.word	0x2007ad50
   87b2c:	2007ad4c 	.word	0x2007ad4c
   87b30:	00087ec1 	.word	0x00087ec1

00087b34 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
   87b34:	b580      	push	{r7, lr}
   87b36:	b084      	sub	sp, #16
   87b38:	af00      	add	r7, sp, #0
   87b3a:	6078      	str	r0, [r7, #4]
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
   87b3c:	687b      	ldr	r3, [r7, #4]
   87b3e:	68db      	ldr	r3, [r3, #12]
   87b40:	68db      	ldr	r3, [r3, #12]
   87b42:	60bb      	str	r3, [r7, #8]
	configASSERT( pxUnblockedTCB );
   87b44:	68bb      	ldr	r3, [r7, #8]
   87b46:	2b00      	cmp	r3, #0
   87b48:	d102      	bne.n	87b50 <xTaskRemoveFromEventList+0x1c>
   87b4a:	4b21      	ldr	r3, [pc, #132]	; (87bd0 <xTaskRemoveFromEventList+0x9c>)
   87b4c:	4798      	blx	r3
   87b4e:	e7fe      	b.n	87b4e <xTaskRemoveFromEventList+0x1a>
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
   87b50:	68bb      	ldr	r3, [r7, #8]
   87b52:	3318      	adds	r3, #24
   87b54:	4618      	mov	r0, r3
   87b56:	4b1f      	ldr	r3, [pc, #124]	; (87bd4 <xTaskRemoveFromEventList+0xa0>)
   87b58:	4798      	blx	r3

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   87b5a:	4b1f      	ldr	r3, [pc, #124]	; (87bd8 <xTaskRemoveFromEventList+0xa4>)
   87b5c:	681b      	ldr	r3, [r3, #0]
   87b5e:	2b00      	cmp	r3, #0
   87b60:	d11c      	bne.n	87b9c <xTaskRemoveFromEventList+0x68>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
   87b62:	68bb      	ldr	r3, [r7, #8]
   87b64:	3304      	adds	r3, #4
   87b66:	4618      	mov	r0, r3
   87b68:	4b1a      	ldr	r3, [pc, #104]	; (87bd4 <xTaskRemoveFromEventList+0xa0>)
   87b6a:	4798      	blx	r3
		prvAddTaskToReadyList( pxUnblockedTCB );
   87b6c:	68bb      	ldr	r3, [r7, #8]
   87b6e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87b70:	2201      	movs	r2, #1
   87b72:	409a      	lsls	r2, r3
   87b74:	4b19      	ldr	r3, [pc, #100]	; (87bdc <xTaskRemoveFromEventList+0xa8>)
   87b76:	681b      	ldr	r3, [r3, #0]
   87b78:	431a      	orrs	r2, r3
   87b7a:	4b18      	ldr	r3, [pc, #96]	; (87bdc <xTaskRemoveFromEventList+0xa8>)
   87b7c:	601a      	str	r2, [r3, #0]
   87b7e:	68bb      	ldr	r3, [r7, #8]
   87b80:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   87b82:	4613      	mov	r3, r2
   87b84:	009b      	lsls	r3, r3, #2
   87b86:	4413      	add	r3, r2
   87b88:	009b      	lsls	r3, r3, #2
   87b8a:	4a15      	ldr	r2, [pc, #84]	; (87be0 <xTaskRemoveFromEventList+0xac>)
   87b8c:	441a      	add	r2, r3
   87b8e:	68bb      	ldr	r3, [r7, #8]
   87b90:	3304      	adds	r3, #4
   87b92:	4610      	mov	r0, r2
   87b94:	4619      	mov	r1, r3
   87b96:	4b13      	ldr	r3, [pc, #76]	; (87be4 <xTaskRemoveFromEventList+0xb0>)
   87b98:	4798      	blx	r3
   87b9a:	e005      	b.n	87ba8 <xTaskRemoveFromEventList+0x74>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
   87b9c:	68bb      	ldr	r3, [r7, #8]
   87b9e:	3318      	adds	r3, #24
   87ba0:	4811      	ldr	r0, [pc, #68]	; (87be8 <xTaskRemoveFromEventList+0xb4>)
   87ba2:	4619      	mov	r1, r3
   87ba4:	4b0f      	ldr	r3, [pc, #60]	; (87be4 <xTaskRemoveFromEventList+0xb0>)
   87ba6:	4798      	blx	r3
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
   87ba8:	68bb      	ldr	r3, [r7, #8]
   87baa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   87bac:	4b0f      	ldr	r3, [pc, #60]	; (87bec <xTaskRemoveFromEventList+0xb8>)
   87bae:	681b      	ldr	r3, [r3, #0]
   87bb0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   87bb2:	429a      	cmp	r2, r3
   87bb4:	d905      	bls.n	87bc2 <xTaskRemoveFromEventList+0x8e>
	{
		/* Return true if the task removed from the event list has a higher
		priority than the calling task.  This allows the calling task to know if
		it should force a context switch now. */
		xReturn = pdTRUE;
   87bb6:	2301      	movs	r3, #1
   87bb8:	60fb      	str	r3, [r7, #12]

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
   87bba:	4b0d      	ldr	r3, [pc, #52]	; (87bf0 <xTaskRemoveFromEventList+0xbc>)
   87bbc:	2201      	movs	r2, #1
   87bbe:	601a      	str	r2, [r3, #0]
   87bc0:	e001      	b.n	87bc6 <xTaskRemoveFromEventList+0x92>
	}
	else
	{
		xReturn = pdFALSE;
   87bc2:	2300      	movs	r3, #0
   87bc4:	60fb      	str	r3, [r7, #12]
	}

	return xReturn;
   87bc6:	68fb      	ldr	r3, [r7, #12]
}
   87bc8:	4618      	mov	r0, r3
   87bca:	3710      	adds	r7, #16
   87bcc:	46bd      	mov	sp, r7
   87bce:	bd80      	pop	{r7, pc}
   87bd0:	000864f9 	.word	0x000864f9
   87bd4:	00086281 	.word	0x00086281
   87bd8:	2007ad68 	.word	0x2007ad68
   87bdc:	2007ad50 	.word	0x2007ad50
   87be0:	2007ac74 	.word	0x2007ac74
   87be4:	000861c9 	.word	0x000861c9
   87be8:	2007ad08 	.word	0x2007ad08
   87bec:	2007ac70 	.word	0x2007ac70
   87bf0:	2007ad5c 	.word	0x2007ad5c

00087bf4 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
   87bf4:	b580      	push	{r7, lr}
   87bf6:	b082      	sub	sp, #8
   87bf8:	af00      	add	r7, sp, #0
   87bfa:	6078      	str	r0, [r7, #4]
	configASSERT( pxTimeOut );
   87bfc:	687b      	ldr	r3, [r7, #4]
   87bfe:	2b00      	cmp	r3, #0
   87c00:	d102      	bne.n	87c08 <vTaskSetTimeOutState+0x14>
   87c02:	4b07      	ldr	r3, [pc, #28]	; (87c20 <vTaskSetTimeOutState+0x2c>)
   87c04:	4798      	blx	r3
   87c06:	e7fe      	b.n	87c06 <vTaskSetTimeOutState+0x12>
	pxTimeOut->xOverflowCount = xNumOfOverflows;
   87c08:	4b06      	ldr	r3, [pc, #24]	; (87c24 <vTaskSetTimeOutState+0x30>)
   87c0a:	681a      	ldr	r2, [r3, #0]
   87c0c:	687b      	ldr	r3, [r7, #4]
   87c0e:	601a      	str	r2, [r3, #0]
	pxTimeOut->xTimeOnEntering = xTickCount;
   87c10:	4b05      	ldr	r3, [pc, #20]	; (87c28 <vTaskSetTimeOutState+0x34>)
   87c12:	681a      	ldr	r2, [r3, #0]
   87c14:	687b      	ldr	r3, [r7, #4]
   87c16:	605a      	str	r2, [r3, #4]
}
   87c18:	3708      	adds	r7, #8
   87c1a:	46bd      	mov	sp, r7
   87c1c:	bd80      	pop	{r7, pc}
   87c1e:	bf00      	nop
   87c20:	000864f9 	.word	0x000864f9
   87c24:	2007ad60 	.word	0x2007ad60
   87c28:	2007ad4c 	.word	0x2007ad4c

00087c2c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
   87c2c:	b580      	push	{r7, lr}
   87c2e:	b084      	sub	sp, #16
   87c30:	af00      	add	r7, sp, #0
   87c32:	6078      	str	r0, [r7, #4]
   87c34:	6039      	str	r1, [r7, #0]
BaseType_t xReturn;

	configASSERT( pxTimeOut );
   87c36:	687b      	ldr	r3, [r7, #4]
   87c38:	2b00      	cmp	r3, #0
   87c3a:	d102      	bne.n	87c42 <xTaskCheckForTimeOut+0x16>
   87c3c:	4b21      	ldr	r3, [pc, #132]	; (87cc4 <xTaskCheckForTimeOut+0x98>)
   87c3e:	4798      	blx	r3
   87c40:	e7fe      	b.n	87c40 <xTaskCheckForTimeOut+0x14>
	configASSERT( pxTicksToWait );
   87c42:	683b      	ldr	r3, [r7, #0]
   87c44:	2b00      	cmp	r3, #0
   87c46:	d102      	bne.n	87c4e <xTaskCheckForTimeOut+0x22>
   87c48:	4b1e      	ldr	r3, [pc, #120]	; (87cc4 <xTaskCheckForTimeOut+0x98>)
   87c4a:	4798      	blx	r3
   87c4c:	e7fe      	b.n	87c4c <xTaskCheckForTimeOut+0x20>

	taskENTER_CRITICAL();
   87c4e:	4b1e      	ldr	r3, [pc, #120]	; (87cc8 <xTaskCheckForTimeOut+0x9c>)
   87c50:	4798      	blx	r3
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
   87c52:	4b1e      	ldr	r3, [pc, #120]	; (87ccc <xTaskCheckForTimeOut+0xa0>)
   87c54:	681b      	ldr	r3, [r3, #0]
   87c56:	60bb      	str	r3, [r7, #8]

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
   87c58:	683b      	ldr	r3, [r7, #0]
   87c5a:	681b      	ldr	r3, [r3, #0]
   87c5c:	f1b3 3fff 	cmp.w	r3, #4294967295
   87c60:	d102      	bne.n	87c68 <xTaskCheckForTimeOut+0x3c>
			{
				xReturn = pdFALSE;
   87c62:	2300      	movs	r3, #0
   87c64:	60fb      	str	r3, [r7, #12]
   87c66:	e026      	b.n	87cb6 <xTaskCheckForTimeOut+0x8a>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
   87c68:	687b      	ldr	r3, [r7, #4]
   87c6a:	681a      	ldr	r2, [r3, #0]
   87c6c:	4b18      	ldr	r3, [pc, #96]	; (87cd0 <xTaskCheckForTimeOut+0xa4>)
   87c6e:	681b      	ldr	r3, [r3, #0]
   87c70:	429a      	cmp	r2, r3
   87c72:	d007      	beq.n	87c84 <xTaskCheckForTimeOut+0x58>
   87c74:	687b      	ldr	r3, [r7, #4]
   87c76:	685a      	ldr	r2, [r3, #4]
   87c78:	68bb      	ldr	r3, [r7, #8]
   87c7a:	429a      	cmp	r2, r3
   87c7c:	d802      	bhi.n	87c84 <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
   87c7e:	2301      	movs	r3, #1
   87c80:	60fb      	str	r3, [r7, #12]
   87c82:	e018      	b.n	87cb6 <xTaskCheckForTimeOut+0x8a>
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
   87c84:	687b      	ldr	r3, [r7, #4]
   87c86:	685b      	ldr	r3, [r3, #4]
   87c88:	68ba      	ldr	r2, [r7, #8]
   87c8a:	1ad2      	subs	r2, r2, r3
   87c8c:	683b      	ldr	r3, [r7, #0]
   87c8e:	681b      	ldr	r3, [r3, #0]
   87c90:	429a      	cmp	r2, r3
   87c92:	d20e      	bcs.n	87cb2 <xTaskCheckForTimeOut+0x86>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
   87c94:	683b      	ldr	r3, [r7, #0]
   87c96:	681a      	ldr	r2, [r3, #0]
   87c98:	687b      	ldr	r3, [r7, #4]
   87c9a:	6859      	ldr	r1, [r3, #4]
   87c9c:	68bb      	ldr	r3, [r7, #8]
   87c9e:	1acb      	subs	r3, r1, r3
   87ca0:	441a      	add	r2, r3
   87ca2:	683b      	ldr	r3, [r7, #0]
   87ca4:	601a      	str	r2, [r3, #0]
			vTaskSetTimeOutState( pxTimeOut );
   87ca6:	6878      	ldr	r0, [r7, #4]
   87ca8:	4b0a      	ldr	r3, [pc, #40]	; (87cd4 <xTaskCheckForTimeOut+0xa8>)
   87caa:	4798      	blx	r3
			xReturn = pdFALSE;
   87cac:	2300      	movs	r3, #0
   87cae:	60fb      	str	r3, [r7, #12]
   87cb0:	e001      	b.n	87cb6 <xTaskCheckForTimeOut+0x8a>
		}
		else
		{
			xReturn = pdTRUE;
   87cb2:	2301      	movs	r3, #1
   87cb4:	60fb      	str	r3, [r7, #12]
		}
	}
	taskEXIT_CRITICAL();
   87cb6:	4b08      	ldr	r3, [pc, #32]	; (87cd8 <xTaskCheckForTimeOut+0xac>)
   87cb8:	4798      	blx	r3

	return xReturn;
   87cba:	68fb      	ldr	r3, [r7, #12]
}
   87cbc:	4618      	mov	r0, r3
   87cbe:	3710      	adds	r7, #16
   87cc0:	46bd      	mov	sp, r7
   87cc2:	bd80      	pop	{r7, pc}
   87cc4:	000864f9 	.word	0x000864f9
   87cc8:	0008647d 	.word	0x0008647d
   87ccc:	2007ad4c 	.word	0x2007ad4c
   87cd0:	2007ad60 	.word	0x2007ad60
   87cd4:	00087bf5 	.word	0x00087bf5
   87cd8:	000864c1 	.word	0x000864c1

00087cdc <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
   87cdc:	b480      	push	{r7}
   87cde:	af00      	add	r7, sp, #0
	xYieldPending = pdTRUE;
   87ce0:	4b03      	ldr	r3, [pc, #12]	; (87cf0 <vTaskMissedYield+0x14>)
   87ce2:	2201      	movs	r2, #1
   87ce4:	601a      	str	r2, [r3, #0]
}
   87ce6:	46bd      	mov	sp, r7
   87ce8:	f85d 7b04 	ldr.w	r7, [sp], #4
   87cec:	4770      	bx	lr
   87cee:	bf00      	nop
   87cf0:	2007ad5c 	.word	0x2007ad5c

00087cf4 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
   87cf4:	b580      	push	{r7, lr}
   87cf6:	b082      	sub	sp, #8
   87cf8:	af00      	add	r7, sp, #0
   87cfa:	6078      	str	r0, [r7, #4]
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
   87cfc:	4b04      	ldr	r3, [pc, #16]	; (87d10 <prvIdleTask+0x1c>)
   87cfe:	4798      	blx	r3

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
   87d00:	4b04      	ldr	r3, [pc, #16]	; (87d14 <prvIdleTask+0x20>)
   87d02:	681b      	ldr	r3, [r3, #0]
   87d04:	2b01      	cmp	r3, #1
   87d06:	d901      	bls.n	87d0c <prvIdleTask+0x18>
			{
				taskYIELD();
   87d08:	4b03      	ldr	r3, [pc, #12]	; (87d18 <prvIdleTask+0x24>)
   87d0a:	4798      	blx	r3
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_TICKLESS_IDLE */
	}
   87d0c:	e7f6      	b.n	87cfc <prvIdleTask+0x8>
   87d0e:	bf00      	nop
   87d10:	00087e35 	.word	0x00087e35
   87d14:	2007ac74 	.word	0x2007ac74
   87d18:	0008645d 	.word	0x0008645d

00087d1c <prvInitialiseTCBVariables>:
	}
#endif /* configUSE_TICKLESS_IDLE */
/*-----------------------------------------------------------*/

static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
   87d1c:	b580      	push	{r7, lr}
   87d1e:	b086      	sub	sp, #24
   87d20:	af00      	add	r7, sp, #0
   87d22:	60f8      	str	r0, [r7, #12]
   87d24:	60b9      	str	r1, [r7, #8]
   87d26:	607a      	str	r2, [r7, #4]
   87d28:	603b      	str	r3, [r7, #0]
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   87d2a:	2300      	movs	r3, #0
   87d2c:	617b      	str	r3, [r7, #20]
   87d2e:	e012      	b.n	87d56 <prvInitialiseTCBVariables+0x3a>
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
   87d30:	68ba      	ldr	r2, [r7, #8]
   87d32:	697b      	ldr	r3, [r7, #20]
   87d34:	4413      	add	r3, r2
   87d36:	781a      	ldrb	r2, [r3, #0]
   87d38:	68f9      	ldr	r1, [r7, #12]
   87d3a:	697b      	ldr	r3, [r7, #20]
   87d3c:	440b      	add	r3, r1
   87d3e:	3330      	adds	r3, #48	; 0x30
   87d40:	711a      	strb	r2, [r3, #4]

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
   87d42:	68ba      	ldr	r2, [r7, #8]
   87d44:	697b      	ldr	r3, [r7, #20]
   87d46:	4413      	add	r3, r2
   87d48:	781b      	ldrb	r3, [r3, #0]
   87d4a:	2b00      	cmp	r3, #0
   87d4c:	d100      	bne.n	87d50 <prvInitialiseTCBVariables+0x34>
		{
			break;
   87d4e:	e005      	b.n	87d5c <prvInitialiseTCBVariables+0x40>
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
   87d50:	697b      	ldr	r3, [r7, #20]
   87d52:	3301      	adds	r3, #1
   87d54:	617b      	str	r3, [r7, #20]
   87d56:	697b      	ldr	r3, [r7, #20]
   87d58:	2b09      	cmp	r3, #9
   87d5a:	d9e9      	bls.n	87d30 <prvInitialiseTCBVariables+0x14>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
   87d5c:	68fb      	ldr	r3, [r7, #12]
   87d5e:	2200      	movs	r2, #0
   87d60:	f883 203d 	strb.w	r2, [r3, #61]	; 0x3d

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
   87d64:	687b      	ldr	r3, [r7, #4]
   87d66:	2b04      	cmp	r3, #4
   87d68:	d901      	bls.n	87d6e <prvInitialiseTCBVariables+0x52>
	{
		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
   87d6a:	2304      	movs	r3, #4
   87d6c:	607b      	str	r3, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
   87d6e:	68fb      	ldr	r3, [r7, #12]
   87d70:	687a      	ldr	r2, [r7, #4]
   87d72:	62da      	str	r2, [r3, #44]	; 0x2c
	#if ( configUSE_MUTEXES == 1 )
	{
		pxTCB->uxBasePriority = uxPriority;
   87d74:	68fb      	ldr	r3, [r7, #12]
   87d76:	687a      	ldr	r2, [r7, #4]
   87d78:	641a      	str	r2, [r3, #64]	; 0x40
		pxTCB->uxMutexesHeld = 0;
   87d7a:	68fb      	ldr	r3, [r7, #12]
   87d7c:	2200      	movs	r2, #0
   87d7e:	645a      	str	r2, [r3, #68]	; 0x44
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
   87d80:	68fb      	ldr	r3, [r7, #12]
   87d82:	3304      	adds	r3, #4
   87d84:	4618      	mov	r0, r3
   87d86:	4b0a      	ldr	r3, [pc, #40]	; (87db0 <prvInitialiseTCBVariables+0x94>)
   87d88:	4798      	blx	r3
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
   87d8a:	68fb      	ldr	r3, [r7, #12]
   87d8c:	3318      	adds	r3, #24
   87d8e:	4618      	mov	r0, r3
   87d90:	4b07      	ldr	r3, [pc, #28]	; (87db0 <prvInitialiseTCBVariables+0x94>)
   87d92:	4798      	blx	r3

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
   87d94:	68fb      	ldr	r3, [r7, #12]
   87d96:	68fa      	ldr	r2, [r7, #12]
   87d98:	611a      	str	r2, [r3, #16]

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   87d9a:	687b      	ldr	r3, [r7, #4]
   87d9c:	f1c3 0205 	rsb	r2, r3, #5
   87da0:	68fb      	ldr	r3, [r7, #12]
   87da2:	619a      	str	r2, [r3, #24]
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
   87da4:	68fb      	ldr	r3, [r7, #12]
   87da6:	68fa      	ldr	r2, [r7, #12]
   87da8:	625a      	str	r2, [r3, #36]	; 0x24
	{
		/* Initialise this task's Newlib reent structure. */
		_REENT_INIT_PTR( ( &( pxTCB->xNewLib_reent ) ) );
	}
	#endif /* configUSE_NEWLIB_REENTRANT */
}
   87daa:	3718      	adds	r7, #24
   87dac:	46bd      	mov	sp, r7
   87dae:	bd80      	pop	{r7, pc}
   87db0:	000861b1 	.word	0x000861b1

00087db4 <prvInitialiseTaskLists>:

#endif /* portUSING_MPU_WRAPPERS */
/*-----------------------------------------------------------*/

static void prvInitialiseTaskLists( void )
{
   87db4:	b580      	push	{r7, lr}
   87db6:	b082      	sub	sp, #8
   87db8:	af00      	add	r7, sp, #0
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   87dba:	2300      	movs	r3, #0
   87dbc:	607b      	str	r3, [r7, #4]
   87dbe:	e00c      	b.n	87dda <prvInitialiseTaskLists+0x26>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
   87dc0:	687a      	ldr	r2, [r7, #4]
   87dc2:	4613      	mov	r3, r2
   87dc4:	009b      	lsls	r3, r3, #2
   87dc6:	4413      	add	r3, r2
   87dc8:	009b      	lsls	r3, r3, #2
   87dca:	4a11      	ldr	r2, [pc, #68]	; (87e10 <prvInitialiseTaskLists+0x5c>)
   87dcc:	4413      	add	r3, r2
   87dce:	4618      	mov	r0, r3
   87dd0:	4b10      	ldr	r3, [pc, #64]	; (87e14 <prvInitialiseTaskLists+0x60>)
   87dd2:	4798      	blx	r3

static void prvInitialiseTaskLists( void )
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
   87dd4:	687b      	ldr	r3, [r7, #4]
   87dd6:	3301      	adds	r3, #1
   87dd8:	607b      	str	r3, [r7, #4]
   87dda:	687b      	ldr	r3, [r7, #4]
   87ddc:	2b04      	cmp	r3, #4
   87dde:	d9ef      	bls.n	87dc0 <prvInitialiseTaskLists+0xc>
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( &xDelayedTaskList1 );
   87de0:	480d      	ldr	r0, [pc, #52]	; (87e18 <prvInitialiseTaskLists+0x64>)
   87de2:	4b0c      	ldr	r3, [pc, #48]	; (87e14 <prvInitialiseTaskLists+0x60>)
   87de4:	4798      	blx	r3
	vListInitialise( &xDelayedTaskList2 );
   87de6:	480d      	ldr	r0, [pc, #52]	; (87e1c <prvInitialiseTaskLists+0x68>)
   87de8:	4b0a      	ldr	r3, [pc, #40]	; (87e14 <prvInitialiseTaskLists+0x60>)
   87dea:	4798      	blx	r3
	vListInitialise( &xPendingReadyList );
   87dec:	480c      	ldr	r0, [pc, #48]	; (87e20 <prvInitialiseTaskLists+0x6c>)
   87dee:	4b09      	ldr	r3, [pc, #36]	; (87e14 <prvInitialiseTaskLists+0x60>)
   87df0:	4798      	blx	r3

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
   87df2:	480c      	ldr	r0, [pc, #48]	; (87e24 <prvInitialiseTaskLists+0x70>)
   87df4:	4b07      	ldr	r3, [pc, #28]	; (87e14 <prvInitialiseTaskLists+0x60>)
   87df6:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
   87df8:	480b      	ldr	r0, [pc, #44]	; (87e28 <prvInitialiseTaskLists+0x74>)
   87dfa:	4b06      	ldr	r3, [pc, #24]	; (87e14 <prvInitialiseTaskLists+0x60>)
   87dfc:	4798      	blx	r3
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
   87dfe:	4b0b      	ldr	r3, [pc, #44]	; (87e2c <prvInitialiseTaskLists+0x78>)
   87e00:	4a05      	ldr	r2, [pc, #20]	; (87e18 <prvInitialiseTaskLists+0x64>)
   87e02:	601a      	str	r2, [r3, #0]
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
   87e04:	4b0a      	ldr	r3, [pc, #40]	; (87e30 <prvInitialiseTaskLists+0x7c>)
   87e06:	4a05      	ldr	r2, [pc, #20]	; (87e1c <prvInitialiseTaskLists+0x68>)
   87e08:	601a      	str	r2, [r3, #0]
}
   87e0a:	3708      	adds	r7, #8
   87e0c:	46bd      	mov	sp, r7
   87e0e:	bd80      	pop	{r7, pc}
   87e10:	2007ac74 	.word	0x2007ac74
   87e14:	00086171 	.word	0x00086171
   87e18:	2007acd8 	.word	0x2007acd8
   87e1c:	2007acec 	.word	0x2007acec
   87e20:	2007ad08 	.word	0x2007ad08
   87e24:	2007ad1c 	.word	0x2007ad1c
   87e28:	2007ad34 	.word	0x2007ad34
   87e2c:	2007ad00 	.word	0x2007ad00
   87e30:	2007ad04 	.word	0x2007ad04

00087e34 <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
   87e34:	b580      	push	{r7, lr}
   87e36:	b082      	sub	sp, #8
   87e38:	af00      	add	r7, sp, #0
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   87e3a:	e028      	b.n	87e8e <prvCheckTasksWaitingTermination+0x5a>
		{
			vTaskSuspendAll();
   87e3c:	4b17      	ldr	r3, [pc, #92]	; (87e9c <prvCheckTasksWaitingTermination+0x68>)
   87e3e:	4798      	blx	r3
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
   87e40:	4b17      	ldr	r3, [pc, #92]	; (87ea0 <prvCheckTasksWaitingTermination+0x6c>)
   87e42:	681b      	ldr	r3, [r3, #0]
   87e44:	2b00      	cmp	r3, #0
   87e46:	bf14      	ite	ne
   87e48:	2300      	movne	r3, #0
   87e4a:	2301      	moveq	r3, #1
   87e4c:	b2db      	uxtb	r3, r3
   87e4e:	607b      	str	r3, [r7, #4]
			}
			( void ) xTaskResumeAll();
   87e50:	4b14      	ldr	r3, [pc, #80]	; (87ea4 <prvCheckTasksWaitingTermination+0x70>)
   87e52:	4798      	blx	r3

			if( xListIsEmpty == pdFALSE )
   87e54:	687b      	ldr	r3, [r7, #4]
   87e56:	2b00      	cmp	r3, #0
   87e58:	d119      	bne.n	87e8e <prvCheckTasksWaitingTermination+0x5a>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
   87e5a:	4b13      	ldr	r3, [pc, #76]	; (87ea8 <prvCheckTasksWaitingTermination+0x74>)
   87e5c:	4798      	blx	r3
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
   87e5e:	4b10      	ldr	r3, [pc, #64]	; (87ea0 <prvCheckTasksWaitingTermination+0x6c>)
   87e60:	68db      	ldr	r3, [r3, #12]
   87e62:	68db      	ldr	r3, [r3, #12]
   87e64:	603b      	str	r3, [r7, #0]
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
   87e66:	683b      	ldr	r3, [r7, #0]
   87e68:	3304      	adds	r3, #4
   87e6a:	4618      	mov	r0, r3
   87e6c:	4b0f      	ldr	r3, [pc, #60]	; (87eac <prvCheckTasksWaitingTermination+0x78>)
   87e6e:	4798      	blx	r3
					--uxCurrentNumberOfTasks;
   87e70:	4b0f      	ldr	r3, [pc, #60]	; (87eb0 <prvCheckTasksWaitingTermination+0x7c>)
   87e72:	681b      	ldr	r3, [r3, #0]
   87e74:	1e5a      	subs	r2, r3, #1
   87e76:	4b0e      	ldr	r3, [pc, #56]	; (87eb0 <prvCheckTasksWaitingTermination+0x7c>)
   87e78:	601a      	str	r2, [r3, #0]
					--uxTasksDeleted;
   87e7a:	4b0e      	ldr	r3, [pc, #56]	; (87eb4 <prvCheckTasksWaitingTermination+0x80>)
   87e7c:	681b      	ldr	r3, [r3, #0]
   87e7e:	1e5a      	subs	r2, r3, #1
   87e80:	4b0c      	ldr	r3, [pc, #48]	; (87eb4 <prvCheckTasksWaitingTermination+0x80>)
   87e82:	601a      	str	r2, [r3, #0]
				}
				taskEXIT_CRITICAL();
   87e84:	4b0c      	ldr	r3, [pc, #48]	; (87eb8 <prvCheckTasksWaitingTermination+0x84>)
   87e86:	4798      	blx	r3

				prvDeleteTCB( pxTCB );
   87e88:	6838      	ldr	r0, [r7, #0]
   87e8a:	4b0c      	ldr	r3, [pc, #48]	; (87ebc <prvCheckTasksWaitingTermination+0x88>)
   87e8c:	4798      	blx	r3
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
   87e8e:	4b09      	ldr	r3, [pc, #36]	; (87eb4 <prvCheckTasksWaitingTermination+0x80>)
   87e90:	681b      	ldr	r3, [r3, #0]
   87e92:	2b00      	cmp	r3, #0
   87e94:	d1d2      	bne.n	87e3c <prvCheckTasksWaitingTermination+0x8>
				mtCOVERAGE_TEST_MARKER();
			}
		}
	}
	#endif /* vTaskDelete */
}
   87e96:	3708      	adds	r7, #8
   87e98:	46bd      	mov	sp, r7
   87e9a:	bd80      	pop	{r7, pc}
   87e9c:	00087631 	.word	0x00087631
   87ea0:	2007ad1c 	.word	0x2007ad1c
   87ea4:	0008764d 	.word	0x0008764d
   87ea8:	0008647d 	.word	0x0008647d
   87eac:	00086281 	.word	0x00086281
   87eb0:	2007ad48 	.word	0x2007ad48
   87eb4:	2007ad30 	.word	0x2007ad30
   87eb8:	000864c1 	.word	0x000864c1
   87ebc:	00087fa1 	.word	0x00087fa1

00087ec0 <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
   87ec0:	b580      	push	{r7, lr}
   87ec2:	b082      	sub	sp, #8
   87ec4:	af00      	add	r7, sp, #0
   87ec6:	6078      	str	r0, [r7, #4]
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
   87ec8:	4b13      	ldr	r3, [pc, #76]	; (87f18 <prvAddCurrentTaskToDelayedList+0x58>)
   87eca:	681b      	ldr	r3, [r3, #0]
   87ecc:	687a      	ldr	r2, [r7, #4]
   87ece:	605a      	str	r2, [r3, #4]

	if( xTimeToWake < xTickCount )
   87ed0:	4b12      	ldr	r3, [pc, #72]	; (87f1c <prvAddCurrentTaskToDelayedList+0x5c>)
   87ed2:	681b      	ldr	r3, [r3, #0]
   87ed4:	687a      	ldr	r2, [r7, #4]
   87ed6:	429a      	cmp	r2, r3
   87ed8:	d209      	bcs.n	87eee <prvAddCurrentTaskToDelayedList+0x2e>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   87eda:	4b11      	ldr	r3, [pc, #68]	; (87f20 <prvAddCurrentTaskToDelayedList+0x60>)
   87edc:	681a      	ldr	r2, [r3, #0]
   87ede:	4b0e      	ldr	r3, [pc, #56]	; (87f18 <prvAddCurrentTaskToDelayedList+0x58>)
   87ee0:	681b      	ldr	r3, [r3, #0]
   87ee2:	3304      	adds	r3, #4
   87ee4:	4610      	mov	r0, r2
   87ee6:	4619      	mov	r1, r3
   87ee8:	4b0e      	ldr	r3, [pc, #56]	; (87f24 <prvAddCurrentTaskToDelayedList+0x64>)
   87eea:	4798      	blx	r3
   87eec:	e010      	b.n	87f10 <prvAddCurrentTaskToDelayedList+0x50>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
   87eee:	4b0e      	ldr	r3, [pc, #56]	; (87f28 <prvAddCurrentTaskToDelayedList+0x68>)
   87ef0:	681a      	ldr	r2, [r3, #0]
   87ef2:	4b09      	ldr	r3, [pc, #36]	; (87f18 <prvAddCurrentTaskToDelayedList+0x58>)
   87ef4:	681b      	ldr	r3, [r3, #0]
   87ef6:	3304      	adds	r3, #4
   87ef8:	4610      	mov	r0, r2
   87efa:	4619      	mov	r1, r3
   87efc:	4b09      	ldr	r3, [pc, #36]	; (87f24 <prvAddCurrentTaskToDelayedList+0x64>)
   87efe:	4798      	blx	r3

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
   87f00:	4b0a      	ldr	r3, [pc, #40]	; (87f2c <prvAddCurrentTaskToDelayedList+0x6c>)
   87f02:	681b      	ldr	r3, [r3, #0]
   87f04:	687a      	ldr	r2, [r7, #4]
   87f06:	429a      	cmp	r2, r3
   87f08:	d202      	bcs.n	87f10 <prvAddCurrentTaskToDelayedList+0x50>
		{
			xNextTaskUnblockTime = xTimeToWake;
   87f0a:	4b08      	ldr	r3, [pc, #32]	; (87f2c <prvAddCurrentTaskToDelayedList+0x6c>)
   87f0c:	687a      	ldr	r2, [r7, #4]
   87f0e:	601a      	str	r2, [r3, #0]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
   87f10:	3708      	adds	r7, #8
   87f12:	46bd      	mov	sp, r7
   87f14:	bd80      	pop	{r7, pc}
   87f16:	bf00      	nop
   87f18:	2007ac70 	.word	0x2007ac70
   87f1c:	2007ad4c 	.word	0x2007ad4c
   87f20:	2007ad04 	.word	0x2007ad04
   87f24:	00086211 	.word	0x00086211
   87f28:	2007ad00 	.word	0x2007ad00
   87f2c:	20070008 	.word	0x20070008

00087f30 <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static TCB_t *prvAllocateTCBAndStack( const uint16_t usStackDepth, StackType_t * const puxStackBuffer )
{
   87f30:	b580      	push	{r7, lr}
   87f32:	b084      	sub	sp, #16
   87f34:	af00      	add	r7, sp, #0
   87f36:	4603      	mov	r3, r0
   87f38:	6039      	str	r1, [r7, #0]
   87f3a:	80fb      	strh	r3, [r7, #6]
TCB_t *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
   87f3c:	2048      	movs	r0, #72	; 0x48
   87f3e:	4b15      	ldr	r3, [pc, #84]	; (87f94 <prvAllocateTCBAndStack+0x64>)
   87f40:	4798      	blx	r3
   87f42:	60f8      	str	r0, [r7, #12]

	if( pxNewTCB != NULL )
   87f44:	68fb      	ldr	r3, [r7, #12]
   87f46:	2b00      	cmp	r3, #0
   87f48:	d01f      	beq.n	87f8a <prvAllocateTCBAndStack+0x5a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   87f4a:	683b      	ldr	r3, [r7, #0]
   87f4c:	2b00      	cmp	r3, #0
   87f4e:	d106      	bne.n	87f5e <prvAllocateTCBAndStack+0x2e>
   87f50:	88fb      	ldrh	r3, [r7, #6]
   87f52:	009b      	lsls	r3, r3, #2
   87f54:	4618      	mov	r0, r3
   87f56:	4b0f      	ldr	r3, [pc, #60]	; (87f94 <prvAllocateTCBAndStack+0x64>)
   87f58:	4798      	blx	r3
   87f5a:	4603      	mov	r3, r0
   87f5c:	e000      	b.n	87f60 <prvAllocateTCBAndStack+0x30>
   87f5e:	683b      	ldr	r3, [r7, #0]
   87f60:	68fa      	ldr	r2, [r7, #12]
   87f62:	6313      	str	r3, [r2, #48]	; 0x30

		if( pxNewTCB->pxStack == NULL )
   87f64:	68fb      	ldr	r3, [r7, #12]
   87f66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   87f68:	2b00      	cmp	r3, #0
   87f6a:	d105      	bne.n	87f78 <prvAllocateTCBAndStack+0x48>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
   87f6c:	68f8      	ldr	r0, [r7, #12]
   87f6e:	4b0a      	ldr	r3, [pc, #40]	; (87f98 <prvAllocateTCBAndStack+0x68>)
   87f70:	4798      	blx	r3
			pxNewTCB = NULL;
   87f72:	2300      	movs	r3, #0
   87f74:	60fb      	str	r3, [r7, #12]
   87f76:	e008      	b.n	87f8a <prvAllocateTCBAndStack+0x5a>
		{
			/* Avoid dependency on memset() if it is not required. */
			#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
			{
				/* Just to help debugging. */
				( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( StackType_t ) );
   87f78:	68fb      	ldr	r3, [r7, #12]
   87f7a:	6b1a      	ldr	r2, [r3, #48]	; 0x30
   87f7c:	88fb      	ldrh	r3, [r7, #6]
   87f7e:	009b      	lsls	r3, r3, #2
   87f80:	4610      	mov	r0, r2
   87f82:	21a5      	movs	r1, #165	; 0xa5
   87f84:	461a      	mov	r2, r3
   87f86:	4b05      	ldr	r3, [pc, #20]	; (87f9c <prvAllocateTCBAndStack+0x6c>)
   87f88:	4798      	blx	r3
			}
			#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
		}
	}

	return pxNewTCB;
   87f8a:	68fb      	ldr	r3, [r7, #12]
}
   87f8c:	4618      	mov	r0, r3
   87f8e:	3710      	adds	r7, #16
   87f90:	46bd      	mov	sp, r7
   87f92:	bd80      	pop	{r7, pc}
   87f94:	0008661d 	.word	0x0008661d
   87f98:	00086795 	.word	0x00086795
   87f9c:	0008aea1 	.word	0x0008aea1

00087fa0 <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( TCB_t *pxTCB )
	{
   87fa0:	b580      	push	{r7, lr}
   87fa2:	b082      	sub	sp, #8
   87fa4:	af00      	add	r7, sp, #0
   87fa6:	6078      	str	r0, [r7, #4]
		#if ( configUSE_NEWLIB_REENTRANT == 1 )
		{
			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */
		vPortFreeAligned( pxTCB->pxStack );
   87fa8:	687b      	ldr	r3, [r7, #4]
   87faa:	6b1b      	ldr	r3, [r3, #48]	; 0x30
   87fac:	4618      	mov	r0, r3
   87fae:	4b04      	ldr	r3, [pc, #16]	; (87fc0 <prvDeleteTCB+0x20>)
   87fb0:	4798      	blx	r3
		vPortFree( pxTCB );
   87fb2:	6878      	ldr	r0, [r7, #4]
   87fb4:	4b02      	ldr	r3, [pc, #8]	; (87fc0 <prvDeleteTCB+0x20>)
   87fb6:	4798      	blx	r3
	}
   87fb8:	3708      	adds	r7, #8
   87fba:	46bd      	mov	sp, r7
   87fbc:	bd80      	pop	{r7, pc}
   87fbe:	bf00      	nop
   87fc0:	00086795 	.word	0x00086795

00087fc4 <prvResetNextTaskUnblockTime>:

#endif /* INCLUDE_vTaskDelete */
/*-----------------------------------------------------------*/

static void prvResetNextTaskUnblockTime( void )
{
   87fc4:	b480      	push	{r7}
   87fc6:	b083      	sub	sp, #12
   87fc8:	af00      	add	r7, sp, #0
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
   87fca:	4b0e      	ldr	r3, [pc, #56]	; (88004 <prvResetNextTaskUnblockTime+0x40>)
   87fcc:	681b      	ldr	r3, [r3, #0]
   87fce:	681b      	ldr	r3, [r3, #0]
   87fd0:	2b00      	cmp	r3, #0
   87fd2:	d101      	bne.n	87fd8 <prvResetNextTaskUnblockTime+0x14>
   87fd4:	2301      	movs	r3, #1
   87fd6:	e000      	b.n	87fda <prvResetNextTaskUnblockTime+0x16>
   87fd8:	2300      	movs	r3, #0
   87fda:	2b00      	cmp	r3, #0
   87fdc:	d004      	beq.n	87fe8 <prvResetNextTaskUnblockTime+0x24>
		/* The new current delayed list is empty.  Set
		xNextTaskUnblockTime to the maximum possible value so it is
		extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
   87fde:	4b0a      	ldr	r3, [pc, #40]	; (88008 <prvResetNextTaskUnblockTime+0x44>)
   87fe0:	f04f 32ff 	mov.w	r2, #4294967295
   87fe4:	601a      	str	r2, [r3, #0]
   87fe6:	e008      	b.n	87ffa <prvResetNextTaskUnblockTime+0x36>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
   87fe8:	4b06      	ldr	r3, [pc, #24]	; (88004 <prvResetNextTaskUnblockTime+0x40>)
   87fea:	681b      	ldr	r3, [r3, #0]
   87fec:	68db      	ldr	r3, [r3, #12]
   87fee:	68db      	ldr	r3, [r3, #12]
   87ff0:	607b      	str	r3, [r7, #4]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
   87ff2:	687b      	ldr	r3, [r7, #4]
   87ff4:	685a      	ldr	r2, [r3, #4]
   87ff6:	4b04      	ldr	r3, [pc, #16]	; (88008 <prvResetNextTaskUnblockTime+0x44>)
   87ff8:	601a      	str	r2, [r3, #0]
	}
}
   87ffa:	370c      	adds	r7, #12
   87ffc:	46bd      	mov	sp, r7
   87ffe:	f85d 7b04 	ldr.w	r7, [sp], #4
   88002:	4770      	bx	lr
   88004:	2007ad00 	.word	0x2007ad00
   88008:	20070008 	.word	0x20070008

0008800c <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	BaseType_t xTaskGetSchedulerState( void )
	{
   8800c:	b480      	push	{r7}
   8800e:	b083      	sub	sp, #12
   88010:	af00      	add	r7, sp, #0
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
   88012:	4b0b      	ldr	r3, [pc, #44]	; (88040 <xTaskGetSchedulerState+0x34>)
   88014:	681b      	ldr	r3, [r3, #0]
   88016:	2b00      	cmp	r3, #0
   88018:	d102      	bne.n	88020 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
   8801a:	2301      	movs	r3, #1
   8801c:	607b      	str	r3, [r7, #4]
   8801e:	e008      	b.n	88032 <xTaskGetSchedulerState+0x26>
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
   88020:	4b08      	ldr	r3, [pc, #32]	; (88044 <xTaskGetSchedulerState+0x38>)
   88022:	681b      	ldr	r3, [r3, #0]
   88024:	2b00      	cmp	r3, #0
   88026:	d102      	bne.n	8802e <xTaskGetSchedulerState+0x22>
			{
				xReturn = taskSCHEDULER_RUNNING;
   88028:	2302      	movs	r3, #2
   8802a:	607b      	str	r3, [r7, #4]
   8802c:	e001      	b.n	88032 <xTaskGetSchedulerState+0x26>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
   8802e:	2300      	movs	r3, #0
   88030:	607b      	str	r3, [r7, #4]
			}
		}

		return xReturn;
   88032:	687b      	ldr	r3, [r7, #4]
	}
   88034:	4618      	mov	r0, r3
   88036:	370c      	adds	r7, #12
   88038:	46bd      	mov	sp, r7
   8803a:	f85d 7b04 	ldr.w	r7, [sp], #4
   8803e:	4770      	bx	lr
   88040:	2007ad54 	.word	0x2007ad54
   88044:	2007ad68 	.word	0x2007ad68

00088048 <vTaskPriorityInherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
	{
   88048:	b580      	push	{r7, lr}
   8804a:	b084      	sub	sp, #16
   8804c:	af00      	add	r7, sp, #0
   8804e:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   88050:	687b      	ldr	r3, [r7, #4]
   88052:	60fb      	str	r3, [r7, #12]

		/* If the mutex was given back by an interrupt while the queue was
		locked then the mutex holder might now be NULL. */
		if( pxMutexHolder != NULL )
   88054:	687b      	ldr	r3, [r7, #4]
   88056:	2b00      	cmp	r3, #0
   88058:	d062      	beq.n	88120 <vTaskPriorityInherit+0xd8>
		{
			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
   8805a:	68fb      	ldr	r3, [r7, #12]
   8805c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8805e:	4b32      	ldr	r3, [pc, #200]	; (88128 <vTaskPriorityInherit+0xe0>)
   88060:	681b      	ldr	r3, [r3, #0]
   88062:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   88064:	429a      	cmp	r2, r3
   88066:	d25b      	bcs.n	88120 <vTaskPriorityInherit+0xd8>
			{
				/* Adjust the mutex holder state to account for its new
				priority.  Only reset the event list item value if the value is
				not	being used for anything else. */
				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
   88068:	68fb      	ldr	r3, [r7, #12]
   8806a:	699b      	ldr	r3, [r3, #24]
   8806c:	2b00      	cmp	r3, #0
   8806e:	db06      	blt.n	8807e <vTaskPriorityInherit+0x36>
				{
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   88070:	4b2d      	ldr	r3, [pc, #180]	; (88128 <vTaskPriorityInherit+0xe0>)
   88072:	681b      	ldr	r3, [r3, #0]
   88074:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   88076:	f1c3 0205 	rsb	r2, r3, #5
   8807a:	68fb      	ldr	r3, [r7, #12]
   8807c:	619a      	str	r2, [r3, #24]
					mtCOVERAGE_TEST_MARKER();
				}

				/* If the task being modified is in the ready state it will need to
				be moved into a new list. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xGenericListItem ) ) != pdFALSE )
   8807e:	68fb      	ldr	r3, [r7, #12]
   88080:	6959      	ldr	r1, [r3, #20]
   88082:	68fb      	ldr	r3, [r7, #12]
   88084:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   88086:	4613      	mov	r3, r2
   88088:	009b      	lsls	r3, r3, #2
   8808a:	4413      	add	r3, r2
   8808c:	009b      	lsls	r3, r3, #2
   8808e:	4a27      	ldr	r2, [pc, #156]	; (8812c <vTaskPriorityInherit+0xe4>)
   88090:	4413      	add	r3, r2
   88092:	4299      	cmp	r1, r3
   88094:	d101      	bne.n	8809a <vTaskPriorityInherit+0x52>
   88096:	2301      	movs	r3, #1
   88098:	e000      	b.n	8809c <vTaskPriorityInherit+0x54>
   8809a:	2300      	movs	r3, #0
   8809c:	2b00      	cmp	r3, #0
   8809e:	d03a      	beq.n	88116 <vTaskPriorityInherit+0xce>
				{
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   880a0:	68fb      	ldr	r3, [r7, #12]
   880a2:	3304      	adds	r3, #4
   880a4:	4618      	mov	r0, r3
   880a6:	4b22      	ldr	r3, [pc, #136]	; (88130 <vTaskPriorityInherit+0xe8>)
   880a8:	4798      	blx	r3
   880aa:	4603      	mov	r3, r0
   880ac:	2b00      	cmp	r3, #0
   880ae:	d115      	bne.n	880dc <vTaskPriorityInherit+0x94>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   880b0:	68fb      	ldr	r3, [r7, #12]
   880b2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   880b4:	491d      	ldr	r1, [pc, #116]	; (8812c <vTaskPriorityInherit+0xe4>)
   880b6:	4613      	mov	r3, r2
   880b8:	009b      	lsls	r3, r3, #2
   880ba:	4413      	add	r3, r2
   880bc:	009b      	lsls	r3, r3, #2
   880be:	440b      	add	r3, r1
   880c0:	681b      	ldr	r3, [r3, #0]
   880c2:	2b00      	cmp	r3, #0
   880c4:	d10a      	bne.n	880dc <vTaskPriorityInherit+0x94>
   880c6:	68fb      	ldr	r3, [r7, #12]
   880c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   880ca:	2201      	movs	r2, #1
   880cc:	fa02 f303 	lsl.w	r3, r2, r3
   880d0:	43da      	mvns	r2, r3
   880d2:	4b18      	ldr	r3, [pc, #96]	; (88134 <vTaskPriorityInherit+0xec>)
   880d4:	681b      	ldr	r3, [r3, #0]
   880d6:	401a      	ands	r2, r3
   880d8:	4b16      	ldr	r3, [pc, #88]	; (88134 <vTaskPriorityInherit+0xec>)
   880da:	601a      	str	r2, [r3, #0]
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* Inherit the priority before being moved into the new list. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   880dc:	4b12      	ldr	r3, [pc, #72]	; (88128 <vTaskPriorityInherit+0xe0>)
   880de:	681b      	ldr	r3, [r3, #0]
   880e0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   880e2:	68fb      	ldr	r3, [r7, #12]
   880e4:	62da      	str	r2, [r3, #44]	; 0x2c
					prvAddTaskToReadyList( pxTCB );
   880e6:	68fb      	ldr	r3, [r7, #12]
   880e8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   880ea:	2201      	movs	r2, #1
   880ec:	409a      	lsls	r2, r3
   880ee:	4b11      	ldr	r3, [pc, #68]	; (88134 <vTaskPriorityInherit+0xec>)
   880f0:	681b      	ldr	r3, [r3, #0]
   880f2:	431a      	orrs	r2, r3
   880f4:	4b0f      	ldr	r3, [pc, #60]	; (88134 <vTaskPriorityInherit+0xec>)
   880f6:	601a      	str	r2, [r3, #0]
   880f8:	68fb      	ldr	r3, [r7, #12]
   880fa:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   880fc:	4613      	mov	r3, r2
   880fe:	009b      	lsls	r3, r3, #2
   88100:	4413      	add	r3, r2
   88102:	009b      	lsls	r3, r3, #2
   88104:	4a09      	ldr	r2, [pc, #36]	; (8812c <vTaskPriorityInherit+0xe4>)
   88106:	441a      	add	r2, r3
   88108:	68fb      	ldr	r3, [r7, #12]
   8810a:	3304      	adds	r3, #4
   8810c:	4610      	mov	r0, r2
   8810e:	4619      	mov	r1, r3
   88110:	4b09      	ldr	r3, [pc, #36]	; (88138 <vTaskPriorityInherit+0xf0>)
   88112:	4798      	blx	r3
   88114:	e004      	b.n	88120 <vTaskPriorityInherit+0xd8>
				}
				else
				{
					/* Just inherit the priority. */
					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
   88116:	4b04      	ldr	r3, [pc, #16]	; (88128 <vTaskPriorityInherit+0xe0>)
   88118:	681b      	ldr	r3, [r3, #0]
   8811a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8811c:	68fb      	ldr	r3, [r7, #12]
   8811e:	62da      	str	r2, [r3, #44]	; 0x2c
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
   88120:	3710      	adds	r7, #16
   88122:	46bd      	mov	sp, r7
   88124:	bd80      	pop	{r7, pc}
   88126:	bf00      	nop
   88128:	2007ac70 	.word	0x2007ac70
   8812c:	2007ac74 	.word	0x2007ac74
   88130:	00086281 	.word	0x00086281
   88134:	2007ad50 	.word	0x2007ad50
   88138:	000861c9 	.word	0x000861c9

0008813c <xTaskPriorityDisinherit>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
	{
   8813c:	b580      	push	{r7, lr}
   8813e:	b084      	sub	sp, #16
   88140:	af00      	add	r7, sp, #0
   88142:	6078      	str	r0, [r7, #4]
	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
   88144:	687b      	ldr	r3, [r7, #4]
   88146:	60bb      	str	r3, [r7, #8]
	BaseType_t xReturn = pdFALSE;
   88148:	2300      	movs	r3, #0
   8814a:	60fb      	str	r3, [r7, #12]

		if( pxMutexHolder != NULL )
   8814c:	687b      	ldr	r3, [r7, #4]
   8814e:	2b00      	cmp	r3, #0
   88150:	d056      	beq.n	88200 <xTaskPriorityDisinherit+0xc4>
		{
			configASSERT( pxTCB->uxMutexesHeld );
   88152:	68bb      	ldr	r3, [r7, #8]
   88154:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   88156:	2b00      	cmp	r3, #0
   88158:	d102      	bne.n	88160 <xTaskPriorityDisinherit+0x24>
   8815a:	4b2c      	ldr	r3, [pc, #176]	; (8820c <xTaskPriorityDisinherit+0xd0>)
   8815c:	4798      	blx	r3
   8815e:	e7fe      	b.n	8815e <xTaskPriorityDisinherit+0x22>
			( pxTCB->uxMutexesHeld )--;
   88160:	68bb      	ldr	r3, [r7, #8]
   88162:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   88164:	1e5a      	subs	r2, r3, #1
   88166:	68bb      	ldr	r3, [r7, #8]
   88168:	645a      	str	r2, [r3, #68]	; 0x44

			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
   8816a:	68bb      	ldr	r3, [r7, #8]
   8816c:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   8816e:	68bb      	ldr	r3, [r7, #8]
   88170:	6c1b      	ldr	r3, [r3, #64]	; 0x40
   88172:	429a      	cmp	r2, r3
   88174:	d044      	beq.n	88200 <xTaskPriorityDisinherit+0xc4>
			{
				/* Only disinherit if no other mutexes are held. */
				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
   88176:	68bb      	ldr	r3, [r7, #8]
   88178:	6c5b      	ldr	r3, [r3, #68]	; 0x44
   8817a:	2b00      	cmp	r3, #0
   8817c:	d140      	bne.n	88200 <xTaskPriorityDisinherit+0xc4>
				{
					/* The holding task must be the running task to be able to give
					the mutex back.  Remove the holding task from the ready list. */
					if( uxListRemove( &( pxTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
   8817e:	68bb      	ldr	r3, [r7, #8]
   88180:	3304      	adds	r3, #4
   88182:	4618      	mov	r0, r3
   88184:	4b22      	ldr	r3, [pc, #136]	; (88210 <xTaskPriorityDisinherit+0xd4>)
   88186:	4798      	blx	r3
   88188:	4603      	mov	r3, r0
   8818a:	2b00      	cmp	r3, #0
   8818c:	d115      	bne.n	881ba <xTaskPriorityDisinherit+0x7e>
					{
						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
   8818e:	68bb      	ldr	r3, [r7, #8]
   88190:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   88192:	4920      	ldr	r1, [pc, #128]	; (88214 <xTaskPriorityDisinherit+0xd8>)
   88194:	4613      	mov	r3, r2
   88196:	009b      	lsls	r3, r3, #2
   88198:	4413      	add	r3, r2
   8819a:	009b      	lsls	r3, r3, #2
   8819c:	440b      	add	r3, r1
   8819e:	681b      	ldr	r3, [r3, #0]
   881a0:	2b00      	cmp	r3, #0
   881a2:	d10a      	bne.n	881ba <xTaskPriorityDisinherit+0x7e>
   881a4:	68bb      	ldr	r3, [r7, #8]
   881a6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   881a8:	2201      	movs	r2, #1
   881aa:	fa02 f303 	lsl.w	r3, r2, r3
   881ae:	43da      	mvns	r2, r3
   881b0:	4b19      	ldr	r3, [pc, #100]	; (88218 <xTaskPriorityDisinherit+0xdc>)
   881b2:	681b      	ldr	r3, [r3, #0]
   881b4:	401a      	ands	r2, r3
   881b6:	4b18      	ldr	r3, [pc, #96]	; (88218 <xTaskPriorityDisinherit+0xdc>)
   881b8:	601a      	str	r2, [r3, #0]
					}

					/* Disinherit the priority before adding the task into the new
					ready list. */
					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
					pxTCB->uxPriority = pxTCB->uxBasePriority;
   881ba:	68bb      	ldr	r3, [r7, #8]
   881bc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
   881be:	68bb      	ldr	r3, [r7, #8]
   881c0:	62da      	str	r2, [r3, #44]	; 0x2c

					/* Reset the event list item value.  It cannot be in use for
					any other purpose if this task is running, and it must be
					running to give back the mutex. */
					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
   881c2:	68bb      	ldr	r3, [r7, #8]
   881c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   881c6:	f1c3 0205 	rsb	r2, r3, #5
   881ca:	68bb      	ldr	r3, [r7, #8]
   881cc:	619a      	str	r2, [r3, #24]
					prvAddTaskToReadyList( pxTCB );
   881ce:	68bb      	ldr	r3, [r7, #8]
   881d0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
   881d2:	2201      	movs	r2, #1
   881d4:	409a      	lsls	r2, r3
   881d6:	4b10      	ldr	r3, [pc, #64]	; (88218 <xTaskPriorityDisinherit+0xdc>)
   881d8:	681b      	ldr	r3, [r3, #0]
   881da:	431a      	orrs	r2, r3
   881dc:	4b0e      	ldr	r3, [pc, #56]	; (88218 <xTaskPriorityDisinherit+0xdc>)
   881de:	601a      	str	r2, [r3, #0]
   881e0:	68bb      	ldr	r3, [r7, #8]
   881e2:	6ada      	ldr	r2, [r3, #44]	; 0x2c
   881e4:	4613      	mov	r3, r2
   881e6:	009b      	lsls	r3, r3, #2
   881e8:	4413      	add	r3, r2
   881ea:	009b      	lsls	r3, r3, #2
   881ec:	4a09      	ldr	r2, [pc, #36]	; (88214 <xTaskPriorityDisinherit+0xd8>)
   881ee:	441a      	add	r2, r3
   881f0:	68bb      	ldr	r3, [r7, #8]
   881f2:	3304      	adds	r3, #4
   881f4:	4610      	mov	r0, r2
   881f6:	4619      	mov	r1, r3
   881f8:	4b08      	ldr	r3, [pc, #32]	; (8821c <xTaskPriorityDisinherit+0xe0>)
   881fa:	4798      	blx	r3

					/* Return true to indicate that a context switch is required.
					This is only actually required in the corner case whereby
					multiple mutexes were held and the mutexes were given back
					in an order different to that in which they were taken. */
					xReturn = pdTRUE;
   881fc:	2301      	movs	r3, #1
   881fe:	60fb      	str	r3, [r7, #12]
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		return xReturn;
   88200:	68fb      	ldr	r3, [r7, #12]
	}
   88202:	4618      	mov	r0, r3
   88204:	3710      	adds	r7, #16
   88206:	46bd      	mov	sp, r7
   88208:	bd80      	pop	{r7, pc}
   8820a:	bf00      	nop
   8820c:	000864f9 	.word	0x000864f9
   88210:	00086281 	.word	0x00086281
   88214:	2007ac74 	.word	0x2007ac74
   88218:	2007ad50 	.word	0x2007ad50
   8821c:	000861c9 	.word	0x000861c9

00088220 <pvTaskIncrementMutexHeldCount>:
/*-----------------------------------------------------------*/

#if ( configUSE_MUTEXES == 1 )

	void *pvTaskIncrementMutexHeldCount( void )
	{
   88220:	b480      	push	{r7}
   88222:	af00      	add	r7, sp, #0
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
   88224:	4b07      	ldr	r3, [pc, #28]	; (88244 <pvTaskIncrementMutexHeldCount+0x24>)
   88226:	681b      	ldr	r3, [r3, #0]
   88228:	2b00      	cmp	r3, #0
   8822a:	d004      	beq.n	88236 <pvTaskIncrementMutexHeldCount+0x16>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
   8822c:	4b05      	ldr	r3, [pc, #20]	; (88244 <pvTaskIncrementMutexHeldCount+0x24>)
   8822e:	681b      	ldr	r3, [r3, #0]
   88230:	6c5a      	ldr	r2, [r3, #68]	; 0x44
   88232:	3201      	adds	r2, #1
   88234:	645a      	str	r2, [r3, #68]	; 0x44
		}

		return pxCurrentTCB;
   88236:	4b03      	ldr	r3, [pc, #12]	; (88244 <pvTaskIncrementMutexHeldCount+0x24>)
   88238:	681b      	ldr	r3, [r3, #0]
	}
   8823a:	4618      	mov	r0, r3
   8823c:	46bd      	mov	sp, r7
   8823e:	f85d 7b04 	ldr.w	r7, [sp], #4
   88242:	4770      	bx	lr
   88244:	2007ac70 	.word	0x2007ac70

00088248 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
   88248:	b590      	push	{r4, r7, lr}
   8824a:	b087      	sub	sp, #28
   8824c:	af04      	add	r7, sp, #16
BaseType_t xReturn = pdFAIL;
   8824e:	2300      	movs	r3, #0
   88250:	607b      	str	r3, [r7, #4]

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
   88252:	4b10      	ldr	r3, [pc, #64]	; (88294 <xTimerCreateTimerTask+0x4c>)
   88254:	4798      	blx	r3

	if( xTimerQueue != NULL )
   88256:	4b10      	ldr	r3, [pc, #64]	; (88298 <xTimerCreateTimerTask+0x50>)
   88258:	681b      	ldr	r3, [r3, #0]
   8825a:	2b00      	cmp	r3, #0
   8825c:	d00f      	beq.n	8827e <xTimerCreateTimerTask+0x36>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
   8825e:	2302      	movs	r3, #2
   88260:	9300      	str	r3, [sp, #0]
   88262:	2300      	movs	r3, #0
   88264:	9301      	str	r3, [sp, #4]
   88266:	2300      	movs	r3, #0
   88268:	9302      	str	r3, [sp, #8]
   8826a:	2300      	movs	r3, #0
   8826c:	9303      	str	r3, [sp, #12]
   8826e:	480b      	ldr	r0, [pc, #44]	; (8829c <xTimerCreateTimerTask+0x54>)
   88270:	490b      	ldr	r1, [pc, #44]	; (882a0 <xTimerCreateTimerTask+0x58>)
   88272:	f44f 7282 	mov.w	r2, #260	; 0x104
   88276:	2300      	movs	r3, #0
   88278:	4c0a      	ldr	r4, [pc, #40]	; (882a4 <xTimerCreateTimerTask+0x5c>)
   8827a:	47a0      	blx	r4
   8827c:	6078      	str	r0, [r7, #4]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
   8827e:	687b      	ldr	r3, [r7, #4]
   88280:	2b00      	cmp	r3, #0
   88282:	d102      	bne.n	8828a <xTimerCreateTimerTask+0x42>
   88284:	4b08      	ldr	r3, [pc, #32]	; (882a8 <xTimerCreateTimerTask+0x60>)
   88286:	4798      	blx	r3
   88288:	e7fe      	b.n	88288 <xTimerCreateTimerTask+0x40>
	return xReturn;
   8828a:	687b      	ldr	r3, [r7, #4]
}
   8828c:	4618      	mov	r0, r3
   8828e:	370c      	adds	r7, #12
   88290:	46bd      	mov	sp, r7
   88292:	bd90      	pop	{r4, r7, pc}
   88294:	0008877d 	.word	0x0008877d
   88298:	2007ad9c 	.word	0x2007ad9c
   8829c:	000883c5 	.word	0x000883c5
   882a0:	0008b188 	.word	0x0008b188
   882a4:	00087335 	.word	0x00087335
   882a8:	000864f9 	.word	0x000864f9

000882ac <xTimerGenericCommand>:
	return ( TimerHandle_t ) pxNewTimer;
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
   882ac:	b590      	push	{r4, r7, lr}
   882ae:	b089      	sub	sp, #36	; 0x24
   882b0:	af00      	add	r7, sp, #0
   882b2:	60f8      	str	r0, [r7, #12]
   882b4:	60b9      	str	r1, [r7, #8]
   882b6:	607a      	str	r2, [r7, #4]
   882b8:	603b      	str	r3, [r7, #0]
BaseType_t xReturn = pdFAIL;
   882ba:	2300      	movs	r3, #0
   882bc:	61fb      	str	r3, [r7, #28]
DaemonTaskMessage_t xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
   882be:	4b1d      	ldr	r3, [pc, #116]	; (88334 <xTimerGenericCommand+0x88>)
   882c0:	681b      	ldr	r3, [r3, #0]
   882c2:	2b00      	cmp	r3, #0
   882c4:	d030      	beq.n	88328 <xTimerGenericCommand+0x7c>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
   882c6:	68bb      	ldr	r3, [r7, #8]
   882c8:	613b      	str	r3, [r7, #16]
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
   882ca:	687b      	ldr	r3, [r7, #4]
   882cc:	617b      	str	r3, [r7, #20]
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
   882ce:	68fb      	ldr	r3, [r7, #12]
   882d0:	61bb      	str	r3, [r7, #24]

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
   882d2:	68bb      	ldr	r3, [r7, #8]
   882d4:	2b05      	cmp	r3, #5
   882d6:	dc1c      	bgt.n	88312 <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
   882d8:	4b17      	ldr	r3, [pc, #92]	; (88338 <xTimerGenericCommand+0x8c>)
   882da:	4798      	blx	r3
   882dc:	4603      	mov	r3, r0
   882de:	2b02      	cmp	r3, #2
   882e0:	d10b      	bne.n	882fa <xTimerGenericCommand+0x4e>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
   882e2:	4b14      	ldr	r3, [pc, #80]	; (88334 <xTimerGenericCommand+0x88>)
   882e4:	681a      	ldr	r2, [r3, #0]
   882e6:	f107 0310 	add.w	r3, r7, #16
   882ea:	4610      	mov	r0, r2
   882ec:	4619      	mov	r1, r3
   882ee:	6b3a      	ldr	r2, [r7, #48]	; 0x30
   882f0:	2300      	movs	r3, #0
   882f2:	4c12      	ldr	r4, [pc, #72]	; (8833c <xTimerGenericCommand+0x90>)
   882f4:	47a0      	blx	r4
   882f6:	61f8      	str	r0, [r7, #28]
   882f8:	e016      	b.n	88328 <xTimerGenericCommand+0x7c>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
   882fa:	4b0e      	ldr	r3, [pc, #56]	; (88334 <xTimerGenericCommand+0x88>)
   882fc:	681a      	ldr	r2, [r3, #0]
   882fe:	f107 0310 	add.w	r3, r7, #16
   88302:	4610      	mov	r0, r2
   88304:	4619      	mov	r1, r3
   88306:	2200      	movs	r2, #0
   88308:	2300      	movs	r3, #0
   8830a:	4c0c      	ldr	r4, [pc, #48]	; (8833c <xTimerGenericCommand+0x90>)
   8830c:	47a0      	blx	r4
   8830e:	61f8      	str	r0, [r7, #28]
   88310:	e00a      	b.n	88328 <xTimerGenericCommand+0x7c>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
   88312:	4b08      	ldr	r3, [pc, #32]	; (88334 <xTimerGenericCommand+0x88>)
   88314:	681a      	ldr	r2, [r3, #0]
   88316:	f107 0310 	add.w	r3, r7, #16
   8831a:	4610      	mov	r0, r2
   8831c:	4619      	mov	r1, r3
   8831e:	683a      	ldr	r2, [r7, #0]
   88320:	2300      	movs	r3, #0
   88322:	4c07      	ldr	r4, [pc, #28]	; (88340 <xTimerGenericCommand+0x94>)
   88324:	47a0      	blx	r4
   88326:	61f8      	str	r0, [r7, #28]
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
   88328:	69fb      	ldr	r3, [r7, #28]
}
   8832a:	4618      	mov	r0, r3
   8832c:	3724      	adds	r7, #36	; 0x24
   8832e:	46bd      	mov	sp, r7
   88330:	bd90      	pop	{r4, r7, pc}
   88332:	bf00      	nop
   88334:	2007ad9c 	.word	0x2007ad9c
   88338:	0008800d 	.word	0x0008800d
   8833c:	00086b01 	.word	0x00086b01
   88340:	00086cc5 	.word	0x00086cc5

00088344 <prvProcessExpiredTimer>:
	return pxTimer->pcTimerName;
}
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
   88344:	b590      	push	{r4, r7, lr}
   88346:	b087      	sub	sp, #28
   88348:	af02      	add	r7, sp, #8
   8834a:	6078      	str	r0, [r7, #4]
   8834c:	6039      	str	r1, [r7, #0]
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   8834e:	4b18      	ldr	r3, [pc, #96]	; (883b0 <prvProcessExpiredTimer+0x6c>)
   88350:	681b      	ldr	r3, [r3, #0]
   88352:	68db      	ldr	r3, [r3, #12]
   88354:	68db      	ldr	r3, [r3, #12]
   88356:	60fb      	str	r3, [r7, #12]

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   88358:	68fb      	ldr	r3, [r7, #12]
   8835a:	3304      	adds	r3, #4
   8835c:	4618      	mov	r0, r3
   8835e:	4b15      	ldr	r3, [pc, #84]	; (883b4 <prvProcessExpiredTimer+0x70>)
   88360:	4798      	blx	r3
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   88362:	68fb      	ldr	r3, [r7, #12]
   88364:	69db      	ldr	r3, [r3, #28]
   88366:	2b01      	cmp	r3, #1
   88368:	d11b      	bne.n	883a2 <prvProcessExpiredTimer+0x5e>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
   8836a:	68fb      	ldr	r3, [r7, #12]
   8836c:	699a      	ldr	r2, [r3, #24]
   8836e:	687b      	ldr	r3, [r7, #4]
   88370:	4413      	add	r3, r2
   88372:	68f8      	ldr	r0, [r7, #12]
   88374:	4619      	mov	r1, r3
   88376:	683a      	ldr	r2, [r7, #0]
   88378:	687b      	ldr	r3, [r7, #4]
   8837a:	4c0f      	ldr	r4, [pc, #60]	; (883b8 <prvProcessExpiredTimer+0x74>)
   8837c:	47a0      	blx	r4
   8837e:	4603      	mov	r3, r0
   88380:	2b01      	cmp	r3, #1
   88382:	d10e      	bne.n	883a2 <prvProcessExpiredTimer+0x5e>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   88384:	2300      	movs	r3, #0
   88386:	9300      	str	r3, [sp, #0]
   88388:	68f8      	ldr	r0, [r7, #12]
   8838a:	2100      	movs	r1, #0
   8838c:	687a      	ldr	r2, [r7, #4]
   8838e:	2300      	movs	r3, #0
   88390:	4c0a      	ldr	r4, [pc, #40]	; (883bc <prvProcessExpiredTimer+0x78>)
   88392:	47a0      	blx	r4
   88394:	60b8      	str	r0, [r7, #8]
			configASSERT( xResult );
   88396:	68bb      	ldr	r3, [r7, #8]
   88398:	2b00      	cmp	r3, #0
   8839a:	d102      	bne.n	883a2 <prvProcessExpiredTimer+0x5e>
   8839c:	4b08      	ldr	r3, [pc, #32]	; (883c0 <prvProcessExpiredTimer+0x7c>)
   8839e:	4798      	blx	r3
   883a0:	e7fe      	b.n	883a0 <prvProcessExpiredTimer+0x5c>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   883a2:	68fb      	ldr	r3, [r7, #12]
   883a4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   883a6:	68f8      	ldr	r0, [r7, #12]
   883a8:	4798      	blx	r3
}
   883aa:	3714      	adds	r7, #20
   883ac:	46bd      	mov	sp, r7
   883ae:	bd90      	pop	{r4, r7, pc}
   883b0:	2007ad94 	.word	0x2007ad94
   883b4:	00086281 	.word	0x00086281
   883b8:	00088509 	.word	0x00088509
   883bc:	000882ad 	.word	0x000882ad
   883c0:	000864f9 	.word	0x000864f9

000883c4 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
   883c4:	b580      	push	{r7, lr}
   883c6:	b084      	sub	sp, #16
   883c8:	af00      	add	r7, sp, #0
   883ca:	6078      	str	r0, [r7, #4]

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
   883cc:	f107 0308 	add.w	r3, r7, #8
   883d0:	4618      	mov	r0, r3
   883d2:	4b05      	ldr	r3, [pc, #20]	; (883e8 <prvTimerTask+0x24>)
   883d4:	4798      	blx	r3
   883d6:	60f8      	str	r0, [r7, #12]

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
   883d8:	68bb      	ldr	r3, [r7, #8]
   883da:	68f8      	ldr	r0, [r7, #12]
   883dc:	4619      	mov	r1, r3
   883de:	4b03      	ldr	r3, [pc, #12]	; (883ec <prvTimerTask+0x28>)
   883e0:	4798      	blx	r3

		/* Empty the command queue. */
		prvProcessReceivedCommands();
   883e2:	4b03      	ldr	r3, [pc, #12]	; (883f0 <prvTimerTask+0x2c>)
   883e4:	4798      	blx	r3
	}
   883e6:	e7f1      	b.n	883cc <prvTimerTask+0x8>
   883e8:	00088479 	.word	0x00088479
   883ec:	000883f5 	.word	0x000883f5
   883f0:	00088591 	.word	0x00088591

000883f4 <prvProcessTimerOrBlockTask>:
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, const BaseType_t xListWasEmpty )
{
   883f4:	b580      	push	{r7, lr}
   883f6:	b084      	sub	sp, #16
   883f8:	af00      	add	r7, sp, #0
   883fa:	6078      	str	r0, [r7, #4]
   883fc:	6039      	str	r1, [r7, #0]
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
   883fe:	4b17      	ldr	r3, [pc, #92]	; (8845c <prvProcessTimerOrBlockTask+0x68>)
   88400:	4798      	blx	r3
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   88402:	f107 0308 	add.w	r3, r7, #8
   88406:	4618      	mov	r0, r3
   88408:	4b15      	ldr	r3, [pc, #84]	; (88460 <prvProcessTimerOrBlockTask+0x6c>)
   8840a:	4798      	blx	r3
   8840c:	60f8      	str	r0, [r7, #12]
		if( xTimerListsWereSwitched == pdFALSE )
   8840e:	68bb      	ldr	r3, [r7, #8]
   88410:	2b00      	cmp	r3, #0
   88412:	d11e      	bne.n	88452 <prvProcessTimerOrBlockTask+0x5e>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
   88414:	683b      	ldr	r3, [r7, #0]
   88416:	2b00      	cmp	r3, #0
   88418:	d10a      	bne.n	88430 <prvProcessTimerOrBlockTask+0x3c>
   8841a:	687a      	ldr	r2, [r7, #4]
   8841c:	68fb      	ldr	r3, [r7, #12]
   8841e:	429a      	cmp	r2, r3
   88420:	d806      	bhi.n	88430 <prvProcessTimerOrBlockTask+0x3c>
			{
				( void ) xTaskResumeAll();
   88422:	4b10      	ldr	r3, [pc, #64]	; (88464 <prvProcessTimerOrBlockTask+0x70>)
   88424:	4798      	blx	r3
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
   88426:	6878      	ldr	r0, [r7, #4]
   88428:	68f9      	ldr	r1, [r7, #12]
   8842a:	4b0f      	ldr	r3, [pc, #60]	; (88468 <prvProcessTimerOrBlockTask+0x74>)
   8842c:	4798      	blx	r3
   8842e:	e012      	b.n	88456 <prvProcessTimerOrBlockTask+0x62>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
   88430:	4b0e      	ldr	r3, [pc, #56]	; (8846c <prvProcessTimerOrBlockTask+0x78>)
   88432:	681a      	ldr	r2, [r3, #0]
   88434:	6879      	ldr	r1, [r7, #4]
   88436:	68fb      	ldr	r3, [r7, #12]
   88438:	1acb      	subs	r3, r1, r3
   8843a:	4610      	mov	r0, r2
   8843c:	4619      	mov	r1, r3
   8843e:	4b0c      	ldr	r3, [pc, #48]	; (88470 <prvProcessTimerOrBlockTask+0x7c>)
   88440:	4798      	blx	r3

				if( xTaskResumeAll() == pdFALSE )
   88442:	4b08      	ldr	r3, [pc, #32]	; (88464 <prvProcessTimerOrBlockTask+0x70>)
   88444:	4798      	blx	r3
   88446:	4603      	mov	r3, r0
   88448:	2b00      	cmp	r3, #0
   8844a:	d104      	bne.n	88456 <prvProcessTimerOrBlockTask+0x62>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
   8844c:	4b09      	ldr	r3, [pc, #36]	; (88474 <prvProcessTimerOrBlockTask+0x80>)
   8844e:	4798      	blx	r3
   88450:	e001      	b.n	88456 <prvProcessTimerOrBlockTask+0x62>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
   88452:	4b04      	ldr	r3, [pc, #16]	; (88464 <prvProcessTimerOrBlockTask+0x70>)
   88454:	4798      	blx	r3
		}
	}
}
   88456:	3710      	adds	r7, #16
   88458:	46bd      	mov	sp, r7
   8845a:	bd80      	pop	{r7, pc}
   8845c:	00087631 	.word	0x00087631
   88460:	000884c1 	.word	0x000884c1
   88464:	0008764d 	.word	0x0008764d
   88468:	00088345 	.word	0x00088345
   8846c:	2007ad9c 	.word	0x2007ad9c
   88470:	000872cd 	.word	0x000872cd
   88474:	0008645d 	.word	0x0008645d

00088478 <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty )
{
   88478:	b480      	push	{r7}
   8847a:	b085      	sub	sp, #20
   8847c:	af00      	add	r7, sp, #0
   8847e:	6078      	str	r0, [r7, #4]
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
   88480:	4b0e      	ldr	r3, [pc, #56]	; (884bc <prvGetNextExpireTime+0x44>)
   88482:	681b      	ldr	r3, [r3, #0]
   88484:	681b      	ldr	r3, [r3, #0]
   88486:	2b00      	cmp	r3, #0
   88488:	bf14      	ite	ne
   8848a:	2300      	movne	r3, #0
   8848c:	2301      	moveq	r3, #1
   8848e:	b2db      	uxtb	r3, r3
   88490:	461a      	mov	r2, r3
   88492:	687b      	ldr	r3, [r7, #4]
   88494:	601a      	str	r2, [r3, #0]
	if( *pxListWasEmpty == pdFALSE )
   88496:	687b      	ldr	r3, [r7, #4]
   88498:	681b      	ldr	r3, [r3, #0]
   8849a:	2b00      	cmp	r3, #0
   8849c:	d105      	bne.n	884aa <prvGetNextExpireTime+0x32>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   8849e:	4b07      	ldr	r3, [pc, #28]	; (884bc <prvGetNextExpireTime+0x44>)
   884a0:	681b      	ldr	r3, [r3, #0]
   884a2:	68db      	ldr	r3, [r3, #12]
   884a4:	681b      	ldr	r3, [r3, #0]
   884a6:	60fb      	str	r3, [r7, #12]
   884a8:	e001      	b.n	884ae <prvGetNextExpireTime+0x36>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
   884aa:	2300      	movs	r3, #0
   884ac:	60fb      	str	r3, [r7, #12]
	}

	return xNextExpireTime;
   884ae:	68fb      	ldr	r3, [r7, #12]
}
   884b0:	4618      	mov	r0, r3
   884b2:	3714      	adds	r7, #20
   884b4:	46bd      	mov	sp, r7
   884b6:	f85d 7b04 	ldr.w	r7, [sp], #4
   884ba:	4770      	bx	lr
   884bc:	2007ad94 	.word	0x2007ad94

000884c0 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
   884c0:	b580      	push	{r7, lr}
   884c2:	b084      	sub	sp, #16
   884c4:	af00      	add	r7, sp, #0
   884c6:	6078      	str	r0, [r7, #4]
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
   884c8:	4b0c      	ldr	r3, [pc, #48]	; (884fc <prvSampleTimeNow+0x3c>)
   884ca:	4798      	blx	r3
   884cc:	60f8      	str	r0, [r7, #12]

	if( xTimeNow < xLastTime )
   884ce:	4b0c      	ldr	r3, [pc, #48]	; (88500 <prvSampleTimeNow+0x40>)
   884d0:	681b      	ldr	r3, [r3, #0]
   884d2:	68fa      	ldr	r2, [r7, #12]
   884d4:	429a      	cmp	r2, r3
   884d6:	d205      	bcs.n	884e4 <prvSampleTimeNow+0x24>
	{
		prvSwitchTimerLists();
   884d8:	4b0a      	ldr	r3, [pc, #40]	; (88504 <prvSampleTimeNow+0x44>)
   884da:	4798      	blx	r3
		*pxTimerListsWereSwitched = pdTRUE;
   884dc:	687b      	ldr	r3, [r7, #4]
   884de:	2201      	movs	r2, #1
   884e0:	601a      	str	r2, [r3, #0]
   884e2:	e002      	b.n	884ea <prvSampleTimeNow+0x2a>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
   884e4:	687b      	ldr	r3, [r7, #4]
   884e6:	2200      	movs	r2, #0
   884e8:	601a      	str	r2, [r3, #0]
	}

	xLastTime = xTimeNow;
   884ea:	4b05      	ldr	r3, [pc, #20]	; (88500 <prvSampleTimeNow+0x40>)
   884ec:	68fa      	ldr	r2, [r7, #12]
   884ee:	601a      	str	r2, [r3, #0]

	return xTimeNow;
   884f0:	68fb      	ldr	r3, [r7, #12]
}
   884f2:	4618      	mov	r0, r3
   884f4:	3710      	adds	r7, #16
   884f6:	46bd      	mov	sp, r7
   884f8:	bd80      	pop	{r7, pc}
   884fa:	bf00      	nop
   884fc:	00087771 	.word	0x00087771
   88500:	2007ada0 	.word	0x2007ada0
   88504:	000886bd 	.word	0x000886bd

00088508 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
   88508:	b580      	push	{r7, lr}
   8850a:	b086      	sub	sp, #24
   8850c:	af00      	add	r7, sp, #0
   8850e:	60f8      	str	r0, [r7, #12]
   88510:	60b9      	str	r1, [r7, #8]
   88512:	607a      	str	r2, [r7, #4]
   88514:	603b      	str	r3, [r7, #0]
BaseType_t xProcessTimerNow = pdFALSE;
   88516:	2300      	movs	r3, #0
   88518:	617b      	str	r3, [r7, #20]

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
   8851a:	68fb      	ldr	r3, [r7, #12]
   8851c:	68ba      	ldr	r2, [r7, #8]
   8851e:	605a      	str	r2, [r3, #4]
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   88520:	68fb      	ldr	r3, [r7, #12]
   88522:	68fa      	ldr	r2, [r7, #12]
   88524:	611a      	str	r2, [r3, #16]

	if( xNextExpiryTime <= xTimeNow )
   88526:	68ba      	ldr	r2, [r7, #8]
   88528:	687b      	ldr	r3, [r7, #4]
   8852a:	429a      	cmp	r2, r3
   8852c:	d812      	bhi.n	88554 <prvInsertTimerInActiveList+0x4c>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
   8852e:	687a      	ldr	r2, [r7, #4]
   88530:	683b      	ldr	r3, [r7, #0]
   88532:	1ad2      	subs	r2, r2, r3
   88534:	68fb      	ldr	r3, [r7, #12]
   88536:	699b      	ldr	r3, [r3, #24]
   88538:	429a      	cmp	r2, r3
   8853a:	d302      	bcc.n	88542 <prvInsertTimerInActiveList+0x3a>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
   8853c:	2301      	movs	r3, #1
   8853e:	617b      	str	r3, [r7, #20]
   88540:	e01b      	b.n	8857a <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
   88542:	4b10      	ldr	r3, [pc, #64]	; (88584 <prvInsertTimerInActiveList+0x7c>)
   88544:	681a      	ldr	r2, [r3, #0]
   88546:	68fb      	ldr	r3, [r7, #12]
   88548:	3304      	adds	r3, #4
   8854a:	4610      	mov	r0, r2
   8854c:	4619      	mov	r1, r3
   8854e:	4b0e      	ldr	r3, [pc, #56]	; (88588 <prvInsertTimerInActiveList+0x80>)
   88550:	4798      	blx	r3
   88552:	e012      	b.n	8857a <prvInsertTimerInActiveList+0x72>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
   88554:	687a      	ldr	r2, [r7, #4]
   88556:	683b      	ldr	r3, [r7, #0]
   88558:	429a      	cmp	r2, r3
   8855a:	d206      	bcs.n	8856a <prvInsertTimerInActiveList+0x62>
   8855c:	68ba      	ldr	r2, [r7, #8]
   8855e:	683b      	ldr	r3, [r7, #0]
   88560:	429a      	cmp	r2, r3
   88562:	d302      	bcc.n	8856a <prvInsertTimerInActiveList+0x62>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
   88564:	2301      	movs	r3, #1
   88566:	617b      	str	r3, [r7, #20]
   88568:	e007      	b.n	8857a <prvInsertTimerInActiveList+0x72>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   8856a:	4b08      	ldr	r3, [pc, #32]	; (8858c <prvInsertTimerInActiveList+0x84>)
   8856c:	681a      	ldr	r2, [r3, #0]
   8856e:	68fb      	ldr	r3, [r7, #12]
   88570:	3304      	adds	r3, #4
   88572:	4610      	mov	r0, r2
   88574:	4619      	mov	r1, r3
   88576:	4b04      	ldr	r3, [pc, #16]	; (88588 <prvInsertTimerInActiveList+0x80>)
   88578:	4798      	blx	r3
		}
	}

	return xProcessTimerNow;
   8857a:	697b      	ldr	r3, [r7, #20]
}
   8857c:	4618      	mov	r0, r3
   8857e:	3718      	adds	r7, #24
   88580:	46bd      	mov	sp, r7
   88582:	bd80      	pop	{r7, pc}
   88584:	2007ad98 	.word	0x2007ad98
   88588:	00086211 	.word	0x00086211
   8858c:	2007ad94 	.word	0x2007ad94

00088590 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
   88590:	b590      	push	{r4, r7, lr}
   88592:	b08b      	sub	sp, #44	; 0x2c
   88594:	af02      	add	r7, sp, #8
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   88596:	e070      	b.n	8867a <prvProcessReceivedCommands+0xea>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
   88598:	68bb      	ldr	r3, [r7, #8]
   8859a:	2b00      	cmp	r3, #0
   8859c:	db6d      	blt.n	8867a <prvProcessReceivedCommands+0xea>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
   8859e:	693b      	ldr	r3, [r7, #16]
   885a0:	61fb      	str	r3, [r7, #28]

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
   885a2:	69fb      	ldr	r3, [r7, #28]
   885a4:	695b      	ldr	r3, [r3, #20]
   885a6:	2b00      	cmp	r3, #0
   885a8:	d004      	beq.n	885b4 <prvProcessReceivedCommands+0x24>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   885aa:	69fb      	ldr	r3, [r7, #28]
   885ac:	3304      	adds	r3, #4
   885ae:	4618      	mov	r0, r3
   885b0:	4b3a      	ldr	r3, [pc, #232]	; (8869c <prvProcessReceivedCommands+0x10c>)
   885b2:	4798      	blx	r3
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
   885b4:	1d3b      	adds	r3, r7, #4
   885b6:	4618      	mov	r0, r3
   885b8:	4b39      	ldr	r3, [pc, #228]	; (886a0 <prvProcessReceivedCommands+0x110>)
   885ba:	4798      	blx	r3
   885bc:	61b8      	str	r0, [r7, #24]

			switch( xMessage.xMessageID )
   885be:	68bb      	ldr	r3, [r7, #8]
   885c0:	2b09      	cmp	r3, #9
   885c2:	d859      	bhi.n	88678 <prvProcessReceivedCommands+0xe8>
   885c4:	a201      	add	r2, pc, #4	; (adr r2, 885cc <prvProcessReceivedCommands+0x3c>)
   885c6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   885ca:	bf00      	nop
   885cc:	000885f5 	.word	0x000885f5
   885d0:	000885f5 	.word	0x000885f5
   885d4:	000885f5 	.word	0x000885f5
   885d8:	00088679 	.word	0x00088679
   885dc:	00088647 	.word	0x00088647
   885e0:	00088671 	.word	0x00088671
   885e4:	000885f5 	.word	0x000885f5
   885e8:	000885f5 	.word	0x000885f5
   885ec:	00088679 	.word	0x00088679
   885f0:	00088647 	.word	0x00088647
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
   885f4:	68fa      	ldr	r2, [r7, #12]
   885f6:	69fb      	ldr	r3, [r7, #28]
   885f8:	699b      	ldr	r3, [r3, #24]
   885fa:	441a      	add	r2, r3
   885fc:	68fb      	ldr	r3, [r7, #12]
   885fe:	69f8      	ldr	r0, [r7, #28]
   88600:	4611      	mov	r1, r2
   88602:	69ba      	ldr	r2, [r7, #24]
   88604:	4c27      	ldr	r4, [pc, #156]	; (886a4 <prvProcessReceivedCommands+0x114>)
   88606:	47a0      	blx	r4
   88608:	4603      	mov	r3, r0
   8860a:	2b01      	cmp	r3, #1
   8860c:	d11a      	bne.n	88644 <prvProcessReceivedCommands+0xb4>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   8860e:	69fb      	ldr	r3, [r7, #28]
   88610:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   88612:	69f8      	ldr	r0, [r7, #28]
   88614:	4798      	blx	r3
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   88616:	69fb      	ldr	r3, [r7, #28]
   88618:	69db      	ldr	r3, [r3, #28]
   8861a:	2b01      	cmp	r3, #1
   8861c:	d112      	bne.n	88644 <prvProcessReceivedCommands+0xb4>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
   8861e:	68fa      	ldr	r2, [r7, #12]
   88620:	69fb      	ldr	r3, [r7, #28]
   88622:	699b      	ldr	r3, [r3, #24]
   88624:	4413      	add	r3, r2
   88626:	2200      	movs	r2, #0
   88628:	9200      	str	r2, [sp, #0]
   8862a:	69f8      	ldr	r0, [r7, #28]
   8862c:	2100      	movs	r1, #0
   8862e:	461a      	mov	r2, r3
   88630:	2300      	movs	r3, #0
   88632:	4c1d      	ldr	r4, [pc, #116]	; (886a8 <prvProcessReceivedCommands+0x118>)
   88634:	47a0      	blx	r4
   88636:	6178      	str	r0, [r7, #20]
							configASSERT( xResult );
   88638:	697b      	ldr	r3, [r7, #20]
   8863a:	2b00      	cmp	r3, #0
   8863c:	d102      	bne.n	88644 <prvProcessReceivedCommands+0xb4>
   8863e:	4b1b      	ldr	r3, [pc, #108]	; (886ac <prvProcessReceivedCommands+0x11c>)
   88640:	4798      	blx	r3
   88642:	e7fe      	b.n	88642 <prvProcessReceivedCommands+0xb2>
					}
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}
					break;
   88644:	e019      	b.n	8867a <prvProcessReceivedCommands+0xea>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
   88646:	68fa      	ldr	r2, [r7, #12]
   88648:	69fb      	ldr	r3, [r7, #28]
   8864a:	619a      	str	r2, [r3, #24]
					configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
   8864c:	69fb      	ldr	r3, [r7, #28]
   8864e:	699b      	ldr	r3, [r3, #24]
   88650:	2b00      	cmp	r3, #0
   88652:	d102      	bne.n	8865a <prvProcessReceivedCommands+0xca>
   88654:	4b15      	ldr	r3, [pc, #84]	; (886ac <prvProcessReceivedCommands+0x11c>)
   88656:	4798      	blx	r3
   88658:	e7fe      	b.n	88658 <prvProcessReceivedCommands+0xc8>
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
   8865a:	69fb      	ldr	r3, [r7, #28]
   8865c:	699a      	ldr	r2, [r3, #24]
   8865e:	69bb      	ldr	r3, [r7, #24]
   88660:	4413      	add	r3, r2
   88662:	69f8      	ldr	r0, [r7, #28]
   88664:	4619      	mov	r1, r3
   88666:	69ba      	ldr	r2, [r7, #24]
   88668:	69bb      	ldr	r3, [r7, #24]
   8866a:	4c0e      	ldr	r4, [pc, #56]	; (886a4 <prvProcessReceivedCommands+0x114>)
   8866c:	47a0      	blx	r4
					break;
   8866e:	e004      	b.n	8867a <prvProcessReceivedCommands+0xea>

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
   88670:	69f8      	ldr	r0, [r7, #28]
   88672:	4b0f      	ldr	r3, [pc, #60]	; (886b0 <prvProcessReceivedCommands+0x120>)
   88674:	4798      	blx	r3
					break;
   88676:	e000      	b.n	8867a <prvProcessReceivedCommands+0xea>

				default	:
					/* Don't expect to get here. */
					break;
   88678:	bf00      	nop
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
   8867a:	4b0e      	ldr	r3, [pc, #56]	; (886b4 <prvProcessReceivedCommands+0x124>)
   8867c:	681a      	ldr	r2, [r3, #0]
   8867e:	f107 0308 	add.w	r3, r7, #8
   88682:	4610      	mov	r0, r2
   88684:	4619      	mov	r1, r3
   88686:	2200      	movs	r2, #0
   88688:	2300      	movs	r3, #0
   8868a:	4c0b      	ldr	r4, [pc, #44]	; (886b8 <prvProcessReceivedCommands+0x128>)
   8868c:	47a0      	blx	r4
   8868e:	4603      	mov	r3, r0
   88690:	2b00      	cmp	r3, #0
   88692:	d181      	bne.n	88598 <prvProcessReceivedCommands+0x8>
					/* Don't expect to get here. */
					break;
			}
		}
	}
}
   88694:	3724      	adds	r7, #36	; 0x24
   88696:	46bd      	mov	sp, r7
   88698:	bd90      	pop	{r4, r7, pc}
   8869a:	bf00      	nop
   8869c:	00086281 	.word	0x00086281
   886a0:	000884c1 	.word	0x000884c1
   886a4:	00088509 	.word	0x00088509
   886a8:	000882ad 	.word	0x000882ad
   886ac:	000864f9 	.word	0x000864f9
   886b0:	00086795 	.word	0x00086795
   886b4:	2007ad9c 	.word	0x2007ad9c
   886b8:	00086dc1 	.word	0x00086dc1

000886bc <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( void )
{
   886bc:	b590      	push	{r4, r7, lr}
   886be:	b089      	sub	sp, #36	; 0x24
   886c0:	af02      	add	r7, sp, #8

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   886c2:	e03d      	b.n	88740 <prvSwitchTimerLists+0x84>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
   886c4:	4b27      	ldr	r3, [pc, #156]	; (88764 <prvSwitchTimerLists+0xa8>)
   886c6:	681b      	ldr	r3, [r3, #0]
   886c8:	68db      	ldr	r3, [r3, #12]
   886ca:	681b      	ldr	r3, [r3, #0]
   886cc:	617b      	str	r3, [r7, #20]

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
   886ce:	4b25      	ldr	r3, [pc, #148]	; (88764 <prvSwitchTimerLists+0xa8>)
   886d0:	681b      	ldr	r3, [r3, #0]
   886d2:	68db      	ldr	r3, [r3, #12]
   886d4:	68db      	ldr	r3, [r3, #12]
   886d6:	613b      	str	r3, [r7, #16]
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
   886d8:	693b      	ldr	r3, [r7, #16]
   886da:	3304      	adds	r3, #4
   886dc:	4618      	mov	r0, r3
   886de:	4b22      	ldr	r3, [pc, #136]	; (88768 <prvSwitchTimerLists+0xac>)
   886e0:	4798      	blx	r3
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
   886e2:	693b      	ldr	r3, [r7, #16]
   886e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
   886e6:	6938      	ldr	r0, [r7, #16]
   886e8:	4798      	blx	r3

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
   886ea:	693b      	ldr	r3, [r7, #16]
   886ec:	69db      	ldr	r3, [r3, #28]
   886ee:	2b01      	cmp	r3, #1
   886f0:	d126      	bne.n	88740 <prvSwitchTimerLists+0x84>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
   886f2:	693b      	ldr	r3, [r7, #16]
   886f4:	699a      	ldr	r2, [r3, #24]
   886f6:	697b      	ldr	r3, [r7, #20]
   886f8:	4413      	add	r3, r2
   886fa:	60fb      	str	r3, [r7, #12]
			if( xReloadTime > xNextExpireTime )
   886fc:	68fa      	ldr	r2, [r7, #12]
   886fe:	697b      	ldr	r3, [r7, #20]
   88700:	429a      	cmp	r2, r3
   88702:	d90e      	bls.n	88722 <prvSwitchTimerLists+0x66>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
   88704:	693b      	ldr	r3, [r7, #16]
   88706:	68fa      	ldr	r2, [r7, #12]
   88708:	605a      	str	r2, [r3, #4]
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
   8870a:	693b      	ldr	r3, [r7, #16]
   8870c:	693a      	ldr	r2, [r7, #16]
   8870e:	611a      	str	r2, [r3, #16]
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
   88710:	4b14      	ldr	r3, [pc, #80]	; (88764 <prvSwitchTimerLists+0xa8>)
   88712:	681a      	ldr	r2, [r3, #0]
   88714:	693b      	ldr	r3, [r7, #16]
   88716:	3304      	adds	r3, #4
   88718:	4610      	mov	r0, r2
   8871a:	4619      	mov	r1, r3
   8871c:	4b13      	ldr	r3, [pc, #76]	; (8876c <prvSwitchTimerLists+0xb0>)
   8871e:	4798      	blx	r3
   88720:	e00e      	b.n	88740 <prvSwitchTimerLists+0x84>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
   88722:	2300      	movs	r3, #0
   88724:	9300      	str	r3, [sp, #0]
   88726:	6938      	ldr	r0, [r7, #16]
   88728:	2100      	movs	r1, #0
   8872a:	697a      	ldr	r2, [r7, #20]
   8872c:	2300      	movs	r3, #0
   8872e:	4c10      	ldr	r4, [pc, #64]	; (88770 <prvSwitchTimerLists+0xb4>)
   88730:	47a0      	blx	r4
   88732:	60b8      	str	r0, [r7, #8]
				configASSERT( xResult );
   88734:	68bb      	ldr	r3, [r7, #8]
   88736:	2b00      	cmp	r3, #0
   88738:	d102      	bne.n	88740 <prvSwitchTimerLists+0x84>
   8873a:	4b0e      	ldr	r3, [pc, #56]	; (88774 <prvSwitchTimerLists+0xb8>)
   8873c:	4798      	blx	r3
   8873e:	e7fe      	b.n	8873e <prvSwitchTimerLists+0x82>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
   88740:	4b08      	ldr	r3, [pc, #32]	; (88764 <prvSwitchTimerLists+0xa8>)
   88742:	681b      	ldr	r3, [r3, #0]
   88744:	681b      	ldr	r3, [r3, #0]
   88746:	2b00      	cmp	r3, #0
   88748:	d1bc      	bne.n	886c4 <prvSwitchTimerLists+0x8>
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
   8874a:	4b06      	ldr	r3, [pc, #24]	; (88764 <prvSwitchTimerLists+0xa8>)
   8874c:	681b      	ldr	r3, [r3, #0]
   8874e:	607b      	str	r3, [r7, #4]
	pxCurrentTimerList = pxOverflowTimerList;
   88750:	4b09      	ldr	r3, [pc, #36]	; (88778 <prvSwitchTimerLists+0xbc>)
   88752:	681a      	ldr	r2, [r3, #0]
   88754:	4b03      	ldr	r3, [pc, #12]	; (88764 <prvSwitchTimerLists+0xa8>)
   88756:	601a      	str	r2, [r3, #0]
	pxOverflowTimerList = pxTemp;
   88758:	4b07      	ldr	r3, [pc, #28]	; (88778 <prvSwitchTimerLists+0xbc>)
   8875a:	687a      	ldr	r2, [r7, #4]
   8875c:	601a      	str	r2, [r3, #0]
}
   8875e:	371c      	adds	r7, #28
   88760:	46bd      	mov	sp, r7
   88762:	bd90      	pop	{r4, r7, pc}
   88764:	2007ad94 	.word	0x2007ad94
   88768:	00086281 	.word	0x00086281
   8876c:	00086211 	.word	0x00086211
   88770:	000882ad 	.word	0x000882ad
   88774:	000864f9 	.word	0x000864f9
   88778:	2007ad98 	.word	0x2007ad98

0008877c <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
   8877c:	b580      	push	{r7, lr}
   8877e:	af00      	add	r7, sp, #0
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
   88780:	4b11      	ldr	r3, [pc, #68]	; (887c8 <prvCheckForValidListAndQueue+0x4c>)
   88782:	4798      	blx	r3
	{
		if( xTimerQueue == NULL )
   88784:	4b11      	ldr	r3, [pc, #68]	; (887cc <prvCheckForValidListAndQueue+0x50>)
   88786:	681b      	ldr	r3, [r3, #0]
   88788:	2b00      	cmp	r3, #0
   8878a:	d11a      	bne.n	887c2 <prvCheckForValidListAndQueue+0x46>
		{
			vListInitialise( &xActiveTimerList1 );
   8878c:	4810      	ldr	r0, [pc, #64]	; (887d0 <prvCheckForValidListAndQueue+0x54>)
   8878e:	4b11      	ldr	r3, [pc, #68]	; (887d4 <prvCheckForValidListAndQueue+0x58>)
   88790:	4798      	blx	r3
			vListInitialise( &xActiveTimerList2 );
   88792:	4811      	ldr	r0, [pc, #68]	; (887d8 <prvCheckForValidListAndQueue+0x5c>)
   88794:	4b0f      	ldr	r3, [pc, #60]	; (887d4 <prvCheckForValidListAndQueue+0x58>)
   88796:	4798      	blx	r3
			pxCurrentTimerList = &xActiveTimerList1;
   88798:	4b10      	ldr	r3, [pc, #64]	; (887dc <prvCheckForValidListAndQueue+0x60>)
   8879a:	4a0d      	ldr	r2, [pc, #52]	; (887d0 <prvCheckForValidListAndQueue+0x54>)
   8879c:	601a      	str	r2, [r3, #0]
			pxOverflowTimerList = &xActiveTimerList2;
   8879e:	4b10      	ldr	r3, [pc, #64]	; (887e0 <prvCheckForValidListAndQueue+0x64>)
   887a0:	4a0d      	ldr	r2, [pc, #52]	; (887d8 <prvCheckForValidListAndQueue+0x5c>)
   887a2:	601a      	str	r2, [r3, #0]
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
   887a4:	2005      	movs	r0, #5
   887a6:	210c      	movs	r1, #12
   887a8:	2200      	movs	r2, #0
   887aa:	4b0e      	ldr	r3, [pc, #56]	; (887e4 <prvCheckForValidListAndQueue+0x68>)
   887ac:	4798      	blx	r3
   887ae:	4602      	mov	r2, r0
   887b0:	4b06      	ldr	r3, [pc, #24]	; (887cc <prvCheckForValidListAndQueue+0x50>)
   887b2:	601a      	str	r2, [r3, #0]
			configASSERT( xTimerQueue );
   887b4:	4b05      	ldr	r3, [pc, #20]	; (887cc <prvCheckForValidListAndQueue+0x50>)
   887b6:	681b      	ldr	r3, [r3, #0]
   887b8:	2b00      	cmp	r3, #0
   887ba:	d102      	bne.n	887c2 <prvCheckForValidListAndQueue+0x46>
   887bc:	4b0a      	ldr	r3, [pc, #40]	; (887e8 <prvCheckForValidListAndQueue+0x6c>)
   887be:	4798      	blx	r3
   887c0:	e7fe      	b.n	887c0 <prvCheckForValidListAndQueue+0x44>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
   887c2:	4b0a      	ldr	r3, [pc, #40]	; (887ec <prvCheckForValidListAndQueue+0x70>)
   887c4:	4798      	blx	r3
}
   887c6:	bd80      	pop	{r7, pc}
   887c8:	0008647d 	.word	0x0008647d
   887cc:	2007ad9c 	.word	0x2007ad9c
   887d0:	2007ad6c 	.word	0x2007ad6c
   887d4:	00086171 	.word	0x00086171
   887d8:	2007ad80 	.word	0x2007ad80
   887dc:	2007ad94 	.word	0x2007ad94
   887e0:	2007ad98 	.word	0x2007ad98
   887e4:	00086a75 	.word	0x00086a75
   887e8:	000864f9 	.word	0x000864f9
   887ec:	000864c1 	.word	0x000864c1

000887f0 <NVIC_EnableIRQ>:
    The interrupt number cannot be a negative value.

    \param [in]      IRQn  Number of the external interrupt to enable
 */
static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
{
   887f0:	b480      	push	{r7}
   887f2:	b083      	sub	sp, #12
   887f4:	af00      	add	r7, sp, #0
   887f6:	4603      	mov	r3, r0
   887f8:	71fb      	strb	r3, [r7, #7]
  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
   887fa:	4b08      	ldr	r3, [pc, #32]	; (8881c <NVIC_EnableIRQ+0x2c>)
   887fc:	f997 2007 	ldrsb.w	r2, [r7, #7]
   88800:	0952      	lsrs	r2, r2, #5
   88802:	79f9      	ldrb	r1, [r7, #7]
   88804:	f001 011f 	and.w	r1, r1, #31
   88808:	2001      	movs	r0, #1
   8880a:	fa00 f101 	lsl.w	r1, r0, r1
   8880e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
   88812:	370c      	adds	r7, #12
   88814:	46bd      	mov	sp, r7
   88816:	f85d 7b04 	ldr.w	r7, [sp], #4
   8881a:	4770      	bx	lr
   8881c:	e000e100 	.word	0xe000e100

00088820 <osc_get_rate>:

	return 0;
}

static inline uint32_t osc_get_rate(uint32_t ul_id)
{
   88820:	b480      	push	{r7}
   88822:	b083      	sub	sp, #12
   88824:	af00      	add	r7, sp, #0
   88826:	6078      	str	r0, [r7, #4]
	switch (ul_id) {
   88828:	687b      	ldr	r3, [r7, #4]
   8882a:	2b07      	cmp	r3, #7
   8882c:	d825      	bhi.n	8887a <osc_get_rate+0x5a>
   8882e:	a201      	add	r2, pc, #4	; (adr r2, 88834 <osc_get_rate+0x14>)
   88830:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   88834:	00088855 	.word	0x00088855
   88838:	0008885b 	.word	0x0008885b
   8883c:	00088861 	.word	0x00088861
   88840:	00088867 	.word	0x00088867
   88844:	0008886b 	.word	0x0008886b
   88848:	0008886f 	.word	0x0008886f
   8884c:	00088873 	.word	0x00088873
   88850:	00088877 	.word	0x00088877
	case OSC_SLCK_32K_RC:
		return OSC_SLCK_32K_RC_HZ;
   88854:	f44f 43fa 	mov.w	r3, #32000	; 0x7d00
   88858:	e010      	b.n	8887c <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_SLCK_XTAL
	case OSC_SLCK_32K_XTAL:
		return BOARD_FREQ_SLCK_XTAL;
   8885a:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   8885e:	e00d      	b.n	8887c <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_SLCK_BYPASS
	case OSC_SLCK_32K_BYPASS:
		return BOARD_FREQ_SLCK_BYPASS;
   88860:	f44f 4300 	mov.w	r3, #32768	; 0x8000
   88864:	e00a      	b.n	8887c <osc_get_rate+0x5c>
#endif

	case OSC_MAINCK_4M_RC:
		return OSC_MAINCK_4M_RC_HZ;
   88866:	4b08      	ldr	r3, [pc, #32]	; (88888 <osc_get_rate+0x68>)
   88868:	e008      	b.n	8887c <osc_get_rate+0x5c>

	case OSC_MAINCK_8M_RC:
		return OSC_MAINCK_8M_RC_HZ;
   8886a:	4b08      	ldr	r3, [pc, #32]	; (8888c <osc_get_rate+0x6c>)
   8886c:	e006      	b.n	8887c <osc_get_rate+0x5c>

	case OSC_MAINCK_12M_RC:
		return OSC_MAINCK_12M_RC_HZ;
   8886e:	4b08      	ldr	r3, [pc, #32]	; (88890 <osc_get_rate+0x70>)
   88870:	e004      	b.n	8887c <osc_get_rate+0x5c>

#ifdef BOARD_FREQ_MAINCK_XTAL
	case OSC_MAINCK_XTAL:
		return BOARD_FREQ_MAINCK_XTAL;
   88872:	4b07      	ldr	r3, [pc, #28]	; (88890 <osc_get_rate+0x70>)
   88874:	e002      	b.n	8887c <osc_get_rate+0x5c>
#endif

#ifdef BOARD_FREQ_MAINCK_BYPASS
	case OSC_MAINCK_BYPASS:
		return BOARD_FREQ_MAINCK_BYPASS;
   88876:	4b06      	ldr	r3, [pc, #24]	; (88890 <osc_get_rate+0x70>)
   88878:	e000      	b.n	8887c <osc_get_rate+0x5c>
#endif
	}

	return 0;
   8887a:	2300      	movs	r3, #0
}
   8887c:	4618      	mov	r0, r3
   8887e:	370c      	adds	r7, #12
   88880:	46bd      	mov	sp, r7
   88882:	f85d 7b04 	ldr.w	r7, [sp], #4
   88886:	4770      	bx	lr
   88888:	003d0900 	.word	0x003d0900
   8888c:	007a1200 	.word	0x007a1200
   88890:	00b71b00 	.word	0x00b71b00

00088894 <sysclk_get_main_hz>:
 */
#if (defined CONFIG_SYSCLK_DEFAULT_RETURNS_SLOW_OSC)
extern uint32_t sysclk_initialized;
#endif
static inline uint32_t sysclk_get_main_hz(void)
{
   88894:	b580      	push	{r7, lr}
   88896:	af00      	add	r7, sp, #0
    case SYSCLK_SRC_MAINCK_BYPASS:
		return OSC_MAINCK_BYPASS_HZ;

#ifdef CONFIG_PLL0_SOURCE
	case SYSCLK_SRC_PLLACK:
		return pll_get_default_rate(0);	
   88898:	2006      	movs	r0, #6
   8889a:	4b04      	ldr	r3, [pc, #16]	; (888ac <sysclk_get_main_hz+0x18>)
   8889c:	4798      	blx	r3
   8889e:	4602      	mov	r2, r0
   888a0:	4613      	mov	r3, r2
   888a2:	00db      	lsls	r3, r3, #3
   888a4:	1a9b      	subs	r3, r3, r2
   888a6:	005b      	lsls	r3, r3, #1
	
	default:
		/* unhandled_case(CONFIG_SYSCLK_SOURCE); */
		return 0;
	}
}
   888a8:	4618      	mov	r0, r3
   888aa:	bd80      	pop	{r7, pc}
   888ac:	00088821 	.word	0x00088821

000888b0 <sysclk_get_cpu_hz>:
 * clocks.
 *
 * \return Frequency of the CPU clock, in Hz.
 */
static inline uint32_t sysclk_get_cpu_hz(void)
{
   888b0:	b580      	push	{r7, lr}
   888b2:	af00      	add	r7, sp, #0
	/* CONFIG_SYSCLK_PRES is the register value for setting the expected */
	/* prescaler, not an immediate value. */
	return sysclk_get_main_hz() / ((CONFIG_SYSCLK_PRES >> PMC_MCKR_PRES_Pos) + 1);
   888b4:	4b02      	ldr	r3, [pc, #8]	; (888c0 <sysclk_get_cpu_hz+0x10>)
   888b6:	4798      	blx	r3
   888b8:	4603      	mov	r3, r0
   888ba:	085b      	lsrs	r3, r3, #1
}
   888bc:	4618      	mov	r0, r3
   888be:	bd80      	pop	{r7, pc}
   888c0:	00088895 	.word	0x00088895

000888c4 <CAN1_Handler>:

/************************************************************************/
/* Interrupt Handler for CAN1								    		*/
/************************************************************************/
void CAN1_Handler(void)
{
   888c4:	b580      	push	{r7, lr}
   888c6:	b082      	sub	sp, #8
   888c8:	af00      	add	r7, sp, #0
	uint32_t ul_status;
	/* Save the state of the can1_mailbox object */	
   	save_can_object(&can1_mailbox, &temp_mailbox_C1);	//Doesn't erase the CAN message.
   888ca:	482f      	ldr	r0, [pc, #188]	; (88988 <CAN1_Handler+0xc4>)
   888cc:	492f      	ldr	r1, [pc, #188]	; (8898c <CAN1_Handler+0xc8>)
   888ce:	4b30      	ldr	r3, [pc, #192]	; (88990 <CAN1_Handler+0xcc>)
   888d0:	4798      	blx	r3
	
	ul_status = can_get_status(CAN1);
   888d2:	4830      	ldr	r0, [pc, #192]	; (88994 <CAN1_Handler+0xd0>)
   888d4:	4b30      	ldr	r3, [pc, #192]	; (88998 <CAN1_Handler+0xd4>)
   888d6:	4798      	blx	r3
   888d8:	6038      	str	r0, [r7, #0]
	if (ul_status & GLOBAL_MAILBOX_MASK) 
   888da:	683b      	ldr	r3, [r7, #0]
   888dc:	b2db      	uxtb	r3, r3
   888de:	2b00      	cmp	r3, #0
   888e0:	d04f      	beq.n	88982 <CAN1_Handler+0xbe>
	{
		for (uint8_t i = 0; i < CANMB_NUMBER; i++) 
   888e2:	2300      	movs	r3, #0
   888e4:	71fb      	strb	r3, [r7, #7]
   888e6:	e049      	b.n	8897c <CAN1_Handler+0xb8>
		{
			ul_status = can_mailbox_get_status(CAN1, i);
   888e8:	79fb      	ldrb	r3, [r7, #7]
   888ea:	482a      	ldr	r0, [pc, #168]	; (88994 <CAN1_Handler+0xd0>)
   888ec:	4619      	mov	r1, r3
   888ee:	4b2b      	ldr	r3, [pc, #172]	; (8899c <CAN1_Handler+0xd8>)
   888f0:	4798      	blx	r3
   888f2:	6038      	str	r0, [r7, #0]
			
			if ((ul_status & CAN_MSR_MRDY) == CAN_MSR_MRDY) 
   888f4:	683b      	ldr	r3, [r7, #0]
   888f6:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
   888fa:	2b00      	cmp	r3, #0
   888fc:	d03b      	beq.n	88976 <CAN1_Handler+0xb2>
			{
				can1_mailbox.ul_mb_idx = i;
   888fe:	79fa      	ldrb	r2, [r7, #7]
   88900:	4b21      	ldr	r3, [pc, #132]	; (88988 <CAN1_Handler+0xc4>)
   88902:	601a      	str	r2, [r3, #0]
				can1_mailbox.ul_status = ul_status;
   88904:	4b20      	ldr	r3, [pc, #128]	; (88988 <CAN1_Handler+0xc4>)
   88906:	683a      	ldr	r2, [r7, #0]
   88908:	609a      	str	r2, [r3, #8]
				can_mailbox_read(CAN1, &can1_mailbox);
   8890a:	4822      	ldr	r0, [pc, #136]	; (88994 <CAN1_Handler+0xd0>)
   8890c:	491e      	ldr	r1, [pc, #120]	; (88988 <CAN1_Handler+0xc4>)
   8890e:	4b24      	ldr	r3, [pc, #144]	; (889a0 <CAN1_Handler+0xdc>)
   88910:	4798      	blx	r3
				
				if((can1_mailbox.ul_datah == 0x01234567) && (can1_mailbox.ul_datal == 0x89ABCDEF))
   88912:	4b1d      	ldr	r3, [pc, #116]	; (88988 <CAN1_Handler+0xc4>)
   88914:	69da      	ldr	r2, [r3, #28]
   88916:	4b23      	ldr	r3, [pc, #140]	; (889a4 <CAN1_Handler+0xe0>)
   88918:	429a      	cmp	r2, r3
   8891a:	d107      	bne.n	8892c <CAN1_Handler+0x68>
   8891c:	4b1a      	ldr	r3, [pc, #104]	; (88988 <CAN1_Handler+0xc4>)
   8891e:	699a      	ldr	r2, [r3, #24]
   88920:	4b21      	ldr	r3, [pc, #132]	; (889a8 <CAN1_Handler+0xe4>)
   88922:	429a      	cmp	r2, r3
   88924:	d102      	bne.n	8892c <CAN1_Handler+0x68>
				{
					SAFE_MODE = 0;
   88926:	4b21      	ldr	r3, [pc, #132]	; (889ac <CAN1_Handler+0xe8>)
   88928:	2200      	movs	r2, #0
   8892a:	601a      	str	r2, [r3, #0]
				}
				store_can_msg(&can1_mailbox, i);			// Save CAN Message to the appropriate global register.
   8892c:	79fb      	ldrb	r3, [r7, #7]
   8892e:	4816      	ldr	r0, [pc, #88]	; (88988 <CAN1_Handler+0xc4>)
   88930:	4619      	mov	r1, r3
   88932:	4b1f      	ldr	r3, [pc, #124]	; (889b0 <CAN1_Handler+0xec>)
   88934:	4798      	blx	r3
				
				/* Debug CAN Message 	*/
				debug_can_msg(&can1_mailbox, CAN1);
   88936:	4814      	ldr	r0, [pc, #80]	; (88988 <CAN1_Handler+0xc4>)
   88938:	4916      	ldr	r1, [pc, #88]	; (88994 <CAN1_Handler+0xd0>)
   8893a:	4b1e      	ldr	r3, [pc, #120]	; (889b4 <CAN1_Handler+0xf0>)
   8893c:	4798      	blx	r3
				/* Decode CAN Message 	*/
				if (i == 7 || i == 2 || i == 3 || i == 4)
   8893e:	79fb      	ldrb	r3, [r7, #7]
   88940:	2b07      	cmp	r3, #7
   88942:	d008      	beq.n	88956 <CAN1_Handler+0x92>
   88944:	79fb      	ldrb	r3, [r7, #7]
   88946:	2b02      	cmp	r3, #2
   88948:	d005      	beq.n	88956 <CAN1_Handler+0x92>
   8894a:	79fb      	ldrb	r3, [r7, #7]
   8894c:	2b03      	cmp	r3, #3
   8894e:	d002      	beq.n	88956 <CAN1_Handler+0x92>
   88950:	79fb      	ldrb	r3, [r7, #7]
   88952:	2b04      	cmp	r3, #4
   88954:	d103      	bne.n	8895e <CAN1_Handler+0x9a>
					decode_can_command(&can1_mailbox, CAN1);
   88956:	480c      	ldr	r0, [pc, #48]	; (88988 <CAN1_Handler+0xc4>)
   88958:	490e      	ldr	r1, [pc, #56]	; (88994 <CAN1_Handler+0xd0>)
   8895a:	4b17      	ldr	r3, [pc, #92]	; (889b8 <CAN1_Handler+0xf4>)
   8895c:	4798      	blx	r3
				if (i < 2)
   8895e:	79fb      	ldrb	r3, [r7, #7]
   88960:	2b01      	cmp	r3, #1
   88962:	d803      	bhi.n	8896c <CAN1_Handler+0xa8>
					alert_can_data(&can1_mailbox, CAN1);
   88964:	4808      	ldr	r0, [pc, #32]	; (88988 <CAN1_Handler+0xc4>)
   88966:	490b      	ldr	r1, [pc, #44]	; (88994 <CAN1_Handler+0xd0>)
   88968:	4b14      	ldr	r3, [pc, #80]	; (889bc <CAN1_Handler+0xf8>)
   8896a:	4798      	blx	r3
					
				/*assert(g_ul_recv_status); ***Implement assert here.*/
				
				/* Restore the can1 mailbox object */
				restore_can_object(&can1_mailbox, &temp_mailbox_C1);
   8896c:	4806      	ldr	r0, [pc, #24]	; (88988 <CAN1_Handler+0xc4>)
   8896e:	4907      	ldr	r1, [pc, #28]	; (8898c <CAN1_Handler+0xc8>)
   88970:	4b13      	ldr	r3, [pc, #76]	; (889c0 <CAN1_Handler+0xfc>)
   88972:	4798      	blx	r3
				break;
   88974:	e005      	b.n	88982 <CAN1_Handler+0xbe>
   	save_can_object(&can1_mailbox, &temp_mailbox_C1);	//Doesn't erase the CAN message.
	
	ul_status = can_get_status(CAN1);
	if (ul_status & GLOBAL_MAILBOX_MASK) 
	{
		for (uint8_t i = 0; i < CANMB_NUMBER; i++) 
   88976:	79fb      	ldrb	r3, [r7, #7]
   88978:	3301      	adds	r3, #1
   8897a:	71fb      	strb	r3, [r7, #7]
   8897c:	79fb      	ldrb	r3, [r7, #7]
   8897e:	2b07      	cmp	r3, #7
   88980:	d9b2      	bls.n	888e8 <CAN1_Handler+0x24>
				restore_can_object(&can1_mailbox, &temp_mailbox_C1);
				break;
			}
		}
	}
}
   88982:	3708      	adds	r7, #8
   88984:	46bd      	mov	sp, r7
   88986:	bd80      	pop	{r7, pc}
   88988:	2007ae34 	.word	0x2007ae34
   8898c:	2007b130 	.word	0x2007b130
   88990:	000895f1 	.word	0x000895f1
   88994:	400b8000 	.word	0x400b8000
   88998:	00084f8d 	.word	0x00084f8d
   8899c:	00084fd1 	.word	0x00084fd1
   889a0:	00085151 	.word	0x00085151
   889a4:	01234567 	.word	0x01234567
   889a8:	89abcdef 	.word	0x89abcdef
   889ac:	2007b438 	.word	0x2007b438
   889b0:	00088f51 	.word	0x00088f51
   889b4:	00088a19 	.word	0x00088a19
   889b8:	00088a75 	.word	0x00088a75
   889bc:	00088e15 	.word	0x00088e15
   889c0:	00089661 	.word	0x00089661

000889c4 <CAN0_Handler>:
/************************************************************************/
/* Interrupt Handler for CAN0										    */
/************************************************************************/
void CAN0_Handler(void)
{
   889c4:	b580      	push	{r7, lr}
   889c6:	b082      	sub	sp, #8
   889c8:	af00      	add	r7, sp, #0
	uint32_t ul_status;

	ul_status = can_get_status(CAN0);
   889ca:	4810      	ldr	r0, [pc, #64]	; (88a0c <CAN0_Handler+0x48>)
   889cc:	4b10      	ldr	r3, [pc, #64]	; (88a10 <CAN0_Handler+0x4c>)
   889ce:	4798      	blx	r3
   889d0:	6038      	str	r0, [r7, #0]
	if (ul_status & GLOBAL_MAILBOX_MASK) 
   889d2:	683b      	ldr	r3, [r7, #0]
   889d4:	b2db      	uxtb	r3, r3
   889d6:	2b00      	cmp	r3, #0
   889d8:	d014      	beq.n	88a04 <CAN0_Handler+0x40>
	{
		for (uint8_t i = 0; i < CANMB_NUMBER; i++) 
   889da:	2300      	movs	r3, #0
   889dc:	71fb      	strb	r3, [r7, #7]
   889de:	e00e      	b.n	889fe <CAN0_Handler+0x3a>
		{
			ul_status = can_mailbox_get_status(CAN0, i);
   889e0:	79fb      	ldrb	r3, [r7, #7]
   889e2:	480a      	ldr	r0, [pc, #40]	; (88a0c <CAN0_Handler+0x48>)
   889e4:	4619      	mov	r1, r3
   889e6:	4b0b      	ldr	r3, [pc, #44]	; (88a14 <CAN0_Handler+0x50>)
   889e8:	4798      	blx	r3
   889ea:	6038      	str	r0, [r7, #0]
			
			if ((ul_status & CAN_MSR_MRDY) == CAN_MSR_MRDY) 
   889ec:	683b      	ldr	r3, [r7, #0]
   889ee:	f403 0300 	and.w	r3, r3, #8388608	; 0x800000
   889f2:	2b00      	cmp	r3, #0
   889f4:	d000      	beq.n	889f8 <CAN0_Handler+0x34>
			{
				//assert(g_ul_recv_status); ***implement assert here.
				break;
   889f6:	e005      	b.n	88a04 <CAN0_Handler+0x40>
	uint32_t ul_status;

	ul_status = can_get_status(CAN0);
	if (ul_status & GLOBAL_MAILBOX_MASK) 
	{
		for (uint8_t i = 0; i < CANMB_NUMBER; i++) 
   889f8:	79fb      	ldrb	r3, [r7, #7]
   889fa:	3301      	adds	r3, #1
   889fc:	71fb      	strb	r3, [r7, #7]
   889fe:	79fb      	ldrb	r3, [r7, #7]
   88a00:	2b07      	cmp	r3, #7
   88a02:	d9ed      	bls.n	889e0 <CAN0_Handler+0x1c>
				//assert(g_ul_recv_status); ***implement assert here.
				break;
			}
		}
	}
}
   88a04:	3708      	adds	r7, #8
   88a06:	46bd      	mov	sp, r7
   88a08:	bd80      	pop	{r7, pc}
   88a0a:	bf00      	nop
   88a0c:	400b4000 	.word	0x400b4000
   88a10:	00084f8d 	.word	0x00084f8d
   88a14:	00084fd1 	.word	0x00084fd1

00088a18 <debug_can_msg>:
/************************************************************************/
/* DEBUG CAN MESSAGE 													*/
/* USED FOR debugging 													*/
/************************************************************************/
void debug_can_msg(can_mb_conf_t *p_mailbox, Can* controller)
{
   88a18:	b580      	push	{r7, lr}
   88a1a:	b084      	sub	sp, #16
   88a1c:	af00      	add	r7, sp, #0
   88a1e:	6078      	str	r0, [r7, #4]
   88a20:	6039      	str	r1, [r7, #0]
	//uint32_t ul_data_incom = p_mailbox->ul_datal;
	uint32_t uh_data_incom = p_mailbox->ul_datah;
   88a22:	687b      	ldr	r3, [r7, #4]
   88a24:	69db      	ldr	r3, [r3, #28]
   88a26:	60fb      	str	r3, [r7, #12]
	uint8_t big_type, small_type;

	big_type = (uint8_t)((uh_data_incom & 0x00FF0000)>>16);
   88a28:	68fb      	ldr	r3, [r7, #12]
   88a2a:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   88a2e:	0c1b      	lsrs	r3, r3, #16
   88a30:	72fb      	strb	r3, [r7, #11]
	small_type = (uint8_t)((uh_data_incom & 0x0000FF00)>>8);
   88a32:	68fb      	ldr	r3, [r7, #12]
   88a34:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   88a38:	0a1b      	lsrs	r3, r3, #8
   88a3a:	72bb      	strb	r3, [r7, #10]

	if ((big_type == MT_COM) && (small_type == RESPONSE))
   88a3c:	7afb      	ldrb	r3, [r7, #11]
   88a3e:	2b02      	cmp	r3, #2
   88a40:	d105      	bne.n	88a4e <debug_can_msg+0x36>
   88a42:	7abb      	ldrb	r3, [r7, #10]
   88a44:	2b04      	cmp	r3, #4
   88a46:	d102      	bne.n	88a4e <debug_can_msg+0x36>
		pio_toggle_pin(LED3_GPIO);	// LED2 indicates a command response.
   88a48:	2057      	movs	r0, #87	; 0x57
   88a4a:	4b09      	ldr	r3, [pc, #36]	; (88a70 <debug_can_msg+0x58>)
   88a4c:	4798      	blx	r3

	if (big_type == MT_HK)
   88a4e:	7afb      	ldrb	r3, [r7, #11]
   88a50:	2b01      	cmp	r3, #1
   88a52:	d102      	bne.n	88a5a <debug_can_msg+0x42>
		pio_toggle_pin(LED1_GPIO);	// LED1 indicates the reception of housekeeping.
   88a54:	2055      	movs	r0, #85	; 0x55
   88a56:	4b06      	ldr	r3, [pc, #24]	; (88a70 <debug_can_msg+0x58>)
   88a58:	4798      	blx	r3
	
	if (big_type == MT_DATA)
   88a5a:	7afb      	ldrb	r3, [r7, #11]
   88a5c:	2b00      	cmp	r3, #0
   88a5e:	d102      	bne.n	88a66 <debug_can_msg+0x4e>
		pio_toggle_pin(LED2_GPIO);	// LED2 indicates the reception of data.
   88a60:	2056      	movs	r0, #86	; 0x56
   88a62:	4b03      	ldr	r3, [pc, #12]	; (88a70 <debug_can_msg+0x58>)
   88a64:	4798      	blx	r3

	return;
   88a66:	bf00      	nop
}
   88a68:	3710      	adds	r7, #16
   88a6a:	46bd      	mov	sp, r7
   88a6c:	bd80      	pop	{r7, pc}
   88a6e:	bf00      	nop
   88a70:	0008553d 	.word	0x0008553d

00088a74 <decode_can_command>:
/* @param: *controller: used to verify authenticity						*/
/* @Purpose: This function decodes commands which are received and 		*/
/* performs different actions based on what was received. 				*/
/************************************************************************/
void decode_can_command(can_mb_conf_t *p_mailbox, Can* controller)
{
   88a74:	b590      	push	{r4, r7, lr}
   88a76:	b0b1      	sub	sp, #196	; 0xc4
   88a78:	af02      	add	r7, sp, #8
   88a7a:	6078      	str	r0, [r7, #4]
   88a7c:	6039      	str	r1, [r7, #0]
	//assert(g_ul_recv_status);		// Only decode if a message was received.	***Asserts here.
	//assert(controller);				// CAN0 or CAN1 are nonzero.
	uint32_t ul_data_incom = p_mailbox->ul_datal;
   88a7e:	687b      	ldr	r3, [r7, #4]
   88a80:	699b      	ldr	r3, [r3, #24]
   88a82:	f8c7 30ac 	str.w	r3, [r7, #172]	; 0xac
	uint32_t uh_data_incom = p_mailbox->ul_datah;
   88a86:	687b      	ldr	r3, [r7, #4]
   88a88:	69db      	ldr	r3, [r3, #28]
   88a8a:	f8c7 30a8 	str.w	r3, [r7, #168]	; 0xa8
	uint8_t sender, destination, big_type, small_type, received_minute, minute_diff = 2;
   88a8e:	2302      	movs	r3, #2
   88a90:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
	BaseType_t wake_task;	// Not needed here.
	uint8_t dumbuf[152];
	uint8_t i;
	for(i = 0; i < 152; i ++)
   88a94:	2300      	movs	r3, #0
   88a96:	f887 30b6 	strb.w	r3, [r7, #182]	; 0xb6
   88a9a:	e00c      	b.n	88ab6 <decode_can_command+0x42>
	{
		dumbuf[i] = 0;
   88a9c:	f897 30b6 	ldrb.w	r3, [r7, #182]	; 0xb6
   88aa0:	f107 02b8 	add.w	r2, r7, #184	; 0xb8
   88aa4:	4413      	add	r3, r2
   88aa6:	2200      	movs	r2, #0
   88aa8:	f803 2cac 	strb.w	r2, [r3, #-172]
	uint32_t uh_data_incom = p_mailbox->ul_datah;
	uint8_t sender, destination, big_type, small_type, received_minute, minute_diff = 2;
	BaseType_t wake_task;	// Not needed here.
	uint8_t dumbuf[152];
	uint8_t i;
	for(i = 0; i < 152; i ++)
   88aac:	f897 30b6 	ldrb.w	r3, [r7, #182]	; 0xb6
   88ab0:	3301      	adds	r3, #1
   88ab2:	f887 30b6 	strb.w	r3, [r7, #182]	; 0xb6
   88ab6:	f897 30b6 	ldrb.w	r3, [r7, #182]	; 0xb6
   88aba:	2b97      	cmp	r3, #151	; 0x97
   88abc:	d9ee      	bls.n	88a9c <decode_can_command+0x28>
	{
		dumbuf[i] = 0;
	}

	sender = (uint8_t)(uh_data_incom >> 28);
   88abe:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   88ac2:	0f1b      	lsrs	r3, r3, #28
   88ac4:	f887 30b5 	strb.w	r3, [r7, #181]	; 0xb5
	destination = (uint8_t)((uh_data_incom & 0x0F000000)>>24);
   88ac8:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   88acc:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
   88ad0:	0e1b      	lsrs	r3, r3, #24
   88ad2:	f887 30b4 	strb.w	r3, [r7, #180]	; 0xb4
	big_type = (uint8_t)((uh_data_incom & 0x00FF0000)>>16);
   88ad6:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   88ada:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   88ade:	0c1b      	lsrs	r3, r3, #16
   88ae0:	f887 30b3 	strb.w	r3, [r7, #179]	; 0xb3
	small_type = (uint8_t)((uh_data_incom & 0x0000FF00)>>8);
   88ae4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   88ae8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   88aec:	0a1b      	lsrs	r3, r3, #8
   88aee:	f887 30b2 	strb.w	r3, [r7, #178]	; 0xb2
	received_minute = (uint8_t)(uh_data_incom & 0x000000FF);
   88af2:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   88af6:	f887 30b1 	strb.w	r3, [r7, #177]	; 0xb1
	minute_diff = CURRENT_MINUTE - received_minute;
   88afa:	4bb1      	ldr	r3, [pc, #708]	; (88dc0 <decode_can_command+0x34c>)
   88afc:	781a      	ldrb	r2, [r3, #0]
   88afe:	f897 30b1 	ldrb.w	r3, [r7, #177]	; 0xb1
   88b02:	1ad3      	subs	r3, r2, r3
   88b04:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
	if((CURRENT_MINUTE == 59) && (received_minute == 0))
   88b08:	4bad      	ldr	r3, [pc, #692]	; (88dc0 <decode_can_command+0x34c>)
   88b0a:	781b      	ldrb	r3, [r3, #0]
   88b0c:	2b3b      	cmp	r3, #59	; 0x3b
   88b0e:	d106      	bne.n	88b1e <decode_can_command+0xaa>
   88b10:	f897 30b1 	ldrb.w	r3, [r7, #177]	; 0xb1
   88b14:	2b00      	cmp	r3, #0
   88b16:	d102      	bne.n	88b1e <decode_can_command+0xaa>
		minute_diff = 1;
   88b18:	2301      	movs	r3, #1
   88b1a:	f887 30b7 	strb.w	r3, [r7, #183]	; 0xb7
	
	if((small_type < 0x0D) && (small_type > 0x14) && (minute_diff > 1))		// CURRENT_MINUTE which was received was invalid.
   88b1e:	f897 30b2 	ldrb.w	r3, [r7, #178]	; 0xb2
   88b22:	2b0c      	cmp	r3, #12
   88b24:	d808      	bhi.n	88b38 <decode_can_command+0xc4>
   88b26:	f897 30b2 	ldrb.w	r3, [r7, #178]	; 0xb2
   88b2a:	2b14      	cmp	r3, #20
   88b2c:	d904      	bls.n	88b38 <decode_can_command+0xc4>
   88b2e:	f897 30b7 	ldrb.w	r3, [r7, #183]	; 0xb7
   88b32:	2b01      	cmp	r3, #1
   88b34:	d900      	bls.n	88b38 <decode_can_command+0xc4>
		return;
   88b36:	e140      	b.n	88dba <decode_can_command+0x346>

	if(big_type != MT_COM)
   88b38:	f897 30b3 	ldrb.w	r3, [r7, #179]	; 0xb3
   88b3c:	2b02      	cmp	r3, #2
   88b3e:	d000      	beq.n	88b42 <decode_can_command+0xce>
		return;
   88b40:	e13b      	b.n	88dba <decode_can_command+0x346>
	
	switch(small_type)	// FROM WHO
   88b42:	f897 30b2 	ldrb.w	r3, [r7, #178]	; 0xb2
   88b46:	3b06      	subs	r3, #6
   88b48:	2b23      	cmp	r3, #35	; 0x23
   88b4a:	f200 8135 	bhi.w	88db8 <decode_can_command+0x344>
   88b4e:	a201      	add	r2, pc, #4	; (adr r2, 88b54 <decode_can_command+0xe0>)
   88b50:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   88b54:	00088be5 	.word	0x00088be5
   88b58:	00088db9 	.word	0x00088db9
   88b5c:	00088c13 	.word	0x00088c13
   88b60:	00088db9 	.word	0x00088db9
   88b64:	00088db9 	.word	0x00088db9
   88b68:	00088db9 	.word	0x00088db9
   88b6c:	00088db9 	.word	0x00088db9
   88b70:	00088db9 	.word	0x00088db9
   88b74:	00088c41 	.word	0x00088c41
   88b78:	00088db9 	.word	0x00088db9
   88b7c:	00088c85 	.word	0x00088c85
   88b80:	00088c73 	.word	0x00088c73
   88b84:	00088db9 	.word	0x00088db9
   88b88:	00088c79 	.word	0x00088c79
   88b8c:	00088db9 	.word	0x00088db9
   88b90:	00088db9 	.word	0x00088db9
   88b94:	00088c8d 	.word	0x00088c8d
   88b98:	00088cbf 	.word	0x00088cbf
   88b9c:	00088db9 	.word	0x00088db9
   88ba0:	00088cd5 	.word	0x00088cd5
   88ba4:	00088db3 	.word	0x00088db3
   88ba8:	00088db9 	.word	0x00088db9
   88bac:	00088db9 	.word	0x00088db9
   88bb0:	00088db9 	.word	0x00088db9
   88bb4:	00088db9 	.word	0x00088db9
   88bb8:	00088db9 	.word	0x00088db9
   88bbc:	00088db9 	.word	0x00088db9
   88bc0:	00088d2f 	.word	0x00088d2f
   88bc4:	00088d37 	.word	0x00088d37
   88bc8:	00088d3f 	.word	0x00088d3f
   88bcc:	00088d47 	.word	0x00088d47
   88bd0:	00088d4f 	.word	0x00088d4f
   88bd4:	00088d7d 	.word	0x00088d7d
   88bd8:	00088db9 	.word	0x00088db9
   88bdc:	00088db9 	.word	0x00088db9
   88be0:	00088dab 	.word	0x00088dab
	{
		case ACK_READ:
			switch(destination)
   88be4:	f897 30b4 	ldrb.w	r3, [r7, #180]	; 0xb4
   88be8:	2b04      	cmp	r3, #4
   88bea:	d000      	beq.n	88bee <decode_can_command+0x17a>
						hk_read_receive[1] = uh_data_incom;
						hk_read_receive[0] = ul_data_incom;
					}
					break;
				default :
					break;
   88bec:	e010      	b.n	88c10 <decode_can_command+0x19c>
	{
		case ACK_READ:
			switch(destination)
			{
				case HK_TASK_ID :
					if(hk_read_requestedf)
   88bee:	4b75      	ldr	r3, [pc, #468]	; (88dc4 <decode_can_command+0x350>)
   88bf0:	781b      	ldrb	r3, [r3, #0]
   88bf2:	2b00      	cmp	r3, #0
   88bf4:	d00b      	beq.n	88c0e <decode_can_command+0x19a>
					{
						hk_read_receivedf = 1;
   88bf6:	4b74      	ldr	r3, [pc, #464]	; (88dc8 <decode_can_command+0x354>)
   88bf8:	2201      	movs	r2, #1
   88bfa:	701a      	strb	r2, [r3, #0]
						hk_read_receive[1] = uh_data_incom;
   88bfc:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   88c00:	4b72      	ldr	r3, [pc, #456]	; (88dcc <decode_can_command+0x358>)
   88c02:	605a      	str	r2, [r3, #4]
						hk_read_receive[0] = ul_data_incom;
   88c04:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   88c08:	4b70      	ldr	r3, [pc, #448]	; (88dcc <decode_can_command+0x358>)
   88c0a:	601a      	str	r2, [r3, #0]
					}
					break;
   88c0c:	e7ff      	b.n	88c0e <decode_can_command+0x19a>
   88c0e:	bf00      	nop
				default :
					break;
			}
			break;
   88c10:	e0d0      	b.n	88db4 <decode_can_command+0x340>
		case ACK_WRITE :
			switch(destination)
   88c12:	f897 30b4 	ldrb.w	r3, [r7, #180]	; 0xb4
   88c16:	2b04      	cmp	r3, #4
   88c18:	d000      	beq.n	88c1c <decode_can_command+0x1a8>
						hk_write_receive[1] = uh_data_incom;
						hk_write_receive[0] = ul_data_incom;
					}
					break;
				default :
					break;
   88c1a:	e010      	b.n	88c3e <decode_can_command+0x1ca>
			break;
		case ACK_WRITE :
			switch(destination)
			{
				case HK_TASK_ID :
					if(hk_write_requestedf)
   88c1c:	4b6c      	ldr	r3, [pc, #432]	; (88dd0 <decode_can_command+0x35c>)
   88c1e:	781b      	ldrb	r3, [r3, #0]
   88c20:	2b00      	cmp	r3, #0
   88c22:	d00b      	beq.n	88c3c <decode_can_command+0x1c8>
					{
						hk_write_receivedf = 1;
   88c24:	4b6b      	ldr	r3, [pc, #428]	; (88dd4 <decode_can_command+0x360>)
   88c26:	2201      	movs	r2, #1
   88c28:	701a      	strb	r2, [r3, #0]
						hk_write_receive[1] = uh_data_incom;
   88c2a:	f8d7 20a8 	ldr.w	r2, [r7, #168]	; 0xa8
   88c2e:	4b6a      	ldr	r3, [pc, #424]	; (88dd8 <decode_can_command+0x364>)
   88c30:	605a      	str	r2, [r3, #4]
						hk_write_receive[0] = ul_data_incom;
   88c32:	f8d7 20ac 	ldr.w	r2, [r7, #172]	; 0xac
   88c36:	4b68      	ldr	r3, [pc, #416]	; (88dd8 <decode_can_command+0x364>)
   88c38:	601a      	str	r2, [r3, #0]
					}
					break;
   88c3a:	e7ff      	b.n	88c3c <decode_can_command+0x1c8>
   88c3c:	bf00      	nop
				default :
					break;
			}
			break;
   88c3e:	e0b9      	b.n	88db4 <decode_can_command+0x340>
		case SEND_TC:
			xQueueSendToBackFromISR(tc_msg_fifo, &ul_data_incom, &wake_task);		// Telecommand reception FIFO.
   88c40:	4b66      	ldr	r3, [pc, #408]	; (88ddc <decode_can_command+0x368>)
   88c42:	6819      	ldr	r1, [r3, #0]
   88c44:	f107 02ac 	add.w	r2, r7, #172	; 0xac
   88c48:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
   88c4c:	4608      	mov	r0, r1
   88c4e:	4611      	mov	r1, r2
   88c50:	461a      	mov	r2, r3
   88c52:	2300      	movs	r3, #0
   88c54:	4c62      	ldr	r4, [pc, #392]	; (88de0 <decode_can_command+0x36c>)
   88c56:	47a0      	blx	r4
			xQueueSendToBackFromISR(tc_msg_fifo, &uh_data_incom, &wake_task);
   88c58:	4b60      	ldr	r3, [pc, #384]	; (88ddc <decode_can_command+0x368>)
   88c5a:	6819      	ldr	r1, [r3, #0]
   88c5c:	f107 02a8 	add.w	r2, r7, #168	; 0xa8
   88c60:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
   88c64:	4608      	mov	r0, r1
   88c66:	4611      	mov	r1, r2
   88c68:	461a      	mov	r2, r3
   88c6a:	2300      	movs	r3, #0
   88c6c:	4c5c      	ldr	r4, [pc, #368]	; (88de0 <decode_can_command+0x36c>)
   88c6e:	47a0      	blx	r4
			break;
   88c70:	e0a0      	b.n	88db4 <decode_can_command+0x340>
		case TC_PACKET_READY:
			start_tc_packet();
   88c72:	4b5c      	ldr	r3, [pc, #368]	; (88de4 <decode_can_command+0x370>)
   88c74:	4798      	blx	r3
			break;
   88c76:	e09d      	b.n	88db4 <decode_can_command+0x340>
		case TM_TRANSACTION_RESP:
			tm_transfer_completef = (uint8_t)(ul_data_incom & 0x000000FF);
   88c78:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   88c7c:	b2da      	uxtb	r2, r3
   88c7e:	4b5a      	ldr	r3, [pc, #360]	; (88de8 <decode_can_command+0x374>)
   88c80:	701a      	strb	r2, [r3, #0]
			break;
   88c82:	e097      	b.n	88db4 <decode_can_command+0x340>
		case OK_START_TM_PACKET:
			start_tm_transferf = 1;
   88c84:	4b59      	ldr	r3, [pc, #356]	; (88dec <decode_can_command+0x378>)
   88c86:	2201      	movs	r2, #1
   88c88:	701a      	strb	r2, [r3, #0]
			break;
   88c8a:	e093      	b.n	88db4 <decode_can_command+0x340>
		case SEND_EVENT:
			xQueueSendToBackFromISR(event_msg_fifo, &ul_data_incom, &wake_task);
   88c8c:	4b58      	ldr	r3, [pc, #352]	; (88df0 <decode_can_command+0x37c>)
   88c8e:	6819      	ldr	r1, [r3, #0]
   88c90:	f107 02ac 	add.w	r2, r7, #172	; 0xac
   88c94:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
   88c98:	4608      	mov	r0, r1
   88c9a:	4611      	mov	r1, r2
   88c9c:	461a      	mov	r2, r3
   88c9e:	2300      	movs	r3, #0
   88ca0:	4c4f      	ldr	r4, [pc, #316]	; (88de0 <decode_can_command+0x36c>)
   88ca2:	47a0      	blx	r4
			xQueueSendToBackFromISR(event_msg_fifo, &uh_data_incom, &wake_task);	// Event reception FIFO.
   88ca4:	4b52      	ldr	r3, [pc, #328]	; (88df0 <decode_can_command+0x37c>)
   88ca6:	6819      	ldr	r1, [r3, #0]
   88ca8:	f107 02a8 	add.w	r2, r7, #168	; 0xa8
   88cac:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
   88cb0:	4608      	mov	r0, r1
   88cb2:	4611      	mov	r1, r2
   88cb4:	461a      	mov	r2, r3
   88cb6:	2300      	movs	r3, #0
   88cb8:	4c49      	ldr	r4, [pc, #292]	; (88de0 <decode_can_command+0x36c>)
   88cba:	47a0      	blx	r4
			break;
   88cbc:	e07a      	b.n	88db4 <decode_can_command+0x340>
		case ASK_OBC_ALIVE:
			send_can_command_from_int(0x00, 0x00, OBC_ID, COMS_ID, OBC_IS_ALIVE, COMMAND_PRIO);
   88cbe:	2318      	movs	r3, #24
   88cc0:	9300      	str	r3, [sp, #0]
   88cc2:	2319      	movs	r3, #25
   88cc4:	9301      	str	r3, [sp, #4]
   88cc6:	2000      	movs	r0, #0
   88cc8:	2100      	movs	r1, #0
   88cca:	2203      	movs	r2, #3
   88ccc:	2300      	movs	r3, #0
   88cce:	4c49      	ldr	r4, [pc, #292]	; (88df4 <decode_can_command+0x380>)
   88cd0:	47a0      	blx	r4
			break;
   88cd2:	e06f      	b.n	88db4 <decode_can_command+0x340>
		case SSM_ERROR_ASSERT:
			dumbuf[148] = (uint8_t)(uh_data_incom & 0x000000FF);
   88cd4:	f8d7 30a8 	ldr.w	r3, [r7, #168]	; 0xa8
   88cd8:	b2db      	uxtb	r3, r3
   88cda:	f887 30a0 	strb.w	r3, [r7, #160]	; 0xa0
			dumbuf[147] = (uint8_t)((ul_data_incom & 0xFF000000) >> 24);
   88cde:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   88ce2:	0e1b      	lsrs	r3, r3, #24
   88ce4:	b2db      	uxtb	r3, r3
   88ce6:	f887 309f 	strb.w	r3, [r7, #159]	; 0x9f
			dumbuf[146] = (uint8_t)((ul_data_incom & 0x00FF0000) >> 16);
   88cea:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   88cee:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   88cf2:	0c1b      	lsrs	r3, r3, #16
   88cf4:	b2db      	uxtb	r3, r3
   88cf6:	f887 309e 	strb.w	r3, [r7, #158]	; 0x9e
			dumbuf[145] = (uint8_t)((ul_data_incom & 0x0000FF00) >> 8);
   88cfa:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   88cfe:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   88d02:	0a1b      	lsrs	r3, r3, #8
   88d04:	b2db      	uxtb	r3, r3
   88d06:	f887 309d 	strb.w	r3, [r7, #157]	; 0x9d
			dumbuf[144] = (uint8_t)(ul_data_incom & 0x000000FF);	
   88d0a:	f8d7 30ac 	ldr.w	r3, [r7, #172]	; 0xac
   88d0e:	b2db      	uxtb	r3, r3
   88d10:	f887 309c 	strb.w	r3, [r7, #156]	; 0x9c
			xQueueSendToBackFromISR(high_sev_to_fdir_fifo, dumbuf, &wake_task);
   88d14:	4b38      	ldr	r3, [pc, #224]	; (88df8 <decode_can_command+0x384>)
   88d16:	6819      	ldr	r1, [r3, #0]
   88d18:	f107 020c 	add.w	r2, r7, #12
   88d1c:	f107 03a4 	add.w	r3, r7, #164	; 0xa4
   88d20:	4608      	mov	r0, r1
   88d22:	4611      	mov	r1, r2
   88d24:	461a      	mov	r2, r3
   88d26:	2300      	movs	r3, #0
   88d28:	4c2d      	ldr	r4, [pc, #180]	; (88de0 <decode_can_command+0x36c>)
   88d2a:	47a0      	blx	r4
			break;
   88d2c:	e042      	b.n	88db4 <decode_can_command+0x340>
		case SSM_ERROR_REPORT:
			break;
		case LOW_POWER_MODE_ENTERED:
			LOW_POWER_MODE = 1;
   88d2e:	4b33      	ldr	r3, [pc, #204]	; (88dfc <decode_can_command+0x388>)
   88d30:	2201      	movs	r2, #1
   88d32:	601a      	str	r2, [r3, #0]
			break;
   88d34:	e03e      	b.n	88db4 <decode_can_command+0x340>
		case LOW_POWER_MODE_EXITED:
			LOW_POWER_MODE = 0;
   88d36:	4b31      	ldr	r3, [pc, #196]	; (88dfc <decode_can_command+0x388>)
   88d38:	2200      	movs	r2, #0
   88d3a:	601a      	str	r2, [r3, #0]
			break;
   88d3c:	e03a      	b.n	88db4 <decode_can_command+0x340>
		case COMS_TAKEOVER_ENTERED:
			COMS_TAKEOVER_MODE = 1;
   88d3e:	4b30      	ldr	r3, [pc, #192]	; (88e00 <decode_can_command+0x38c>)
   88d40:	2201      	movs	r2, #1
   88d42:	601a      	str	r2, [r3, #0]
			break;
   88d44:	e036      	b.n	88db4 <decode_can_command+0x340>
		case COMS_TAKEOVER_EXITED:
			COMS_TAKEOVER_MODE = 0;
   88d46:	4b2e      	ldr	r3, [pc, #184]	; (88e00 <decode_can_command+0x38c>)
   88d48:	2200      	movs	r2, #0
   88d4a:	601a      	str	r2, [r3, #0]
			break;
   88d4c:	e032      	b.n	88db4 <decode_can_command+0x340>
		case OPERATIONS_PAUSED:
			if(sender == COMS_ID)
   88d4e:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
   88d52:	2b00      	cmp	r3, #0
   88d54:	d102      	bne.n	88d5c <decode_can_command+0x2e8>
				COMS_PAUSED = 1;
   88d56:	4b2b      	ldr	r3, [pc, #172]	; (88e04 <decode_can_command+0x390>)
   88d58:	2201      	movs	r2, #1
   88d5a:	601a      	str	r2, [r3, #0]
			if(sender == EPS_ID)
   88d5c:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
   88d60:	2b01      	cmp	r3, #1
   88d62:	d102      	bne.n	88d6a <decode_can_command+0x2f6>
				EPS_PAUSED = 1;
   88d64:	4b28      	ldr	r3, [pc, #160]	; (88e08 <decode_can_command+0x394>)
   88d66:	2201      	movs	r2, #1
   88d68:	601a      	str	r2, [r3, #0]
			if(sender == PAY_ID)
   88d6a:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
   88d6e:	2b02      	cmp	r3, #2
   88d70:	d103      	bne.n	88d7a <decode_can_command+0x306>
				PAY_PAUSED = 1;
   88d72:	4b26      	ldr	r3, [pc, #152]	; (88e0c <decode_can_command+0x398>)
   88d74:	2201      	movs	r2, #1
   88d76:	601a      	str	r2, [r3, #0]
			break;
   88d78:	e01c      	b.n	88db4 <decode_can_command+0x340>
   88d7a:	e01b      	b.n	88db4 <decode_can_command+0x340>
		case OPERATIONS_RESUMED:
			if(sender == COMS_ID)
   88d7c:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
   88d80:	2b00      	cmp	r3, #0
   88d82:	d102      	bne.n	88d8a <decode_can_command+0x316>
				COMS_PAUSED = 0;
   88d84:	4b1f      	ldr	r3, [pc, #124]	; (88e04 <decode_can_command+0x390>)
   88d86:	2200      	movs	r2, #0
   88d88:	601a      	str	r2, [r3, #0]
			if(sender == EPS_ID)
   88d8a:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
   88d8e:	2b01      	cmp	r3, #1
   88d90:	d102      	bne.n	88d98 <decode_can_command+0x324>
				EPS_PAUSED = 0;
   88d92:	4b1d      	ldr	r3, [pc, #116]	; (88e08 <decode_can_command+0x394>)
   88d94:	2200      	movs	r2, #0
   88d96:	601a      	str	r2, [r3, #0]
			if(sender == PAY_ID)
   88d98:	f897 30b5 	ldrb.w	r3, [r7, #181]	; 0xb5
   88d9c:	2b02      	cmp	r3, #2
   88d9e:	d103      	bne.n	88da8 <decode_can_command+0x334>
				PAY_PAUSED = 0;
   88da0:	4b1a      	ldr	r3, [pc, #104]	; (88e0c <decode_can_command+0x398>)
   88da2:	2200      	movs	r2, #0
   88da4:	601a      	str	r2, [r3, #0]
			break;
   88da6:	e005      	b.n	88db4 <decode_can_command+0x340>
   88da8:	e004      	b.n	88db4 <decode_can_command+0x340>
		case PD_COLLECTED:
			pd_collectedf = 1;
   88daa:	4b19      	ldr	r3, [pc, #100]	; (88e10 <decode_can_command+0x39c>)
   88dac:	2201      	movs	r2, #1
   88dae:	701a      	strb	r2, [r3, #0]
			break;
   88db0:	e000      	b.n	88db4 <decode_can_command+0x340>
			dumbuf[145] = (uint8_t)((ul_data_incom & 0x0000FF00) >> 8);
			dumbuf[144] = (uint8_t)(ul_data_incom & 0x000000FF);	
			xQueueSendToBackFromISR(high_sev_to_fdir_fifo, dumbuf, &wake_task);
			break;
		case SSM_ERROR_REPORT:
			break;
   88db2:	bf00      	nop
			pd_collectedf = 1;
			break;
		default :
			return;
	}
	return;
   88db4:	bf00      	nop
   88db6:	e000      	b.n	88dba <decode_can_command+0x346>
			break;
		case PD_COLLECTED:
			pd_collectedf = 1;
			break;
		default :
			return;
   88db8:	bf00      	nop
	}
	return;
}
   88dba:	37bc      	adds	r7, #188	; 0xbc
   88dbc:	46bd      	mov	sp, r7
   88dbe:	bd90      	pop	{r4, r7, pc}
   88dc0:	2007b108 	.word	0x2007b108
   88dc4:	2007b508 	.word	0x2007b508
   88dc8:	2007ae2c 	.word	0x2007ae2c
   88dcc:	2007b11c 	.word	0x2007b11c
   88dd0:	2007b3c8 	.word	0x2007b3c8
   88dd4:	2007b100 	.word	0x2007b100
   88dd8:	2007b3ec 	.word	0x2007b3ec
   88ddc:	2007b4e8 	.word	0x2007b4e8
   88de0:	00086cc5 	.word	0x00086cc5
   88de4:	00089e1d 	.word	0x00089e1d
   88de8:	2007b4e0 	.word	0x2007b4e0
   88dec:	2007aef1 	.word	0x2007aef1
   88df0:	2007b4fc 	.word	0x2007b4fc
   88df4:	0008932d 	.word	0x0008932d
   88df8:	2007b51c 	.word	0x2007b51c
   88dfc:	2007ada4 	.word	0x2007ada4
   88e00:	2007b15c 	.word	0x2007b15c
   88e04:	2007b3a8 	.word	0x2007b3a8
   88e08:	2007ae20 	.word	0x2007ae20
   88e0c:	2007b3d8 	.word	0x2007b3d8
   88e10:	2007b170 	.word	0x2007b170

00088e14 <alert_can_data>:
/* @param: *controller: To be used to verify that the request was genuin*/
/* @Purpose: This function sets flags which let process know that they 	*/
/* have data waiting for them. 											*/
/************************************************************************/
void alert_can_data(can_mb_conf_t *p_mailbox, Can* controller)
{
   88e14:	b480      	push	{r7}
   88e16:	b087      	sub	sp, #28
   88e18:	af00      	add	r7, sp, #0
   88e1a:	6078      	str	r0, [r7, #4]
   88e1c:	6039      	str	r1, [r7, #0]
	//assert(g_ul_recv_status);		// Only decode if a message was received.	***Asserts here.
	//assert(controller);				// CAN0 or CAN1 are nonzero.
	uint32_t uh_data_incom = p_mailbox->ul_datah;
   88e1e:	687b      	ldr	r3, [r7, #4]
   88e20:	69db      	ldr	r3, [r3, #28]
   88e22:	617b      	str	r3, [r7, #20]
	uint32_t ul_data_incom = p_mailbox->ul_datal;
   88e24:	687b      	ldr	r3, [r7, #4]
   88e26:	699b      	ldr	r3, [r3, #24]
   88e28:	613b      	str	r3, [r7, #16]
	uint8_t big_type, small_type, destination;

	big_type = (uint8_t)((uh_data_incom & 0x00FF0000)>>16);
   88e2a:	697b      	ldr	r3, [r7, #20]
   88e2c:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
   88e30:	0c1b      	lsrs	r3, r3, #16
   88e32:	73fb      	strb	r3, [r7, #15]
	small_type = (uint8_t)((uh_data_incom & 0x0000FF00)>>8);
   88e34:	697b      	ldr	r3, [r7, #20]
   88e36:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   88e3a:	0a1b      	lsrs	r3, r3, #8
   88e3c:	73bb      	strb	r3, [r7, #14]
	destination = (uint8_t)((uh_data_incom & 0x0F000000)>>24);
   88e3e:	697b      	ldr	r3, [r7, #20]
   88e40:	f003 6370 	and.w	r3, r3, #251658240	; 0xf000000
   88e44:	0e1b      	lsrs	r3, r3, #24
   88e46:	737b      	strb	r3, [r7, #13]

	if(big_type != MT_DATA)
   88e48:	7bfb      	ldrb	r3, [r7, #15]
   88e4a:	2b00      	cmp	r3, #0
   88e4c:	d000      	beq.n	88e50 <alert_can_data+0x3c>
		return;
   88e4e:	e05e      	b.n	88f0e <alert_can_data+0xfa>
	
	if(small_type == SPI_TEMP1)
   88e50:	7bbb      	ldrb	r3, [r7, #14]
   88e52:	2bff      	cmp	r3, #255	; 0xff
   88e54:	d102      	bne.n	88e5c <alert_can_data+0x48>
		glob_drf = 1;
   88e56:	4b30      	ldr	r3, [pc, #192]	; (88f18 <alert_can_data+0x104>)
   88e58:	2201      	movs	r2, #1
   88e5a:	701a      	strb	r2, [r3, #0]
		
	if(small_type == COMS_PACKET)
   88e5c:	7bbb      	ldrb	r3, [r7, #14]
   88e5e:	2bfe      	cmp	r3, #254	; 0xfe
   88e60:	d102      	bne.n	88e68 <alert_can_data+0x54>
		glob_comsf = 1;
   88e62:	4b2e      	ldr	r3, [pc, #184]	; (88f1c <alert_can_data+0x108>)
   88e64:	2201      	movs	r2, #1
   88e66:	701a      	strb	r2, [r3, #0]
		
	switch(destination)
   88e68:	7b7b      	ldrb	r3, [r7, #13]
   88e6a:	3b07      	subs	r3, #7
   88e6c:	2b05      	cmp	r3, #5
   88e6e:	d84d      	bhi.n	88f0c <alert_can_data+0xf8>
   88e70:	a201      	add	r2, pc, #4	; (adr r2, 88e78 <alert_can_data+0x64>)
   88e72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   88e76:	bf00      	nop
   88e78:	00088ea5 	.word	0x00088ea5
   88e7c:	00088e91 	.word	0x00088e91
   88e80:	00088eb9 	.word	0x00088eb9
   88e84:	00088ecd 	.word	0x00088ecd
   88e88:	00088ef5 	.word	0x00088ef5
   88e8c:	00088ee1 	.word	0x00088ee1
	{
		case EPS_TASK_ID:
			eps_data_receivedf = 1;
   88e90:	4b23      	ldr	r3, [pc, #140]	; (88f20 <alert_can_data+0x10c>)
   88e92:	2201      	movs	r2, #1
   88e94:	701a      	strb	r2, [r3, #0]
			eps_data_receive[1] = uh_data_incom;
   88e96:	4b23      	ldr	r3, [pc, #140]	; (88f24 <alert_can_data+0x110>)
   88e98:	697a      	ldr	r2, [r7, #20]
   88e9a:	605a      	str	r2, [r3, #4]
			eps_data_receive[0] = ul_data_incom;
   88e9c:	4b21      	ldr	r3, [pc, #132]	; (88f24 <alert_can_data+0x110>)
   88e9e:	693a      	ldr	r2, [r7, #16]
   88ea0:	601a      	str	r2, [r3, #0]
			break;
   88ea2:	e031      	b.n	88f08 <alert_can_data+0xf4>
		case COMS_TASK_ID:
			coms_data_receivedf = 1;
   88ea4:	4b20      	ldr	r3, [pc, #128]	; (88f28 <alert_can_data+0x114>)
   88ea6:	2201      	movs	r2, #1
   88ea8:	701a      	strb	r2, [r3, #0]
			coms_data_receive[1] = uh_data_incom;
   88eaa:	4b20      	ldr	r3, [pc, #128]	; (88f2c <alert_can_data+0x118>)
   88eac:	697a      	ldr	r2, [r7, #20]
   88eae:	605a      	str	r2, [r3, #4]
			coms_data_receive[0] = ul_data_incom;
   88eb0:	4b1e      	ldr	r3, [pc, #120]	; (88f2c <alert_can_data+0x118>)
   88eb2:	693a      	ldr	r2, [r7, #16]
   88eb4:	601a      	str	r2, [r3, #0]
			break;
   88eb6:	e027      	b.n	88f08 <alert_can_data+0xf4>
		case PAY_TASK_ID:
			pay_data_receivedf = 1;
   88eb8:	4b1d      	ldr	r3, [pc, #116]	; (88f30 <alert_can_data+0x11c>)
   88eba:	2201      	movs	r2, #1
   88ebc:	701a      	strb	r2, [r3, #0]
			pay_data_receive[1] = uh_data_incom;
   88ebe:	4b1d      	ldr	r3, [pc, #116]	; (88f34 <alert_can_data+0x120>)
   88ec0:	697a      	ldr	r2, [r7, #20]
   88ec2:	605a      	str	r2, [r3, #4]
			pay_data_receive[0] = ul_data_incom;
   88ec4:	4b1b      	ldr	r3, [pc, #108]	; (88f34 <alert_can_data+0x120>)
   88ec6:	693a      	ldr	r2, [r7, #16]
   88ec8:	601a      	str	r2, [r3, #0]
			break;
   88eca:	e01d      	b.n	88f08 <alert_can_data+0xf4>
		case OBC_PACKET_ROUTER_ID:
			opr_data_receivedf = 1;
   88ecc:	4b1a      	ldr	r3, [pc, #104]	; (88f38 <alert_can_data+0x124>)
   88ece:	2201      	movs	r2, #1
   88ed0:	701a      	strb	r2, [r3, #0]
			opr_data_receive[1] = uh_data_incom;
   88ed2:	4b1a      	ldr	r3, [pc, #104]	; (88f3c <alert_can_data+0x128>)
   88ed4:	697a      	ldr	r2, [r7, #20]
   88ed6:	605a      	str	r2, [r3, #4]
			opr_data_receive[0] = ul_data_incom;
   88ed8:	4b18      	ldr	r3, [pc, #96]	; (88f3c <alert_can_data+0x128>)
   88eda:	693a      	ldr	r2, [r7, #16]
   88edc:	601a      	str	r2, [r3, #0]
			break;
   88ede:	e013      	b.n	88f08 <alert_can_data+0xf4>
		case FDIR_TASK_ID:
			fdir_data_receivedf = 1;
   88ee0:	4b17      	ldr	r3, [pc, #92]	; (88f40 <alert_can_data+0x12c>)
   88ee2:	2201      	movs	r2, #1
   88ee4:	701a      	strb	r2, [r3, #0]
			fdir_data_receive[1] = uh_data_incom;
   88ee6:	4b17      	ldr	r3, [pc, #92]	; (88f44 <alert_can_data+0x130>)
   88ee8:	697a      	ldr	r2, [r7, #20]
   88eea:	605a      	str	r2, [r3, #4]
			fdir_data_receive[0] = ul_data_incom;
   88eec:	4b15      	ldr	r3, [pc, #84]	; (88f44 <alert_can_data+0x130>)
   88eee:	693a      	ldr	r2, [r7, #16]
   88ef0:	601a      	str	r2, [r3, #0]
			break;
   88ef2:	e009      	b.n	88f08 <alert_can_data+0xf4>
		case SCHEDULING_TASK_ID:
			sched_data_receivedf = 1;
   88ef4:	4b14      	ldr	r3, [pc, #80]	; (88f48 <alert_can_data+0x134>)
   88ef6:	2201      	movs	r2, #1
   88ef8:	701a      	strb	r2, [r3, #0]
			sched_data_receive[1] = uh_data_incom;
   88efa:	4b14      	ldr	r3, [pc, #80]	; (88f4c <alert_can_data+0x138>)
   88efc:	697a      	ldr	r2, [r7, #20]
   88efe:	605a      	str	r2, [r3, #4]
			sched_data_receive[0] = ul_data_incom;
   88f00:	4b12      	ldr	r3, [pc, #72]	; (88f4c <alert_can_data+0x138>)
   88f02:	693a      	ldr	r2, [r7, #16]
   88f04:	601a      	str	r2, [r3, #0]
			break;
   88f06:	bf00      	nop
		default:
			return;	
	}
	return;
   88f08:	bf00      	nop
   88f0a:	e000      	b.n	88f0e <alert_can_data+0xfa>
			sched_data_receivedf = 1;
			sched_data_receive[1] = uh_data_incom;
			sched_data_receive[0] = ul_data_incom;
			break;
		default:
			return;	
   88f0c:	bf00      	nop
	}
	return;
}
   88f0e:	371c      	adds	r7, #28
   88f10:	46bd      	mov	sp, r7
   88f12:	f85d 7b04 	ldr.w	r7, [sp], #4
   88f16:	4770      	bx	lr
   88f18:	2007ae54 	.word	0x2007ae54
   88f1c:	2007b0f4 	.word	0x2007b0f4
   88f20:	2007b520 	.word	0x2007b520
   88f24:	2007b428 	.word	0x2007b428
   88f28:	2007aef0 	.word	0x2007aef0
   88f2c:	2007b39c 	.word	0x2007b39c
   88f30:	2007b528 	.word	0x2007b528
   88f34:	2007b3d0 	.word	0x2007b3d0
   88f38:	2007b3f4 	.word	0x2007b3f4
   88f3c:	2007adb0 	.word	0x2007adb0
   88f40:	2007ae25 	.word	0x2007ae25
   88f44:	2007adbc 	.word	0x2007adbc
   88f48:	2007b550 	.word	0x2007b550
   88f4c:	2007add4 	.word	0x2007add4

00088f50 <store_can_msg>:
/* @param: mb: The mailbox from which the message was received. 		*/
/* @Purpose: This function takes a message which was received and stores*/
/* in the proper FIFO in memory.										*/
/************************************************************************/
void store_can_msg(can_mb_conf_t *p_mailbox, uint8_t mb)
{
   88f50:	b590      	push	{r4, r7, lr}
   88f52:	b087      	sub	sp, #28
   88f54:	af00      	add	r7, sp, #0
   88f56:	6078      	str	r0, [r7, #4]
   88f58:	460b      	mov	r3, r1
   88f5a:	70fb      	strb	r3, [r7, #3]
	uint32_t ul_data_incom = p_mailbox->ul_datal;
   88f5c:	687b      	ldr	r3, [r7, #4]
   88f5e:	699b      	ldr	r3, [r3, #24]
   88f60:	617b      	str	r3, [r7, #20]
	uint32_t uh_data_incom = p_mailbox->ul_datah;
   88f62:	687b      	ldr	r3, [r7, #4]
   88f64:	69db      	ldr	r3, [r3, #28]
   88f66:	613b      	str	r3, [r7, #16]
	BaseType_t wake_task;	// Not needed here.

	/* UPDATE THE GLOBAL CAN REGS		*/
	switch(mb)
   88f68:	78fb      	ldrb	r3, [r7, #3]
   88f6a:	2b07      	cmp	r3, #7
   88f6c:	d879      	bhi.n	89062 <store_can_msg+0x112>
   88f6e:	a201      	add	r2, pc, #4	; (adr r2, 88f74 <store_can_msg+0x24>)
   88f70:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
   88f74:	00088f95 	.word	0x00088f95
   88f78:	00088fc7 	.word	0x00088fc7
   88f7c:	00089063 	.word	0x00089063
   88f80:	00089063 	.word	0x00089063
   88f84:	00089063 	.word	0x00089063
   88f88:	00088ff9 	.word	0x00088ff9
   88f8c:	0008902b 	.word	0x0008902b
   88f90:	0008905d 	.word	0x0008905d
	{		
	case 0 :
		xQueueSendToBackFromISR(can_data_fifo, &ul_data_incom, &wake_task);		// Global CAN Data FIFO
   88f94:	4b35      	ldr	r3, [pc, #212]	; (8906c <store_can_msg+0x11c>)
   88f96:	6819      	ldr	r1, [r3, #0]
   88f98:	f107 0214 	add.w	r2, r7, #20
   88f9c:	f107 030c 	add.w	r3, r7, #12
   88fa0:	4608      	mov	r0, r1
   88fa2:	4611      	mov	r1, r2
   88fa4:	461a      	mov	r2, r3
   88fa6:	2300      	movs	r3, #0
   88fa8:	4c31      	ldr	r4, [pc, #196]	; (89070 <store_can_msg+0x120>)
   88faa:	47a0      	blx	r4
		xQueueSendToBackFromISR(can_data_fifo, &uh_data_incom, &wake_task);
   88fac:	4b2f      	ldr	r3, [pc, #188]	; (8906c <store_can_msg+0x11c>)
   88fae:	6819      	ldr	r1, [r3, #0]
   88fb0:	f107 0210 	add.w	r2, r7, #16
   88fb4:	f107 030c 	add.w	r3, r7, #12
   88fb8:	4608      	mov	r0, r1
   88fba:	4611      	mov	r1, r2
   88fbc:	461a      	mov	r2, r3
   88fbe:	2300      	movs	r3, #0
   88fc0:	4c2b      	ldr	r4, [pc, #172]	; (89070 <store_can_msg+0x120>)
   88fc2:	47a0      	blx	r4
		break;
   88fc4:	e04b      	b.n	8905e <store_can_msg+0x10e>
	case 1 :
		xQueueSendToBackFromISR(can_data_fifo, &ul_data_incom, &wake_task);		// Global CAN Data FIFO
   88fc6:	4b29      	ldr	r3, [pc, #164]	; (8906c <store_can_msg+0x11c>)
   88fc8:	6819      	ldr	r1, [r3, #0]
   88fca:	f107 0214 	add.w	r2, r7, #20
   88fce:	f107 030c 	add.w	r3, r7, #12
   88fd2:	4608      	mov	r0, r1
   88fd4:	4611      	mov	r1, r2
   88fd6:	461a      	mov	r2, r3
   88fd8:	2300      	movs	r3, #0
   88fda:	4c25      	ldr	r4, [pc, #148]	; (89070 <store_can_msg+0x120>)
   88fdc:	47a0      	blx	r4
		xQueueSendToBackFromISR(can_data_fifo, &uh_data_incom, &wake_task);
   88fde:	4b23      	ldr	r3, [pc, #140]	; (8906c <store_can_msg+0x11c>)
   88fe0:	6819      	ldr	r1, [r3, #0]
   88fe2:	f107 0210 	add.w	r2, r7, #16
   88fe6:	f107 030c 	add.w	r3, r7, #12
   88fea:	4608      	mov	r0, r1
   88fec:	4611      	mov	r1, r2
   88fee:	461a      	mov	r2, r3
   88ff0:	2300      	movs	r3, #0
   88ff2:	4c1f      	ldr	r4, [pc, #124]	; (89070 <store_can_msg+0x120>)
   88ff4:	47a0      	blx	r4
		break;
   88ff6:	e032      	b.n	8905e <store_can_msg+0x10e>
		//xQueueSendToBackFromISR(can_data_fifo, &uh_data_incom, &wake_task);
	//case 4 :
		//xQueueSendToBackFromISR(can_hk_fifo, &ul_data_incom, &wake_task);		// Global CAN HK FIFO.
		//xQueueSendToBackFromISR(can_hk_fifo, &uh_data_incom, &wake_task);
	case 5 :
		xQueueSendToBackFromISR(can_hk_fifo, &ul_data_incom, &wake_task);		// Global CAN HK FIFO.
   88ff8:	4b1e      	ldr	r3, [pc, #120]	; (89074 <store_can_msg+0x124>)
   88ffa:	6819      	ldr	r1, [r3, #0]
   88ffc:	f107 0214 	add.w	r2, r7, #20
   89000:	f107 030c 	add.w	r3, r7, #12
   89004:	4608      	mov	r0, r1
   89006:	4611      	mov	r1, r2
   89008:	461a      	mov	r2, r3
   8900a:	2300      	movs	r3, #0
   8900c:	4c18      	ldr	r4, [pc, #96]	; (89070 <store_can_msg+0x120>)
   8900e:	47a0      	blx	r4
		xQueueSendToBackFromISR(can_hk_fifo, &uh_data_incom, &wake_task);
   89010:	4b18      	ldr	r3, [pc, #96]	; (89074 <store_can_msg+0x124>)
   89012:	6819      	ldr	r1, [r3, #0]
   89014:	f107 0210 	add.w	r2, r7, #16
   89018:	f107 030c 	add.w	r3, r7, #12
   8901c:	4608      	mov	r0, r1
   8901e:	4611      	mov	r1, r2
   89020:	461a      	mov	r2, r3
   89022:	2300      	movs	r3, #0
   89024:	4c12      	ldr	r4, [pc, #72]	; (89070 <store_can_msg+0x120>)
   89026:	47a0      	blx	r4
		break;
   89028:	e019      	b.n	8905e <store_can_msg+0x10e>
	case 6 :
		xQueueSendToBackFromISR(can_hk_fifo, &ul_data_incom, &wake_task);		// Global CAN HK FIFO.
   8902a:	4b12      	ldr	r3, [pc, #72]	; (89074 <store_can_msg+0x124>)
   8902c:	6819      	ldr	r1, [r3, #0]
   8902e:	f107 0214 	add.w	r2, r7, #20
   89032:	f107 030c 	add.w	r3, r7, #12
   89036:	4608      	mov	r0, r1
   89038:	4611      	mov	r1, r2
   8903a:	461a      	mov	r2, r3
   8903c:	2300      	movs	r3, #0
   8903e:	4c0c      	ldr	r4, [pc, #48]	; (89070 <store_can_msg+0x120>)
   89040:	47a0      	blx	r4
		xQueueSendToBackFromISR(can_hk_fifo, &uh_data_incom, &wake_task);
   89042:	4b0c      	ldr	r3, [pc, #48]	; (89074 <store_can_msg+0x124>)
   89044:	6819      	ldr	r1, [r3, #0]
   89046:	f107 0210 	add.w	r2, r7, #16
   8904a:	f107 030c 	add.w	r3, r7, #12
   8904e:	4608      	mov	r0, r1
   89050:	4611      	mov	r1, r2
   89052:	461a      	mov	r2, r3
   89054:	2300      	movs	r3, #0
   89056:	4c06      	ldr	r4, [pc, #24]	; (89070 <store_can_msg+0x120>)
   89058:	47a0      	blx	r4
		break;
   8905a:	e000      	b.n	8905e <store_can_msg+0x10e>
	case 7 :
		break;
   8905c:	bf00      	nop
		// to the requesting process.

	default :
		return;
	}
	return;
   8905e:	bf00      	nop
   89060:	e000      	b.n	89064 <store_can_msg+0x114>
		// be able to use without reading CAN messages.
		// Of course, CAN messages and FIFOs will still be used to transmit info
		// to the requesting process.

	default :
		return;
   89062:	bf00      	nop
	}
	return;
}
   89064:	371c      	adds	r7, #28
   89066:	46bd      	mov	sp, r7
   89068:	bd90      	pop	{r4, r7, pc}
   8906a:	bf00      	nop
   8906c:	2007b12c 	.word	0x2007b12c
   89070:	00086cc5 	.word	0x00086cc5
   89074:	2007adf4 	.word	0x2007adf4

00089078 <reset_mailbox_conf>:
/* RESET_MAILBOX_CONF 		                                            */
/* @param: *p_mailbox: the mailbox object to be reset. 					*/
/* @Purpose: This function resets the attributes of object p_mailbox.	*/
/************************************************************************/
void reset_mailbox_conf(can_mb_conf_t *p_mailbox)
{
   89078:	b480      	push	{r7}
   8907a:	b083      	sub	sp, #12
   8907c:	af00      	add	r7, sp, #0
   8907e:	6078      	str	r0, [r7, #4]
	p_mailbox->ul_mb_idx = 0;
   89080:	687b      	ldr	r3, [r7, #4]
   89082:	2200      	movs	r2, #0
   89084:	601a      	str	r2, [r3, #0]
	p_mailbox->uc_obj_type = 0;
   89086:	687b      	ldr	r3, [r7, #4]
   89088:	2200      	movs	r2, #0
   8908a:	711a      	strb	r2, [r3, #4]
	p_mailbox->uc_id_ver = 0;
   8908c:	687b      	ldr	r3, [r7, #4]
   8908e:	2200      	movs	r2, #0
   89090:	715a      	strb	r2, [r3, #5]
	p_mailbox->uc_length = 0;
   89092:	687b      	ldr	r3, [r7, #4]
   89094:	2200      	movs	r2, #0
   89096:	719a      	strb	r2, [r3, #6]
	p_mailbox->uc_tx_prio = 0;
   89098:	687b      	ldr	r3, [r7, #4]
   8909a:	2200      	movs	r2, #0
   8909c:	71da      	strb	r2, [r3, #7]
	p_mailbox->ul_status = 0;
   8909e:	687b      	ldr	r3, [r7, #4]
   890a0:	2200      	movs	r2, #0
   890a2:	609a      	str	r2, [r3, #8]
	p_mailbox->ul_id_msk = 0;
   890a4:	687b      	ldr	r3, [r7, #4]
   890a6:	2200      	movs	r2, #0
   890a8:	60da      	str	r2, [r3, #12]
	p_mailbox->ul_id = 0;
   890aa:	687b      	ldr	r3, [r7, #4]
   890ac:	2200      	movs	r2, #0
   890ae:	611a      	str	r2, [r3, #16]
	p_mailbox->ul_fid = 0;
   890b0:	687b      	ldr	r3, [r7, #4]
   890b2:	2200      	movs	r2, #0
   890b4:	615a      	str	r2, [r3, #20]
	p_mailbox->ul_datal = 0;
   890b6:	687b      	ldr	r3, [r7, #4]
   890b8:	2200      	movs	r2, #0
   890ba:	619a      	str	r2, [r3, #24]
	p_mailbox->ul_datah = 0;
   890bc:	687b      	ldr	r3, [r7, #4]
   890be:	2200      	movs	r2, #0
   890c0:	61da      	str	r2, [r3, #28]

	return;
   890c2:	bf00      	nop
}
   890c4:	370c      	adds	r7, #12
   890c6:	46bd      	mov	sp, r7
   890c8:	f85d 7b04 	ldr.w	r7, [sp], #4
   890cc:	4770      	bx	lr
   890ce:	bf00      	nop

000890d0 <send_can_command_h>:
/* @NOTE: 1 != Success (Necessarily) 									*/
/* @NOTE: This is a helper function, it is only to be used in sections  */
/* of code where the Can0_Mutex has been acquired.						*/
/************************************************************************/
uint32_t send_can_command_h(uint32_t low, uint32_t high, uint32_t ID, uint32_t PRIORITY)
{	
   890d0:	b580      	push	{r7, lr}
   890d2:	b084      	sub	sp, #16
   890d4:	af00      	add	r7, sp, #0
   890d6:	60f8      	str	r0, [r7, #12]
   890d8:	60b9      	str	r1, [r7, #8]
   890da:	607a      	str	r2, [r7, #4]
   890dc:	603b      	str	r3, [r7, #0]
	//uint32_t timeout = 8400;		// ~ 100 us timeout.
	/* Init CAN0 Mailbox 7 to Transmit Mailbox. */	
	/* CAN0 MB7 == COMMAND/MSG MB				*/
	reset_mailbox_conf(&can0_mailbox);
   890de:	4819      	ldr	r0, [pc, #100]	; (89144 <send_can_command_h+0x74>)
   890e0:	4b19      	ldr	r3, [pc, #100]	; (89148 <send_can_command_h+0x78>)
   890e2:	4798      	blx	r3
	can0_mailbox.ul_mb_idx = 7;						//Mailbox Number 7
   890e4:	4b17      	ldr	r3, [pc, #92]	; (89144 <send_can_command_h+0x74>)
   890e6:	2207      	movs	r2, #7
   890e8:	601a      	str	r2, [r3, #0]
	can0_mailbox.uc_obj_type = CAN_MB_TX_MODE;
   890ea:	4b16      	ldr	r3, [pc, #88]	; (89144 <send_can_command_h+0x74>)
   890ec:	2203      	movs	r2, #3
   890ee:	711a      	strb	r2, [r3, #4]
	can0_mailbox.uc_tx_prio = PRIORITY;				//Transmission Priority (Can be Changed dynamically)
   890f0:	683b      	ldr	r3, [r7, #0]
   890f2:	b2da      	uxtb	r2, r3
   890f4:	4b13      	ldr	r3, [pc, #76]	; (89144 <send_can_command_h+0x74>)
   890f6:	71da      	strb	r2, [r3, #7]
	can0_mailbox.uc_id_ver = 0;
   890f8:	4b12      	ldr	r3, [pc, #72]	; (89144 <send_can_command_h+0x74>)
   890fa:	2200      	movs	r2, #0
   890fc:	715a      	strb	r2, [r3, #5]
	can0_mailbox.ul_id_msk = 0;
   890fe:	4b11      	ldr	r3, [pc, #68]	; (89144 <send_can_command_h+0x74>)
   89100:	2200      	movs	r2, #0
   89102:	60da      	str	r2, [r3, #12]
	can_mailbox_init(CAN0, &can0_mailbox);
   89104:	4811      	ldr	r0, [pc, #68]	; (8914c <send_can_command_h+0x7c>)
   89106:	490f      	ldr	r1, [pc, #60]	; (89144 <send_can_command_h+0x74>)
   89108:	4b11      	ldr	r3, [pc, #68]	; (89150 <send_can_command_h+0x80>)
   8910a:	4798      	blx	r3

	/* Write transmit information into mailbox. */
	can0_mailbox.ul_id = CAN_MID_MIDvA(ID);			// ID of the message being sent,
   8910c:	687b      	ldr	r3, [r7, #4]
   8910e:	049a      	lsls	r2, r3, #18
   89110:	4b10      	ldr	r3, [pc, #64]	; (89154 <send_can_command_h+0x84>)
   89112:	4013      	ands	r3, r2
   89114:	4a0b      	ldr	r2, [pc, #44]	; (89144 <send_can_command_h+0x74>)
   89116:	6113      	str	r3, [r2, #16]
	can0_mailbox.ul_datal = low;					// shifted over to the standard frame position./
   89118:	4b0a      	ldr	r3, [pc, #40]	; (89144 <send_can_command_h+0x74>)
   8911a:	68fa      	ldr	r2, [r7, #12]
   8911c:	619a      	str	r2, [r3, #24]
	can0_mailbox.ul_datah = high;
   8911e:	4b09      	ldr	r3, [pc, #36]	; (89144 <send_can_command_h+0x74>)
   89120:	68ba      	ldr	r2, [r7, #8]
   89122:	61da      	str	r2, [r3, #28]
	can0_mailbox.uc_length = MAX_CAN_FRAME_DATA_LEN;
   89124:	4b07      	ldr	r3, [pc, #28]	; (89144 <send_can_command_h+0x74>)
   89126:	2208      	movs	r2, #8
   89128:	719a      	strb	r2, [r3, #6]
	can_mailbox_write(CAN0, &can0_mailbox);
   8912a:	4808      	ldr	r0, [pc, #32]	; (8914c <send_can_command_h+0x7c>)
   8912c:	4905      	ldr	r1, [pc, #20]	; (89144 <send_can_command_h+0x74>)
   8912e:	4b0a      	ldr	r3, [pc, #40]	; (89158 <send_can_command_h+0x88>)
   89130:	4798      	blx	r3

	/* Send out the information in the mailbox. */
	can_global_send_transfer_cmd(CAN0, CAN_TCR_MB7);
   89132:	4806      	ldr	r0, [pc, #24]	; (8914c <send_can_command_h+0x7c>)
   89134:	2180      	movs	r1, #128	; 0x80
   89136:	4b09      	ldr	r3, [pc, #36]	; (8915c <send_can_command_h+0x8c>)
   89138:	4798      	blx	r3
	
	return 0;
   8913a:	2300      	movs	r3, #0
}
   8913c:	4618      	mov	r0, r3
   8913e:	3710      	adds	r7, #16
   89140:	46bd      	mov	sp, r7
   89142:	bd80      	pop	{r7, pc}
   89144:	2007b408 	.word	0x2007b408
   89148:	00089079 	.word	0x00089079
   8914c:	400b4000 	.word	0x400b4000
   89150:	00085031 	.word	0x00085031
   89154:	1ffc0000 	.word	0x1ffc0000
   89158:	00085215 	.word	0x00085215
   8915c:	00084fa5 	.word	0x00084fa5

00089160 <send_can_command_h2>:
/* @Purpose: This function sends an 8 byte message to the SSM chosen. 	*/
/* @return: 1 == completed, (<=0) == failure.							*/
/* @NOTE: 1 != Success (Necessarily) 									*/
/************************************************************************/
int send_can_command_h2(uint32_t low, uint8_t byte_four, uint8_t sender_id, uint8_t ssm_id, uint8_t smalltype, uint8_t priority)
{	
   89160:	b590      	push	{r4, r7, lr}
   89162:	b087      	sub	sp, #28
   89164:	af00      	add	r7, sp, #0
   89166:	6078      	str	r0, [r7, #4]
   89168:	70f9      	strb	r1, [r7, #3]
   8916a:	70ba      	strb	r2, [r7, #2]
   8916c:	707b      	strb	r3, [r7, #1]
	//uint32_t timeout = 8400;		// ~ 100 us timeout.
	uint32_t id, ret_val, high;
	
	if(ssm_id == COMS_ID)
   8916e:	787b      	ldrb	r3, [r7, #1]
   89170:	2b00      	cmp	r3, #0
   89172:	d101      	bne.n	89178 <send_can_command_h2+0x18>
		id = SUB0_ID0;
   89174:	2314      	movs	r3, #20
   89176:	617b      	str	r3, [r7, #20]
	if(ssm_id == EPS_ID)
   89178:	787b      	ldrb	r3, [r7, #1]
   8917a:	2b01      	cmp	r3, #1
   8917c:	d101      	bne.n	89182 <send_can_command_h2+0x22>
		id = SUB1_ID0;
   8917e:	231a      	movs	r3, #26
   89180:	617b      	str	r3, [r7, #20]
	if(ssm_id == PAY_ID)
   89182:	787b      	ldrb	r3, [r7, #1]
   89184:	2b02      	cmp	r3, #2
   89186:	d101      	bne.n	8918c <send_can_command_h2+0x2c>
		id = SUB2_ID0;
   89188:	2320      	movs	r3, #32
   8918a:	617b      	str	r3, [r7, #20]
		
	high = high_command_generator(sender_id, ssm_id, MT_COM, smalltype);
   8918c:	78b9      	ldrb	r1, [r7, #2]
   8918e:	787a      	ldrb	r2, [r7, #1]
   89190:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   89194:	4608      	mov	r0, r1
   89196:	4611      	mov	r1, r2
   89198:	2202      	movs	r2, #2
   8919a:	4c0b      	ldr	r4, [pc, #44]	; (891c8 <send_can_command_h2+0x68>)
   8919c:	47a0      	blx	r4
   8919e:	6138      	str	r0, [r7, #16]
	if(byte_four)
   891a0:	78fb      	ldrb	r3, [r7, #3]
   891a2:	2b00      	cmp	r3, #0
   891a4:	d003      	beq.n	891ae <send_can_command_h2+0x4e>
		high |= (uint32_t)byte_four;
   891a6:	78fb      	ldrb	r3, [r7, #3]
   891a8:	693a      	ldr	r2, [r7, #16]
   891aa:	4313      	orrs	r3, r2
   891ac:	613b      	str	r3, [r7, #16]

	ret_val = send_can_command_h(low, high, id, priority);
   891ae:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   891b2:	6878      	ldr	r0, [r7, #4]
   891b4:	6939      	ldr	r1, [r7, #16]
   891b6:	697a      	ldr	r2, [r7, #20]
   891b8:	4c04      	ldr	r4, [pc, #16]	; (891cc <send_can_command_h2+0x6c>)
   891ba:	47a0      	blx	r4
   891bc:	60f8      	str	r0, [r7, #12]
	return (int)ret_val;
   891be:	68fb      	ldr	r3, [r7, #12]
}
   891c0:	4618      	mov	r0, r3
   891c2:	371c      	adds	r7, #28
   891c4:	46bd      	mov	sp, r7
   891c6:	bd90      	pop	{r4, r7, pc}
   891c8:	000899a9 	.word	0x000899a9
   891cc:	000890d1 	.word	0x000890d1

000891d0 <send_can_command>:
/* @Purpose: This function sends an 8 byte message to the SSM chosen. 	*/
/* @return: 1 == completed, (<=0) == failure.							*/
/* @NOTE: 1 != Success (Necessarily) 									*/
/************************************************************************/
int send_can_command(uint32_t low, uint8_t byte_four, uint8_t sender_id, uint8_t ssm_id, uint8_t smalltype, uint8_t priority)
{	
   891d0:	b590      	push	{r4, r7, lr}
   891d2:	b087      	sub	sp, #28
   891d4:	af00      	add	r7, sp, #0
   891d6:	6078      	str	r0, [r7, #4]
   891d8:	70f9      	strb	r1, [r7, #3]
   891da:	70ba      	strb	r2, [r7, #2]
   891dc:	707b      	strb	r3, [r7, #1]
	//uint32_t timeout = 8400;		// ~ 100 us timeout.
	uint32_t id, ret_val, high;
	
	if(ssm_id == COMS_ID)
   891de:	787b      	ldrb	r3, [r7, #1]
   891e0:	2b00      	cmp	r3, #0
   891e2:	d101      	bne.n	891e8 <send_can_command+0x18>
		id = SUB0_ID0;
   891e4:	2314      	movs	r3, #20
   891e6:	617b      	str	r3, [r7, #20]
	if(ssm_id == EPS_ID)
   891e8:	787b      	ldrb	r3, [r7, #1]
   891ea:	2b01      	cmp	r3, #1
   891ec:	d101      	bne.n	891f2 <send_can_command+0x22>
		id = SUB1_ID0;
   891ee:	231a      	movs	r3, #26
   891f0:	617b      	str	r3, [r7, #20]
	if(ssm_id == PAY_ID)
   891f2:	787b      	ldrb	r3, [r7, #1]
   891f4:	2b02      	cmp	r3, #2
   891f6:	d101      	bne.n	891fc <send_can_command+0x2c>
		id = SUB2_ID0;
   891f8:	2320      	movs	r3, #32
   891fa:	617b      	str	r3, [r7, #20]
		
	high = high_command_generator(sender_id, ssm_id, MT_COM, smalltype);
   891fc:	78b9      	ldrb	r1, [r7, #2]
   891fe:	787a      	ldrb	r2, [r7, #1]
   89200:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   89204:	4608      	mov	r0, r1
   89206:	4611      	mov	r1, r2
   89208:	2202      	movs	r2, #2
   8920a:	4c18      	ldr	r4, [pc, #96]	; (8926c <send_can_command+0x9c>)
   8920c:	47a0      	blx	r4
   8920e:	6138      	str	r0, [r7, #16]
	if(byte_four)
   89210:	78fb      	ldrb	r3, [r7, #3]
   89212:	2b00      	cmp	r3, #0
   89214:	d003      	beq.n	8921e <send_can_command+0x4e>
		high |= (uint32_t)byte_four;
   89216:	78fb      	ldrb	r3, [r7, #3]
   89218:	693a      	ldr	r2, [r7, #16]
   8921a:	4313      	orrs	r3, r2
   8921c:	613b      	str	r3, [r7, #16]

	if (xSemaphoreTake(Can0_Mutex, (TickType_t) 1) == pdTRUE)		// Attempt to acquire CAN1 Mutex, block for 1 tick.
   8921e:	4b14      	ldr	r3, [pc, #80]	; (89270 <send_can_command+0xa0>)
   89220:	681b      	ldr	r3, [r3, #0]
   89222:	4618      	mov	r0, r3
   89224:	2100      	movs	r1, #0
   89226:	2201      	movs	r2, #1
   89228:	2300      	movs	r3, #0
   8922a:	4c12      	ldr	r4, [pc, #72]	; (89274 <send_can_command+0xa4>)
   8922c:	47a0      	blx	r4
   8922e:	4603      	mov	r3, r0
   89230:	2b01      	cmp	r3, #1
   89232:	d114      	bne.n	8925e <send_can_command+0x8e>
	{
		ret_val = send_can_command_h(low, high, id, priority);
   89234:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   89238:	6878      	ldr	r0, [r7, #4]
   8923a:	6939      	ldr	r1, [r7, #16]
   8923c:	697a      	ldr	r2, [r7, #20]
   8923e:	4c0e      	ldr	r4, [pc, #56]	; (89278 <send_can_command+0xa8>)
   89240:	47a0      	blx	r4
   89242:	60f8      	str	r0, [r7, #12]
		xSemaphoreGive(Can0_Mutex);
   89244:	4b0a      	ldr	r3, [pc, #40]	; (89270 <send_can_command+0xa0>)
   89246:	681b      	ldr	r3, [r3, #0]
   89248:	4618      	mov	r0, r3
   8924a:	2100      	movs	r1, #0
   8924c:	2200      	movs	r2, #0
   8924e:	2300      	movs	r3, #0
   89250:	4c0a      	ldr	r4, [pc, #40]	; (8927c <send_can_command+0xac>)
   89252:	47a0      	blx	r4
		delay_us(100);
   89254:	2064      	movs	r0, #100	; 0x64
   89256:	4b0a      	ldr	r3, [pc, #40]	; (89280 <send_can_command+0xb0>)
   89258:	4798      	blx	r3
		return (int)ret_val;
   8925a:	68fb      	ldr	r3, [r7, #12]
   8925c:	e001      	b.n	89262 <send_can_command+0x92>
	}
	
	else
		return -1;												// CAN0 is currently busy, or something has gone wrong.
   8925e:	f04f 33ff 	mov.w	r3, #4294967295
}
   89262:	4618      	mov	r0, r3
   89264:	371c      	adds	r7, #28
   89266:	46bd      	mov	sp, r7
   89268:	bd90      	pop	{r4, r7, pc}
   8926a:	bf00      	nop
   8926c:	000899a9 	.word	0x000899a9
   89270:	2007b524 	.word	0x2007b524
   89274:	00086dc1 	.word	0x00086dc1
   89278:	000890d1 	.word	0x000890d1
   8927c:	00086b01 	.word	0x00086b01
   89280:	0008425d 	.word	0x0008425d

00089284 <send_tc_can_command>:
/* SEND_TC_CAN_COMMAND 		                                            */
/* @NOTE: To be used only for sending TC COMMANDS, directs the outgoing */
/* message to SUB0_ID3 in the COMS SSM.									*/
/************************************************************************/
int send_tc_can_command(uint32_t low, uint8_t byte_four, uint8_t sender_id, uint8_t ssm_id, uint8_t smalltype, uint8_t priority)
{
   89284:	b590      	push	{r4, r7, lr}
   89286:	b087      	sub	sp, #28
   89288:	af00      	add	r7, sp, #0
   8928a:	6078      	str	r0, [r7, #4]
   8928c:	70f9      	strb	r1, [r7, #3]
   8928e:	70ba      	strb	r2, [r7, #2]
   89290:	707b      	strb	r3, [r7, #1]
	//uint32_t timeout = 8400;		// ~ 100 us timeout.//
	uint32_t id, ret_val, high;
	
	if(ssm_id == COMS_ID)
   89292:	787b      	ldrb	r3, [r7, #1]
   89294:	2b00      	cmp	r3, #0
   89296:	d10f      	bne.n	892b8 <send_tc_can_command+0x34>
		id = SUB0_ID3;
   89298:	2317      	movs	r3, #23
   8929a:	613b      	str	r3, [r7, #16]
	else
		return -1;
	
	high = high_command_generator(sender_id, ssm_id, MT_COM, smalltype);
   8929c:	78b9      	ldrb	r1, [r7, #2]
   8929e:	787a      	ldrb	r2, [r7, #1]
   892a0:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   892a4:	4608      	mov	r0, r1
   892a6:	4611      	mov	r1, r2
   892a8:	2202      	movs	r2, #2
   892aa:	4c1a      	ldr	r4, [pc, #104]	; (89314 <send_tc_can_command+0x90>)
   892ac:	47a0      	blx	r4
   892ae:	6178      	str	r0, [r7, #20]
	if(byte_four)
   892b0:	78fb      	ldrb	r3, [r7, #3]
   892b2:	2b00      	cmp	r3, #0
   892b4:	d007      	beq.n	892c6 <send_tc_can_command+0x42>
   892b6:	e002      	b.n	892be <send_tc_can_command+0x3a>
	uint32_t id, ret_val, high;
	
	if(ssm_id == COMS_ID)
		id = SUB0_ID3;
	else
		return -1;
   892b8:	f04f 33ff 	mov.w	r3, #4294967295
   892bc:	e025      	b.n	8930a <send_tc_can_command+0x86>
	
	high = high_command_generator(sender_id, ssm_id, MT_COM, smalltype);
	if(byte_four)
		high |= (uint32_t)byte_four;
   892be:	78fb      	ldrb	r3, [r7, #3]
   892c0:	697a      	ldr	r2, [r7, #20]
   892c2:	4313      	orrs	r3, r2
   892c4:	617b      	str	r3, [r7, #20]

	if (xSemaphoreTake(Can0_Mutex, (TickType_t) 1) == pdTRUE)		// Attempt to acquire CAN1 Mutex, block for 1 tick.
   892c6:	4b14      	ldr	r3, [pc, #80]	; (89318 <send_tc_can_command+0x94>)
   892c8:	681b      	ldr	r3, [r3, #0]
   892ca:	4618      	mov	r0, r3
   892cc:	2100      	movs	r1, #0
   892ce:	2201      	movs	r2, #1
   892d0:	2300      	movs	r3, #0
   892d2:	4c12      	ldr	r4, [pc, #72]	; (8931c <send_tc_can_command+0x98>)
   892d4:	47a0      	blx	r4
   892d6:	4603      	mov	r3, r0
   892d8:	2b01      	cmp	r3, #1
   892da:	d114      	bne.n	89306 <send_tc_can_command+0x82>
	{
		ret_val = send_can_command_h(low, high, id, priority);
   892dc:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   892e0:	6878      	ldr	r0, [r7, #4]
   892e2:	6979      	ldr	r1, [r7, #20]
   892e4:	693a      	ldr	r2, [r7, #16]
   892e6:	4c0e      	ldr	r4, [pc, #56]	; (89320 <send_tc_can_command+0x9c>)
   892e8:	47a0      	blx	r4
   892ea:	60f8      	str	r0, [r7, #12]
		xSemaphoreGive(Can0_Mutex);
   892ec:	4b0a      	ldr	r3, [pc, #40]	; (89318 <send_tc_can_command+0x94>)
   892ee:	681b      	ldr	r3, [r3, #0]
   892f0:	4618      	mov	r0, r3
   892f2:	2100      	movs	r1, #0
   892f4:	2200      	movs	r2, #0
   892f6:	2300      	movs	r3, #0
   892f8:	4c0a      	ldr	r4, [pc, #40]	; (89324 <send_tc_can_command+0xa0>)
   892fa:	47a0      	blx	r4
		delay_us(100);
   892fc:	2064      	movs	r0, #100	; 0x64
   892fe:	4b0a      	ldr	r3, [pc, #40]	; (89328 <send_tc_can_command+0xa4>)
   89300:	4798      	blx	r3
		return (int)ret_val;
   89302:	68fb      	ldr	r3, [r7, #12]
   89304:	e001      	b.n	8930a <send_tc_can_command+0x86>
	}
	
	else
		return -1;												// CAN0 is currently busy, or something has gone wrong.
   89306:	f04f 33ff 	mov.w	r3, #4294967295
}
   8930a:	4618      	mov	r0, r3
   8930c:	371c      	adds	r7, #28
   8930e:	46bd      	mov	sp, r7
   89310:	bd90      	pop	{r4, r7, pc}
   89312:	bf00      	nop
   89314:	000899a9 	.word	0x000899a9
   89318:	2007b524 	.word	0x2007b524
   8931c:	00086dc1 	.word	0x00086dc1
   89320:	000890d1 	.word	0x000890d1
   89324:	00086b01 	.word	0x00086b01
   89328:	0008425d 	.word	0x0008425d

0008932c <send_can_command_from_int>:
/************************************************************************/
/* SEND_CAN_COMMAND_FROM_INT                                            */
/* @NOTE: To be used only from the CAN1 interrupt handler.				*/
/************************************************************************/
int send_can_command_from_int(uint32_t low, uint8_t byte_four, uint8_t sender_id, uint8_t ssm_id, uint8_t smalltype, uint8_t priority)
{
   8932c:	b590      	push	{r4, r7, lr}
   8932e:	b087      	sub	sp, #28
   89330:	af00      	add	r7, sp, #0
   89332:	6078      	str	r0, [r7, #4]
   89334:	70f9      	strb	r1, [r7, #3]
   89336:	70ba      	strb	r2, [r7, #2]
   89338:	707b      	strb	r3, [r7, #1]
	//uint32_t timeout = 8400;		// ~ 100 us timeout.
	uint32_t id, ret_val, high;
	BaseType_t* higher_task_woken;
	higher_task_woken = pdFALSE;
   8933a:	2300      	movs	r3, #0
   8933c:	60fb      	str	r3, [r7, #12]
	
	if(ssm_id == COMS_ID)
   8933e:	787b      	ldrb	r3, [r7, #1]
   89340:	2b00      	cmp	r3, #0
   89342:	d101      	bne.n	89348 <send_can_command_from_int+0x1c>
		id = SUB0_ID0;
   89344:	2314      	movs	r3, #20
   89346:	617b      	str	r3, [r7, #20]
	if(ssm_id == EPS_ID)
   89348:	787b      	ldrb	r3, [r7, #1]
   8934a:	2b01      	cmp	r3, #1
   8934c:	d101      	bne.n	89352 <send_can_command_from_int+0x26>
		id = SUB1_ID0;
   8934e:	231a      	movs	r3, #26
   89350:	617b      	str	r3, [r7, #20]
	if(ssm_id == PAY_ID)
   89352:	787b      	ldrb	r3, [r7, #1]
   89354:	2b02      	cmp	r3, #2
   89356:	d101      	bne.n	8935c <send_can_command_from_int+0x30>
		id = SUB2_ID0;
   89358:	2320      	movs	r3, #32
   8935a:	617b      	str	r3, [r7, #20]
		
	high = high_command_generator(sender_id, ssm_id, MT_COM, smalltype);
   8935c:	78b9      	ldrb	r1, [r7, #2]
   8935e:	787a      	ldrb	r2, [r7, #1]
   89360:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   89364:	4608      	mov	r0, r1
   89366:	4611      	mov	r1, r2
   89368:	2202      	movs	r2, #2
   8936a:	4c17      	ldr	r4, [pc, #92]	; (893c8 <send_can_command_from_int+0x9c>)
   8936c:	47a0      	blx	r4
   8936e:	6138      	str	r0, [r7, #16]
	if(byte_four)
   89370:	78fb      	ldrb	r3, [r7, #3]
   89372:	2b00      	cmp	r3, #0
   89374:	d003      	beq.n	8937e <send_can_command_from_int+0x52>
		high |= (uint32_t)byte_four;
   89376:	78fb      	ldrb	r3, [r7, #3]
   89378:	693a      	ldr	r2, [r7, #16]
   8937a:	4313      	orrs	r3, r2
   8937c:	613b      	str	r3, [r7, #16]

	if (xSemaphoreTakeFromISR(Can0_Mutex, higher_task_woken) == pdTRUE)		// Attempt to acquire CAN0 Mutex, block for 1 tick.
   8937e:	4b13      	ldr	r3, [pc, #76]	; (893cc <send_can_command_from_int+0xa0>)
   89380:	681b      	ldr	r3, [r3, #0]
   89382:	4618      	mov	r0, r3
   89384:	2100      	movs	r1, #0
   89386:	68fa      	ldr	r2, [r7, #12]
   89388:	4b11      	ldr	r3, [pc, #68]	; (893d0 <send_can_command_from_int+0xa4>)
   8938a:	4798      	blx	r3
   8938c:	4603      	mov	r3, r0
   8938e:	2b01      	cmp	r3, #1
   89390:	d114      	bne.n	893bc <send_can_command_from_int+0x90>
	{
		ret_val = send_can_command_h(low, high, id, priority);
   89392:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   89396:	6878      	ldr	r0, [r7, #4]
   89398:	6939      	ldr	r1, [r7, #16]
   8939a:	697a      	ldr	r2, [r7, #20]
   8939c:	4c0d      	ldr	r4, [pc, #52]	; (893d4 <send_can_command_from_int+0xa8>)
   8939e:	47a0      	blx	r4
   893a0:	60b8      	str	r0, [r7, #8]
		xSemaphoreGiveFromISR(Can0_Mutex, higher_task_woken);
   893a2:	4b0a      	ldr	r3, [pc, #40]	; (893cc <send_can_command_from_int+0xa0>)
   893a4:	681b      	ldr	r3, [r3, #0]
   893a6:	4618      	mov	r0, r3
   893a8:	2100      	movs	r1, #0
   893aa:	68fa      	ldr	r2, [r7, #12]
   893ac:	2300      	movs	r3, #0
   893ae:	4c0a      	ldr	r4, [pc, #40]	; (893d8 <send_can_command_from_int+0xac>)
   893b0:	47a0      	blx	r4
		delay_us(100);
   893b2:	2064      	movs	r0, #100	; 0x64
   893b4:	4b09      	ldr	r3, [pc, #36]	; (893dc <send_can_command_from_int+0xb0>)
   893b6:	4798      	blx	r3
		return (int)ret_val;
   893b8:	68bb      	ldr	r3, [r7, #8]
   893ba:	e001      	b.n	893c0 <send_can_command_from_int+0x94>
	}
	
	else
		return -1;												// CAN0 is currently busy, or something has gone wrong.
   893bc:	f04f 33ff 	mov.w	r3, #4294967295
}
   893c0:	4618      	mov	r0, r3
   893c2:	371c      	adds	r7, #28
   893c4:	46bd      	mov	sp, r7
   893c6:	bd90      	pop	{r4, r7, pc}
   893c8:	000899a9 	.word	0x000899a9
   893cc:	2007b524 	.word	0x2007b524
   893d0:	00086fbd 	.word	0x00086fbd
   893d4:	000890d1 	.word	0x000890d1
   893d8:	00086cc5 	.word	0x00086cc5
   893dc:	0008425d 	.word	0x0008425d

000893e0 <send_tc_can_command_from_int>:
/* @NOTE: To be used only for sending TC COMMANDS, directs the outgoing */
/* message to SUB0_ID3 in the COMS SSM.									*/
/* @NOTE: To be used only from the CAN1 interrupt handler.				*/
/************************************************************************/
int send_tc_can_command_from_int(uint32_t low, uint8_t byte_four, uint8_t sender_id, uint8_t ssm_id, uint8_t smalltype, uint8_t priority)
{
   893e0:	b590      	push	{r4, r7, lr}
   893e2:	b087      	sub	sp, #28
   893e4:	af00      	add	r7, sp, #0
   893e6:	6078      	str	r0, [r7, #4]
   893e8:	70f9      	strb	r1, [r7, #3]
   893ea:	70ba      	strb	r2, [r7, #2]
   893ec:	707b      	strb	r3, [r7, #1]
	//uint32_t timeout = 8400;		// ~ 100 us timeout.
	uint32_t id, ret_val, high;
	BaseType_t* higher_task_woken;
	higher_task_woken = pdFALSE;
   893ee:	2300      	movs	r3, #0
   893f0:	613b      	str	r3, [r7, #16]
	
	if(ssm_id == COMS_ID)
   893f2:	787b      	ldrb	r3, [r7, #1]
   893f4:	2b00      	cmp	r3, #0
   893f6:	d10f      	bne.n	89418 <send_tc_can_command_from_int+0x38>
		id = SUB0_ID3;
   893f8:	2317      	movs	r3, #23
   893fa:	60fb      	str	r3, [r7, #12]
	else
		return -1;
	
	high = high_command_generator(sender_id, ssm_id, MT_COM, smalltype);
   893fc:	78b9      	ldrb	r1, [r7, #2]
   893fe:	787a      	ldrb	r2, [r7, #1]
   89400:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
   89404:	4608      	mov	r0, r1
   89406:	4611      	mov	r1, r2
   89408:	2202      	movs	r2, #2
   8940a:	4c19      	ldr	r4, [pc, #100]	; (89470 <send_tc_can_command_from_int+0x90>)
   8940c:	47a0      	blx	r4
   8940e:	6178      	str	r0, [r7, #20]
	if(byte_four)
   89410:	78fb      	ldrb	r3, [r7, #3]
   89412:	2b00      	cmp	r3, #0
   89414:	d007      	beq.n	89426 <send_tc_can_command_from_int+0x46>
   89416:	e002      	b.n	8941e <send_tc_can_command_from_int+0x3e>
	higher_task_woken = pdFALSE;
	
	if(ssm_id == COMS_ID)
		id = SUB0_ID3;
	else
		return -1;
   89418:	f04f 33ff 	mov.w	r3, #4294967295
   8941c:	e024      	b.n	89468 <send_tc_can_command_from_int+0x88>
	
	high = high_command_generator(sender_id, ssm_id, MT_COM, smalltype);
	if(byte_four)
		high |= (uint32_t)byte_four;
   8941e:	78fb      	ldrb	r3, [r7, #3]
   89420:	697a      	ldr	r2, [r7, #20]
   89422:	4313      	orrs	r3, r2
   89424:	617b      	str	r3, [r7, #20]

	if (xSemaphoreTakeFromISR(Can0_Mutex, higher_task_woken) == pdTRUE)		// Attempt to acquire CAN0 Mutex, block for 1 tick.
   89426:	4b13      	ldr	r3, [pc, #76]	; (89474 <send_tc_can_command_from_int+0x94>)
   89428:	681b      	ldr	r3, [r3, #0]
   8942a:	4618      	mov	r0, r3
   8942c:	2100      	movs	r1, #0
   8942e:	693a      	ldr	r2, [r7, #16]
   89430:	4b11      	ldr	r3, [pc, #68]	; (89478 <send_tc_can_command_from_int+0x98>)
   89432:	4798      	blx	r3
   89434:	4603      	mov	r3, r0
   89436:	2b01      	cmp	r3, #1
   89438:	d114      	bne.n	89464 <send_tc_can_command_from_int+0x84>
	{
		ret_val = send_can_command_h(low, high, id, priority);
   8943a:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
   8943e:	6878      	ldr	r0, [r7, #4]
   89440:	6979      	ldr	r1, [r7, #20]
   89442:	68fa      	ldr	r2, [r7, #12]
   89444:	4c0d      	ldr	r4, [pc, #52]	; (8947c <send_tc_can_command_from_int+0x9c>)
   89446:	47a0      	blx	r4
   89448:	60b8      	str	r0, [r7, #8]
		xSemaphoreGiveFromISR(Can0_Mutex, higher_task_woken);
   8944a:	4b0a      	ldr	r3, [pc, #40]	; (89474 <send_tc_can_command_from_int+0x94>)
   8944c:	681b      	ldr	r3, [r3, #0]
   8944e:	4618      	mov	r0, r3
   89450:	2100      	movs	r1, #0
   89452:	693a      	ldr	r2, [r7, #16]
   89454:	2300      	movs	r3, #0
   89456:	4c0a      	ldr	r4, [pc, #40]	; (89480 <send_tc_can_command_from_int+0xa0>)
   89458:	47a0      	blx	r4
		delay_us(100);
   8945a:	2064      	movs	r0, #100	; 0x64
   8945c:	4b09      	ldr	r3, [pc, #36]	; (89484 <send_tc_can_command_from_int+0xa4>)
   8945e:	4798      	blx	r3
		return (int)ret_val;
   89460:	68bb      	ldr	r3, [r7, #8]
   89462:	e001      	b.n	89468 <send_tc_can_command_from_int+0x88>
	}
	
	else
		return -1;												// CAN0 is currently busy, or something has gone wrong.
   89464:	f04f 33ff 	mov.w	r3, #4294967295
}
   89468:	4618      	mov	r0, r3
   8946a:	371c      	adds	r7, #28
   8946c:	46bd      	mov	sp, r7
   8946e:	bd90      	pop	{r4, r7, pc}
   89470:	000899a9 	.word	0x000899a9
   89474:	2007b524 	.word	0x2007b524
   89478:	00086fbd 	.word	0x00086fbd
   8947c:	000890d1 	.word	0x000890d1
   89480:	00086cc5 	.word	0x00086cc5
   89484:	0008425d 	.word	0x0008425d

00089488 <read_can_hk>:
/* the can_hk_fifo queue. 												*/
/* @return: 1 == successful, 0 == failure.								*/
/* @Note: This function will block for a maximum of 2 ticks.			*/
/************************************************************************/
uint32_t read_can_hk(uint32_t* message_high, uint32_t* message_low, uint32_t access_code)
{
   89488:	b590      	push	{r4, r7, lr}
   8948a:	b085      	sub	sp, #20
   8948c:	af00      	add	r7, sp, #0
   8948e:	60f8      	str	r0, [r7, #12]
   89490:	60b9      	str	r1, [r7, #8]
   89492:	607a      	str	r2, [r7, #4]
	// *** Implement an assert here on access_code.
	if (access_code == 1234)
   89494:	687a      	ldr	r2, [r7, #4]
   89496:	f240 43d2 	movw	r3, #1234	; 0x4d2
   8949a:	429a      	cmp	r2, r3
   8949c:	d11d      	bne.n	894da <read_can_hk+0x52>
	{
		if(xQueueReceive(can_hk_fifo, message_low, (TickType_t) 1) == pdTRUE)
   8949e:	4b12      	ldr	r3, [pc, #72]	; (894e8 <read_can_hk+0x60>)
   894a0:	681b      	ldr	r3, [r3, #0]
   894a2:	4618      	mov	r0, r3
   894a4:	68b9      	ldr	r1, [r7, #8]
   894a6:	2201      	movs	r2, #1
   894a8:	2300      	movs	r3, #0
   894aa:	4c10      	ldr	r4, [pc, #64]	; (894ec <read_can_hk+0x64>)
   894ac:	47a0      	blx	r4
   894ae:	4603      	mov	r3, r0
   894b0:	2b01      	cmp	r3, #1
   894b2:	d10f      	bne.n	894d4 <read_can_hk+0x4c>
		{
			if(xQueueReceive(can_hk_fifo, message_high, (TickType_t) 1) == pdTRUE)
   894b4:	4b0c      	ldr	r3, [pc, #48]	; (894e8 <read_can_hk+0x60>)
   894b6:	681b      	ldr	r3, [r3, #0]
   894b8:	4618      	mov	r0, r3
   894ba:	68f9      	ldr	r1, [r7, #12]
   894bc:	2201      	movs	r2, #1
   894be:	2300      	movs	r3, #0
   894c0:	4c0a      	ldr	r4, [pc, #40]	; (894ec <read_can_hk+0x64>)
   894c2:	47a0      	blx	r4
   894c4:	4603      	mov	r3, r0
   894c6:	2b01      	cmp	r3, #1
   894c8:	d101      	bne.n	894ce <read_can_hk+0x46>
			{
				return 1;
   894ca:	2301      	movs	r3, #1
   894cc:	e007      	b.n	894de <read_can_hk+0x56>
			}
			else
			return -1;
   894ce:	f04f 33ff 	mov.w	r3, #4294967295
   894d2:	e004      	b.n	894de <read_can_hk+0x56>
		}
		else
		return -1;
   894d4:	f04f 33ff 	mov.w	r3, #4294967295
   894d8:	e001      	b.n	894de <read_can_hk+0x56>
	}
	return -1;
   894da:	f04f 33ff 	mov.w	r3, #4294967295
}
   894de:	4618      	mov	r0, r3
   894e0:	3714      	adds	r7, #20
   894e2:	46bd      	mov	sp, r7
   894e4:	bd90      	pop	{r4, r7, pc}
   894e6:	bf00      	nop
   894e8:	2007adf4 	.word	0x2007adf4
   894ec:	00086dc1 	.word	0x00086dc1

000894f0 <request_housekeeping>:
/* priority from CAN0 MB6.												*/
/* @return: 1 == complete, 0 == incomplete.								*/
/* @NOTE: 1 != successful (necessarily)									*/
/************************************************************************/
uint32_t request_housekeeping(uint32_t ssm_id)
{
   894f0:	b590      	push	{r4, r7, lr}
   894f2:	b085      	sub	sp, #20
   894f4:	af00      	add	r7, sp, #0
   894f6:	6078      	str	r0, [r7, #4]
	uint32_t high, id;
	//uint32_t timeout = 8400;		// ~ 100 us timeout.
	
	if(ssm_id == COMS_ID)
   894f8:	687b      	ldr	r3, [r7, #4]
   894fa:	2b00      	cmp	r3, #0
   894fc:	d101      	bne.n	89502 <request_housekeeping+0x12>
		id = SUB0_ID5;				// Housekeeping request mailbox in the SSM.
   894fe:	2319      	movs	r3, #25
   89500:	60fb      	str	r3, [r7, #12]
	if(ssm_id == EPS_ID)
   89502:	687b      	ldr	r3, [r7, #4]
   89504:	2b01      	cmp	r3, #1
   89506:	d101      	bne.n	8950c <request_housekeeping+0x1c>
		id = SUB1_ID5;
   89508:	231f      	movs	r3, #31
   8950a:	60fb      	str	r3, [r7, #12]
	if(ssm_id == PAY_ID)
   8950c:	687b      	ldr	r3, [r7, #4]
   8950e:	2b02      	cmp	r3, #2
   89510:	d101      	bne.n	89516 <request_housekeeping+0x26>
		id = SUB2_ID5;
   89512:	2325      	movs	r3, #37	; 0x25
   89514:	60fb      	str	r3, [r7, #12]

	if (xSemaphoreTake(Can0_Mutex, (TickType_t) 1) == pdTRUE)		// Attempt to acquire CAN1 Mutex, block for 1 tick.
   89516:	4b2a      	ldr	r3, [pc, #168]	; (895c0 <request_housekeeping+0xd0>)
   89518:	681b      	ldr	r3, [r3, #0]
   8951a:	4618      	mov	r0, r3
   8951c:	2100      	movs	r1, #0
   8951e:	2201      	movs	r2, #1
   89520:	2300      	movs	r3, #0
   89522:	4c28      	ldr	r4, [pc, #160]	; (895c4 <request_housekeeping+0xd4>)
   89524:	47a0      	blx	r4
   89526:	4603      	mov	r3, r0
   89528:	2b01      	cmp	r3, #1
   8952a:	d142      	bne.n	895b2 <request_housekeeping+0xc2>
	{
		/* Init CAN0 Mailbox 6 to Housekeeping Request Mailbox. */	
		reset_mailbox_conf(&can0_mailbox);
   8952c:	4826      	ldr	r0, [pc, #152]	; (895c8 <request_housekeeping+0xd8>)
   8952e:	4b27      	ldr	r3, [pc, #156]	; (895cc <request_housekeeping+0xdc>)
   89530:	4798      	blx	r3
		can0_mailbox.ul_mb_idx = 6;			//Mailbox Number 6
   89532:	4b25      	ldr	r3, [pc, #148]	; (895c8 <request_housekeeping+0xd8>)
   89534:	2206      	movs	r2, #6
   89536:	601a      	str	r2, [r3, #0]
		can0_mailbox.uc_obj_type = CAN_MB_TX_MODE;
   89538:	4b23      	ldr	r3, [pc, #140]	; (895c8 <request_housekeeping+0xd8>)
   8953a:	2203      	movs	r2, #3
   8953c:	711a      	strb	r2, [r3, #4]
		can0_mailbox.uc_tx_prio = 10;		//Transmission Priority (Can be Changed dynamically)
   8953e:	4b22      	ldr	r3, [pc, #136]	; (895c8 <request_housekeeping+0xd8>)
   89540:	220a      	movs	r2, #10
   89542:	71da      	strb	r2, [r3, #7]
		can0_mailbox.uc_id_ver = 0;
   89544:	4b20      	ldr	r3, [pc, #128]	; (895c8 <request_housekeeping+0xd8>)
   89546:	2200      	movs	r2, #0
   89548:	715a      	strb	r2, [r3, #5]
		can0_mailbox.ul_id_msk = 0;
   8954a:	4b1f      	ldr	r3, [pc, #124]	; (895c8 <request_housekeeping+0xd8>)
   8954c:	2200      	movs	r2, #0
   8954e:	60da      	str	r2, [r3, #12]
		can_mailbox_init(CAN0, &can0_mailbox);
   89550:	481f      	ldr	r0, [pc, #124]	; (895d0 <request_housekeeping+0xe0>)
   89552:	491d      	ldr	r1, [pc, #116]	; (895c8 <request_housekeeping+0xd8>)
   89554:	4b1f      	ldr	r3, [pc, #124]	; (895d4 <request_housekeeping+0xe4>)
   89556:	4798      	blx	r3

		high = high_command_generator(HK_TASK_ID, ssm_id, MT_COM, REQ_HK);
   89558:	687b      	ldr	r3, [r7, #4]
   8955a:	b2db      	uxtb	r3, r3
   8955c:	2004      	movs	r0, #4
   8955e:	4619      	mov	r1, r3
   89560:	2202      	movs	r2, #2
   89562:	2303      	movs	r3, #3
   89564:	4c1c      	ldr	r4, [pc, #112]	; (895d8 <request_housekeeping+0xe8>)
   89566:	47a0      	blx	r4
   89568:	60b8      	str	r0, [r7, #8]

		/* Write transmit information into mailbox. */
		can0_mailbox.ul_id = CAN_MID_MIDvA(id);			// ID of the message being sent,
   8956a:	68fb      	ldr	r3, [r7, #12]
   8956c:	049a      	lsls	r2, r3, #18
   8956e:	4b1b      	ldr	r3, [pc, #108]	; (895dc <request_housekeeping+0xec>)
   89570:	4013      	ands	r3, r2
   89572:	4a15      	ldr	r2, [pc, #84]	; (895c8 <request_housekeeping+0xd8>)
   89574:	6113      	str	r3, [r2, #16]
		can0_mailbox.ul_datal = 0x00;				// shifted over to the standard frame position.
   89576:	4b14      	ldr	r3, [pc, #80]	; (895c8 <request_housekeeping+0xd8>)
   89578:	2200      	movs	r2, #0
   8957a:	619a      	str	r2, [r3, #24]
		can0_mailbox.ul_datah = high;
   8957c:	4b12      	ldr	r3, [pc, #72]	; (895c8 <request_housekeeping+0xd8>)
   8957e:	68ba      	ldr	r2, [r7, #8]
   89580:	61da      	str	r2, [r3, #28]
		can0_mailbox.uc_length = MAX_CAN_FRAME_DATA_LEN;
   89582:	4b11      	ldr	r3, [pc, #68]	; (895c8 <request_housekeeping+0xd8>)
   89584:	2208      	movs	r2, #8
   89586:	719a      	strb	r2, [r3, #6]
		can_mailbox_write(CAN0, &can0_mailbox);
   89588:	4811      	ldr	r0, [pc, #68]	; (895d0 <request_housekeeping+0xe0>)
   8958a:	490f      	ldr	r1, [pc, #60]	; (895c8 <request_housekeeping+0xd8>)
   8958c:	4b14      	ldr	r3, [pc, #80]	; (895e0 <request_housekeeping+0xf0>)
   8958e:	4798      	blx	r3

		/* Send out the information in the mailbox. */
		can_global_send_transfer_cmd(CAN0, CAN_TCR_MB6);		
   89590:	480f      	ldr	r0, [pc, #60]	; (895d0 <request_housekeeping+0xe0>)
   89592:	2140      	movs	r1, #64	; 0x40
   89594:	4b13      	ldr	r3, [pc, #76]	; (895e4 <request_housekeeping+0xf4>)
   89596:	4798      	blx	r3
		xSemaphoreGive(Can0_Mutex);
   89598:	4b09      	ldr	r3, [pc, #36]	; (895c0 <request_housekeeping+0xd0>)
   8959a:	681b      	ldr	r3, [r3, #0]
   8959c:	4618      	mov	r0, r3
   8959e:	2100      	movs	r1, #0
   895a0:	2200      	movs	r2, #0
   895a2:	2300      	movs	r3, #0
   895a4:	4c10      	ldr	r4, [pc, #64]	; (895e8 <request_housekeeping+0xf8>)
   895a6:	47a0      	blx	r4
		delay_us(100);
   895a8:	2064      	movs	r0, #100	; 0x64
   895aa:	4b10      	ldr	r3, [pc, #64]	; (895ec <request_housekeeping+0xfc>)
   895ac:	4798      	blx	r3
		return 1;
   895ae:	2301      	movs	r3, #1
   895b0:	e001      	b.n	895b6 <request_housekeeping+0xc6>
	}
	else
		return -1;										// CAN0 is currently busy, or something has gone wrong.
   895b2:	f04f 33ff 	mov.w	r3, #4294967295
}
   895b6:	4618      	mov	r0, r3
   895b8:	3714      	adds	r7, #20
   895ba:	46bd      	mov	sp, r7
   895bc:	bd90      	pop	{r4, r7, pc}
   895be:	bf00      	nop
   895c0:	2007b524 	.word	0x2007b524
   895c4:	00086dc1 	.word	0x00086dc1
   895c8:	2007b408 	.word	0x2007b408
   895cc:	00089079 	.word	0x00089079
   895d0:	400b4000 	.word	0x400b4000
   895d4:	00085031 	.word	0x00085031
   895d8:	000899a9 	.word	0x000899a9
   895dc:	1ffc0000 	.word	0x1ffc0000
   895e0:	00085215 	.word	0x00085215
   895e4:	00084fa5 	.word	0x00084fa5
   895e8:	00086b01 	.word	0x00086b01
   895ec:	0008425d 	.word	0x0008425d

000895f0 <save_can_object>:
/* the one that enables the functionality you want.						*/
/* @Purpose: The function takes all the attributes of the original		*/
/* object and stores them in the temp object.							*/
/************************************************************************/
void save_can_object(can_mb_conf_t *original, can_temp_t *temp)
{
   895f0:	b480      	push	{r7}
   895f2:	b083      	sub	sp, #12
   895f4:	af00      	add	r7, sp, #0
   895f6:	6078      	str	r0, [r7, #4]
   895f8:	6039      	str	r1, [r7, #0]
	/*This function takes in a mailbox object as the original pointer*/
	
	temp->ul_mb_idx		= original->ul_mb_idx;
   895fa:	687b      	ldr	r3, [r7, #4]
   895fc:	681a      	ldr	r2, [r3, #0]
   895fe:	683b      	ldr	r3, [r7, #0]
   89600:	601a      	str	r2, [r3, #0]
	temp->uc_obj_type	= original->uc_obj_type;
   89602:	687b      	ldr	r3, [r7, #4]
   89604:	791a      	ldrb	r2, [r3, #4]
   89606:	683b      	ldr	r3, [r7, #0]
   89608:	711a      	strb	r2, [r3, #4]
	temp->uc_id_ver		= original->uc_id_ver;
   8960a:	687b      	ldr	r3, [r7, #4]
   8960c:	795a      	ldrb	r2, [r3, #5]
   8960e:	683b      	ldr	r3, [r7, #0]
   89610:	715a      	strb	r2, [r3, #5]
	temp->uc_length		= original->uc_length;
   89612:	687b      	ldr	r3, [r7, #4]
   89614:	799a      	ldrb	r2, [r3, #6]
   89616:	683b      	ldr	r3, [r7, #0]
   89618:	719a      	strb	r2, [r3, #6]
	temp->uc_tx_prio	= original->uc_tx_prio;
   8961a:	687b      	ldr	r3, [r7, #4]
   8961c:	79da      	ldrb	r2, [r3, #7]
   8961e:	683b      	ldr	r3, [r7, #0]
   89620:	71da      	strb	r2, [r3, #7]
	temp->ul_status		= original->ul_status;
   89622:	687b      	ldr	r3, [r7, #4]
   89624:	689a      	ldr	r2, [r3, #8]
   89626:	683b      	ldr	r3, [r7, #0]
   89628:	609a      	str	r2, [r3, #8]
	temp->ul_id_msk		= original->ul_id_msk;
   8962a:	687b      	ldr	r3, [r7, #4]
   8962c:	68da      	ldr	r2, [r3, #12]
   8962e:	683b      	ldr	r3, [r7, #0]
   89630:	60da      	str	r2, [r3, #12]
	temp->ul_id			= original->ul_id;
   89632:	687b      	ldr	r3, [r7, #4]
   89634:	691a      	ldr	r2, [r3, #16]
   89636:	683b      	ldr	r3, [r7, #0]
   89638:	611a      	str	r2, [r3, #16]
	temp->ul_fid		= original->ul_fid;
   8963a:	687b      	ldr	r3, [r7, #4]
   8963c:	695a      	ldr	r2, [r3, #20]
   8963e:	683b      	ldr	r3, [r7, #0]
   89640:	615a      	str	r2, [r3, #20]
	temp->ul_datal		= original->ul_datal;
   89642:	687b      	ldr	r3, [r7, #4]
   89644:	699a      	ldr	r2, [r3, #24]
   89646:	683b      	ldr	r3, [r7, #0]
   89648:	619a      	str	r2, [r3, #24]
	temp->ul_datah		= original->ul_datah;
   8964a:	687b      	ldr	r3, [r7, #4]
   8964c:	69da      	ldr	r2, [r3, #28]
   8964e:	683b      	ldr	r3, [r7, #0]
   89650:	61da      	str	r2, [r3, #28]
	
	return;
   89652:	bf00      	nop
}
   89654:	370c      	adds	r7, #12
   89656:	46bd      	mov	sp, r7
   89658:	f85d 7b04 	ldr.w	r7, [sp], #4
   8965c:	4770      	bx	lr
   8965e:	bf00      	nop

00089660 <restore_can_object>:
/* @param: *temp: A pointer to what was the temporary CAN object.		*/
/* @Purpose: This function replaces all the attributes of the "original"*/
/* object with all the attributes in the "temp" object.					*/
/************************************************************************/
void restore_can_object(can_mb_conf_t *original, can_temp_t *temp)
{
   89660:	b480      	push	{r7}
   89662:	b083      	sub	sp, #12
   89664:	af00      	add	r7, sp, #0
   89666:	6078      	str	r0, [r7, #4]
   89668:	6039      	str	r1, [r7, #0]
	/*This function takes in a mailbox object as the original pointer*/	
	
	original->ul_mb_idx		= temp->ul_mb_idx; 
   8966a:	683b      	ldr	r3, [r7, #0]
   8966c:	681a      	ldr	r2, [r3, #0]
   8966e:	687b      	ldr	r3, [r7, #4]
   89670:	601a      	str	r2, [r3, #0]
	original->uc_obj_type	= temp->uc_obj_type;
   89672:	683b      	ldr	r3, [r7, #0]
   89674:	791a      	ldrb	r2, [r3, #4]
   89676:	687b      	ldr	r3, [r7, #4]
   89678:	711a      	strb	r2, [r3, #4]
	original->uc_id_ver		= temp->uc_id_ver;
   8967a:	683b      	ldr	r3, [r7, #0]
   8967c:	795a      	ldrb	r2, [r3, #5]
   8967e:	687b      	ldr	r3, [r7, #4]
   89680:	715a      	strb	r2, [r3, #5]
	original->uc_length		= temp->uc_length;
   89682:	683b      	ldr	r3, [r7, #0]
   89684:	799a      	ldrb	r2, [r3, #6]
   89686:	687b      	ldr	r3, [r7, #4]
   89688:	719a      	strb	r2, [r3, #6]
	original->uc_tx_prio	= temp->uc_tx_prio;
   8968a:	683b      	ldr	r3, [r7, #0]
   8968c:	79da      	ldrb	r2, [r3, #7]
   8968e:	687b      	ldr	r3, [r7, #4]
   89690:	71da      	strb	r2, [r3, #7]
	original->ul_status		= temp->ul_status;
   89692:	683b      	ldr	r3, [r7, #0]
   89694:	689a      	ldr	r2, [r3, #8]
   89696:	687b      	ldr	r3, [r7, #4]
   89698:	609a      	str	r2, [r3, #8]
	original->ul_id_msk		= temp->ul_id_msk;
   8969a:	683b      	ldr	r3, [r7, #0]
   8969c:	68da      	ldr	r2, [r3, #12]
   8969e:	687b      	ldr	r3, [r7, #4]
   896a0:	60da      	str	r2, [r3, #12]
	original->ul_id			= temp->ul_id;
   896a2:	683b      	ldr	r3, [r7, #0]
   896a4:	691a      	ldr	r2, [r3, #16]
   896a6:	687b      	ldr	r3, [r7, #4]
   896a8:	611a      	str	r2, [r3, #16]
	original->ul_fid		= temp->ul_fid;
   896aa:	683b      	ldr	r3, [r7, #0]
   896ac:	695a      	ldr	r2, [r3, #20]
   896ae:	687b      	ldr	r3, [r7, #4]
   896b0:	615a      	str	r2, [r3, #20]
	original->ul_datal		= temp->ul_datal;
   896b2:	683b      	ldr	r3, [r7, #0]
   896b4:	699a      	ldr	r2, [r3, #24]
   896b6:	687b      	ldr	r3, [r7, #4]
   896b8:	619a      	str	r2, [r3, #24]
	original->ul_datah		= temp->ul_datah;
   896ba:	683b      	ldr	r3, [r7, #0]
   896bc:	69da      	ldr	r2, [r3, #28]
   896be:	687b      	ldr	r3, [r7, #4]
   896c0:	61da      	str	r2, [r3, #28]
	
	return;
   896c2:	bf00      	nop
}
   896c4:	370c      	adds	r7, #12
   896c6:	46bd      	mov	sp, r7
   896c8:	f85d 7b04 	ldr.w	r7, [sp], #4
   896cc:	4770      	bx	lr
   896ce:	bf00      	nop

000896d0 <can_initialize>:
/* CAN_INITIALIZE 			                                            */
/* @Purpose: Initializes and enables CAN0 & CAN1 controllers and clocks.*/
/* CAN0/CAN1 mailboxes are reset and interrupts are disabled.			*/
/************************************************************************/
void can_initialize(void)
{
   896d0:	b580      	push	{r7, lr}
   896d2:	b082      	sub	sp, #8
   896d4:	af00      	add	r7, sp, #0
	uint32_t ul_sysclk;
	uint32_t x = 1;
   896d6:	2301      	movs	r3, #1
   896d8:	607b      	str	r3, [r7, #4]

	/* Enable CAN0 & CAN1 clock. */
	pmc_enable_periph_clk(ID_CAN0);
   896da:	202b      	movs	r0, #43	; 0x2b
   896dc:	4b19      	ldr	r3, [pc, #100]	; (89744 <can_initialize+0x74>)
   896de:	4798      	blx	r3
	pmc_enable_periph_clk(ID_CAN1);
   896e0:	202c      	movs	r0, #44	; 0x2c
   896e2:	4b18      	ldr	r3, [pc, #96]	; (89744 <can_initialize+0x74>)
   896e4:	4798      	blx	r3

	ul_sysclk = sysclk_get_cpu_hz();
   896e6:	4b18      	ldr	r3, [pc, #96]	; (89748 <can_initialize+0x78>)
   896e8:	4798      	blx	r3
   896ea:	6038      	str	r0, [r7, #0]
	if (can_init(CAN0, ul_sysclk, CAN_BPS_250K) &&
   896ec:	4817      	ldr	r0, [pc, #92]	; (8974c <can_initialize+0x7c>)
   896ee:	6839      	ldr	r1, [r7, #0]
   896f0:	22fa      	movs	r2, #250	; 0xfa
   896f2:	4b17      	ldr	r3, [pc, #92]	; (89750 <can_initialize+0x80>)
   896f4:	4798      	blx	r3
   896f6:	4603      	mov	r3, r0
   896f8:	2b00      	cmp	r3, #0
   896fa:	d01e      	beq.n	8973a <can_initialize+0x6a>
			can_init(CAN1, ul_sysclk, CAN_BPS_250K)) 
   896fc:	4815      	ldr	r0, [pc, #84]	; (89754 <can_initialize+0x84>)
   896fe:	6839      	ldr	r1, [r7, #0]
   89700:	22fa      	movs	r2, #250	; 0xfa
   89702:	4b13      	ldr	r3, [pc, #76]	; (89750 <can_initialize+0x80>)
   89704:	4798      	blx	r3
   89706:	4603      	mov	r3, r0
	/* Enable CAN0 & CAN1 clock. */
	pmc_enable_periph_clk(ID_CAN0);
	pmc_enable_periph_clk(ID_CAN1);

	ul_sysclk = sysclk_get_cpu_hz();
	if (can_init(CAN0, ul_sysclk, CAN_BPS_250K) &&
   89708:	2b00      	cmp	r3, #0
   8970a:	d016      	beq.n	8973a <can_initialize+0x6a>
			can_init(CAN1, ul_sysclk, CAN_BPS_250K)) 
	{
		/* Disable all CAN0 & CAN1 interrupts. */
		can_disable_interrupt(CAN0, CAN_DISABLE_ALL_INTERRUPT_MASK);
   8970c:	480f      	ldr	r0, [pc, #60]	; (8974c <can_initialize+0x7c>)
   8970e:	f04f 31ff 	mov.w	r1, #4294967295
   89712:	4b11      	ldr	r3, [pc, #68]	; (89758 <can_initialize+0x88>)
   89714:	4798      	blx	r3
		can_disable_interrupt(CAN1, CAN_DISABLE_ALL_INTERRUPT_MASK);
   89716:	480f      	ldr	r0, [pc, #60]	; (89754 <can_initialize+0x84>)
   89718:	f04f 31ff 	mov.w	r1, #4294967295
   8971c:	4b0e      	ldr	r3, [pc, #56]	; (89758 <can_initialize+0x88>)
   8971e:	4798      	blx	r3

		NVIC_EnableIRQ(CAN1_IRQn);
   89720:	202c      	movs	r0, #44	; 0x2c
   89722:	4b0e      	ldr	r3, [pc, #56]	; (8975c <can_initialize+0x8c>)
   89724:	4798      	blx	r3
		
		can_reset_all_mailbox(CAN0);
   89726:	4809      	ldr	r0, [pc, #36]	; (8974c <can_initialize+0x7c>)
   89728:	4b0d      	ldr	r3, [pc, #52]	; (89760 <can_initialize+0x90>)
   8972a:	4798      	blx	r3
		can_reset_all_mailbox(CAN1);
   8972c:	4809      	ldr	r0, [pc, #36]	; (89754 <can_initialize+0x84>)
   8972e:	4b0c      	ldr	r3, [pc, #48]	; (89760 <can_initialize+0x90>)
   89730:	4798      	blx	r3
		
		/* Initialize the CAN0 & CAN1 mailboxes */
		x = can_init_mailboxes(x); // Prevent Random PC jumps to this point.
   89732:	6878      	ldr	r0, [r7, #4]
   89734:	4b0b      	ldr	r3, [pc, #44]	; (89764 <can_initialize+0x94>)
   89736:	4798      	blx	r3
   89738:	6078      	str	r0, [r7, #4]
		//configASSERT(x);
				
		/* MAKE SURE TO SEND LOW 4 BYTES FIRST, AND RECEIVE LOW 4 BYTES FIRST. */
	}
	return;
   8973a:	bf00      	nop
}
   8973c:	3708      	adds	r7, #8
   8973e:	46bd      	mov	sp, r7
   89740:	bd80      	pop	{r7, pc}
   89742:	bf00      	nop
   89744:	00085b29 	.word	0x00085b29
   89748:	000888b1 	.word	0x000888b1
   8974c:	400b4000 	.word	0x400b4000
   89750:	00084e8d 	.word	0x00084e8d
   89754:	400b8000 	.word	0x400b8000
   89758:	00084f71 	.word	0x00084f71
   8975c:	000887f1 	.word	0x000887f1
   89760:	000852cd 	.word	0x000852cd
   89764:	00089769 	.word	0x00089769

00089768 <can_init_mailboxes>:
/* @param: x: simply meant to be to confirm that this function was 		*/
/* called naturally.													*/
/* @Purpose: This function initializes the CAN mailboxes for use.		*/
/************************************************************************/
uint32_t can_init_mailboxes(uint32_t x)
{
   89768:	b580      	push	{r7, lr}
   8976a:	b082      	sub	sp, #8
   8976c:	af00      	add	r7, sp, #0
   8976e:	6078      	str	r0, [r7, #4]
	//configASSERT(x);	//Check if this function was called naturally.

	/* Init CAN0 Mailbox 7 to Transmit Mailbox. */
	/* CAN0 MB7 == COMMAND/MSG MB				*/	
	reset_mailbox_conf(&can0_mailbox);
   89770:	4886      	ldr	r0, [pc, #536]	; (8998c <can_init_mailboxes+0x224>)
   89772:	4b87      	ldr	r3, [pc, #540]	; (89990 <can_init_mailboxes+0x228>)
   89774:	4798      	blx	r3
	can0_mailbox.ul_mb_idx = 7;			//Mailbox Number 7
   89776:	4b85      	ldr	r3, [pc, #532]	; (8998c <can_init_mailboxes+0x224>)
   89778:	2207      	movs	r2, #7
   8977a:	601a      	str	r2, [r3, #0]
	can0_mailbox.uc_obj_type = CAN_MB_TX_MODE;
   8977c:	4b83      	ldr	r3, [pc, #524]	; (8998c <can_init_mailboxes+0x224>)
   8977e:	2203      	movs	r2, #3
   89780:	711a      	strb	r2, [r3, #4]
	can0_mailbox.uc_tx_prio = 10;		//Transmission Priority (Can be Changed dynamically)
   89782:	4b82      	ldr	r3, [pc, #520]	; (8998c <can_init_mailboxes+0x224>)
   89784:	220a      	movs	r2, #10
   89786:	71da      	strb	r2, [r3, #7]
	can0_mailbox.uc_id_ver = 0;
   89788:	4b80      	ldr	r3, [pc, #512]	; (8998c <can_init_mailboxes+0x224>)
   8978a:	2200      	movs	r2, #0
   8978c:	715a      	strb	r2, [r3, #5]
	can0_mailbox.ul_id_msk = 0;
   8978e:	4b7f      	ldr	r3, [pc, #508]	; (8998c <can_init_mailboxes+0x224>)
   89790:	2200      	movs	r2, #0
   89792:	60da      	str	r2, [r3, #12]
	can_mailbox_init(CAN0, &can0_mailbox);
   89794:	487f      	ldr	r0, [pc, #508]	; (89994 <can_init_mailboxes+0x22c>)
   89796:	497d      	ldr	r1, [pc, #500]	; (8998c <can_init_mailboxes+0x224>)
   89798:	4b7f      	ldr	r3, [pc, #508]	; (89998 <can_init_mailboxes+0x230>)
   8979a:	4798      	blx	r3
	
	/* Init CAN1 Mailbox 0 to Data Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   8979c:	487f      	ldr	r0, [pc, #508]	; (8999c <can_init_mailboxes+0x234>)
   8979e:	4b7c      	ldr	r3, [pc, #496]	; (89990 <can_init_mailboxes+0x228>)
   897a0:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 0;				// Mailbox 0
   897a2:	4b7e      	ldr	r3, [pc, #504]	; (8999c <can_init_mailboxes+0x234>)
   897a4:	2200      	movs	r2, #0
   897a6:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   897a8:	4b7c      	ldr	r3, [pc, #496]	; (8999c <can_init_mailboxes+0x234>)
   897aa:	2201      	movs	r2, #1
   897ac:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   897ae:	4b7b      	ldr	r3, [pc, #492]	; (8999c <can_init_mailboxes+0x234>)
   897b0:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   897b4:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB0);					  // The ID of CAN1 MB0 is currently CAN1_MB0 (standard).
   897b6:	4b79      	ldr	r3, [pc, #484]	; (8999c <can_init_mailboxes+0x234>)
   897b8:	f44f 1220 	mov.w	r2, #2621440	; 0x280000
   897bc:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   897be:	4878      	ldr	r0, [pc, #480]	; (899a0 <can_init_mailboxes+0x238>)
   897c0:	4976      	ldr	r1, [pc, #472]	; (8999c <can_init_mailboxes+0x234>)
   897c2:	4b75      	ldr	r3, [pc, #468]	; (89998 <can_init_mailboxes+0x230>)
   897c4:	4798      	blx	r3
	
	/* Init CAN1 Mailbox 1 to Data Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   897c6:	4875      	ldr	r0, [pc, #468]	; (8999c <can_init_mailboxes+0x234>)
   897c8:	4b71      	ldr	r3, [pc, #452]	; (89990 <can_init_mailboxes+0x228>)
   897ca:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 1;				// Mailbox 1
   897cc:	4b73      	ldr	r3, [pc, #460]	; (8999c <can_init_mailboxes+0x234>)
   897ce:	2201      	movs	r2, #1
   897d0:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   897d2:	4b72      	ldr	r3, [pc, #456]	; (8999c <can_init_mailboxes+0x234>)
   897d4:	2201      	movs	r2, #1
   897d6:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   897d8:	4b70      	ldr	r3, [pc, #448]	; (8999c <can_init_mailboxes+0x234>)
   897da:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   897de:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB1);					  // The ID of CAN1 MB0 is currently CAN1_MB0 (standard).
   897e0:	4b6e      	ldr	r3, [pc, #440]	; (8999c <can_init_mailboxes+0x234>)
   897e2:	f44f 1220 	mov.w	r2, #2621440	; 0x280000
   897e6:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   897e8:	486d      	ldr	r0, [pc, #436]	; (899a0 <can_init_mailboxes+0x238>)
   897ea:	496c      	ldr	r1, [pc, #432]	; (8999c <can_init_mailboxes+0x234>)
   897ec:	4b6a      	ldr	r3, [pc, #424]	; (89998 <can_init_mailboxes+0x230>)
   897ee:	4798      	blx	r3
	
	/* Init CAN1 Mailbox 2 to Data Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   897f0:	486a      	ldr	r0, [pc, #424]	; (8999c <can_init_mailboxes+0x234>)
   897f2:	4b67      	ldr	r3, [pc, #412]	; (89990 <can_init_mailboxes+0x228>)
   897f4:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 2;				// Mailbox 2
   897f6:	4b69      	ldr	r3, [pc, #420]	; (8999c <can_init_mailboxes+0x234>)
   897f8:	2202      	movs	r2, #2
   897fa:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   897fc:	4b67      	ldr	r3, [pc, #412]	; (8999c <can_init_mailboxes+0x234>)
   897fe:	2201      	movs	r2, #1
   89800:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   89802:	4b66      	ldr	r3, [pc, #408]	; (8999c <can_init_mailboxes+0x234>)
   89804:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   89808:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB2);					  // The ID of CAN1 MB0 is currently CAN1_MB0 (standard).
   8980a:	4b64      	ldr	r3, [pc, #400]	; (8999c <can_init_mailboxes+0x234>)
   8980c:	f44f 1230 	mov.w	r2, #2883584	; 0x2c0000
   89810:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   89812:	4863      	ldr	r0, [pc, #396]	; (899a0 <can_init_mailboxes+0x238>)
   89814:	4961      	ldr	r1, [pc, #388]	; (8999c <can_init_mailboxes+0x234>)
   89816:	4b60      	ldr	r3, [pc, #384]	; (89998 <can_init_mailboxes+0x230>)
   89818:	4798      	blx	r3

	/* Init CAN1 Mailbox 3 to Data Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   8981a:	4860      	ldr	r0, [pc, #384]	; (8999c <can_init_mailboxes+0x234>)
   8981c:	4b5c      	ldr	r3, [pc, #368]	; (89990 <can_init_mailboxes+0x228>)
   8981e:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 3;				// Mailbox 3
   89820:	4b5e      	ldr	r3, [pc, #376]	; (8999c <can_init_mailboxes+0x234>)
   89822:	2203      	movs	r2, #3
   89824:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   89826:	4b5d      	ldr	r3, [pc, #372]	; (8999c <can_init_mailboxes+0x234>)
   89828:	2201      	movs	r2, #1
   8982a:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   8982c:	4b5b      	ldr	r3, [pc, #364]	; (8999c <can_init_mailboxes+0x234>)
   8982e:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   89832:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB3);					  // The ID of CAN1 MB0 is currently CAN1_MB0 (standard).
   89834:	4b59      	ldr	r3, [pc, #356]	; (8999c <can_init_mailboxes+0x234>)
   89836:	f44f 1230 	mov.w	r2, #2883584	; 0x2c0000
   8983a:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   8983c:	4858      	ldr	r0, [pc, #352]	; (899a0 <can_init_mailboxes+0x238>)
   8983e:	4957      	ldr	r1, [pc, #348]	; (8999c <can_init_mailboxes+0x234>)
   89840:	4b55      	ldr	r3, [pc, #340]	; (89998 <can_init_mailboxes+0x230>)
   89842:	4798      	blx	r3
	
	/* Init CAN1 Mailbox 5 to Message Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   89844:	4855      	ldr	r0, [pc, #340]	; (8999c <can_init_mailboxes+0x234>)
   89846:	4b52      	ldr	r3, [pc, #328]	; (89990 <can_init_mailboxes+0x228>)
   89848:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 5;				// Mailbox 5
   8984a:	4b54      	ldr	r3, [pc, #336]	; (8999c <can_init_mailboxes+0x234>)
   8984c:	2205      	movs	r2, #5
   8984e:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   89850:	4b52      	ldr	r3, [pc, #328]	; (8999c <can_init_mailboxes+0x234>)
   89852:	2201      	movs	r2, #1
   89854:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   89856:	4b51      	ldr	r3, [pc, #324]	; (8999c <can_init_mailboxes+0x234>)
   89858:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   8985c:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB5);					  // The ID of CAN1 MB0 is currently CAN1_MB0 (standard).
   8985e:	4b4f      	ldr	r3, [pc, #316]	; (8999c <can_init_mailboxes+0x234>)
   89860:	f44f 1260 	mov.w	r2, #3670016	; 0x380000
   89864:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   89866:	484e      	ldr	r0, [pc, #312]	; (899a0 <can_init_mailboxes+0x238>)
   89868:	494c      	ldr	r1, [pc, #304]	; (8999c <can_init_mailboxes+0x234>)
   8986a:	4b4b      	ldr	r3, [pc, #300]	; (89998 <can_init_mailboxes+0x230>)
   8986c:	4798      	blx	r3
	
	/* Init CAN1 Mailbox 4 to HK Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   8986e:	484b      	ldr	r0, [pc, #300]	; (8999c <can_init_mailboxes+0x234>)
   89870:	4b47      	ldr	r3, [pc, #284]	; (89990 <can_init_mailboxes+0x228>)
   89872:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 4;				// Mailbox 6
   89874:	4b49      	ldr	r3, [pc, #292]	; (8999c <can_init_mailboxes+0x234>)
   89876:	2204      	movs	r2, #4
   89878:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   8987a:	4b48      	ldr	r3, [pc, #288]	; (8999c <can_init_mailboxes+0x234>)
   8987c:	2201      	movs	r2, #1
   8987e:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   89880:	4b46      	ldr	r3, [pc, #280]	; (8999c <can_init_mailboxes+0x234>)
   89882:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   89886:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB4);					  // The ID of CAN1 MB6 is currently CAN1_MB6 (standard).
   89888:	4b44      	ldr	r3, [pc, #272]	; (8999c <can_init_mailboxes+0x234>)
   8988a:	f44f 1230 	mov.w	r2, #2883584	; 0x2c0000
   8988e:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   89890:	4843      	ldr	r0, [pc, #268]	; (899a0 <can_init_mailboxes+0x238>)
   89892:	4942      	ldr	r1, [pc, #264]	; (8999c <can_init_mailboxes+0x234>)
   89894:	4b40      	ldr	r3, [pc, #256]	; (89998 <can_init_mailboxes+0x230>)
   89896:	4798      	blx	r3
	
	/* Init CAN1 Mailbox 5 to HK Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   89898:	4840      	ldr	r0, [pc, #256]	; (8999c <can_init_mailboxes+0x234>)
   8989a:	4b3d      	ldr	r3, [pc, #244]	; (89990 <can_init_mailboxes+0x228>)
   8989c:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 5;				// Mailbox 5
   8989e:	4b3f      	ldr	r3, [pc, #252]	; (8999c <can_init_mailboxes+0x234>)
   898a0:	2205      	movs	r2, #5
   898a2:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   898a4:	4b3d      	ldr	r3, [pc, #244]	; (8999c <can_init_mailboxes+0x234>)
   898a6:	2201      	movs	r2, #1
   898a8:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   898aa:	4b3c      	ldr	r3, [pc, #240]	; (8999c <can_init_mailboxes+0x234>)
   898ac:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   898b0:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB5);					  // The ID of CAN1 MB6 is currently CAN1_MB6 (standard).
   898b2:	4b3a      	ldr	r3, [pc, #232]	; (8999c <can_init_mailboxes+0x234>)
   898b4:	f44f 1260 	mov.w	r2, #3670016	; 0x380000
   898b8:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   898ba:	4839      	ldr	r0, [pc, #228]	; (899a0 <can_init_mailboxes+0x238>)
   898bc:	4937      	ldr	r1, [pc, #220]	; (8999c <can_init_mailboxes+0x234>)
   898be:	4b36      	ldr	r3, [pc, #216]	; (89998 <can_init_mailboxes+0x230>)
   898c0:	4798      	blx	r3
	
	/* Init CAN1 Mailbox 6 to HK Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   898c2:	4836      	ldr	r0, [pc, #216]	; (8999c <can_init_mailboxes+0x234>)
   898c4:	4b32      	ldr	r3, [pc, #200]	; (89990 <can_init_mailboxes+0x228>)
   898c6:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 6;				// Mailbox 6
   898c8:	4b34      	ldr	r3, [pc, #208]	; (8999c <can_init_mailboxes+0x234>)
   898ca:	2206      	movs	r2, #6
   898cc:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   898ce:	4b33      	ldr	r3, [pc, #204]	; (8999c <can_init_mailboxes+0x234>)
   898d0:	2201      	movs	r2, #1
   898d2:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   898d4:	4b31      	ldr	r3, [pc, #196]	; (8999c <can_init_mailboxes+0x234>)
   898d6:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   898da:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB6);					  // The ID of CAN1 MB6 is currently CAN1_MB6 (standard).
   898dc:	4b2f      	ldr	r3, [pc, #188]	; (8999c <can_init_mailboxes+0x234>)
   898de:	f44f 1260 	mov.w	r2, #3670016	; 0x380000
   898e2:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   898e4:	482e      	ldr	r0, [pc, #184]	; (899a0 <can_init_mailboxes+0x238>)
   898e6:	492d      	ldr	r1, [pc, #180]	; (8999c <can_init_mailboxes+0x234>)
   898e8:	4b2b      	ldr	r3, [pc, #172]	; (89998 <can_init_mailboxes+0x230>)
   898ea:	4798      	blx	r3
		
	/* Init CAN1 Mailbox 7 to Command Reception Mailbox. */
	reset_mailbox_conf(&can1_mailbox);
   898ec:	482b      	ldr	r0, [pc, #172]	; (8999c <can_init_mailboxes+0x234>)
   898ee:	4b28      	ldr	r3, [pc, #160]	; (89990 <can_init_mailboxes+0x228>)
   898f0:	4798      	blx	r3
	can1_mailbox.ul_mb_idx = 7;				// Mailbox 7
   898f2:	4b2a      	ldr	r3, [pc, #168]	; (8999c <can_init_mailboxes+0x234>)
   898f4:	2207      	movs	r2, #7
   898f6:	601a      	str	r2, [r3, #0]
	can1_mailbox.uc_obj_type = CAN_MB_RX_MODE;
   898f8:	4b28      	ldr	r3, [pc, #160]	; (8999c <can_init_mailboxes+0x234>)
   898fa:	2201      	movs	r2, #1
   898fc:	711a      	strb	r2, [r3, #4]
	can1_mailbox.ul_id_msk = CAN_MID_MIDvA_Msk | CAN_MID_MIDvB_Msk;	  // Compare the full 11 bits of the ID in both standard and extended.
   898fe:	4b27      	ldr	r3, [pc, #156]	; (8999c <can_init_mailboxes+0x234>)
   89900:	f06f 4260 	mvn.w	r2, #3758096384	; 0xe0000000
   89904:	60da      	str	r2, [r3, #12]
	can1_mailbox.ul_id = CAN_MID_MIDvA(CAN1_MB7);					  // The ID of CAN1 MB7 is currently CAN1_MB7 (standard).
   89906:	4b25      	ldr	r3, [pc, #148]	; (8999c <can_init_mailboxes+0x234>)
   89908:	f44f 0288 	mov.w	r2, #4456448	; 0x440000
   8990c:	611a      	str	r2, [r3, #16]
	can_mailbox_init(CAN1, &can1_mailbox);
   8990e:	4824      	ldr	r0, [pc, #144]	; (899a0 <can_init_mailboxes+0x238>)
   89910:	4922      	ldr	r1, [pc, #136]	; (8999c <can_init_mailboxes+0x234>)
   89912:	4b21      	ldr	r3, [pc, #132]	; (89998 <can_init_mailboxes+0x230>)
   89914:	4798      	blx	r3
	
	/* Init CAN0 Mailbox 6 to Housekeeping Request Mailbox. */	
	reset_mailbox_conf(&can0_mailbox);
   89916:	481d      	ldr	r0, [pc, #116]	; (8998c <can_init_mailboxes+0x224>)
   89918:	4b1d      	ldr	r3, [pc, #116]	; (89990 <can_init_mailboxes+0x228>)
   8991a:	4798      	blx	r3
	can0_mailbox.ul_mb_idx = 6;			//Mailbox Number 6
   8991c:	4b1b      	ldr	r3, [pc, #108]	; (8998c <can_init_mailboxes+0x224>)
   8991e:	2206      	movs	r2, #6
   89920:	601a      	str	r2, [r3, #0]
	can0_mailbox.uc_obj_type = CAN_MB_TX_MODE;
   89922:	4b1a      	ldr	r3, [pc, #104]	; (8998c <can_init_mailboxes+0x224>)
   89924:	2203      	movs	r2, #3
   89926:	711a      	strb	r2, [r3, #4]
	can0_mailbox.uc_tx_prio = HK_REQUEST_PRIO;		//Transmission Priority (Can be Changed dynamically)
   89928:	4b18      	ldr	r3, [pc, #96]	; (8998c <can_init_mailboxes+0x224>)
   8992a:	2214      	movs	r2, #20
   8992c:	71da      	strb	r2, [r3, #7]
	can0_mailbox.uc_id_ver = 0;
   8992e:	4b17      	ldr	r3, [pc, #92]	; (8998c <can_init_mailboxes+0x224>)
   89930:	2200      	movs	r2, #0
   89932:	715a      	strb	r2, [r3, #5]
	can0_mailbox.ul_id_msk = 0;
   89934:	4b15      	ldr	r3, [pc, #84]	; (8998c <can_init_mailboxes+0x224>)
   89936:	2200      	movs	r2, #0
   89938:	60da      	str	r2, [r3, #12]
	can_mailbox_init(CAN0, &can0_mailbox);
   8993a:	4816      	ldr	r0, [pc, #88]	; (89994 <can_init_mailboxes+0x22c>)
   8993c:	4913      	ldr	r1, [pc, #76]	; (8998c <can_init_mailboxes+0x224>)
   8993e:	4b16      	ldr	r3, [pc, #88]	; (89998 <can_init_mailboxes+0x230>)
   89940:	4798      	blx	r3

	can_enable_interrupt(CAN1, CAN_IER_MB0);
   89942:	4817      	ldr	r0, [pc, #92]	; (899a0 <can_init_mailboxes+0x238>)
   89944:	2101      	movs	r1, #1
   89946:	4b17      	ldr	r3, [pc, #92]	; (899a4 <can_init_mailboxes+0x23c>)
   89948:	4798      	blx	r3
	can_enable_interrupt(CAN1, CAN_IER_MB1);
   8994a:	4815      	ldr	r0, [pc, #84]	; (899a0 <can_init_mailboxes+0x238>)
   8994c:	2102      	movs	r1, #2
   8994e:	4b15      	ldr	r3, [pc, #84]	; (899a4 <can_init_mailboxes+0x23c>)
   89950:	4798      	blx	r3
	can_enable_interrupt(CAN1, CAN_IER_MB2);
   89952:	4813      	ldr	r0, [pc, #76]	; (899a0 <can_init_mailboxes+0x238>)
   89954:	2104      	movs	r1, #4
   89956:	4b13      	ldr	r3, [pc, #76]	; (899a4 <can_init_mailboxes+0x23c>)
   89958:	4798      	blx	r3
	can_enable_interrupt(CAN1, CAN_IER_MB3);
   8995a:	4811      	ldr	r0, [pc, #68]	; (899a0 <can_init_mailboxes+0x238>)
   8995c:	2108      	movs	r1, #8
   8995e:	4b11      	ldr	r3, [pc, #68]	; (899a4 <can_init_mailboxes+0x23c>)
   89960:	4798      	blx	r3
	can_enable_interrupt(CAN1, CAN_IER_MB4);
   89962:	480f      	ldr	r0, [pc, #60]	; (899a0 <can_init_mailboxes+0x238>)
   89964:	2110      	movs	r1, #16
   89966:	4b0f      	ldr	r3, [pc, #60]	; (899a4 <can_init_mailboxes+0x23c>)
   89968:	4798      	blx	r3
	can_enable_interrupt(CAN1, CAN_IER_MB5);
   8996a:	480d      	ldr	r0, [pc, #52]	; (899a0 <can_init_mailboxes+0x238>)
   8996c:	2120      	movs	r1, #32
   8996e:	4b0d      	ldr	r3, [pc, #52]	; (899a4 <can_init_mailboxes+0x23c>)
   89970:	4798      	blx	r3
	can_enable_interrupt(CAN1, CAN_IER_MB6);
   89972:	480b      	ldr	r0, [pc, #44]	; (899a0 <can_init_mailboxes+0x238>)
   89974:	2140      	movs	r1, #64	; 0x40
   89976:	4b0b      	ldr	r3, [pc, #44]	; (899a4 <can_init_mailboxes+0x23c>)
   89978:	4798      	blx	r3
	can_enable_interrupt(CAN1, CAN_IER_MB7);
   8997a:	4809      	ldr	r0, [pc, #36]	; (899a0 <can_init_mailboxes+0x238>)
   8997c:	2180      	movs	r1, #128	; 0x80
   8997e:	4b09      	ldr	r3, [pc, #36]	; (899a4 <can_init_mailboxes+0x23c>)
   89980:	4798      	blx	r3
	
	return 1;
   89982:	2301      	movs	r3, #1
}
   89984:	4618      	mov	r0, r3
   89986:	3708      	adds	r7, #8
   89988:	46bd      	mov	sp, r7
   8998a:	bd80      	pop	{r7, pc}
   8998c:	2007b408 	.word	0x2007b408
   89990:	00089079 	.word	0x00089079
   89994:	400b4000 	.word	0x400b4000
   89998:	00085031 	.word	0x00085031
   8999c:	2007ae34 	.word	0x2007ae34
   899a0:	400b8000 	.word	0x400b8000
   899a4:	00084f55 	.word	0x00084f55

000899a8 <high_command_generator>:
/* the one that enables the functionality you want.						*/
/* @Purpose: This function is used to generate the upper 4 bytes of all */
/* CAN messages as per the new structure. 								*/
/************************************************************************/
uint32_t high_command_generator(uint8_t sender_id, uint8_t ssm_id, uint8_t MessageType, uint8_t smalltype)
{
   899a8:	b480      	push	{r7}
   899aa:	b087      	sub	sp, #28
   899ac:	af00      	add	r7, sp, #0
   899ae:	71f8      	strb	r0, [r7, #7]
   899b0:	71b9      	strb	r1, [r7, #6]
   899b2:	717a      	strb	r2, [r7, #5]
   899b4:	713b      	strb	r3, [r7, #4]
	uint32_t sender, m_type, s_type, destination;
	
	sender = (uint32_t)sender_id;
   899b6:	79fb      	ldrb	r3, [r7, #7]
   899b8:	617b      	str	r3, [r7, #20]
	sender = sender << 28;
   899ba:	697b      	ldr	r3, [r7, #20]
   899bc:	071b      	lsls	r3, r3, #28
   899be:	617b      	str	r3, [r7, #20]
	
	destination = (uint32_t)ssm_id;
   899c0:	79bb      	ldrb	r3, [r7, #6]
   899c2:	613b      	str	r3, [r7, #16]
	destination = destination << 24;
   899c4:	693b      	ldr	r3, [r7, #16]
   899c6:	061b      	lsls	r3, r3, #24
   899c8:	613b      	str	r3, [r7, #16]
		
	m_type = (uint32_t)MessageType;
   899ca:	797b      	ldrb	r3, [r7, #5]
   899cc:	60fb      	str	r3, [r7, #12]
	m_type = m_type << 16;
   899ce:	68fb      	ldr	r3, [r7, #12]
   899d0:	041b      	lsls	r3, r3, #16
   899d2:	60fb      	str	r3, [r7, #12]
	
	s_type = (uint32_t)smalltype;
   899d4:	793b      	ldrb	r3, [r7, #4]
   899d6:	60bb      	str	r3, [r7, #8]
	s_type = s_type << 8;
   899d8:	68bb      	ldr	r3, [r7, #8]
   899da:	021b      	lsls	r3, r3, #8
   899dc:	60bb      	str	r3, [r7, #8]
	
	return sender + destination + m_type + s_type;
   899de:	697a      	ldr	r2, [r7, #20]
   899e0:	693b      	ldr	r3, [r7, #16]
   899e2:	441a      	add	r2, r3
   899e4:	68fb      	ldr	r3, [r7, #12]
   899e6:	441a      	add	r2, r3
   899e8:	68bb      	ldr	r3, [r7, #8]
   899ea:	4413      	add	r3, r2
}
   899ec:	4618      	mov	r0, r3
   899ee:	371c      	adds	r7, #28
   899f0:	46bd      	mov	sp, r7
   899f2:	f85d 7b04 	ldr.w	r7, [sp], #4
   899f6:	4770      	bx	lr

000899f8 <request_sensor_data_h>:
/* NOTE: This function should only be used in sections of code where the*/
/* Can0_Mutex was acquired.												*/
/************************************************************************/

static uint32_t request_sensor_data_h(uint8_t sender_id, uint8_t ssm_id, uint8_t sensor_name, uint8_t* status)
{
   899f8:	b590      	push	{r4, r7, lr}
   899fa:	b089      	sub	sp, #36	; 0x24
   899fc:	af02      	add	r7, sp, #8
   899fe:	603b      	str	r3, [r7, #0]
   89a00:	4603      	mov	r3, r0
   89a02:	71fb      	strb	r3, [r7, #7]
   89a04:	460b      	mov	r3, r1
   89a06:	71bb      	strb	r3, [r7, #6]
   89a08:	4613      	mov	r3, r2
   89a0a:	717b      	strb	r3, [r7, #5]
	uint32_t s, ret_val;
	uint32_t timeout = req_data_timeout;
   89a0c:	4b95      	ldr	r3, [pc, #596]	; (89c64 <request_sensor_data_h+0x26c>)
   89a0e:	681b      	ldr	r3, [r3, #0]
   89a10:	613b      	str	r3, [r7, #16]
	
	if (send_can_command_h2(0x00, sensor_name, sender_id, ssm_id, REQ_DATA, COMMAND_PRIO) < 0)
   89a12:	7979      	ldrb	r1, [r7, #5]
   89a14:	79fa      	ldrb	r2, [r7, #7]
   89a16:	79bb      	ldrb	r3, [r7, #6]
   89a18:	2002      	movs	r0, #2
   89a1a:	9000      	str	r0, [sp, #0]
   89a1c:	2019      	movs	r0, #25
   89a1e:	9001      	str	r0, [sp, #4]
   89a20:	2000      	movs	r0, #0
   89a22:	4c91      	ldr	r4, [pc, #580]	; (89c68 <request_sensor_data_h+0x270>)
   89a24:	47a0      	blx	r4
   89a26:	4603      	mov	r3, r0
   89a28:	2b00      	cmp	r3, #0
   89a2a:	da05      	bge.n	89a38 <request_sensor_data_h+0x40>
	{
		*status = 0xFF;
   89a2c:	683b      	ldr	r3, [r7, #0]
   89a2e:	22ff      	movs	r2, #255	; 0xff
   89a30:	701a      	strb	r2, [r3, #0]
		return 0xFFFFFFFF;
   89a32:	f04f 33ff 	mov.w	r3, #4294967295
   89a36:	e110      	b.n	89c5a <request_sensor_data_h+0x262>
	}

	if(sender_id == EPS_TASK_ID)
   89a38:	79fb      	ldrb	r3, [r7, #7]
   89a3a:	2b08      	cmp	r3, #8
   89a3c:	d128      	bne.n	89a90 <request_sensor_data_h+0x98>
	{
		while(!eps_data_receivedf)	// Wait for the response to come back.
   89a3e:	e00a      	b.n	89a56 <request_sensor_data_h+0x5e>
		{
			if(!timeout--)
   89a40:	693b      	ldr	r3, [r7, #16]
   89a42:	1e5a      	subs	r2, r3, #1
   89a44:	613a      	str	r2, [r7, #16]
   89a46:	2b00      	cmp	r3, #0
   89a48:	d105      	bne.n	89a56 <request_sensor_data_h+0x5e>
			{
				*status = 0xFF;
   89a4a:	683b      	ldr	r3, [r7, #0]
   89a4c:	22ff      	movs	r2, #255	; 0xff
   89a4e:	701a      	strb	r2, [r3, #0]
				return 0xFFFFFFFF;			// The operation failed.
   89a50:	f04f 33ff 	mov.w	r3, #4294967295
   89a54:	e101      	b.n	89c5a <request_sensor_data_h+0x262>
		return 0xFFFFFFFF;
	}

	if(sender_id == EPS_TASK_ID)
	{
		while(!eps_data_receivedf)	// Wait for the response to come back.
   89a56:	4b85      	ldr	r3, [pc, #532]	; (89c6c <request_sensor_data_h+0x274>)
   89a58:	781b      	ldrb	r3, [r3, #0]
   89a5a:	2b00      	cmp	r3, #0
   89a5c:	d0f0      	beq.n	89a40 <request_sensor_data_h+0x48>
			{
				*status = 0xFF;
				return 0xFFFFFFFF;			// The operation failed.
			}
		}
		s = (uint32_t)((eps_data_receive[1] & 0x0000FF00) >> 8);	// Name of the sensor
   89a5e:	4b84      	ldr	r3, [pc, #528]	; (89c70 <request_sensor_data_h+0x278>)
   89a60:	685b      	ldr	r3, [r3, #4]
   89a62:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   89a66:	0a1b      	lsrs	r3, r3, #8
   89a68:	60fb      	str	r3, [r7, #12]
	
		if (s != sensor_name)
   89a6a:	797a      	ldrb	r2, [r7, #5]
   89a6c:	68fb      	ldr	r3, [r7, #12]
   89a6e:	429a      	cmp	r2, r3
   89a70:	d008      	beq.n	89a84 <request_sensor_data_h+0x8c>
		{
			eps_data_receivedf = 0;
   89a72:	4b7e      	ldr	r3, [pc, #504]	; (89c6c <request_sensor_data_h+0x274>)
   89a74:	2200      	movs	r2, #0
   89a76:	701a      	strb	r2, [r3, #0]
			*status = 0xFF;
   89a78:	683b      	ldr	r3, [r7, #0]
   89a7a:	22ff      	movs	r2, #255	; 0xff
   89a7c:	701a      	strb	r2, [r3, #0]
			return 0xFFFFFFFF;			// The operation failed.
   89a7e:	f04f 33ff 	mov.w	r3, #4294967295
   89a82:	e0ea      	b.n	89c5a <request_sensor_data_h+0x262>
		}
	
		ret_val = eps_data_receive[0];	// 32-bit return value.
   89a84:	4b7a      	ldr	r3, [pc, #488]	; (89c70 <request_sensor_data_h+0x278>)
   89a86:	681b      	ldr	r3, [r3, #0]
   89a88:	617b      	str	r3, [r7, #20]
	
		eps_data_receivedf = 0;		// Zero this last to keep in sync.
   89a8a:	4b78      	ldr	r3, [pc, #480]	; (89c6c <request_sensor_data_h+0x274>)
   89a8c:	2200      	movs	r2, #0
   89a8e:	701a      	strb	r2, [r3, #0]
	}

	if(sender_id == COMS_TASK_ID)
   89a90:	79fb      	ldrb	r3, [r7, #7]
   89a92:	2b07      	cmp	r3, #7
   89a94:	d129      	bne.n	89aea <request_sensor_data_h+0xf2>
	{
		while(!coms_data_receivedf)	// Wait for the response to come back.
   89a96:	e00a      	b.n	89aae <request_sensor_data_h+0xb6>
		{
			if(!timeout--)
   89a98:	693b      	ldr	r3, [r7, #16]
   89a9a:	1e5a      	subs	r2, r3, #1
   89a9c:	613a      	str	r2, [r7, #16]
   89a9e:	2b00      	cmp	r3, #0
   89aa0:	d105      	bne.n	89aae <request_sensor_data_h+0xb6>
			{
				*status = 0xFF;
   89aa2:	683b      	ldr	r3, [r7, #0]
   89aa4:	22ff      	movs	r2, #255	; 0xff
   89aa6:	701a      	strb	r2, [r3, #0]
				return 0xFFFFFFFF;			// The operation failed.
   89aa8:	f04f 33ff 	mov.w	r3, #4294967295
   89aac:	e0d5      	b.n	89c5a <request_sensor_data_h+0x262>
		eps_data_receivedf = 0;		// Zero this last to keep in sync.
	}

	if(sender_id == COMS_TASK_ID)
	{
		while(!coms_data_receivedf)	// Wait for the response to come back.
   89aae:	4b71      	ldr	r3, [pc, #452]	; (89c74 <request_sensor_data_h+0x27c>)
   89ab0:	781b      	ldrb	r3, [r3, #0]
   89ab2:	2b00      	cmp	r3, #0
   89ab4:	d0f0      	beq.n	89a98 <request_sensor_data_h+0xa0>
			{
				*status = 0xFF;
				return 0xFFFFFFFF;			// The operation failed.
			}
		}
		s = (uint8_t)((coms_data_receive[1] & 0x0000FF00) >> 8);	// Name of the sensor
   89ab6:	4b70      	ldr	r3, [pc, #448]	; (89c78 <request_sensor_data_h+0x280>)
   89ab8:	685b      	ldr	r3, [r3, #4]
   89aba:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   89abe:	0a1b      	lsrs	r3, r3, #8
   89ac0:	b2db      	uxtb	r3, r3
   89ac2:	60fb      	str	r3, [r7, #12]
	
		if (s != sensor_name)
   89ac4:	797a      	ldrb	r2, [r7, #5]
   89ac6:	68fb      	ldr	r3, [r7, #12]
   89ac8:	429a      	cmp	r2, r3
   89aca:	d008      	beq.n	89ade <request_sensor_data_h+0xe6>
		{
			coms_data_receivedf = 0;
   89acc:	4b69      	ldr	r3, [pc, #420]	; (89c74 <request_sensor_data_h+0x27c>)
   89ace:	2200      	movs	r2, #0
   89ad0:	701a      	strb	r2, [r3, #0]
			*status = 0xFF;
   89ad2:	683b      	ldr	r3, [r7, #0]
   89ad4:	22ff      	movs	r2, #255	; 0xff
   89ad6:	701a      	strb	r2, [r3, #0]
			return 0xFFFFFFFF;			// The operation failed.
   89ad8:	f04f 33ff 	mov.w	r3, #4294967295
   89adc:	e0bd      	b.n	89c5a <request_sensor_data_h+0x262>
		}
	
		ret_val = coms_data_receive[0];	// 32-bit return value.
   89ade:	4b66      	ldr	r3, [pc, #408]	; (89c78 <request_sensor_data_h+0x280>)
   89ae0:	681b      	ldr	r3, [r3, #0]
   89ae2:	617b      	str	r3, [r7, #20]
	
		coms_data_receivedf = 0;		// Zero this last to keep in sync.
   89ae4:	4b63      	ldr	r3, [pc, #396]	; (89c74 <request_sensor_data_h+0x27c>)
   89ae6:	2200      	movs	r2, #0
   89ae8:	701a      	strb	r2, [r3, #0]
	}

	if(sender_id == PAY_TASK_ID)
   89aea:	79fb      	ldrb	r3, [r7, #7]
   89aec:	2b09      	cmp	r3, #9
   89aee:	d129      	bne.n	89b44 <request_sensor_data_h+0x14c>
	{
		while(!pay_data_receivedf)	// Wait for the response to come back.
   89af0:	e00a      	b.n	89b08 <request_sensor_data_h+0x110>
		{
			if(!timeout--)
   89af2:	693b      	ldr	r3, [r7, #16]
   89af4:	1e5a      	subs	r2, r3, #1
   89af6:	613a      	str	r2, [r7, #16]
   89af8:	2b00      	cmp	r3, #0
   89afa:	d105      	bne.n	89b08 <request_sensor_data_h+0x110>
			{
				*status = 0xFF;
   89afc:	683b      	ldr	r3, [r7, #0]
   89afe:	22ff      	movs	r2, #255	; 0xff
   89b00:	701a      	strb	r2, [r3, #0]
				return 0xFFFFFFFF;			// The operation failed.
   89b02:	f04f 33ff 	mov.w	r3, #4294967295
   89b06:	e0a8      	b.n	89c5a <request_sensor_data_h+0x262>
		coms_data_receivedf = 0;		// Zero this last to keep in sync.
	}

	if(sender_id == PAY_TASK_ID)
	{
		while(!pay_data_receivedf)	// Wait for the response to come back.
   89b08:	4b5c      	ldr	r3, [pc, #368]	; (89c7c <request_sensor_data_h+0x284>)
   89b0a:	781b      	ldrb	r3, [r3, #0]
   89b0c:	2b00      	cmp	r3, #0
   89b0e:	d0f0      	beq.n	89af2 <request_sensor_data_h+0xfa>
			{
				*status = 0xFF;
				return 0xFFFFFFFF;			// The operation failed.
			}
		}
		s = (uint8_t)((pay_data_receive[1] & 0x0000FF00) >> 8);	// Name of the sensor
   89b10:	4b5b      	ldr	r3, [pc, #364]	; (89c80 <request_sensor_data_h+0x288>)
   89b12:	685b      	ldr	r3, [r3, #4]
   89b14:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   89b18:	0a1b      	lsrs	r3, r3, #8
   89b1a:	b2db      	uxtb	r3, r3
   89b1c:	60fb      	str	r3, [r7, #12]
	
		if (s != sensor_name)
   89b1e:	797a      	ldrb	r2, [r7, #5]
   89b20:	68fb      	ldr	r3, [r7, #12]
   89b22:	429a      	cmp	r2, r3
   89b24:	d008      	beq.n	89b38 <request_sensor_data_h+0x140>
		{
			pay_data_receivedf = 0;
   89b26:	4b55      	ldr	r3, [pc, #340]	; (89c7c <request_sensor_data_h+0x284>)
   89b28:	2200      	movs	r2, #0
   89b2a:	701a      	strb	r2, [r3, #0]
			*status = 0xFF;
   89b2c:	683b      	ldr	r3, [r7, #0]
   89b2e:	22ff      	movs	r2, #255	; 0xff
   89b30:	701a      	strb	r2, [r3, #0]
			return 0xFFFFFFFF;			// The operation failed.
   89b32:	f04f 33ff 	mov.w	r3, #4294967295
   89b36:	e090      	b.n	89c5a <request_sensor_data_h+0x262>
		}
	
		ret_val = pay_data_receive[0];	// 32-bit return value.
   89b38:	4b51      	ldr	r3, [pc, #324]	; (89c80 <request_sensor_data_h+0x288>)
   89b3a:	681b      	ldr	r3, [r3, #0]
   89b3c:	617b      	str	r3, [r7, #20]
	
		pay_data_receivedf = 0;		// Zero this last to keep in sync.
   89b3e:	4b4f      	ldr	r3, [pc, #316]	; (89c7c <request_sensor_data_h+0x284>)
   89b40:	2200      	movs	r2, #0
   89b42:	701a      	strb	r2, [r3, #0]
	}
	
	if(sender_id == OBC_PACKET_ROUTER_ID)
   89b44:	79fb      	ldrb	r3, [r7, #7]
   89b46:	2b0a      	cmp	r3, #10
   89b48:	d129      	bne.n	89b9e <request_sensor_data_h+0x1a6>
	{
		while(!opr_data_receivedf)	// Wait for the response to come back.
   89b4a:	e00a      	b.n	89b62 <request_sensor_data_h+0x16a>
		{
			if(!timeout--)
   89b4c:	693b      	ldr	r3, [r7, #16]
   89b4e:	1e5a      	subs	r2, r3, #1
   89b50:	613a      	str	r2, [r7, #16]
   89b52:	2b00      	cmp	r3, #0
   89b54:	d105      	bne.n	89b62 <request_sensor_data_h+0x16a>
			{
				*status = 0xFF;
   89b56:	683b      	ldr	r3, [r7, #0]
   89b58:	22ff      	movs	r2, #255	; 0xff
   89b5a:	701a      	strb	r2, [r3, #0]
				return 0xFFFFFFFF;			// The operation failed.
   89b5c:	f04f 33ff 	mov.w	r3, #4294967295
   89b60:	e07b      	b.n	89c5a <request_sensor_data_h+0x262>
		pay_data_receivedf = 0;		// Zero this last to keep in sync.
	}
	
	if(sender_id == OBC_PACKET_ROUTER_ID)
	{
		while(!opr_data_receivedf)	// Wait for the response to come back.
   89b62:	4b48      	ldr	r3, [pc, #288]	; (89c84 <request_sensor_data_h+0x28c>)
   89b64:	781b      	ldrb	r3, [r3, #0]
   89b66:	2b00      	cmp	r3, #0
   89b68:	d0f0      	beq.n	89b4c <request_sensor_data_h+0x154>
			{
				*status = 0xFF;
				return 0xFFFFFFFF;			// The operation failed.
			}
		}
		s = (uint8_t)((opr_data_receive[1] & 0x0000FF00) >> 8);	// Name of the sensor
   89b6a:	4b47      	ldr	r3, [pc, #284]	; (89c88 <request_sensor_data_h+0x290>)
   89b6c:	685b      	ldr	r3, [r3, #4]
   89b6e:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   89b72:	0a1b      	lsrs	r3, r3, #8
   89b74:	b2db      	uxtb	r3, r3
   89b76:	60fb      	str	r3, [r7, #12]
		
		if (s != sensor_name)
   89b78:	797a      	ldrb	r2, [r7, #5]
   89b7a:	68fb      	ldr	r3, [r7, #12]
   89b7c:	429a      	cmp	r2, r3
   89b7e:	d008      	beq.n	89b92 <request_sensor_data_h+0x19a>
		{
			opr_data_receivedf = 0;
   89b80:	4b40      	ldr	r3, [pc, #256]	; (89c84 <request_sensor_data_h+0x28c>)
   89b82:	2200      	movs	r2, #0
   89b84:	701a      	strb	r2, [r3, #0]
			*status = 0xFF;
   89b86:	683b      	ldr	r3, [r7, #0]
   89b88:	22ff      	movs	r2, #255	; 0xff
   89b8a:	701a      	strb	r2, [r3, #0]
			return 0xFFFFFFFF;			// The operation failed.
   89b8c:	f04f 33ff 	mov.w	r3, #4294967295
   89b90:	e063      	b.n	89c5a <request_sensor_data_h+0x262>
		}
		
		ret_val = opr_data_receive[0];	// 32-bit return value.
   89b92:	4b3d      	ldr	r3, [pc, #244]	; (89c88 <request_sensor_data_h+0x290>)
   89b94:	681b      	ldr	r3, [r3, #0]
   89b96:	617b      	str	r3, [r7, #20]
		
		opr_data_receivedf = 0;		// Zero this last to keep in sync.
   89b98:	4b3a      	ldr	r3, [pc, #232]	; (89c84 <request_sensor_data_h+0x28c>)
   89b9a:	2200      	movs	r2, #0
   89b9c:	701a      	strb	r2, [r3, #0]
	}
	
	if(sender_id == FDIR_TASK_ID)
   89b9e:	79fb      	ldrb	r3, [r7, #7]
   89ba0:	2b0c      	cmp	r3, #12
   89ba2:	d129      	bne.n	89bf8 <request_sensor_data_h+0x200>
	{
		while(!fdir_data_receivedf)	// Wait for the response to come back.
   89ba4:	e00a      	b.n	89bbc <request_sensor_data_h+0x1c4>
		{
			if(!timeout--)
   89ba6:	693b      	ldr	r3, [r7, #16]
   89ba8:	1e5a      	subs	r2, r3, #1
   89baa:	613a      	str	r2, [r7, #16]
   89bac:	2b00      	cmp	r3, #0
   89bae:	d105      	bne.n	89bbc <request_sensor_data_h+0x1c4>
			{
				*status = 0xFF;
   89bb0:	683b      	ldr	r3, [r7, #0]
   89bb2:	22ff      	movs	r2, #255	; 0xff
   89bb4:	701a      	strb	r2, [r3, #0]
				return 0xFFFFFFFF;			// The operation failed.
   89bb6:	f04f 33ff 	mov.w	r3, #4294967295
   89bba:	e04e      	b.n	89c5a <request_sensor_data_h+0x262>
		opr_data_receivedf = 0;		// Zero this last to keep in sync.
	}
	
	if(sender_id == FDIR_TASK_ID)
	{
		while(!fdir_data_receivedf)	// Wait for the response to come back.
   89bbc:	4b33      	ldr	r3, [pc, #204]	; (89c8c <request_sensor_data_h+0x294>)
   89bbe:	781b      	ldrb	r3, [r3, #0]
   89bc0:	2b00      	cmp	r3, #0
   89bc2:	d0f0      	beq.n	89ba6 <request_sensor_data_h+0x1ae>
			{
				*status = 0xFF;
				return 0xFFFFFFFF;			// The operation failed.
			}
		}
		s = (uint8_t)((fdir_data_receive[1] & 0x0000FF00) >> 8);	// Name of the sensor
   89bc4:	4b32      	ldr	r3, [pc, #200]	; (89c90 <request_sensor_data_h+0x298>)
   89bc6:	685b      	ldr	r3, [r3, #4]
   89bc8:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   89bcc:	0a1b      	lsrs	r3, r3, #8
   89bce:	b2db      	uxtb	r3, r3
   89bd0:	60fb      	str	r3, [r7, #12]
		
		if (s != sensor_name)
   89bd2:	797a      	ldrb	r2, [r7, #5]
   89bd4:	68fb      	ldr	r3, [r7, #12]
   89bd6:	429a      	cmp	r2, r3
   89bd8:	d008      	beq.n	89bec <request_sensor_data_h+0x1f4>
		{
			fdir_data_receivedf = 0;
   89bda:	4b2c      	ldr	r3, [pc, #176]	; (89c8c <request_sensor_data_h+0x294>)
   89bdc:	2200      	movs	r2, #0
   89bde:	701a      	strb	r2, [r3, #0]
			*status = 0xFF;
   89be0:	683b      	ldr	r3, [r7, #0]
   89be2:	22ff      	movs	r2, #255	; 0xff
   89be4:	701a      	strb	r2, [r3, #0]
			return 0xFFFFFFFF;			// The operation failed.
   89be6:	f04f 33ff 	mov.w	r3, #4294967295
   89bea:	e036      	b.n	89c5a <request_sensor_data_h+0x262>
		}
		
		ret_val = fdir_data_receive[0];	// 32-bit return value.
   89bec:	4b28      	ldr	r3, [pc, #160]	; (89c90 <request_sensor_data_h+0x298>)
   89bee:	681b      	ldr	r3, [r3, #0]
   89bf0:	617b      	str	r3, [r7, #20]
		
		fdir_data_receivedf = 0;		// Zero this last to keep in sync.
   89bf2:	4b26      	ldr	r3, [pc, #152]	; (89c8c <request_sensor_data_h+0x294>)
   89bf4:	2200      	movs	r2, #0
   89bf6:	701a      	strb	r2, [r3, #0]
	}
	
	if(sender_id == SCHEDULING_TASK_ID)
   89bf8:	79fb      	ldrb	r3, [r7, #7]
   89bfa:	2b0b      	cmp	r3, #11
   89bfc:	d129      	bne.n	89c52 <request_sensor_data_h+0x25a>
	{
		while(!sched_data_receivedf)	// Wait for the response to come back.
   89bfe:	e00a      	b.n	89c16 <request_sensor_data_h+0x21e>
		{
			if(!timeout--)
   89c00:	693b      	ldr	r3, [r7, #16]
   89c02:	1e5a      	subs	r2, r3, #1
   89c04:	613a      	str	r2, [r7, #16]
   89c06:	2b00      	cmp	r3, #0
   89c08:	d105      	bne.n	89c16 <request_sensor_data_h+0x21e>
			{
				*status = 0xFF;
   89c0a:	683b      	ldr	r3, [r7, #0]
   89c0c:	22ff      	movs	r2, #255	; 0xff
   89c0e:	701a      	strb	r2, [r3, #0]
				return 0xFFFFFFFF;			// The operation failed.
   89c10:	f04f 33ff 	mov.w	r3, #4294967295
   89c14:	e021      	b.n	89c5a <request_sensor_data_h+0x262>
		fdir_data_receivedf = 0;		// Zero this last to keep in sync.
	}
	
	if(sender_id == SCHEDULING_TASK_ID)
	{
		while(!sched_data_receivedf)	// Wait for the response to come back.
   89c16:	4b1f      	ldr	r3, [pc, #124]	; (89c94 <request_sensor_data_h+0x29c>)
   89c18:	781b      	ldrb	r3, [r3, #0]
   89c1a:	2b00      	cmp	r3, #0
   89c1c:	d0f0      	beq.n	89c00 <request_sensor_data_h+0x208>
			{
				*status = 0xFF;
				return 0xFFFFFFFF;			// The operation failed.
			}
		}
		s = (uint8_t)((sched_data_receive[1] & 0x0000FF00) >> 8);	// Name of the sensor
   89c1e:	4b1e      	ldr	r3, [pc, #120]	; (89c98 <request_sensor_data_h+0x2a0>)
   89c20:	685b      	ldr	r3, [r3, #4]
   89c22:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
   89c26:	0a1b      	lsrs	r3, r3, #8
   89c28:	b2db      	uxtb	r3, r3
   89c2a:	60fb      	str	r3, [r7, #12]
		
		if (s != sensor_name)
   89c2c:	797a      	ldrb	r2, [r7, #5]
   89c2e:	68fb      	ldr	r3, [r7, #12]
   89c30:	429a      	cmp	r2, r3
   89c32:	d008      	beq.n	89c46 <request_sensor_data_h+0x24e>
		{
			sched_data_receivedf = 0;
   89c34:	4b17      	ldr	r3, [pc, #92]	; (89c94 <request_sensor_data_h+0x29c>)
   89c36:	2200      	movs	r2, #0
   89c38:	701a      	strb	r2, [r3, #0]
			*status = 0xFF;
   89c3a:	683b      	ldr	r3, [r7, #0]
   89c3c:	22ff      	movs	r2, #255	; 0xff
   89c3e:	701a      	strb	r2, [r3, #0]
			return 0xFFFFFFFF;			// The operation failed.
   89c40:	f04f 33ff 	mov.w	r3, #4294967295
   89c44:	e009      	b.n	89c5a <request_sensor_data_h+0x262>
		}
		
		ret_val = sched_data_receive[0];	// 32-bit return value.
   89c46:	4b14      	ldr	r3, [pc, #80]	; (89c98 <request_sensor_data_h+0x2a0>)
   89c48:	681b      	ldr	r3, [r3, #0]
   89c4a:	617b      	str	r3, [r7, #20]
		
		sched_data_receivedf = 0;		// Zero this last to keep in sync.
   89c4c:	4b11      	ldr	r3, [pc, #68]	; (89c94 <request_sensor_data_h+0x29c>)
   89c4e:	2200      	movs	r2, #0
   89c50:	701a      	strb	r2, [r3, #0]
	}

	*status = 1;				// The operation succeeded.
   89c52:	683b      	ldr	r3, [r7, #0]
   89c54:	2201      	movs	r2, #1
   89c56:	701a      	strb	r2, [r3, #0]
	return ret_val;				// This is the requested data.
   89c58:	697b      	ldr	r3, [r7, #20]
}
   89c5a:	4618      	mov	r0, r3
   89c5c:	371c      	adds	r7, #28
   89c5e:	46bd      	mov	sp, r7
   89c60:	bd90      	pop	{r4, r7, pc}
   89c62:	bf00      	nop
   89c64:	2007ae1c 	.word	0x2007ae1c
   89c68:	00089161 	.word	0x00089161
   89c6c:	2007b520 	.word	0x2007b520
   89c70:	2007b428 	.word	0x2007b428
   89c74:	2007aef0 	.word	0x2007aef0
   89c78:	2007b39c 	.word	0x2007b39c
   89c7c:	2007b528 	.word	0x2007b528
   89c80:	2007b3d0 	.word	0x2007b3d0
   89c84:	2007b3f4 	.word	0x2007b3f4
   89c88:	2007adb0 	.word	0x2007adb0
   89c8c:	2007ae25 	.word	0x2007ae25
   89c90:	2007adbc 	.word	0x2007adbc
   89c94:	2007b550 	.word	0x2007b550
   89c98:	2007add4 	.word	0x2007add4

00089c9c <request_sensor_data>:
/* NOTE: This function will wait for a maximum of 25ms. for the			*/
/* operation to complete.												*/
/************************************************************************/

uint32_t request_sensor_data(uint8_t sender_id, uint8_t ssm_id, uint8_t sensor_name, int* status)
{
   89c9c:	b590      	push	{r4, r7, lr}
   89c9e:	b087      	sub	sp, #28
   89ca0:	af00      	add	r7, sp, #0
   89ca2:	603b      	str	r3, [r7, #0]
   89ca4:	4603      	mov	r3, r0
   89ca6:	71fb      	strb	r3, [r7, #7]
   89ca8:	460b      	mov	r3, r1
   89caa:	71bb      	strb	r3, [r7, #6]
   89cac:	4613      	mov	r3, r2
   89cae:	717b      	strb	r3, [r7, #5]
	uint32_t ret_val = 0;
   89cb0:	2300      	movs	r3, #0
   89cb2:	617b      	str	r3, [r7, #20]
	uint8_t* s = 0;
   89cb4:	2300      	movs	r3, #0
   89cb6:	613b      	str	r3, [r7, #16]
	uint8_t temp = 0;
   89cb8:	2300      	movs	r3, #0
   89cba:	73fb      	strb	r3, [r7, #15]
	
	if (xSemaphoreTake(Can0_Mutex, (TickType_t) 0) == pdTRUE)		// Attempt to acquire CAN1 Mutex, block for 1 tick.
   89cbc:	4b17      	ldr	r3, [pc, #92]	; (89d1c <request_sensor_data+0x80>)
   89cbe:	681b      	ldr	r3, [r3, #0]
   89cc0:	4618      	mov	r0, r3
   89cc2:	2100      	movs	r1, #0
   89cc4:	2200      	movs	r2, #0
   89cc6:	2300      	movs	r3, #0
   89cc8:	4c15      	ldr	r4, [pc, #84]	; (89d20 <request_sensor_data+0x84>)
   89cca:	47a0      	blx	r4
   89ccc:	4603      	mov	r3, r0
   89cce:	2b01      	cmp	r3, #1
   89cd0:	d119      	bne.n	89d06 <request_sensor_data+0x6a>
	{
		ret_val = request_sensor_data_h(sender_id, ssm_id, sensor_name, s);
   89cd2:	79f9      	ldrb	r1, [r7, #7]
   89cd4:	79ba      	ldrb	r2, [r7, #6]
   89cd6:	797b      	ldrb	r3, [r7, #5]
   89cd8:	4608      	mov	r0, r1
   89cda:	4611      	mov	r1, r2
   89cdc:	461a      	mov	r2, r3
   89cde:	693b      	ldr	r3, [r7, #16]
   89ce0:	4c10      	ldr	r4, [pc, #64]	; (89d24 <request_sensor_data+0x88>)
   89ce2:	47a0      	blx	r4
   89ce4:	6178      	str	r0, [r7, #20]
		temp = *s;
   89ce6:	693b      	ldr	r3, [r7, #16]
   89ce8:	781b      	ldrb	r3, [r3, #0]
   89cea:	73fb      	strb	r3, [r7, #15]
		*status = (int)temp;
   89cec:	7bfa      	ldrb	r2, [r7, #15]
   89cee:	683b      	ldr	r3, [r7, #0]
   89cf0:	601a      	str	r2, [r3, #0]
		xSemaphoreGive(Can0_Mutex);
   89cf2:	4b0a      	ldr	r3, [pc, #40]	; (89d1c <request_sensor_data+0x80>)
   89cf4:	681b      	ldr	r3, [r3, #0]
   89cf6:	4618      	mov	r0, r3
   89cf8:	2100      	movs	r1, #0
   89cfa:	2200      	movs	r2, #0
   89cfc:	2300      	movs	r3, #0
   89cfe:	4c0a      	ldr	r4, [pc, #40]	; (89d28 <request_sensor_data+0x8c>)
   89d00:	47a0      	blx	r4
		return ret_val;
   89d02:	697b      	ldr	r3, [r7, #20]
   89d04:	e005      	b.n	89d12 <request_sensor_data+0x76>
	}
	else
	{
		*status = -1;
   89d06:	683b      	ldr	r3, [r7, #0]
   89d08:	f04f 32ff 	mov.w	r2, #4294967295
   89d0c:	601a      	str	r2, [r3, #0]
		return -1;					// CAN0 was busy or something has gone wrong.
   89d0e:	f04f 33ff 	mov.w	r3, #4294967295
	}
}
   89d12:	4618      	mov	r0, r3
   89d14:	371c      	adds	r7, #28
   89d16:	46bd      	mov	sp, r7
   89d18:	bd90      	pop	{r4, r7, pc}
   89d1a:	bf00      	nop
   89d1c:	2007b524 	.word	0x2007b524
   89d20:	00086dc1 	.word	0x00086dc1
   89d24:	000899f9 	.word	0x000899f9
   89d28:	00086b01 	.word	0x00086b01

00089d2c <set_variable>:
/* @NOTE: This function checks to make sure that the request succeeded	*/
/*			(this has a timeout of 25 ms)								*/
/* @NOTE: This is for use with tasks and their corresponding SSMs only.	*/
/************************************************************************/
int set_variable(uint8_t sender_id, uint8_t ssm_id, uint8_t var_name, uint16_t value)
{
   89d2c:	b590      	push	{r4, r7, lr}
   89d2e:	b089      	sub	sp, #36	; 0x24
   89d30:	af00      	add	r7, sp, #0
   89d32:	71f8      	strb	r0, [r7, #7]
   89d34:	71b9      	strb	r1, [r7, #6]
   89d36:	717a      	strb	r2, [r7, #5]
   89d38:	807b      	strh	r3, [r7, #2]
	uint32_t high, low, check;
	uint8_t ret_val;
	uint32_t id;

	if(ssm_id == COMS_ID)
   89d3a:	79bb      	ldrb	r3, [r7, #6]
   89d3c:	2b00      	cmp	r3, #0
   89d3e:	d101      	bne.n	89d44 <set_variable+0x18>
		id = SUB0_ID0;
   89d40:	2314      	movs	r3, #20
   89d42:	61fb      	str	r3, [r7, #28]
	if(ssm_id == EPS_ID)
   89d44:	79bb      	ldrb	r3, [r7, #6]
   89d46:	2b01      	cmp	r3, #1
   89d48:	d101      	bne.n	89d4e <set_variable+0x22>
		id = SUB1_ID0;
   89d4a:	231a      	movs	r3, #26
   89d4c:	61fb      	str	r3, [r7, #28]
	if(ssm_id == PAY_ID)
   89d4e:	79bb      	ldrb	r3, [r7, #6]
   89d50:	2b02      	cmp	r3, #2
   89d52:	d101      	bne.n	89d58 <set_variable+0x2c>
		id = SUB2_ID0;
   89d54:	2320      	movs	r3, #32
   89d56:	61fb      	str	r3, [r7, #28]
	
	high = high_command_generator(sender_id, ssm_id, MT_COM, SET_VAR);
   89d58:	79fa      	ldrb	r2, [r7, #7]
   89d5a:	79bb      	ldrb	r3, [r7, #6]
   89d5c:	4610      	mov	r0, r2
   89d5e:	4619      	mov	r1, r3
   89d60:	2202      	movs	r2, #2
   89d62:	230b      	movs	r3, #11
   89d64:	4c26      	ldr	r4, [pc, #152]	; (89e00 <set_variable+0xd4>)
   89d66:	47a0      	blx	r4
   89d68:	61b8      	str	r0, [r7, #24]
	low = (uint32_t)var_name;
   89d6a:	797b      	ldrb	r3, [r7, #5]
   89d6c:	617b      	str	r3, [r7, #20]
	low = low << 24;
   89d6e:	697b      	ldr	r3, [r7, #20]
   89d70:	061b      	lsls	r3, r3, #24
   89d72:	617b      	str	r3, [r7, #20]
	low |= value;
   89d74:	887b      	ldrh	r3, [r7, #2]
   89d76:	697a      	ldr	r2, [r7, #20]
   89d78:	4313      	orrs	r3, r2
   89d7a:	617b      	str	r3, [r7, #20]
	
	if (xSemaphoreTake(Can0_Mutex, (TickType_t) 0) == pdTRUE)		// Attempt to acquire CAN1 Mutex, block for 1 tick.
   89d7c:	4b21      	ldr	r3, [pc, #132]	; (89e04 <set_variable+0xd8>)
   89d7e:	681b      	ldr	r3, [r3, #0]
   89d80:	4618      	mov	r0, r3
   89d82:	2100      	movs	r1, #0
   89d84:	2200      	movs	r2, #0
   89d86:	2300      	movs	r3, #0
   89d88:	4c1f      	ldr	r4, [pc, #124]	; (89e08 <set_variable+0xdc>)
   89d8a:	47a0      	blx	r4
   89d8c:	4603      	mov	r3, r0
   89d8e:	2b01      	cmp	r3, #1
   89d90:	d12f      	bne.n	89df2 <set_variable+0xc6>
	{
		ret_val = send_can_command_h(low, high, id, DEF_PRIO);
   89d92:	6978      	ldr	r0, [r7, #20]
   89d94:	69b9      	ldr	r1, [r7, #24]
   89d96:	69fa      	ldr	r2, [r7, #28]
   89d98:	230a      	movs	r3, #10
   89d9a:	4c1c      	ldr	r4, [pc, #112]	; (89e0c <set_variable+0xe0>)
   89d9c:	47a0      	blx	r4
   89d9e:	4603      	mov	r3, r0
   89da0:	b2db      	uxtb	r3, r3
   89da2:	73fb      	strb	r3, [r7, #15]
		check = request_sensor_data_h(sender_id, ssm_id, var_name, &ret_val);
   89da4:	79f8      	ldrb	r0, [r7, #7]
   89da6:	79b9      	ldrb	r1, [r7, #6]
   89da8:	797a      	ldrb	r2, [r7, #5]
   89daa:	f107 030f 	add.w	r3, r7, #15
   89dae:	4c18      	ldr	r4, [pc, #96]	; (89e10 <set_variable+0xe4>)
   89db0:	47a0      	blx	r4
   89db2:	6138      	str	r0, [r7, #16]
		
		if ((ret_val > 1) || (check != value))
   89db4:	7bfb      	ldrb	r3, [r7, #15]
   89db6:	2b01      	cmp	r3, #1
   89db8:	d803      	bhi.n	89dc2 <set_variable+0x96>
   89dba:	887a      	ldrh	r2, [r7, #2]
   89dbc:	693b      	ldr	r3, [r7, #16]
   89dbe:	429a      	cmp	r2, r3
   89dc0:	d00a      	beq.n	89dd8 <set_variable+0xac>
		{
			xSemaphoreGive(Can0_Mutex);
   89dc2:	4b10      	ldr	r3, [pc, #64]	; (89e04 <set_variable+0xd8>)
   89dc4:	681b      	ldr	r3, [r3, #0]
   89dc6:	4618      	mov	r0, r3
   89dc8:	2100      	movs	r1, #0
   89dca:	2200      	movs	r2, #0
   89dcc:	2300      	movs	r3, #0
   89dce:	4c11      	ldr	r4, [pc, #68]	; (89e14 <set_variable+0xe8>)
   89dd0:	47a0      	blx	r4
			return -1;
   89dd2:	f04f 33ff 	mov.w	r3, #4294967295
   89dd6:	e00e      	b.n	89df6 <set_variable+0xca>
		}
		else
		{
			xSemaphoreGive(Can0_Mutex);
   89dd8:	4b0a      	ldr	r3, [pc, #40]	; (89e04 <set_variable+0xd8>)
   89dda:	681b      	ldr	r3, [r3, #0]
   89ddc:	4618      	mov	r0, r3
   89dde:	2100      	movs	r1, #0
   89de0:	2200      	movs	r2, #0
   89de2:	2300      	movs	r3, #0
   89de4:	4c0b      	ldr	r4, [pc, #44]	; (89e14 <set_variable+0xe8>)
   89de6:	47a0      	blx	r4
			delay_us(100);
   89de8:	2064      	movs	r0, #100	; 0x64
   89dea:	4b0b      	ldr	r3, [pc, #44]	; (89e18 <set_variable+0xec>)
   89dec:	4798      	blx	r3
			return 1;
   89dee:	2301      	movs	r3, #1
   89df0:	e001      	b.n	89df6 <set_variable+0xca>
		}
	}
	else
		return -1;					// CAN0 is currently busy or something has gone wrong.
   89df2:	f04f 33ff 	mov.w	r3, #4294967295
}
   89df6:	4618      	mov	r0, r3
   89df8:	3724      	adds	r7, #36	; 0x24
   89dfa:	46bd      	mov	sp, r7
   89dfc:	bd90      	pop	{r4, r7, pc}
   89dfe:	bf00      	nop
   89e00:	000899a9 	.word	0x000899a9
   89e04:	2007b524 	.word	0x2007b524
   89e08:	00086dc1 	.word	0x00086dc1
   89e0c:	000890d1 	.word	0x000890d1
   89e10:	000899f9 	.word	0x000899f9
   89e14:	00086b01 	.word	0x00086b01
   89e18:	0008425d 	.word	0x0008425d

00089e1c <start_tc_packet>:
/* that a Telecommand (TC) packet is ready, the OBC needs to send a		*/
/* message back to the SSM letting it know that it is ready to receive	*/
/* CAN messages corresponding to that TC packet. This function does that*/
/************************************************************************/
static void start_tc_packet(void)
{
   89e1c:	b590      	push	{r4, r7, lr}
   89e1e:	b083      	sub	sp, #12
   89e20:	af02      	add	r7, sp, #8
	if(!current_tc_fullf)
   89e22:	4b0a      	ldr	r3, [pc, #40]	; (89e4c <start_tc_packet+0x30>)
   89e24:	781b      	ldrb	r3, [r3, #0]
   89e26:	2b00      	cmp	r3, #0
   89e28:	d109      	bne.n	89e3e <start_tc_packet+0x22>
	{
		send_tc_can_command_from_int(0x00, 0x00, OBC_PACKET_ROUTER_ID, COMS_ID, OK_START_TC_PACKET, COMMAND_PRIO);
   89e2a:	2312      	movs	r3, #18
   89e2c:	9300      	str	r3, [sp, #0]
   89e2e:	2319      	movs	r3, #25
   89e30:	9301      	str	r3, [sp, #4]
   89e32:	2000      	movs	r0, #0
   89e34:	2100      	movs	r1, #0
   89e36:	220a      	movs	r2, #10
   89e38:	2300      	movs	r3, #0
   89e3a:	4c05      	ldr	r4, [pc, #20]	; (89e50 <start_tc_packet+0x34>)
   89e3c:	47a0      	blx	r4
	}
	receiving_tcf = 1;
   89e3e:	4b05      	ldr	r3, [pc, #20]	; (89e54 <start_tc_packet+0x38>)
   89e40:	2201      	movs	r2, #1
   89e42:	701a      	strb	r2, [r3, #0]
	return;
   89e44:	bf00      	nop
}
   89e46:	3704      	adds	r7, #4
   89e48:	46bd      	mov	sp, r7
   89e4a:	bd90      	pop	{r4, r7, pc}
   89e4c:	2007ada9 	.word	0x2007ada9
   89e50:	000893e1 	.word	0x000893e1
   89e54:	2007adcc 	.word	0x2007adcc

00089e58 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field
 */
static __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
   89e58:	b480      	push	{r7}
   89e5a:	b085      	sub	sp, #20
   89e5c:	af00      	add	r7, sp, #0
   89e5e:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */
   89e60:	687b      	ldr	r3, [r7, #4]
   89e62:	f003 0307 	and.w	r3, r3, #7
   89e66:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
   89e68:	4b0c      	ldr	r3, [pc, #48]	; (89e9c <NVIC_SetPriorityGrouping+0x44>)
   89e6a:	68db      	ldr	r3, [r3, #12]
   89e6c:	60bb      	str	r3, [r7, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
   89e6e:	68ba      	ldr	r2, [r7, #8]
   89e70:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
   89e74:	4013      	ands	r3, r2
   89e76:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
   89e78:	68fb      	ldr	r3, [r7, #12]
   89e7a:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
   89e7c:	68bb      	ldr	r3, [r7, #8]
   89e7e:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
   89e80:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
   89e84:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
   89e88:	60bb      	str	r3, [r7, #8]
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
   89e8a:	4b04      	ldr	r3, [pc, #16]	; (89e9c <NVIC_SetPriorityGrouping+0x44>)
   89e8c:	68ba      	ldr	r2, [r7, #8]
   89e8e:	60da      	str	r2, [r3, #12]
}
   89e90:	3714      	adds	r7, #20
   89e92:	46bd      	mov	sp, r7
   89e94:	f85d 7b04 	ldr.w	r7, [sp], #4
   89e98:	4770      	bx	lr
   89e9a:	bf00      	nop
   89e9c:	e000ed00 	.word	0xe000ed00

00089ea0 <NVIC_SetPriority>:

    \param [in]      IRQn  Number of the interrupt for set priority
    \param [in]  priority  Priority to set
 */
static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
   89ea0:	b480      	push	{r7}
   89ea2:	b083      	sub	sp, #12
   89ea4:	af00      	add	r7, sp, #0
   89ea6:	4603      	mov	r3, r0
   89ea8:	6039      	str	r1, [r7, #0]
   89eaa:	71fb      	strb	r3, [r7, #7]
  if(IRQn < 0) {
   89eac:	f997 3007 	ldrsb.w	r3, [r7, #7]
   89eb0:	2b00      	cmp	r3, #0
   89eb2:	da0b      	bge.n	89ecc <NVIC_SetPriority+0x2c>
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
   89eb4:	490d      	ldr	r1, [pc, #52]	; (89eec <NVIC_SetPriority+0x4c>)
   89eb6:	79fb      	ldrb	r3, [r7, #7]
   89eb8:	f003 030f 	and.w	r3, r3, #15
   89ebc:	3b04      	subs	r3, #4
   89ebe:	683a      	ldr	r2, [r7, #0]
   89ec0:	b2d2      	uxtb	r2, r2
   89ec2:	0112      	lsls	r2, r2, #4
   89ec4:	b2d2      	uxtb	r2, r2
   89ec6:	440b      	add	r3, r1
   89ec8:	761a      	strb	r2, [r3, #24]
   89eca:	e009      	b.n	89ee0 <NVIC_SetPriority+0x40>
  else {
    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts  */
   89ecc:	4908      	ldr	r1, [pc, #32]	; (89ef0 <NVIC_SetPriority+0x50>)
   89ece:	f997 3007 	ldrsb.w	r3, [r7, #7]
   89ed2:	683a      	ldr	r2, [r7, #0]
   89ed4:	b2d2      	uxtb	r2, r2
   89ed6:	0112      	lsls	r2, r2, #4
   89ed8:	b2d2      	uxtb	r2, r2
   89eda:	440b      	add	r3, r1
   89edc:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
}
   89ee0:	370c      	adds	r7, #12
   89ee2:	46bd      	mov	sp, r7
   89ee4:	f85d 7b04 	ldr.w	r7, [sp], #4
   89ee8:	4770      	bx	lr
   89eea:	bf00      	nop
   89eec:	e000ed00 	.word	0xe000ed00
   89ef0:	e000e100 	.word	0xe000e100

00089ef4 <NVIC_GetPriority>:

    \param [in]   IRQn  Number of the interrupt for get priority
    \return             Interrupt Priority
 */
static __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{
   89ef4:	b480      	push	{r7}
   89ef6:	b083      	sub	sp, #12
   89ef8:	af00      	add	r7, sp, #0
   89efa:	4603      	mov	r3, r0
   89efc:	71fb      	strb	r3, [r7, #7]

  if(IRQn < 0) {
   89efe:	f997 3007 	ldrsb.w	r3, [r7, #7]
   89f02:	2b00      	cmp	r3, #0
   89f04:	da0a      	bge.n	89f1c <NVIC_GetPriority+0x28>
    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M  system interrupts */
   89f06:	4a0d      	ldr	r2, [pc, #52]	; (89f3c <NVIC_GetPriority+0x48>)
   89f08:	79fb      	ldrb	r3, [r7, #7]
   89f0a:	f003 030f 	and.w	r3, r3, #15
   89f0e:	3b04      	subs	r3, #4
   89f10:	4413      	add	r3, r2
   89f12:	7e1b      	ldrb	r3, [r3, #24]
   89f14:	b2db      	uxtb	r3, r3
   89f16:	091b      	lsrs	r3, r3, #4
   89f18:	b2db      	uxtb	r3, r3
   89f1a:	e008      	b.n	89f2e <NVIC_GetPriority+0x3a>
  else {
    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
   89f1c:	4a08      	ldr	r2, [pc, #32]	; (89f40 <NVIC_GetPriority+0x4c>)
   89f1e:	f997 3007 	ldrsb.w	r3, [r7, #7]
   89f22:	4413      	add	r3, r2
   89f24:	f893 3300 	ldrb.w	r3, [r3, #768]	; 0x300
   89f28:	b2db      	uxtb	r3, r3
   89f2a:	091b      	lsrs	r3, r3, #4
   89f2c:	b2db      	uxtb	r3, r3
}
   89f2e:	4618      	mov	r0, r3
   89f30:	370c      	adds	r7, #12
   89f32:	46bd      	mov	sp, r7
   89f34:	f85d 7b04 	ldr.w	r7, [sp], #4
   89f38:	4770      	bx	lr
   89f3a:	bf00      	nop
   89f3c:	e000ed00 	.word	0xe000ed00
   89f40:	e000e100 	.word	0xe000e100

00089f44 <main>:
/*		This is the function that is called when the reset handler		*/
/*		is triggered.													*/
/************************************************************************/

int main(void)
{
   89f44:	b580      	push	{r7, lr}
   89f46:	af00      	add	r7, sp, #0
	SAFE_MODE = 0;
   89f48:	4b0f      	ldr	r3, [pc, #60]	; (89f88 <main+0x44>)
   89f4a:	2200      	movs	r2, #0
   89f4c:	601a      	str	r2, [r3, #0]
	safe_mode();
   89f4e:	4b0f      	ldr	r3, [pc, #60]	; (89f8c <main+0x48>)
   89f50:	4798      	blx	r3
	
	/* Initialize Interrupt Priorities */
	prvInitializeInterruptPriorities();
   89f52:	4b0f      	ldr	r3, [pc, #60]	; (89f90 <main+0x4c>)
   89f54:	4798      	blx	r3
	
	/* Prepare the hardware */
	prvSetupHardware();
   89f56:	4b0f      	ldr	r3, [pc, #60]	; (89f94 <main+0x50>)
   89f58:	4798      	blx	r3
	
	/* Initialize Global FIFOs			*/
	prvInitializeFifos();
   89f5a:	4b0f      	ldr	r3, [pc, #60]	; (89f98 <main+0x54>)
   89f5c:	4798      	blx	r3
	
	/* Initialize Global variables		*/
	prvInitializeGlobalVars();
   89f5e:	4b0f      	ldr	r3, [pc, #60]	; (89f9c <main+0x58>)
   89f60:	4798      	blx	r3
		
	/* Create Tasks */
	//fdir_HANDLE = fdir();
	housekeeping_HANDLE = housekeep();
   89f62:	4b0f      	ldr	r3, [pc, #60]	; (89fa0 <main+0x5c>)
   89f64:	4798      	blx	r3
   89f66:	4602      	mov	r2, r0
   89f68:	4b0e      	ldr	r3, [pc, #56]	; (89fa4 <main+0x60>)
   89f6a:	601a      	str	r2, [r3, #0]
	opr_HANDLE = obc_packet_router();
   89f6c:	4b0e      	ldr	r3, [pc, #56]	; (89fa8 <main+0x64>)
   89f6e:	4798      	blx	r3
   89f70:	4602      	mov	r2, r0
   89f72:	4b0e      	ldr	r3, [pc, #56]	; (89fac <main+0x68>)
   89f74:	601a      	str	r2, [r3, #0]
	//time_manage_HANDLE = time_manage();
	//memory_manage_HANDLE = memory_manage();
	//eps_HANDLE = eps();
	//coms_HANDLE = coms();
	//pay_HANDLE = payload();
	wdt_reset_HANDLE = wdt_reset();
   89f76:	4b0e      	ldr	r3, [pc, #56]	; (89fb0 <main+0x6c>)
   89f78:	4798      	blx	r3
   89f7a:	4602      	mov	r2, r0
   89f7c:	4b0d      	ldr	r3, [pc, #52]	; (89fb4 <main+0x70>)
   89f7e:	601a      	str	r2, [r3, #0]
	/* Start Scheduler */
	vTaskStartScheduler();
   89f80:	4b0d      	ldr	r3, [pc, #52]	; (89fb8 <main+0x74>)
   89f82:	4798      	blx	r3
	
	/* If all is well, the scheduler will now be running, and the following
	line will never be reached.  If the following line does execute, then
	there was insufficient FreeRTOS heap memory available for tasks	to be created.*/
	
	while (1);
   89f84:	e7fe      	b.n	89f84 <main+0x40>
   89f86:	bf00      	nop
   89f88:	2007b438 	.word	0x2007b438
   89f8c:	00089fbd 	.word	0x00089fbd
   89f90:	0008a375 	.word	0x0008a375
   89f94:	0008a04d 	.word	0x0008a04d
   89f98:	0008a12d 	.word	0x0008a12d
   89f9c:	0008a3c1 	.word	0x0008a3c1
   89fa0:	00082b31 	.word	0x00082b31
   89fa4:	2007b160 	.word	0x2007b160
   89fa8:	00080a0d 	.word	0x00080a0d
   89fac:	2007b518 	.word	0x2007b518
   89fb0:	0008297d 	.word	0x0008297d
   89fb4:	2007ae00 	.word	0x2007ae00
   89fb8:	000875b1 	.word	0x000875b1

00089fbc <safe_mode>:
/* SAFE_MODE															*/
/* @Purpose: Before entering into regular operation mode, the OBC waits	*/
/* for a CAN message to take it out of safe mode.						*/
/************************************************************************/
static void safe_mode(void)
{
   89fbc:	b590      	push	{r4, r7, lr}
   89fbe:	b087      	sub	sp, #28
   89fc0:	af02      	add	r7, sp, #8
	extern void SystemCoreClockUpdate(void);
	uint32_t timeout = 80000000, low=0;
   89fc2:	4b19      	ldr	r3, [pc, #100]	; (8a028 <safe_mode+0x6c>)
   89fc4:	60fb      	str	r3, [r7, #12]
   89fc6:	2300      	movs	r3, #0
   89fc8:	60bb      	str	r3, [r7, #8]
	uint32_t* MEM_LOCATION;
	MEM_LOCATION = (uint32_t*)0x00080000;
   89fca:	f44f 2300 	mov.w	r3, #524288	; 0x80000
   89fce:	607b      	str	r3, [r7, #4]
	size_t SIZE = 10;
   89fd0:	230a      	movs	r3, #10
   89fd2:	603b      	str	r3, [r7, #0]
	/* ASF function to setup clocking. */
	sysclk_init();
   89fd4:	4b15      	ldr	r3, [pc, #84]	; (8a02c <safe_mode+0x70>)
   89fd6:	4798      	blx	r3
	
	/* Ensure all priority bits are assigned as preemption priority bits. */
	NVIC_SetPriorityGrouping(0);
   89fd8:	2000      	movs	r0, #0
   89fda:	4b15      	ldr	r3, [pc, #84]	; (8a030 <safe_mode+0x74>)
   89fdc:	4798      	blx	r3
	
	/* Initializes WDT, CAN, and interrupts. */
	safe_board_init();
   89fde:	4b15      	ldr	r3, [pc, #84]	; (8a034 <safe_mode+0x78>)
   89fe0:	4798      	blx	r3
	
	/* Initialize Mutexes */
	prvInitializeMutexes();
   89fe2:	4b15      	ldr	r3, [pc, #84]	; (8a038 <safe_mode+0x7c>)
   89fe4:	4798      	blx	r3
	
	/* Initialize CAN-related registers and functions for tests and operation */
	can_initialize();
   89fe6:	4b15      	ldr	r3, [pc, #84]	; (8a03c <safe_mode+0x80>)
   89fe8:	4798      	blx	r3

	low = fletcher32(MEM_LOCATION, SIZE);
   89fea:	6878      	ldr	r0, [r7, #4]
   89fec:	6839      	ldr	r1, [r7, #0]
   89fee:	4b14      	ldr	r3, [pc, #80]	; (8a040 <safe_mode+0x84>)
   89ff0:	4798      	blx	r3
   89ff2:	60b8      	str	r0, [r7, #8]
	
	while(SAFE_MODE)
   89ff4:	e010      	b.n	8a018 <safe_mode+0x5c>
	{
		if(timeout--)
   89ff6:	68fb      	ldr	r3, [r7, #12]
   89ff8:	1e5a      	subs	r2, r3, #1
   89ffa:	60fa      	str	r2, [r7, #12]
   89ffc:	2b00      	cmp	r3, #0
   89ffe:	d00b      	beq.n	8a018 <safe_mode+0x5c>
		{
			send_can_command(low, 0x00, OBC_ID, COMS_ID, SAFE_MODE_TYPE, COMMAND_PRIO);
   8a000:	2315      	movs	r3, #21
   8a002:	9300      	str	r3, [sp, #0]
   8a004:	2319      	movs	r3, #25
   8a006:	9301      	str	r3, [sp, #4]
   8a008:	68b8      	ldr	r0, [r7, #8]
   8a00a:	2100      	movs	r1, #0
   8a00c:	2203      	movs	r2, #3
   8a00e:	2300      	movs	r3, #0
   8a010:	4c0c      	ldr	r4, [pc, #48]	; (8a044 <safe_mode+0x88>)
   8a012:	47a0      	blx	r4
			timeout = 80000000;
   8a014:	4b04      	ldr	r3, [pc, #16]	; (8a028 <safe_mode+0x6c>)
   8a016:	60fb      	str	r3, [r7, #12]
	/* Initialize CAN-related registers and functions for tests and operation */
	can_initialize();

	low = fletcher32(MEM_LOCATION, SIZE);
	
	while(SAFE_MODE)
   8a018:	4b0b      	ldr	r3, [pc, #44]	; (8a048 <safe_mode+0x8c>)
   8a01a:	681b      	ldr	r3, [r3, #0]
   8a01c:	2b00      	cmp	r3, #0
   8a01e:	d1ea      	bne.n	89ff6 <safe_mode+0x3a>
		{
			send_can_command(low, 0x00, OBC_ID, COMS_ID, SAFE_MODE_TYPE, COMMAND_PRIO);
			timeout = 80000000;
		}
	}
}
   8a020:	3714      	adds	r7, #20
   8a022:	46bd      	mov	sp, r7
   8a024:	bd90      	pop	{r4, r7, pc}
   8a026:	bf00      	nop
   8a028:	04c4b400 	.word	0x04c4b400
   8a02c:	00084b85 	.word	0x00084b85
   8a030:	00089e59 	.word	0x00089e59
   8a034:	00084bed 	.word	0x00084bed
   8a038:	0008a08d 	.word	0x0008a08d
   8a03c:	000896d1 	.word	0x000896d1
   8a040:	00082a09 	.word	0x00082a09
   8a044:	000891d1 	.word	0x000891d1
   8a048:	2007b438 	.word	0x2007b438

0008a04c <prvSetupHardware>:
/************************************************************************/
/* PRVSETUPHARDWARE														*/
/* @Purpose: sets up hardware/pin values and initializes drivers		*/
/************************************************************************/
static void prvSetupHardware(void)
{
   8a04c:	b580      	push	{r7, lr}
   8a04e:	af00      	add	r7, sp, #0
	/* Perform the remainder of board initialization functions. */
	board_init();
   8a050:	4b07      	ldr	r3, [pc, #28]	; (8a070 <prvSetupHardware+0x24>)
   8a052:	4798      	blx	r3

	/* Perform any configuration necessary to use the ParTest LED output functions. */
	vParTestInitialise();
   8a054:	4b07      	ldr	r3, [pc, #28]	; (8a074 <prvSetupHardware+0x28>)
   8a056:	4798      	blx	r3
		
	/* Initialize USART-related registers and functions. */
	usart_initialize();
   8a058:	4b07      	ldr	r3, [pc, #28]	; (8a078 <prvSetupHardware+0x2c>)
   8a05a:	4798      	blx	r3
	
	/* Initialize SPI related registers and functions. */
	spi_initialize();
   8a05c:	4b07      	ldr	r3, [pc, #28]	; (8a07c <prvSetupHardware+0x30>)
   8a05e:	4798      	blx	r3
	
	/* Initialize RTC registers and set the default initial time. */
	rtc_init(DS3234_INTCN);
   8a060:	2004      	movs	r0, #4
   8a062:	4b07      	ldr	r3, [pc, #28]	; (8a080 <prvSetupHardware+0x34>)
   8a064:	4798      	blx	r3
	
	/* Initialize the SPI memory chips	*/
	spimem_initialize();
   8a066:	4b07      	ldr	r3, [pc, #28]	; (8a084 <prvSetupHardware+0x38>)
   8a068:	4798      	blx	r3
	
	/* Initialize the Camera */
	//camera_initialize();
	
	can_initialize();
   8a06a:	4b07      	ldr	r3, [pc, #28]	; (8a088 <prvSetupHardware+0x3c>)
   8a06c:	4798      	blx	r3
}
   8a06e:	bd80      	pop	{r7, pc}
   8a070:	00084c41 	.word	0x00084c41
   8a074:	0008374d 	.word	0x0008374d
   8a078:	00084831 	.word	0x00084831
   8a07c:	0008421d 	.word	0x0008421d
   8a080:	00083849 	.word	0x00083849
   8a084:	00083ab1 	.word	0x00083ab1
   8a088:	000896d1 	.word	0x000896d1

0008a08c <prvInitializeMutexes>:
/************************************************************************/
/* PRVINITIALIZEMUTEXES													*/
/* @Purpose: initializes mutexes used for resource management			*/
/************************************************************************/
static void prvInitializeMutexes(void)
{	
   8a08c:	b598      	push	{r3, r4, r7, lr}
   8a08e:	af00      	add	r7, sp, #0
	Can0_Mutex = xSemaphoreCreateBinary();
   8a090:	2001      	movs	r0, #1
   8a092:	2100      	movs	r1, #0
   8a094:	2203      	movs	r2, #3
   8a096:	4b1f      	ldr	r3, [pc, #124]	; (8a114 <prvInitializeMutexes+0x88>)
   8a098:	4798      	blx	r3
   8a09a:	4602      	mov	r2, r0
   8a09c:	4b1e      	ldr	r3, [pc, #120]	; (8a118 <prvInitializeMutexes+0x8c>)
   8a09e:	601a      	str	r2, [r3, #0]
	Spi0_Mutex = xSemaphoreCreateBinary();
   8a0a0:	2001      	movs	r0, #1
   8a0a2:	2100      	movs	r1, #0
   8a0a4:	2203      	movs	r2, #3
   8a0a6:	4b1b      	ldr	r3, [pc, #108]	; (8a114 <prvInitializeMutexes+0x88>)
   8a0a8:	4798      	blx	r3
   8a0aa:	4602      	mov	r2, r0
   8a0ac:	4b1b      	ldr	r3, [pc, #108]	; (8a11c <prvInitializeMutexes+0x90>)
   8a0ae:	601a      	str	r2, [r3, #0]
	Highsev_Mutex = xSemaphoreCreateBinary();
   8a0b0:	2001      	movs	r0, #1
   8a0b2:	2100      	movs	r1, #0
   8a0b4:	2203      	movs	r2, #3
   8a0b6:	4b17      	ldr	r3, [pc, #92]	; (8a114 <prvInitializeMutexes+0x88>)
   8a0b8:	4798      	blx	r3
   8a0ba:	4602      	mov	r2, r0
   8a0bc:	4b18      	ldr	r3, [pc, #96]	; (8a120 <prvInitializeMutexes+0x94>)
   8a0be:	601a      	str	r2, [r3, #0]
	Lowsev_Mutex = xSemaphoreCreateBinary();
   8a0c0:	2001      	movs	r0, #1
   8a0c2:	2100      	movs	r1, #0
   8a0c4:	2203      	movs	r2, #3
   8a0c6:	4b13      	ldr	r3, [pc, #76]	; (8a114 <prvInitializeMutexes+0x88>)
   8a0c8:	4798      	blx	r3
   8a0ca:	4602      	mov	r2, r0
   8a0cc:	4b15      	ldr	r3, [pc, #84]	; (8a124 <prvInitializeMutexes+0x98>)
   8a0ce:	601a      	str	r2, [r3, #0]

	xSemaphoreGive(Can0_Mutex);
   8a0d0:	4b11      	ldr	r3, [pc, #68]	; (8a118 <prvInitializeMutexes+0x8c>)
   8a0d2:	681b      	ldr	r3, [r3, #0]
   8a0d4:	4618      	mov	r0, r3
   8a0d6:	2100      	movs	r1, #0
   8a0d8:	2200      	movs	r2, #0
   8a0da:	2300      	movs	r3, #0
   8a0dc:	4c12      	ldr	r4, [pc, #72]	; (8a128 <prvInitializeMutexes+0x9c>)
   8a0de:	47a0      	blx	r4
	xSemaphoreGive(Spi0_Mutex);
   8a0e0:	4b0e      	ldr	r3, [pc, #56]	; (8a11c <prvInitializeMutexes+0x90>)
   8a0e2:	681b      	ldr	r3, [r3, #0]
   8a0e4:	4618      	mov	r0, r3
   8a0e6:	2100      	movs	r1, #0
   8a0e8:	2200      	movs	r2, #0
   8a0ea:	2300      	movs	r3, #0
   8a0ec:	4c0e      	ldr	r4, [pc, #56]	; (8a128 <prvInitializeMutexes+0x9c>)
   8a0ee:	47a0      	blx	r4
	xSemaphoreGive(Highsev_Mutex);
   8a0f0:	4b0b      	ldr	r3, [pc, #44]	; (8a120 <prvInitializeMutexes+0x94>)
   8a0f2:	681b      	ldr	r3, [r3, #0]
   8a0f4:	4618      	mov	r0, r3
   8a0f6:	2100      	movs	r1, #0
   8a0f8:	2200      	movs	r2, #0
   8a0fa:	2300      	movs	r3, #0
   8a0fc:	4c0a      	ldr	r4, [pc, #40]	; (8a128 <prvInitializeMutexes+0x9c>)
   8a0fe:	47a0      	blx	r4
	xSemaphoreGive(Lowsev_Mutex);
   8a100:	4b08      	ldr	r3, [pc, #32]	; (8a124 <prvInitializeMutexes+0x98>)
   8a102:	681b      	ldr	r3, [r3, #0]
   8a104:	4618      	mov	r0, r3
   8a106:	2100      	movs	r1, #0
   8a108:	2200      	movs	r2, #0
   8a10a:	2300      	movs	r3, #0
   8a10c:	4c06      	ldr	r4, [pc, #24]	; (8a128 <prvInitializeMutexes+0x9c>)
   8a10e:	47a0      	blx	r4
	return;
   8a110:	bf00      	nop
}
   8a112:	bd98      	pop	{r3, r4, r7, pc}
   8a114:	00086a75 	.word	0x00086a75
   8a118:	2007b524 	.word	0x2007b524
   8a11c:	2007b504 	.word	0x2007b504
   8a120:	2007ade8 	.word	0x2007ade8
   8a124:	2007b4f0 	.word	0x2007b4f0
   8a128:	00086b01 	.word	0x00086b01

0008a12c <prvInitializeFifos>:
/************************************************************************/
/* PRVINITIALIZEFIFOS													*/
/* @Purpose: initializes fifos for CAN communication and PUS services	*/
/************************************************************************/
static void prvInitializeFifos(void)
{
   8a12c:	b580      	push	{r7, lr}
   8a12e:	b082      	sub	sp, #8
   8a130:	af00      	add	r7, sp, #0
	UBaseType_t fifo_length, item_size;
	/* Initialize global CAN FIFOs					*/
	fifo_length = 100;		// Max number of items in the FIFO.
   8a132:	2364      	movs	r3, #100	; 0x64
   8a134:	607b      	str	r3, [r7, #4]
	item_size = 4;			// Number of bytes in the items.
   8a136:	2304      	movs	r3, #4
   8a138:	603b      	str	r3, [r7, #0]
		
	/* This corresponds to 400 bytes, or 50 CAN messages */
	can_data_fifo = xQueueCreate(fifo_length, item_size);
   8a13a:	6878      	ldr	r0, [r7, #4]
   8a13c:	6839      	ldr	r1, [r7, #0]
   8a13e:	2200      	movs	r2, #0
   8a140:	4b72      	ldr	r3, [pc, #456]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a142:	4798      	blx	r3
   8a144:	4602      	mov	r2, r0
   8a146:	4b72      	ldr	r3, [pc, #456]	; (8a310 <prvInitializeFifos+0x1e4>)
   8a148:	601a      	str	r2, [r3, #0]
	can_msg_fifo = xQueueCreate(fifo_length, item_size);
   8a14a:	6878      	ldr	r0, [r7, #4]
   8a14c:	6839      	ldr	r1, [r7, #0]
   8a14e:	2200      	movs	r2, #0
   8a150:	4b6e      	ldr	r3, [pc, #440]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a152:	4798      	blx	r3
   8a154:	4602      	mov	r2, r0
   8a156:	4b6f      	ldr	r3, [pc, #444]	; (8a314 <prvInitializeFifos+0x1e8>)
   8a158:	601a      	str	r2, [r3, #0]
	can_hk_fifo = xQueueCreate(fifo_length, item_size);
   8a15a:	6878      	ldr	r0, [r7, #4]
   8a15c:	6839      	ldr	r1, [r7, #0]
   8a15e:	2200      	movs	r2, #0
   8a160:	4b6a      	ldr	r3, [pc, #424]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a162:	4798      	blx	r3
   8a164:	4602      	mov	r2, r0
   8a166:	4b6c      	ldr	r3, [pc, #432]	; (8a318 <prvInitializeFifos+0x1ec>)
   8a168:	601a      	str	r2, [r3, #0]
	can_com_fifo = xQueueCreate(fifo_length, item_size);
   8a16a:	6878      	ldr	r0, [r7, #4]
   8a16c:	6839      	ldr	r1, [r7, #0]
   8a16e:	2200      	movs	r2, #0
   8a170:	4b66      	ldr	r3, [pc, #408]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a172:	4798      	blx	r3
   8a174:	4602      	mov	r2, r0
   8a176:	4b69      	ldr	r3, [pc, #420]	; (8a31c <prvInitializeFifos+0x1f0>)
   8a178:	601a      	str	r2, [r3, #0]
	fifo_length = 152;
   8a17a:	2398      	movs	r3, #152	; 0x98
   8a17c:	607b      	str	r3, [r7, #4]
	tc_msg_fifo = xQueueCreate(fifo_length, item_size);
   8a17e:	6878      	ldr	r0, [r7, #4]
   8a180:	6839      	ldr	r1, [r7, #0]
   8a182:	2200      	movs	r2, #0
   8a184:	4b61      	ldr	r3, [pc, #388]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a186:	4798      	blx	r3
   8a188:	4602      	mov	r2, r0
   8a18a:	4b65      	ldr	r3, [pc, #404]	; (8a320 <prvInitializeFifos+0x1f4>)
   8a18c:	601a      	str	r2, [r3, #0]
	fifo_length = 100;
   8a18e:	2364      	movs	r3, #100	; 0x64
   8a190:	607b      	str	r3, [r7, #4]
	event_msg_fifo = xQueueCreate(fifo_length, item_size);
   8a192:	6878      	ldr	r0, [r7, #4]
   8a194:	6839      	ldr	r1, [r7, #0]
   8a196:	2200      	movs	r2, #0
   8a198:	4b5c      	ldr	r3, [pc, #368]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a19a:	4798      	blx	r3
   8a19c:	4602      	mov	r2, r0
   8a19e:	4b61      	ldr	r3, [pc, #388]	; (8a324 <prvInitializeFifos+0x1f8>)
   8a1a0:	601a      	str	r2, [r3, #0]

	/* Initialize global PUS Packet FIFOs			*/
	fifo_length = 4;			// Max number of items in the FIFO.
   8a1a2:	2304      	movs	r3, #4
   8a1a4:	607b      	str	r3, [r7, #4]
	item_size = 147;			// Number of bytes in the items
   8a1a6:	2393      	movs	r3, #147	; 0x93
   8a1a8:	603b      	str	r3, [r7, #0]
	hk_to_obc_fifo = xQueueCreate(fifo_length, item_size);
   8a1aa:	6878      	ldr	r0, [r7, #4]
   8a1ac:	6839      	ldr	r1, [r7, #0]
   8a1ae:	2200      	movs	r2, #0
   8a1b0:	4b56      	ldr	r3, [pc, #344]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a1b2:	4798      	blx	r3
   8a1b4:	4602      	mov	r2, r0
   8a1b6:	4b5c      	ldr	r3, [pc, #368]	; (8a328 <prvInitializeFifos+0x1fc>)
   8a1b8:	601a      	str	r2, [r3, #0]
	mem_to_obc_fifo = xQueueCreate(fifo_length, item_size);
   8a1ba:	6878      	ldr	r0, [r7, #4]
   8a1bc:	6839      	ldr	r1, [r7, #0]
   8a1be:	2200      	movs	r2, #0
   8a1c0:	4b52      	ldr	r3, [pc, #328]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a1c2:	4798      	blx	r3
   8a1c4:	4602      	mov	r2, r0
   8a1c6:	4b59      	ldr	r3, [pc, #356]	; (8a32c <prvInitializeFifos+0x200>)
   8a1c8:	601a      	str	r2, [r3, #0]
	sched_to_obc_fifo = xQueueCreate(fifo_length, item_size);
   8a1ca:	6878      	ldr	r0, [r7, #4]
   8a1cc:	6839      	ldr	r1, [r7, #0]
   8a1ce:	2200      	movs	r2, #0
   8a1d0:	4b4e      	ldr	r3, [pc, #312]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a1d2:	4798      	blx	r3
   8a1d4:	4602      	mov	r2, r0
   8a1d6:	4b56      	ldr	r3, [pc, #344]	; (8a330 <prvInitializeFifos+0x204>)
   8a1d8:	601a      	str	r2, [r3, #0]
	fdir_to_obc_fifo = xQueueCreate(fifo_length, item_size);
   8a1da:	6878      	ldr	r0, [r7, #4]
   8a1dc:	6839      	ldr	r1, [r7, #0]
   8a1de:	2200      	movs	r2, #0
   8a1e0:	4b4a      	ldr	r3, [pc, #296]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a1e2:	4798      	blx	r3
   8a1e4:	4602      	mov	r2, r0
   8a1e6:	4b53      	ldr	r3, [pc, #332]	; (8a334 <prvInitializeFifos+0x208>)
   8a1e8:	601a      	str	r2, [r3, #0]
	eps_to_obc_fifo = xQueueCreate(fifo_length, item_size);
   8a1ea:	6878      	ldr	r0, [r7, #4]
   8a1ec:	6839      	ldr	r1, [r7, #0]
   8a1ee:	2200      	movs	r2, #0
   8a1f0:	4b46      	ldr	r3, [pc, #280]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a1f2:	4798      	blx	r3
   8a1f4:	4602      	mov	r2, r0
   8a1f6:	4b50      	ldr	r3, [pc, #320]	; (8a338 <prvInitializeFifos+0x20c>)
   8a1f8:	601a      	str	r2, [r3, #0]
	fdir_fifo_buffer = xQueueCreate(fifo_length, item_size);
   8a1fa:	6878      	ldr	r0, [r7, #4]
   8a1fc:	6839      	ldr	r1, [r7, #0]
   8a1fe:	2200      	movs	r2, #0
   8a200:	4b42      	ldr	r3, [pc, #264]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a202:	4798      	blx	r3
   8a204:	4602      	mov	r2, r0
   8a206:	4b4d      	ldr	r3, [pc, #308]	; (8a33c <prvInitializeFifos+0x210>)
   8a208:	601a      	str	r2, [r3, #0]
	fifo_length = 4;
   8a20a:	2304      	movs	r3, #4
   8a20c:	607b      	str	r3, [r7, #4]
	item_size = 10;
   8a20e:	230a      	movs	r3, #10
   8a210:	603b      	str	r3, [r7, #0]
	time_to_obc_fifo = xQueueCreate(fifo_length, item_size);
   8a212:	6878      	ldr	r0, [r7, #4]
   8a214:	6839      	ldr	r1, [r7, #0]
   8a216:	2200      	movs	r2, #0
   8a218:	4b3c      	ldr	r3, [pc, #240]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a21a:	4798      	blx	r3
   8a21c:	4602      	mov	r2, r0
   8a21e:	4b48      	ldr	r3, [pc, #288]	; (8a340 <prvInitializeFifos+0x214>)
   8a220:	601a      	str	r2, [r3, #0]

	/* Initialize global Command FIFOs				*/
	fifo_length = 4;
   8a222:	2304      	movs	r3, #4
   8a224:	607b      	str	r3, [r7, #4]
	item_size = 147;
   8a226:	2393      	movs	r3, #147	; 0x93
   8a228:	603b      	str	r3, [r7, #0]
	obc_to_hk_fifo = xQueueCreate(fifo_length, item_size);
   8a22a:	6878      	ldr	r0, [r7, #4]
   8a22c:	6839      	ldr	r1, [r7, #0]
   8a22e:	2200      	movs	r2, #0
   8a230:	4b36      	ldr	r3, [pc, #216]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a232:	4798      	blx	r3
   8a234:	4602      	mov	r2, r0
   8a236:	4b43      	ldr	r3, [pc, #268]	; (8a344 <prvInitializeFifos+0x218>)
   8a238:	601a      	str	r2, [r3, #0]
	obc_to_mem_fifo = xQueueCreate(fifo_length, item_size);
   8a23a:	6878      	ldr	r0, [r7, #4]
   8a23c:	6839      	ldr	r1, [r7, #0]
   8a23e:	2200      	movs	r2, #0
   8a240:	4b32      	ldr	r3, [pc, #200]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a242:	4798      	blx	r3
   8a244:	4602      	mov	r2, r0
   8a246:	4b40      	ldr	r3, [pc, #256]	; (8a348 <prvInitializeFifos+0x21c>)
   8a248:	601a      	str	r2, [r3, #0]
	obc_to_sched_fifo = xQueueCreate(fifo_length, item_size);
   8a24a:	6878      	ldr	r0, [r7, #4]
   8a24c:	6839      	ldr	r1, [r7, #0]
   8a24e:	2200      	movs	r2, #0
   8a250:	4b2e      	ldr	r3, [pc, #184]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a252:	4798      	blx	r3
   8a254:	4602      	mov	r2, r0
   8a256:	4b3d      	ldr	r3, [pc, #244]	; (8a34c <prvInitializeFifos+0x220>)
   8a258:	601a      	str	r2, [r3, #0]
	obc_to_fdir_fifo = xQueueCreate(fifo_length, item_size);
   8a25a:	6878      	ldr	r0, [r7, #4]
   8a25c:	6839      	ldr	r1, [r7, #0]
   8a25e:	2200      	movs	r2, #0
   8a260:	4b2a      	ldr	r3, [pc, #168]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a262:	4798      	blx	r3
   8a264:	4602      	mov	r2, r0
   8a266:	4b3a      	ldr	r3, [pc, #232]	; (8a350 <prvInitializeFifos+0x224>)
   8a268:	601a      	str	r2, [r3, #0]
	fifo_length = 2;
   8a26a:	2302      	movs	r3, #2
   8a26c:	607b      	str	r3, [r7, #4]
	sched_to_hk_fifo = xQueueCreate(fifo_length, item_size);
   8a26e:	6878      	ldr	r0, [r7, #4]
   8a270:	6839      	ldr	r1, [r7, #0]
   8a272:	2200      	movs	r2, #0
   8a274:	4b25      	ldr	r3, [pc, #148]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a276:	4798      	blx	r3
   8a278:	4602      	mov	r2, r0
   8a27a:	4b36      	ldr	r3, [pc, #216]	; (8a354 <prvInitializeFifos+0x228>)
   8a27c:	601a      	str	r2, [r3, #0]
	sched_to_memory_fifo = xQueueCreate(fifo_length, item_size);
   8a27e:	6878      	ldr	r0, [r7, #4]
   8a280:	6839      	ldr	r1, [r7, #0]
   8a282:	2200      	movs	r2, #0
   8a284:	4b21      	ldr	r3, [pc, #132]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a286:	4798      	blx	r3
   8a288:	4602      	mov	r2, r0
   8a28a:	4b33      	ldr	r3, [pc, #204]	; (8a358 <prvInitializeFifos+0x22c>)
   8a28c:	601a      	str	r2, [r3, #0]
	sched_to_time_fifo = xQueueCreate(fifo_length, item_size);
   8a28e:	6878      	ldr	r0, [r7, #4]
   8a290:	6839      	ldr	r1, [r7, #0]
   8a292:	2200      	movs	r2, #0
   8a294:	4b1d      	ldr	r3, [pc, #116]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a296:	4798      	blx	r3
   8a298:	4602      	mov	r2, r0
   8a29a:	4b30      	ldr	r3, [pc, #192]	; (8a35c <prvInitializeFifos+0x230>)
   8a29c:	601a      	str	r2, [r3, #0]
	fifo_length	 = 4;
   8a29e:	2304      	movs	r3, #4
   8a2a0:	607b      	str	r3, [r7, #4]
	item_size = 10;
   8a2a2:	230a      	movs	r3, #10
   8a2a4:	603b      	str	r3, [r7, #0]
	obc_to_time_fifo = xQueueCreate(fifo_length, item_size);
   8a2a6:	6878      	ldr	r0, [r7, #4]
   8a2a8:	6839      	ldr	r1, [r7, #0]
   8a2aa:	2200      	movs	r2, #0
   8a2ac:	4b17      	ldr	r3, [pc, #92]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a2ae:	4798      	blx	r3
   8a2b0:	4602      	mov	r2, r0
   8a2b2:	4b2b      	ldr	r3, [pc, #172]	; (8a360 <prvInitializeFifos+0x234>)
   8a2b4:	601a      	str	r2, [r3, #0]
	item_size = 152;	
   8a2b6:	2398      	movs	r3, #152	; 0x98
   8a2b8:	603b      	str	r3, [r7, #0]
	high_sev_to_fdir_fifo = xQueueCreate(fifo_length, item_size);
   8a2ba:	6878      	ldr	r0, [r7, #4]
   8a2bc:	6839      	ldr	r1, [r7, #0]
   8a2be:	2200      	movs	r2, #0
   8a2c0:	4b12      	ldr	r3, [pc, #72]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a2c2:	4798      	blx	r3
   8a2c4:	4602      	mov	r2, r0
   8a2c6:	4b27      	ldr	r3, [pc, #156]	; (8a364 <prvInitializeFifos+0x238>)
   8a2c8:	601a      	str	r2, [r3, #0]
	low_sev_to_fdir_fifo = xQueueCreate(fifo_length, item_size);
   8a2ca:	6878      	ldr	r0, [r7, #4]
   8a2cc:	6839      	ldr	r1, [r7, #0]
   8a2ce:	2200      	movs	r2, #0
   8a2d0:	4b0e      	ldr	r3, [pc, #56]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a2d2:	4798      	blx	r3
   8a2d4:	4602      	mov	r2, r0
   8a2d6:	4b24      	ldr	r3, [pc, #144]	; (8a368 <prvInitializeFifos+0x23c>)
   8a2d8:	601a      	str	r2, [r3, #0]

	/* Initialize PUS packet buffers				*/
	fifo_length = 10;
   8a2da:	230a      	movs	r3, #10
   8a2dc:	607b      	str	r3, [r7, #4]
	item_size = 152;
   8a2de:	2398      	movs	r3, #152	; 0x98
   8a2e0:	603b      	str	r3, [r7, #0]
	tc_buffer = xQueueCreate(fifo_length, item_size);
   8a2e2:	6878      	ldr	r0, [r7, #4]
   8a2e4:	6839      	ldr	r1, [r7, #0]
   8a2e6:	2200      	movs	r2, #0
   8a2e8:	4b08      	ldr	r3, [pc, #32]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a2ea:	4798      	blx	r3
   8a2ec:	4602      	mov	r2, r0
   8a2ee:	4b1f      	ldr	r3, [pc, #124]	; (8a36c <prvInitializeFifos+0x240>)
   8a2f0:	601a      	str	r2, [r3, #0]
	tm_buffer = xQueueCreate(fifo_length, item_size);
   8a2f2:	6878      	ldr	r0, [r7, #4]
   8a2f4:	6839      	ldr	r1, [r7, #0]
   8a2f6:	2200      	movs	r2, #0
   8a2f8:	4b04      	ldr	r3, [pc, #16]	; (8a30c <prvInitializeFifos+0x1e0>)
   8a2fa:	4798      	blx	r3
   8a2fc:	4602      	mov	r2, r0
   8a2fe:	4b1c      	ldr	r3, [pc, #112]	; (8a370 <prvInitializeFifos+0x244>)
   8a300:	601a      	str	r2, [r3, #0]
	
	return;
   8a302:	bf00      	nop
}
   8a304:	3708      	adds	r7, #8
   8a306:	46bd      	mov	sp, r7
   8a308:	bd80      	pop	{r7, pc}
   8a30a:	bf00      	nop
   8a30c:	00086a75 	.word	0x00086a75
   8a310:	2007b12c 	.word	0x2007b12c
   8a314:	2007b548 	.word	0x2007b548
   8a318:	2007adf4 	.word	0x2007adf4
   8a31c:	2007b50c 	.word	0x2007b50c
   8a320:	2007b4e8 	.word	0x2007b4e8
   8a324:	2007b4fc 	.word	0x2007b4fc
   8a328:	2007b38c 	.word	0x2007b38c
   8a32c:	2007d57c 	.word	0x2007d57c
   8a330:	2007b52c 	.word	0x2007b52c
   8a334:	2007ae30 	.word	0x2007ae30
   8a338:	2007b4d4 	.word	0x2007b4d4
   8a33c:	2007b4d8 	.word	0x2007b4d8
   8a340:	2007b430 	.word	0x2007b430
   8a344:	2007adc4 	.word	0x2007adc4
   8a348:	2007b534 	.word	0x2007b534
   8a34c:	2007b110 	.word	0x2007b110
   8a350:	2007adc8 	.word	0x2007adc8
   8a354:	2007b0fc 	.word	0x2007b0fc
   8a358:	2007b128 	.word	0x2007b128
   8a35c:	2007b510 	.word	0x2007b510
   8a360:	2007d580 	.word	0x2007d580
   8a364:	2007b51c 	.word	0x2007b51c
   8a368:	2007b54c 	.word	0x2007b54c
   8a36c:	2007b4f8 	.word	0x2007b4f8
   8a370:	2007b500 	.word	0x2007b500

0008a374 <prvInitializeInterruptPriorities>:
/************************************************************************/
/* PRVINITIALIZEINTERRUPTPRIORITIES										*/
/* @Purpose: initializes relevant interrupt priorities					*/
/************************************************************************/
static void prvInitializeInterruptPriorities(void)
{
   8a374:	b580      	push	{r7, lr}
   8a376:	b082      	sub	sp, #8
   8a378:	af00      	add	r7, sp, #0
	uint32_t priority = 11;
   8a37a:	230b      	movs	r3, #11
   8a37c:	607b      	str	r3, [r7, #4]
	IRQn_Type can1_int_num = (IRQn_Type)44;
   8a37e:	232c      	movs	r3, #44	; 0x2c
   8a380:	70fb      	strb	r3, [r7, #3]
	IRQn_Type can0_int_num = (IRQn_Type)43;
   8a382:	232b      	movs	r3, #43	; 0x2b
   8a384:	70bb      	strb	r3, [r7, #2]
		
	NVIC_SetPriority(can1_int_num, priority);
   8a386:	f997 3003 	ldrsb.w	r3, [r7, #3]
   8a38a:	4618      	mov	r0, r3
   8a38c:	6879      	ldr	r1, [r7, #4]
   8a38e:	4b0a      	ldr	r3, [pc, #40]	; (8a3b8 <prvInitializeInterruptPriorities+0x44>)
   8a390:	4798      	blx	r3
	
	priority = 12;	
   8a392:	230c      	movs	r3, #12
   8a394:	607b      	str	r3, [r7, #4]
	NVIC_SetPriority(can0_int_num, priority);
   8a396:	f997 3002 	ldrsb.w	r3, [r7, #2]
   8a39a:	4618      	mov	r0, r3
   8a39c:	6879      	ldr	r1, [r7, #4]
   8a39e:	4b06      	ldr	r3, [pc, #24]	; (8a3b8 <prvInitializeInterruptPriorities+0x44>)
   8a3a0:	4798      	blx	r3
	
	priority = NVIC_GetPriority(can1_int_num);
   8a3a2:	f997 3003 	ldrsb.w	r3, [r7, #3]
   8a3a6:	4618      	mov	r0, r3
   8a3a8:	4b04      	ldr	r3, [pc, #16]	; (8a3bc <prvInitializeInterruptPriorities+0x48>)
   8a3aa:	4798      	blx	r3
   8a3ac:	6078      	str	r0, [r7, #4]
	
	return;
   8a3ae:	bf00      	nop
}
   8a3b0:	3708      	adds	r7, #8
   8a3b2:	46bd      	mov	sp, r7
   8a3b4:	bd80      	pop	{r7, pc}
   8a3b6:	bf00      	nop
   8a3b8:	00089ea1 	.word	0x00089ea1
   8a3bc:	00089ef5 	.word	0x00089ef5

0008a3c0 <prvInitializeGlobalVars>:
/************************************************************************/
/* PRVINITIALIZEGLOBALVARS	                                            */
/* @Purpose: This function initializes all global variables.			*/
/************************************************************************/
static void prvInitializeGlobalVars(void)
{
   8a3c0:	b480      	push	{r7}
   8a3c2:	b083      	sub	sp, #12
   8a3c4:	af00      	add	r7, sp, #0
	uint8_t i;
	
	/* Global Mode Variables */
	SAFE_MODE = 0;
   8a3c6:	4b82      	ldr	r3, [pc, #520]	; (8a5d0 <prvInitializeGlobalVars+0x210>)
   8a3c8:	2200      	movs	r2, #0
   8a3ca:	601a      	str	r2, [r3, #0]
	LOW_POWER_MODE = 0;
   8a3cc:	4b81      	ldr	r3, [pc, #516]	; (8a5d4 <prvInitializeGlobalVars+0x214>)
   8a3ce:	2200      	movs	r2, #0
   8a3d0:	601a      	str	r2, [r3, #0]
	COMS_TAKEOVER_MODE = 0;
   8a3d2:	4b81      	ldr	r3, [pc, #516]	; (8a5d8 <prvInitializeGlobalVars+0x218>)
   8a3d4:	2200      	movs	r2, #0
   8a3d6:	601a      	str	r2, [r3, #0]
	COMS_PAUSED = 0;
   8a3d8:	4b80      	ldr	r3, [pc, #512]	; (8a5dc <prvInitializeGlobalVars+0x21c>)
   8a3da:	2200      	movs	r2, #0
   8a3dc:	601a      	str	r2, [r3, #0]
	PAY_PAUSED = 0;
   8a3de:	4b80      	ldr	r3, [pc, #512]	; (8a5e0 <prvInitializeGlobalVars+0x220>)
   8a3e0:	2200      	movs	r2, #0
   8a3e2:	601a      	str	r2, [r3, #0]
	EPS_PAUSED = 0;
   8a3e4:	4b7f      	ldr	r3, [pc, #508]	; (8a5e4 <prvInitializeGlobalVars+0x224>)
   8a3e6:	2200      	movs	r2, #0
   8a3e8:	601a      	str	r2, [r3, #0]
	INTERNAL_MEMORY_FALLBACK_MODE = 0;
   8a3ea:	4b7f      	ldr	r3, [pc, #508]	; (8a5e8 <prvInitializeGlobalVars+0x228>)
   8a3ec:	2200      	movs	r2, #0
   8a3ee:	601a      	str	r2, [r3, #0]
	
	/* Initialize the data reception flags	*/
	glob_drf = 0;
   8a3f0:	4b7e      	ldr	r3, [pc, #504]	; (8a5ec <prvInitializeGlobalVars+0x22c>)
   8a3f2:	2200      	movs	r2, #0
   8a3f4:	701a      	strb	r2, [r3, #0]
	eps_data_receivedf = 0;
   8a3f6:	4b7e      	ldr	r3, [pc, #504]	; (8a5f0 <prvInitializeGlobalVars+0x230>)
   8a3f8:	2200      	movs	r2, #0
   8a3fa:	701a      	strb	r2, [r3, #0]
	coms_data_receivedf = 0;
   8a3fc:	4b7d      	ldr	r3, [pc, #500]	; (8a5f4 <prvInitializeGlobalVars+0x234>)
   8a3fe:	2200      	movs	r2, #0
   8a400:	701a      	strb	r2, [r3, #0]
	pay_data_receivedf = 0;
   8a402:	4b7d      	ldr	r3, [pc, #500]	; (8a5f8 <prvInitializeGlobalVars+0x238>)
   8a404:	2200      	movs	r2, #0
   8a406:	701a      	strb	r2, [r3, #0]
	opr_data_receivedf = 0;
   8a408:	4b7c      	ldr	r3, [pc, #496]	; (8a5fc <prvInitializeGlobalVars+0x23c>)
   8a40a:	2200      	movs	r2, #0
   8a40c:	701a      	strb	r2, [r3, #0]
	sched_data_receivedf = 0;
   8a40e:	4b7c      	ldr	r3, [pc, #496]	; (8a600 <prvInitializeGlobalVars+0x240>)
   8a410:	2200      	movs	r2, #0
   8a412:	701a      	strb	r2, [r3, #0]
	fdir_data_receivedf = 0;
   8a414:	4b7b      	ldr	r3, [pc, #492]	; (8a604 <prvInitializeGlobalVars+0x244>)
   8a416:	2200      	movs	r2, #0
   8a418:	701a      	strb	r2, [r3, #0]
		
	/* Initialize the message reception flag */
	glob_comsf = 0;
   8a41a:	4b7b      	ldr	r3, [pc, #492]	; (8a608 <prvInitializeGlobalVars+0x248>)
   8a41c:	2200      	movs	r2, #0
   8a41e:	701a      	strb	r2, [r3, #0]
		
	/* Initialize the HK Command Flags */
	hk_read_requestedf = 0;
   8a420:	4b7a      	ldr	r3, [pc, #488]	; (8a60c <prvInitializeGlobalVars+0x24c>)
   8a422:	2200      	movs	r2, #0
   8a424:	701a      	strb	r2, [r3, #0]
	hk_read_receivedf = 0;
   8a426:	4b7a      	ldr	r3, [pc, #488]	; (8a610 <prvInitializeGlobalVars+0x250>)
   8a428:	2200      	movs	r2, #0
   8a42a:	701a      	strb	r2, [r3, #0]
	hk_write_requestedf = 0;
   8a42c:	4b79      	ldr	r3, [pc, #484]	; (8a614 <prvInitializeGlobalVars+0x254>)
   8a42e:	2200      	movs	r2, #0
   8a430:	701a      	strb	r2, [r3, #0]
	hk_write_receivedf = 0;
   8a432:	4b79      	ldr	r3, [pc, #484]	; (8a618 <prvInitializeGlobalVars+0x258>)
   8a434:	2200      	movs	r2, #0
   8a436:	701a      	strb	r2, [r3, #0]
		
	/* Initialize the global can regs		*/
	for (i = 0; i < 2; i++)
   8a438:	2300      	movs	r3, #0
   8a43a:	71fb      	strb	r3, [r7, #7]
   8a43c:	e016      	b.n	8a46c <prvInitializeGlobalVars+0xac>
	{
		glob_stored_data[i] = 0;
   8a43e:	79fa      	ldrb	r2, [r7, #7]
   8a440:	4b76      	ldr	r3, [pc, #472]	; (8a61c <prvInitializeGlobalVars+0x25c>)
   8a442:	2100      	movs	r1, #0
   8a444:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		glob_stored_message[i] = 0;
   8a448:	79fa      	ldrb	r2, [r7, #7]
   8a44a:	4b75      	ldr	r3, [pc, #468]	; (8a620 <prvInitializeGlobalVars+0x260>)
   8a44c:	2100      	movs	r1, #0
   8a44e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		hk_read_receive[i] = 0;
   8a452:	79fa      	ldrb	r2, [r7, #7]
   8a454:	4b73      	ldr	r3, [pc, #460]	; (8a624 <prvInitializeGlobalVars+0x264>)
   8a456:	2100      	movs	r1, #0
   8a458:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
		hk_write_receive[i] = 0;
   8a45c:	79fa      	ldrb	r2, [r7, #7]
   8a45e:	4b72      	ldr	r3, [pc, #456]	; (8a628 <prvInitializeGlobalVars+0x268>)
   8a460:	2100      	movs	r1, #0
   8a462:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	hk_read_receivedf = 0;
	hk_write_requestedf = 0;
	hk_write_receivedf = 0;
		
	/* Initialize the global can regs		*/
	for (i = 0; i < 2; i++)
   8a466:	79fb      	ldrb	r3, [r7, #7]
   8a468:	3301      	adds	r3, #1
   8a46a:	71fb      	strb	r3, [r7, #7]
   8a46c:	79fb      	ldrb	r3, [r7, #7]
   8a46e:	2b01      	cmp	r3, #1
   8a470:	d9e5      	bls.n	8a43e <prvInitializeGlobalVars+0x7e>
		glob_stored_message[i] = 0;
		hk_read_receive[i] = 0;
		hk_write_receive[i] = 0;
	}
	
	for (i = 0; i < 152; i++)
   8a472:	2300      	movs	r3, #0
   8a474:	71fb      	strb	r3, [r7, #7]
   8a476:	e00a      	b.n	8a48e <prvInitializeGlobalVars+0xce>
	{
		high_error_array[i] = 0;
   8a478:	79fb      	ldrb	r3, [r7, #7]
   8a47a:	4a6c      	ldr	r2, [pc, #432]	; (8a62c <prvInitializeGlobalVars+0x26c>)
   8a47c:	2100      	movs	r1, #0
   8a47e:	54d1      	strb	r1, [r2, r3]
		low_error_array[i] = 0;
   8a480:	79fb      	ldrb	r3, [r7, #7]
   8a482:	4a6b      	ldr	r2, [pc, #428]	; (8a630 <prvInitializeGlobalVars+0x270>)
   8a484:	2100      	movs	r1, #0
   8a486:	54d1      	strb	r1, [r2, r3]
		glob_stored_message[i] = 0;
		hk_read_receive[i] = 0;
		hk_write_receive[i] = 0;
	}
	
	for (i = 0; i < 152; i++)
   8a488:	79fb      	ldrb	r3, [r7, #7]
   8a48a:	3301      	adds	r3, #1
   8a48c:	71fb      	strb	r3, [r7, #7]
   8a48e:	79fb      	ldrb	r3, [r7, #7]
   8a490:	2b97      	cmp	r3, #151	; 0x97
   8a492:	d9f1      	bls.n	8a478 <prvInitializeGlobalVars+0xb8>
		high_error_array[i] = 0;
		low_error_array[i] = 0;
	}

	/* TC/ TM transaction Flags */
	tm_transfer_completef = 0;
   8a494:	4b67      	ldr	r3, [pc, #412]	; (8a634 <prvInitializeGlobalVars+0x274>)
   8a496:	2200      	movs	r2, #0
   8a498:	701a      	strb	r2, [r3, #0]
	start_tm_transferf = 0;
   8a49a:	4b67      	ldr	r3, [pc, #412]	; (8a638 <prvInitializeGlobalVars+0x278>)
   8a49c:	2200      	movs	r2, #0
   8a49e:	701a      	strb	r2, [r3, #0]
	current_tc_fullf = 0;
   8a4a0:	4b66      	ldr	r3, [pc, #408]	; (8a63c <prvInitializeGlobalVars+0x27c>)
   8a4a2:	2200      	movs	r2, #0
   8a4a4:	701a      	strb	r2, [r3, #0]
	current_tm_fullf = 0;
   8a4a6:	4b66      	ldr	r3, [pc, #408]	; (8a640 <prvInitializeGlobalVars+0x280>)
   8a4a8:	2200      	movs	r2, #0
   8a4aa:	701a      	strb	r2, [r3, #0]
	tm_down_fullf = 0;
   8a4ac:	4b65      	ldr	r3, [pc, #404]	; (8a644 <prvInitializeGlobalVars+0x284>)
   8a4ae:	2200      	movs	r2, #0
   8a4b0:	701a      	strb	r2, [r3, #0]
	receiving_tcf = 0;
   8a4b2:	4b65      	ldr	r3, [pc, #404]	; (8a648 <prvInitializeGlobalVars+0x288>)
   8a4b4:	2200      	movs	r2, #0
   8a4b6:	701a      	strb	r2, [r3, #0]
	
	/* FDIR signals that individuals tasks loop on */
	hk_fdir_signal = 0;
   8a4b8:	4b64      	ldr	r3, [pc, #400]	; (8a64c <prvInitializeGlobalVars+0x28c>)
   8a4ba:	2200      	movs	r2, #0
   8a4bc:	701a      	strb	r2, [r3, #0]
	time_fdir_signal = 0;
   8a4be:	4b64      	ldr	r3, [pc, #400]	; (8a650 <prvInitializeGlobalVars+0x290>)
   8a4c0:	2200      	movs	r2, #0
   8a4c2:	701a      	strb	r2, [r3, #0]
	coms_fdir_signal = 0;
   8a4c4:	4b63      	ldr	r3, [pc, #396]	; (8a654 <prvInitializeGlobalVars+0x294>)
   8a4c6:	2200      	movs	r2, #0
   8a4c8:	701a      	strb	r2, [r3, #0]
	eps_fdir_signal = 0;
   8a4ca:	4b63      	ldr	r3, [pc, #396]	; (8a658 <prvInitializeGlobalVars+0x298>)
   8a4cc:	2200      	movs	r2, #0
   8a4ce:	701a      	strb	r2, [r3, #0]
	pay_fdir_signal = 0;
   8a4d0:	4b62      	ldr	r3, [pc, #392]	; (8a65c <prvInitializeGlobalVars+0x29c>)
   8a4d2:	2200      	movs	r2, #0
   8a4d4:	701a      	strb	r2, [r3, #0]
	opr_fdir_signal = 0;
   8a4d6:	4b62      	ldr	r3, [pc, #392]	; (8a660 <prvInitializeGlobalVars+0x2a0>)
   8a4d8:	2200      	movs	r2, #0
   8a4da:	701a      	strb	r2, [r3, #0]
	sched_fdir_signal = 0;
   8a4dc:	4b61      	ldr	r3, [pc, #388]	; (8a664 <prvInitializeGlobalVars+0x2a4>)
   8a4de:	2200      	movs	r2, #0
   8a4e0:	701a      	strb	r2, [r3, #0]
	wdt_fdir_signal = 0;
   8a4e2:	4b61      	ldr	r3, [pc, #388]	; (8a668 <prvInitializeGlobalVars+0x2a8>)
   8a4e4:	2200      	movs	r2, #0
   8a4e6:	701a      	strb	r2, [r3, #0]
	mem_fdir_signal = 0;
   8a4e8:	4b60      	ldr	r3, [pc, #384]	; (8a66c <prvInitializeGlobalVars+0x2ac>)
   8a4ea:	2200      	movs	r2, #0
   8a4ec:	701a      	strb	r2, [r3, #0]
	
	/* Timeouts used for various operations */
	req_data_timeout = 2000000;		// Maximum wait time of 25ms.
   8a4ee:	4b60      	ldr	r3, [pc, #384]	; (8a670 <prvInitializeGlobalVars+0x2b0>)
   8a4f0:	4a60      	ldr	r2, [pc, #384]	; (8a674 <prvInitializeGlobalVars+0x2b4>)
   8a4f2:	601a      	str	r2, [r3, #0]
	erase_sector_timeout = 30;		// Maximum wait time of 300ms.
   8a4f4:	4b60      	ldr	r3, [pc, #384]	; (8a678 <prvInitializeGlobalVars+0x2b8>)
   8a4f6:	221e      	movs	r2, #30
   8a4f8:	601a      	str	r2, [r3, #0]
	chip_erase_timeout = 1500;		// Maximum wait time of 15s.
   8a4fa:	4b60      	ldr	r3, [pc, #384]	; (8a67c <prvInitializeGlobalVars+0x2bc>)
   8a4fc:	f240 52dc 	movw	r2, #1500	; 0x5dc
   8a500:	601a      	str	r2, [r3, #0]
	obc_consec_trans_timeout = 100;	// Maximum wait time of 100ms.
   8a502:	4b5f      	ldr	r3, [pc, #380]	; (8a680 <prvInitializeGlobalVars+0x2c0>)
   8a504:	2264      	movs	r2, #100	; 0x64
   8a506:	601a      	str	r2, [r3, #0]
	obc_ok_go_timeout = 25;			// Maximum wait time of 25ms.
   8a508:	4b5e      	ldr	r3, [pc, #376]	; (8a684 <prvInitializeGlobalVars+0x2c4>)
   8a50a:	2219      	movs	r2, #25
   8a50c:	601a      	str	r2, [r3, #0]
	
	/* SPI MEMORY BASE ADDRESSES	*/
	COMS_BASE		=	0x00000;	// COMS = 16kB: 0x00000 - 0x03FFF
   8a50e:	4b5e      	ldr	r3, [pc, #376]	; (8a688 <prvInitializeGlobalVars+0x2c8>)
   8a510:	2200      	movs	r2, #0
   8a512:	601a      	str	r2, [r3, #0]
	EPS_BASE		=	0x04000;	// EPS = 16kB: 0x04000 - 0x07FFF
   8a514:	4b5d      	ldr	r3, [pc, #372]	; (8a68c <prvInitializeGlobalVars+0x2cc>)
   8a516:	f44f 4280 	mov.w	r2, #16384	; 0x4000
   8a51a:	601a      	str	r2, [r3, #0]
	PAY_BASE		=	0x08000;	// PAY = 16kB: 0x08000 - 0x0BFFF
   8a51c:	4b5c      	ldr	r3, [pc, #368]	; (8a690 <prvInitializeGlobalVars+0x2d0>)
   8a51e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
   8a522:	601a      	str	r2, [r3, #0]
	HK_BASE			=	0x0C000;	// HK = 8kB: 0x0C000 - 0x0DFFF
   8a524:	4b5b      	ldr	r3, [pc, #364]	; (8a694 <prvInitializeGlobalVars+0x2d4>)
   8a526:	f44f 4240 	mov.w	r2, #49152	; 0xc000
   8a52a:	601a      	str	r2, [r3, #0]
	EVENT_BASE		=	0x0E000;	// EVENT = 8kB: 0x0E000 - 0x0FFFF
   8a52c:	4b5a      	ldr	r3, [pc, #360]	; (8a698 <prvInitializeGlobalVars+0x2d8>)
   8a52e:	f44f 4260 	mov.w	r2, #57344	; 0xe000
   8a532:	601a      	str	r2, [r3, #0]
	SCHEDULE_BASE	=	0x10000;	// SCHEDULE = 8kB: 0x10000 - 0x11FFF
   8a534:	4b59      	ldr	r3, [pc, #356]	; (8a69c <prvInitializeGlobalVars+0x2dc>)
   8a536:	f44f 3280 	mov.w	r2, #65536	; 0x10000
   8a53a:	601a      	str	r2, [r3, #0]
	DIAG_BASE		=	0x12000;	// DIAGNOSTICS = 16kB: 0x12000 - 0x15FFF
   8a53c:	4b58      	ldr	r3, [pc, #352]	; (8a6a0 <prvInitializeGlobalVars+0x2e0>)
   8a53e:	f44f 3290 	mov.w	r2, #73728	; 0x12000
   8a542:	601a      	str	r2, [r3, #0]
	SCIENCE_BASE	=	0x24000;	// SCIENCE = 256kB: 0x24000 - 0x63FFF
   8a544:	4b57      	ldr	r3, [pc, #348]	; (8a6a4 <prvInitializeGlobalVars+0x2e4>)
   8a546:	f44f 3210 	mov.w	r2, #147456	; 0x24000
   8a54a:	601a      	str	r2, [r3, #0]
	TM_BASE			=	0x64000;	// TM = 128kB: 0x64000 - 0x83FFF
   8a54c:	4b56      	ldr	r3, [pc, #344]	; (8a6a8 <prvInitializeGlobalVars+0x2e8>)
   8a54e:	f44f 22c8 	mov.w	r2, #409600	; 0x64000
   8a552:	601a      	str	r2, [r3, #0]
	TC_BASE			=	0x84000;	// TC = 128kB: 0x84000 - 0xA3FFF
   8a554:	4b55      	ldr	r3, [pc, #340]	; (8a6ac <prvInitializeGlobalVars+0x2ec>)
   8a556:	f44f 2204 	mov.w	r2, #540672	; 0x84000
   8a55a:	601a      	str	r2, [r3, #0]
	TIME_BASE		=	0xFFFFC;	// TIME = 4B: 0xFFFFC - 0xFFFFF
   8a55c:	4b54      	ldr	r3, [pc, #336]	; (8a6b0 <prvInitializeGlobalVars+0x2f0>)
   8a55e:	4a55      	ldr	r2, [pc, #340]	; (8a6b4 <prvInitializeGlobalVars+0x2f4>)
   8a560:	601a      	str	r2, [r3, #0]

	/* Limits for task operations */
	if(!INTERNAL_MEMORY_FALLBACK_MODE)
   8a562:	4b21      	ldr	r3, [pc, #132]	; (8a5e8 <prvInitializeGlobalVars+0x228>)
   8a564:	681b      	ldr	r3, [r3, #0]
   8a566:	2b00      	cmp	r3, #0
   8a568:	d107      	bne.n	8a57a <prvInitializeGlobalVars+0x1ba>
	{
		MAX_SCHED_COMMANDS = 511;
   8a56a:	4b53      	ldr	r3, [pc, #332]	; (8a6b8 <prvInitializeGlobalVars+0x2f8>)
   8a56c:	f240 12ff 	movw	r2, #511	; 0x1ff
   8a570:	601a      	str	r2, [r3, #0]
		LENGTH_OF_HK = 8192;
   8a572:	4b52      	ldr	r3, [pc, #328]	; (8a6bc <prvInitializeGlobalVars+0x2fc>)
   8a574:	f44f 5200 	mov.w	r2, #8192	; 0x2000
   8a578:	601a      	str	r2, [r3, #0]
	}
	
	/* Variables used for starting the science experiment */
	experiment_armed = 0;
   8a57a:	4b51      	ldr	r3, [pc, #324]	; (8a6c0 <prvInitializeGlobalVars+0x300>)
   8a57c:	2200      	movs	r2, #0
   8a57e:	701a      	strb	r2, [r3, #0]
	experiment_started = 0;
   8a580:	4b50      	ldr	r3, [pc, #320]	; (8a6c4 <prvInitializeGlobalVars+0x304>)
   8a582:	2200      	movs	r2, #0
   8a584:	701a      	strb	r2, [r3, #0]

	/* Variables for keeping track of the PUS Packet Buffer */
	NEXT_TM_PACKET = 0;
   8a586:	4b50      	ldr	r3, [pc, #320]	; (8a6c8 <prvInitializeGlobalVars+0x308>)
   8a588:	2200      	movs	r2, #0
   8a58a:	601a      	str	r2, [r3, #0]
	NEXT_TC_PACKET = 0;
   8a58c:	4b4f      	ldr	r3, [pc, #316]	; (8a6cc <prvInitializeGlobalVars+0x30c>)
   8a58e:	2200      	movs	r2, #0
   8a590:	601a      	str	r2, [r3, #0]
	CURRENT_TC_PACKET = 0;
   8a592:	4b4f      	ldr	r3, [pc, #316]	; (8a6d0 <prvInitializeGlobalVars+0x310>)
   8a594:	2200      	movs	r2, #0
   8a596:	601a      	str	r2, [r3, #0]
	CURRENT_TM_PACKET = 0;
   8a598:	4b4e      	ldr	r3, [pc, #312]	; (8a6d4 <prvInitializeGlobalVars+0x314>)
   8a59a:	2200      	movs	r2, #0
   8a59c:	601a      	str	r2, [r3, #0]
	MAX_TM_PACKETS = 862;
   8a59e:	4b4e      	ldr	r3, [pc, #312]	; (8a6d8 <prvInitializeGlobalVars+0x318>)
   8a5a0:	f240 325e 	movw	r2, #862	; 0x35e
   8a5a4:	601a      	str	r2, [r3, #0]
	TM_PACKET_COUNT = 0;
   8a5a6:	4b4d      	ldr	r3, [pc, #308]	; (8a6dc <prvInitializeGlobalVars+0x31c>)
   8a5a8:	2200      	movs	r2, #0
   8a5aa:	601a      	str	r2, [r3, #0]
	TC_PACKET_COUNT = 0;
   8a5ac:	4b4c      	ldr	r3, [pc, #304]	; (8a6e0 <prvInitializeGlobalVars+0x320>)
   8a5ae:	2200      	movs	r2, #0
   8a5b0:	601a      	str	r2, [r3, #0]
	
	SPI_HEALTH1 = 0;
   8a5b2:	4b4c      	ldr	r3, [pc, #304]	; (8a6e4 <prvInitializeGlobalVars+0x324>)
   8a5b4:	2200      	movs	r2, #0
   8a5b6:	701a      	strb	r2, [r3, #0]
	SPI_HEALTH2 = 1;
   8a5b8:	4b4b      	ldr	r3, [pc, #300]	; (8a6e8 <prvInitializeGlobalVars+0x328>)
   8a5ba:	2201      	movs	r2, #1
   8a5bc:	701a      	strb	r2, [r3, #0]
	SPI_HEALTH3 = 0;
   8a5be:	4b4b      	ldr	r3, [pc, #300]	; (8a6ec <prvInitializeGlobalVars+0x32c>)
   8a5c0:	2200      	movs	r2, #0
   8a5c2:	701a      	strb	r2, [r3, #0]
	
	return;
   8a5c4:	bf00      	nop
}
   8a5c6:	370c      	adds	r7, #12
   8a5c8:	46bd      	mov	sp, r7
   8a5ca:	f85d 7b04 	ldr.w	r7, [sp], #4
   8a5ce:	4770      	bx	lr
   8a5d0:	2007b438 	.word	0x2007b438
   8a5d4:	2007ada4 	.word	0x2007ada4
   8a5d8:	2007b15c 	.word	0x2007b15c
   8a5dc:	2007b3a8 	.word	0x2007b3a8
   8a5e0:	2007b3d8 	.word	0x2007b3d8
   8a5e4:	2007ae20 	.word	0x2007ae20
   8a5e8:	2007b3f8 	.word	0x2007b3f8
   8a5ec:	2007ae54 	.word	0x2007ae54
   8a5f0:	2007b520 	.word	0x2007b520
   8a5f4:	2007aef0 	.word	0x2007aef0
   8a5f8:	2007b528 	.word	0x2007b528
   8a5fc:	2007b3f4 	.word	0x2007b3f4
   8a600:	2007b550 	.word	0x2007b550
   8a604:	2007ae25 	.word	0x2007ae25
   8a608:	2007b0f4 	.word	0x2007b0f4
   8a60c:	2007b508 	.word	0x2007b508
   8a610:	2007ae2c 	.word	0x2007ae2c
   8a614:	2007b3c8 	.word	0x2007b3c8
   8a618:	2007b100 	.word	0x2007b100
   8a61c:	2007ae08 	.word	0x2007ae08
   8a620:	2007b538 	.word	0x2007b538
   8a624:	2007b11c 	.word	0x2007b11c
   8a628:	2007b3ec 	.word	0x2007b3ec
   8a62c:	2007b43c 	.word	0x2007b43c
   8a630:	2007ae58 	.word	0x2007ae58
   8a634:	2007b4e0 	.word	0x2007b4e0
   8a638:	2007aef1 	.word	0x2007aef1
   8a63c:	2007ada9 	.word	0x2007ada9
   8a640:	2007b4ed 	.word	0x2007b4ed
   8a644:	2007b551 	.word	0x2007b551
   8a648:	2007adcc 	.word	0x2007adcc
   8a64c:	2007b3e0 	.word	0x2007b3e0
   8a650:	2007ae10 	.word	0x2007ae10
   8a654:	2007ade4 	.word	0x2007ade4
   8a658:	2007b398 	.word	0x2007b398
   8a65c:	2007b544 	.word	0x2007b544
   8a660:	2007ae18 	.word	0x2007ae18
   8a664:	2007b514 	.word	0x2007b514
   8a668:	2007b388 	.word	0x2007b388
   8a66c:	2007adfc 	.word	0x2007adfc
   8a670:	2007ae1c 	.word	0x2007ae1c
   8a674:	001e8480 	.word	0x001e8480
   8a678:	2007b384 	.word	0x2007b384
   8a67c:	2007adf0 	.word	0x2007adf0
   8a680:	2007b168 	.word	0x2007b168
   8a684:	2007adac 	.word	0x2007adac
   8a688:	2007b578 	.word	0x2007b578
   8a68c:	2007b404 	.word	0x2007b404
   8a690:	2007ae04 	.word	0x2007ae04
   8a694:	2007b540 	.word	0x2007b540
   8a698:	2007b434 	.word	0x2007b434
   8a69c:	2007b394 	.word	0x2007b394
   8a6a0:	2007b3dc 	.word	0x2007b3dc
   8a6a4:	2007b3cc 	.word	0x2007b3cc
   8a6a8:	2007b16c 	.word	0x2007b16c
   8a6ac:	2007b4dc 	.word	0x2007b4dc
   8a6b0:	2007ade0 	.word	0x2007ade0
   8a6b4:	000ffffc 	.word	0x000ffffc
   8a6b8:	2007b3b4 	.word	0x2007b3b4
   8a6bc:	2007b3ac 	.word	0x2007b3ac
   8a6c0:	2007ada8 	.word	0x2007ada8
   8a6c4:	2007b164 	.word	0x2007b164
   8a6c8:	2007b150 	.word	0x2007b150
   8a6cc:	2007ae14 	.word	0x2007ae14
   8a6d0:	2007b380 	.word	0x2007b380
   8a6d4:	2007b390 	.word	0x2007b390
   8a6d8:	2007b3b0 	.word	0x2007b3b0
   8a6dc:	2007b158 	.word	0x2007b158
   8a6e0:	2007b3e8 	.word	0x2007b3e8
   8a6e4:	2007b3fe 	.word	0x2007b3fe
   8a6e8:	2007ade5 	.word	0x2007ade5
   8a6ec:	2007b574 	.word	0x2007b574

0008a6f0 <vApplicationMallocFailedHook>:

void vApplicationMallocFailedHook(void)
{
   8a6f0:	b580      	push	{r7, lr}
   8a6f2:	af00      	add	r7, sp, #0
	demo application.  If heap_1.c or heap_2.c are used, then the size of the
	heap available to pvPortMalloc() is defined by configTOTAL_HEAP_SIZE in
	FreeRTOSConfig.h, and the xPortGetFreeHeapSize() API function can be used
	to query the size of free heap space that remains (although it does not
	provide information on how the remaining heap might be fragmented). */
	taskDISABLE_INTERRUPTS();
   8a6f4:	4b01      	ldr	r3, [pc, #4]	; (8a6fc <vApplicationMallocFailedHook+0xc>)
   8a6f6:	4798      	blx	r3
	/* @non-terminating@ */
	for (;;);
   8a6f8:	e7fe      	b.n	8a6f8 <vApplicationMallocFailedHook+0x8>
   8a6fa:	bf00      	nop
   8a6fc:	000864f9 	.word	0x000864f9

0008a700 <vApplicationStackOverflowHook>:
	memory allocated by the kernel to any task that has since been deleted. */
}
/*-----------------------------------------------------------*/

void vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName)
{
   8a700:	b580      	push	{r7, lr}
   8a702:	b082      	sub	sp, #8
   8a704:	af00      	add	r7, sp, #0
   8a706:	6078      	str	r0, [r7, #4]
   8a708:	6039      	str	r1, [r7, #0]
	(void)pxTask;

	/* Run time stack overflow checking is performed if
	configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2.  This hook
	function is called if a stack overflow is detected. */
	taskDISABLE_INTERRUPTS();
   8a70a:	4b01      	ldr	r3, [pc, #4]	; (8a710 <vApplicationStackOverflowHook+0x10>)
   8a70c:	4798      	blx	r3
	/* @non-terminating@ */
	for (;;);
   8a70e:	e7fe      	b.n	8a70e <vApplicationStackOverflowHook+0xe>
   8a710:	000864f9 	.word	0x000864f9

0008a714 <__aeabi_frsub>:
   8a714:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
   8a718:	e002      	b.n	8a720 <__addsf3>
   8a71a:	bf00      	nop

0008a71c <__aeabi_fsub>:
   8a71c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

0008a720 <__addsf3>:
   8a720:	0042      	lsls	r2, r0, #1
   8a722:	bf1f      	itttt	ne
   8a724:	ea5f 0341 	movsne.w	r3, r1, lsl #1
   8a728:	ea92 0f03 	teqne	r2, r3
   8a72c:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
   8a730:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   8a734:	d06a      	beq.n	8a80c <__addsf3+0xec>
   8a736:	ea4f 6212 	mov.w	r2, r2, lsr #24
   8a73a:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
   8a73e:	bfc1      	itttt	gt
   8a740:	18d2      	addgt	r2, r2, r3
   8a742:	4041      	eorgt	r1, r0
   8a744:	4048      	eorgt	r0, r1
   8a746:	4041      	eorgt	r1, r0
   8a748:	bfb8      	it	lt
   8a74a:	425b      	neglt	r3, r3
   8a74c:	2b19      	cmp	r3, #25
   8a74e:	bf88      	it	hi
   8a750:	4770      	bxhi	lr
   8a752:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
   8a756:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8a75a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
   8a75e:	bf18      	it	ne
   8a760:	4240      	negne	r0, r0
   8a762:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
   8a766:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
   8a76a:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
   8a76e:	bf18      	it	ne
   8a770:	4249      	negne	r1, r1
   8a772:	ea92 0f03 	teq	r2, r3
   8a776:	d03f      	beq.n	8a7f8 <__addsf3+0xd8>
   8a778:	f1a2 0201 	sub.w	r2, r2, #1
   8a77c:	fa41 fc03 	asr.w	ip, r1, r3
   8a780:	eb10 000c 	adds.w	r0, r0, ip
   8a784:	f1c3 0320 	rsb	r3, r3, #32
   8a788:	fa01 f103 	lsl.w	r1, r1, r3
   8a78c:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   8a790:	d502      	bpl.n	8a798 <__addsf3+0x78>
   8a792:	4249      	negs	r1, r1
   8a794:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
   8a798:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
   8a79c:	d313      	bcc.n	8a7c6 <__addsf3+0xa6>
   8a79e:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
   8a7a2:	d306      	bcc.n	8a7b2 <__addsf3+0x92>
   8a7a4:	0840      	lsrs	r0, r0, #1
   8a7a6:	ea4f 0131 	mov.w	r1, r1, rrx
   8a7aa:	f102 0201 	add.w	r2, r2, #1
   8a7ae:	2afe      	cmp	r2, #254	; 0xfe
   8a7b0:	d251      	bcs.n	8a856 <__addsf3+0x136>
   8a7b2:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
   8a7b6:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   8a7ba:	bf08      	it	eq
   8a7bc:	f020 0001 	biceq.w	r0, r0, #1
   8a7c0:	ea40 0003 	orr.w	r0, r0, r3
   8a7c4:	4770      	bx	lr
   8a7c6:	0049      	lsls	r1, r1, #1
   8a7c8:	eb40 0000 	adc.w	r0, r0, r0
   8a7cc:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
   8a7d0:	f1a2 0201 	sub.w	r2, r2, #1
   8a7d4:	d1ed      	bne.n	8a7b2 <__addsf3+0x92>
   8a7d6:	fab0 fc80 	clz	ip, r0
   8a7da:	f1ac 0c08 	sub.w	ip, ip, #8
   8a7de:	ebb2 020c 	subs.w	r2, r2, ip
   8a7e2:	fa00 f00c 	lsl.w	r0, r0, ip
   8a7e6:	bfaa      	itet	ge
   8a7e8:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
   8a7ec:	4252      	neglt	r2, r2
   8a7ee:	4318      	orrge	r0, r3
   8a7f0:	bfbc      	itt	lt
   8a7f2:	40d0      	lsrlt	r0, r2
   8a7f4:	4318      	orrlt	r0, r3
   8a7f6:	4770      	bx	lr
   8a7f8:	f092 0f00 	teq	r2, #0
   8a7fc:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
   8a800:	bf06      	itte	eq
   8a802:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
   8a806:	3201      	addeq	r2, #1
   8a808:	3b01      	subne	r3, #1
   8a80a:	e7b5      	b.n	8a778 <__addsf3+0x58>
   8a80c:	ea4f 0341 	mov.w	r3, r1, lsl #1
   8a810:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   8a814:	bf18      	it	ne
   8a816:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   8a81a:	d021      	beq.n	8a860 <__addsf3+0x140>
   8a81c:	ea92 0f03 	teq	r2, r3
   8a820:	d004      	beq.n	8a82c <__addsf3+0x10c>
   8a822:	f092 0f00 	teq	r2, #0
   8a826:	bf08      	it	eq
   8a828:	4608      	moveq	r0, r1
   8a82a:	4770      	bx	lr
   8a82c:	ea90 0f01 	teq	r0, r1
   8a830:	bf1c      	itt	ne
   8a832:	2000      	movne	r0, #0
   8a834:	4770      	bxne	lr
   8a836:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
   8a83a:	d104      	bne.n	8a846 <__addsf3+0x126>
   8a83c:	0040      	lsls	r0, r0, #1
   8a83e:	bf28      	it	cs
   8a840:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
   8a844:	4770      	bx	lr
   8a846:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
   8a84a:	bf3c      	itt	cc
   8a84c:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
   8a850:	4770      	bxcc	lr
   8a852:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
   8a856:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
   8a85a:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8a85e:	4770      	bx	lr
   8a860:	ea7f 6222 	mvns.w	r2, r2, asr #24
   8a864:	bf16      	itet	ne
   8a866:	4608      	movne	r0, r1
   8a868:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
   8a86c:	4601      	movne	r1, r0
   8a86e:	0242      	lsls	r2, r0, #9
   8a870:	bf06      	itte	eq
   8a872:	ea5f 2341 	movseq.w	r3, r1, lsl #9
   8a876:	ea90 0f01 	teqeq	r0, r1
   8a87a:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
   8a87e:	4770      	bx	lr

0008a880 <__aeabi_ui2f>:
   8a880:	f04f 0300 	mov.w	r3, #0
   8a884:	e004      	b.n	8a890 <__aeabi_i2f+0x8>
   8a886:	bf00      	nop

0008a888 <__aeabi_i2f>:
   8a888:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
   8a88c:	bf48      	it	mi
   8a88e:	4240      	negmi	r0, r0
   8a890:	ea5f 0c00 	movs.w	ip, r0
   8a894:	bf08      	it	eq
   8a896:	4770      	bxeq	lr
   8a898:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
   8a89c:	4601      	mov	r1, r0
   8a89e:	f04f 0000 	mov.w	r0, #0
   8a8a2:	e01c      	b.n	8a8de <__aeabi_l2f+0x2a>

0008a8a4 <__aeabi_ul2f>:
   8a8a4:	ea50 0201 	orrs.w	r2, r0, r1
   8a8a8:	bf08      	it	eq
   8a8aa:	4770      	bxeq	lr
   8a8ac:	f04f 0300 	mov.w	r3, #0
   8a8b0:	e00a      	b.n	8a8c8 <__aeabi_l2f+0x14>
   8a8b2:	bf00      	nop

0008a8b4 <__aeabi_l2f>:
   8a8b4:	ea50 0201 	orrs.w	r2, r0, r1
   8a8b8:	bf08      	it	eq
   8a8ba:	4770      	bxeq	lr
   8a8bc:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
   8a8c0:	d502      	bpl.n	8a8c8 <__aeabi_l2f+0x14>
   8a8c2:	4240      	negs	r0, r0
   8a8c4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
   8a8c8:	ea5f 0c01 	movs.w	ip, r1
   8a8cc:	bf02      	ittt	eq
   8a8ce:	4684      	moveq	ip, r0
   8a8d0:	4601      	moveq	r1, r0
   8a8d2:	2000      	moveq	r0, #0
   8a8d4:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
   8a8d8:	bf08      	it	eq
   8a8da:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
   8a8de:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
   8a8e2:	fabc f28c 	clz	r2, ip
   8a8e6:	3a08      	subs	r2, #8
   8a8e8:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
   8a8ec:	db10      	blt.n	8a910 <__aeabi_l2f+0x5c>
   8a8ee:	fa01 fc02 	lsl.w	ip, r1, r2
   8a8f2:	4463      	add	r3, ip
   8a8f4:	fa00 fc02 	lsl.w	ip, r0, r2
   8a8f8:	f1c2 0220 	rsb	r2, r2, #32
   8a8fc:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
   8a900:	fa20 f202 	lsr.w	r2, r0, r2
   8a904:	eb43 0002 	adc.w	r0, r3, r2
   8a908:	bf08      	it	eq
   8a90a:	f020 0001 	biceq.w	r0, r0, #1
   8a90e:	4770      	bx	lr
   8a910:	f102 0220 	add.w	r2, r2, #32
   8a914:	fa01 fc02 	lsl.w	ip, r1, r2
   8a918:	f1c2 0220 	rsb	r2, r2, #32
   8a91c:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
   8a920:	fa21 f202 	lsr.w	r2, r1, r2
   8a924:	eb43 0002 	adc.w	r0, r3, r2
   8a928:	bf08      	it	eq
   8a92a:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   8a92e:	4770      	bx	lr

0008a930 <__aeabi_fmul>:
   8a930:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8a934:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   8a938:	bf1e      	ittt	ne
   8a93a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   8a93e:	ea92 0f0c 	teqne	r2, ip
   8a942:	ea93 0f0c 	teqne	r3, ip
   8a946:	d06f      	beq.n	8aa28 <__aeabi_fmul+0xf8>
   8a948:	441a      	add	r2, r3
   8a94a:	ea80 0c01 	eor.w	ip, r0, r1
   8a94e:	0240      	lsls	r0, r0, #9
   8a950:	bf18      	it	ne
   8a952:	ea5f 2141 	movsne.w	r1, r1, lsl #9
   8a956:	d01e      	beq.n	8a996 <__aeabi_fmul+0x66>
   8a958:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
   8a95c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
   8a960:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
   8a964:	fba0 3101 	umull	r3, r1, r0, r1
   8a968:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   8a96c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
   8a970:	bf3e      	ittt	cc
   8a972:	0049      	lslcc	r1, r1, #1
   8a974:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
   8a978:	005b      	lslcc	r3, r3, #1
   8a97a:	ea40 0001 	orr.w	r0, r0, r1
   8a97e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
   8a982:	2afd      	cmp	r2, #253	; 0xfd
   8a984:	d81d      	bhi.n	8a9c2 <__aeabi_fmul+0x92>
   8a986:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
   8a98a:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   8a98e:	bf08      	it	eq
   8a990:	f020 0001 	biceq.w	r0, r0, #1
   8a994:	4770      	bx	lr
   8a996:	f090 0f00 	teq	r0, #0
   8a99a:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   8a99e:	bf08      	it	eq
   8a9a0:	0249      	lsleq	r1, r1, #9
   8a9a2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   8a9a6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
   8a9aa:	3a7f      	subs	r2, #127	; 0x7f
   8a9ac:	bfc2      	ittt	gt
   8a9ae:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   8a9b2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   8a9b6:	4770      	bxgt	lr
   8a9b8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8a9bc:	f04f 0300 	mov.w	r3, #0
   8a9c0:	3a01      	subs	r2, #1
   8a9c2:	dc5d      	bgt.n	8aa80 <__aeabi_fmul+0x150>
   8a9c4:	f112 0f19 	cmn.w	r2, #25
   8a9c8:	bfdc      	itt	le
   8a9ca:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
   8a9ce:	4770      	bxle	lr
   8a9d0:	f1c2 0200 	rsb	r2, r2, #0
   8a9d4:	0041      	lsls	r1, r0, #1
   8a9d6:	fa21 f102 	lsr.w	r1, r1, r2
   8a9da:	f1c2 0220 	rsb	r2, r2, #32
   8a9de:	fa00 fc02 	lsl.w	ip, r0, r2
   8a9e2:	ea5f 0031 	movs.w	r0, r1, rrx
   8a9e6:	f140 0000 	adc.w	r0, r0, #0
   8a9ea:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
   8a9ee:	bf08      	it	eq
   8a9f0:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
   8a9f4:	4770      	bx	lr
   8a9f6:	f092 0f00 	teq	r2, #0
   8a9fa:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   8a9fe:	bf02      	ittt	eq
   8aa00:	0040      	lsleq	r0, r0, #1
   8aa02:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   8aa06:	3a01      	subeq	r2, #1
   8aa08:	d0f9      	beq.n	8a9fe <__aeabi_fmul+0xce>
   8aa0a:	ea40 000c 	orr.w	r0, r0, ip
   8aa0e:	f093 0f00 	teq	r3, #0
   8aa12:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   8aa16:	bf02      	ittt	eq
   8aa18:	0049      	lsleq	r1, r1, #1
   8aa1a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   8aa1e:	3b01      	subeq	r3, #1
   8aa20:	d0f9      	beq.n	8aa16 <__aeabi_fmul+0xe6>
   8aa22:	ea41 010c 	orr.w	r1, r1, ip
   8aa26:	e78f      	b.n	8a948 <__aeabi_fmul+0x18>
   8aa28:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   8aa2c:	ea92 0f0c 	teq	r2, ip
   8aa30:	bf18      	it	ne
   8aa32:	ea93 0f0c 	teqne	r3, ip
   8aa36:	d00a      	beq.n	8aa4e <__aeabi_fmul+0x11e>
   8aa38:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   8aa3c:	bf18      	it	ne
   8aa3e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   8aa42:	d1d8      	bne.n	8a9f6 <__aeabi_fmul+0xc6>
   8aa44:	ea80 0001 	eor.w	r0, r0, r1
   8aa48:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   8aa4c:	4770      	bx	lr
   8aa4e:	f090 0f00 	teq	r0, #0
   8aa52:	bf17      	itett	ne
   8aa54:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
   8aa58:	4608      	moveq	r0, r1
   8aa5a:	f091 0f00 	teqne	r1, #0
   8aa5e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
   8aa62:	d014      	beq.n	8aa8e <__aeabi_fmul+0x15e>
   8aa64:	ea92 0f0c 	teq	r2, ip
   8aa68:	d101      	bne.n	8aa6e <__aeabi_fmul+0x13e>
   8aa6a:	0242      	lsls	r2, r0, #9
   8aa6c:	d10f      	bne.n	8aa8e <__aeabi_fmul+0x15e>
   8aa6e:	ea93 0f0c 	teq	r3, ip
   8aa72:	d103      	bne.n	8aa7c <__aeabi_fmul+0x14c>
   8aa74:	024b      	lsls	r3, r1, #9
   8aa76:	bf18      	it	ne
   8aa78:	4608      	movne	r0, r1
   8aa7a:	d108      	bne.n	8aa8e <__aeabi_fmul+0x15e>
   8aa7c:	ea80 0001 	eor.w	r0, r0, r1
   8aa80:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
   8aa84:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   8aa88:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8aa8c:	4770      	bx	lr
   8aa8e:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
   8aa92:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
   8aa96:	4770      	bx	lr

0008aa98 <__aeabi_fdiv>:
   8aa98:	f04f 0cff 	mov.w	ip, #255	; 0xff
   8aa9c:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
   8aaa0:	bf1e      	ittt	ne
   8aaa2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
   8aaa6:	ea92 0f0c 	teqne	r2, ip
   8aaaa:	ea93 0f0c 	teqne	r3, ip
   8aaae:	d069      	beq.n	8ab84 <__aeabi_fdiv+0xec>
   8aab0:	eba2 0203 	sub.w	r2, r2, r3
   8aab4:	ea80 0c01 	eor.w	ip, r0, r1
   8aab8:	0249      	lsls	r1, r1, #9
   8aaba:	ea4f 2040 	mov.w	r0, r0, lsl #9
   8aabe:	d037      	beq.n	8ab30 <__aeabi_fdiv+0x98>
   8aac0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
   8aac4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
   8aac8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
   8aacc:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
   8aad0:	428b      	cmp	r3, r1
   8aad2:	bf38      	it	cc
   8aad4:	005b      	lslcc	r3, r3, #1
   8aad6:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
   8aada:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
   8aade:	428b      	cmp	r3, r1
   8aae0:	bf24      	itt	cs
   8aae2:	1a5b      	subcs	r3, r3, r1
   8aae4:	ea40 000c 	orrcs.w	r0, r0, ip
   8aae8:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
   8aaec:	bf24      	itt	cs
   8aaee:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
   8aaf2:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
   8aaf6:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
   8aafa:	bf24      	itt	cs
   8aafc:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
   8ab00:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
   8ab04:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
   8ab08:	bf24      	itt	cs
   8ab0a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
   8ab0e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
   8ab12:	011b      	lsls	r3, r3, #4
   8ab14:	bf18      	it	ne
   8ab16:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
   8ab1a:	d1e0      	bne.n	8aade <__aeabi_fdiv+0x46>
   8ab1c:	2afd      	cmp	r2, #253	; 0xfd
   8ab1e:	f63f af50 	bhi.w	8a9c2 <__aeabi_fmul+0x92>
   8ab22:	428b      	cmp	r3, r1
   8ab24:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
   8ab28:	bf08      	it	eq
   8ab2a:	f020 0001 	biceq.w	r0, r0, #1
   8ab2e:	4770      	bx	lr
   8ab30:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
   8ab34:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
   8ab38:	327f      	adds	r2, #127	; 0x7f
   8ab3a:	bfc2      	ittt	gt
   8ab3c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
   8ab40:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
   8ab44:	4770      	bxgt	lr
   8ab46:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
   8ab4a:	f04f 0300 	mov.w	r3, #0
   8ab4e:	3a01      	subs	r2, #1
   8ab50:	e737      	b.n	8a9c2 <__aeabi_fmul+0x92>
   8ab52:	f092 0f00 	teq	r2, #0
   8ab56:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
   8ab5a:	bf02      	ittt	eq
   8ab5c:	0040      	lsleq	r0, r0, #1
   8ab5e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
   8ab62:	3a01      	subeq	r2, #1
   8ab64:	d0f9      	beq.n	8ab5a <__aeabi_fdiv+0xc2>
   8ab66:	ea40 000c 	orr.w	r0, r0, ip
   8ab6a:	f093 0f00 	teq	r3, #0
   8ab6e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
   8ab72:	bf02      	ittt	eq
   8ab74:	0049      	lsleq	r1, r1, #1
   8ab76:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
   8ab7a:	3b01      	subeq	r3, #1
   8ab7c:	d0f9      	beq.n	8ab72 <__aeabi_fdiv+0xda>
   8ab7e:	ea41 010c 	orr.w	r1, r1, ip
   8ab82:	e795      	b.n	8aab0 <__aeabi_fdiv+0x18>
   8ab84:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
   8ab88:	ea92 0f0c 	teq	r2, ip
   8ab8c:	d108      	bne.n	8aba0 <__aeabi_fdiv+0x108>
   8ab8e:	0242      	lsls	r2, r0, #9
   8ab90:	f47f af7d 	bne.w	8aa8e <__aeabi_fmul+0x15e>
   8ab94:	ea93 0f0c 	teq	r3, ip
   8ab98:	f47f af70 	bne.w	8aa7c <__aeabi_fmul+0x14c>
   8ab9c:	4608      	mov	r0, r1
   8ab9e:	e776      	b.n	8aa8e <__aeabi_fmul+0x15e>
   8aba0:	ea93 0f0c 	teq	r3, ip
   8aba4:	d104      	bne.n	8abb0 <__aeabi_fdiv+0x118>
   8aba6:	024b      	lsls	r3, r1, #9
   8aba8:	f43f af4c 	beq.w	8aa44 <__aeabi_fmul+0x114>
   8abac:	4608      	mov	r0, r1
   8abae:	e76e      	b.n	8aa8e <__aeabi_fmul+0x15e>
   8abb0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
   8abb4:	bf18      	it	ne
   8abb6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
   8abba:	d1ca      	bne.n	8ab52 <__aeabi_fdiv+0xba>
   8abbc:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
   8abc0:	f47f af5c 	bne.w	8aa7c <__aeabi_fmul+0x14c>
   8abc4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
   8abc8:	f47f af3c 	bne.w	8aa44 <__aeabi_fmul+0x114>
   8abcc:	e75f      	b.n	8aa8e <__aeabi_fmul+0x15e>
   8abce:	bf00      	nop

0008abd0 <__gesf2>:
   8abd0:	f04f 3cff 	mov.w	ip, #4294967295
   8abd4:	e006      	b.n	8abe4 <__cmpsf2+0x4>
   8abd6:	bf00      	nop

0008abd8 <__lesf2>:
   8abd8:	f04f 0c01 	mov.w	ip, #1
   8abdc:	e002      	b.n	8abe4 <__cmpsf2+0x4>
   8abde:	bf00      	nop

0008abe0 <__cmpsf2>:
   8abe0:	f04f 0c01 	mov.w	ip, #1
   8abe4:	f84d cd04 	str.w	ip, [sp, #-4]!
   8abe8:	ea4f 0240 	mov.w	r2, r0, lsl #1
   8abec:	ea4f 0341 	mov.w	r3, r1, lsl #1
   8abf0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   8abf4:	bf18      	it	ne
   8abf6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
   8abfa:	d011      	beq.n	8ac20 <__cmpsf2+0x40>
   8abfc:	b001      	add	sp, #4
   8abfe:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
   8ac02:	bf18      	it	ne
   8ac04:	ea90 0f01 	teqne	r0, r1
   8ac08:	bf58      	it	pl
   8ac0a:	ebb2 0003 	subspl.w	r0, r2, r3
   8ac0e:	bf88      	it	hi
   8ac10:	17c8      	asrhi	r0, r1, #31
   8ac12:	bf38      	it	cc
   8ac14:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
   8ac18:	bf18      	it	ne
   8ac1a:	f040 0001 	orrne.w	r0, r0, #1
   8ac1e:	4770      	bx	lr
   8ac20:	ea7f 6c22 	mvns.w	ip, r2, asr #24
   8ac24:	d102      	bne.n	8ac2c <__cmpsf2+0x4c>
   8ac26:	ea5f 2c40 	movs.w	ip, r0, lsl #9
   8ac2a:	d105      	bne.n	8ac38 <__cmpsf2+0x58>
   8ac2c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
   8ac30:	d1e4      	bne.n	8abfc <__cmpsf2+0x1c>
   8ac32:	ea5f 2c41 	movs.w	ip, r1, lsl #9
   8ac36:	d0e1      	beq.n	8abfc <__cmpsf2+0x1c>
   8ac38:	f85d 0b04 	ldr.w	r0, [sp], #4
   8ac3c:	4770      	bx	lr
   8ac3e:	bf00      	nop

0008ac40 <__aeabi_cfrcmple>:
   8ac40:	4684      	mov	ip, r0
   8ac42:	4608      	mov	r0, r1
   8ac44:	4661      	mov	r1, ip
   8ac46:	e7ff      	b.n	8ac48 <__aeabi_cfcmpeq>

0008ac48 <__aeabi_cfcmpeq>:
   8ac48:	b50f      	push	{r0, r1, r2, r3, lr}
   8ac4a:	f7ff ffc9 	bl	8abe0 <__cmpsf2>
   8ac4e:	2800      	cmp	r0, #0
   8ac50:	bf48      	it	mi
   8ac52:	f110 0f00 	cmnmi.w	r0, #0
   8ac56:	bd0f      	pop	{r0, r1, r2, r3, pc}

0008ac58 <__aeabi_fcmpeq>:
   8ac58:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ac5c:	f7ff fff4 	bl	8ac48 <__aeabi_cfcmpeq>
   8ac60:	bf0c      	ite	eq
   8ac62:	2001      	moveq	r0, #1
   8ac64:	2000      	movne	r0, #0
   8ac66:	f85d fb08 	ldr.w	pc, [sp], #8
   8ac6a:	bf00      	nop

0008ac6c <__aeabi_fcmplt>:
   8ac6c:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ac70:	f7ff ffea 	bl	8ac48 <__aeabi_cfcmpeq>
   8ac74:	bf34      	ite	cc
   8ac76:	2001      	movcc	r0, #1
   8ac78:	2000      	movcs	r0, #0
   8ac7a:	f85d fb08 	ldr.w	pc, [sp], #8
   8ac7e:	bf00      	nop

0008ac80 <__aeabi_fcmple>:
   8ac80:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ac84:	f7ff ffe0 	bl	8ac48 <__aeabi_cfcmpeq>
   8ac88:	bf94      	ite	ls
   8ac8a:	2001      	movls	r0, #1
   8ac8c:	2000      	movhi	r0, #0
   8ac8e:	f85d fb08 	ldr.w	pc, [sp], #8
   8ac92:	bf00      	nop

0008ac94 <__aeabi_fcmpge>:
   8ac94:	f84d ed08 	str.w	lr, [sp, #-8]!
   8ac98:	f7ff ffd2 	bl	8ac40 <__aeabi_cfrcmple>
   8ac9c:	bf94      	ite	ls
   8ac9e:	2001      	movls	r0, #1
   8aca0:	2000      	movhi	r0, #0
   8aca2:	f85d fb08 	ldr.w	pc, [sp], #8
   8aca6:	bf00      	nop

0008aca8 <__aeabi_fcmpgt>:
   8aca8:	f84d ed08 	str.w	lr, [sp, #-8]!
   8acac:	f7ff ffc8 	bl	8ac40 <__aeabi_cfrcmple>
   8acb0:	bf34      	ite	cc
   8acb2:	2001      	movcc	r0, #1
   8acb4:	2000      	movcs	r0, #0
   8acb6:	f85d fb08 	ldr.w	pc, [sp], #8
   8acba:	bf00      	nop

0008acbc <__aeabi_f2uiz>:
   8acbc:	0042      	lsls	r2, r0, #1
   8acbe:	d20e      	bcs.n	8acde <__aeabi_f2uiz+0x22>
   8acc0:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
   8acc4:	d30b      	bcc.n	8acde <__aeabi_f2uiz+0x22>
   8acc6:	f04f 039e 	mov.w	r3, #158	; 0x9e
   8acca:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
   8acce:	d409      	bmi.n	8ace4 <__aeabi_f2uiz+0x28>
   8acd0:	ea4f 2300 	mov.w	r3, r0, lsl #8
   8acd4:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
   8acd8:	fa23 f002 	lsr.w	r0, r3, r2
   8acdc:	4770      	bx	lr
   8acde:	f04f 0000 	mov.w	r0, #0
   8ace2:	4770      	bx	lr
   8ace4:	f112 0f61 	cmn.w	r2, #97	; 0x61
   8ace8:	d101      	bne.n	8acee <__aeabi_f2uiz+0x32>
   8acea:	0242      	lsls	r2, r0, #9
   8acec:	d102      	bne.n	8acf4 <__aeabi_f2uiz+0x38>
   8acee:	f04f 30ff 	mov.w	r0, #4294967295
   8acf2:	4770      	bx	lr
   8acf4:	f04f 0000 	mov.w	r0, #0
   8acf8:	4770      	bx	lr
   8acfa:	bf00      	nop

0008acfc <__libc_init_array>:
   8acfc:	b570      	push	{r4, r5, r6, lr}
   8acfe:	4e0f      	ldr	r6, [pc, #60]	; (8ad3c <__libc_init_array+0x40>)
   8ad00:	4d0f      	ldr	r5, [pc, #60]	; (8ad40 <__libc_init_array+0x44>)
   8ad02:	1b76      	subs	r6, r6, r5
   8ad04:	10b6      	asrs	r6, r6, #2
   8ad06:	d007      	beq.n	8ad18 <__libc_init_array+0x1c>
   8ad08:	3d04      	subs	r5, #4
   8ad0a:	2400      	movs	r4, #0
   8ad0c:	3401      	adds	r4, #1
   8ad0e:	f855 3f04 	ldr.w	r3, [r5, #4]!
   8ad12:	4798      	blx	r3
   8ad14:	42a6      	cmp	r6, r4
   8ad16:	d1f9      	bne.n	8ad0c <__libc_init_array+0x10>
   8ad18:	4e0a      	ldr	r6, [pc, #40]	; (8ad44 <__libc_init_array+0x48>)
   8ad1a:	4d0b      	ldr	r5, [pc, #44]	; (8ad48 <__libc_init_array+0x4c>)
   8ad1c:	f000 fa3c 	bl	8b198 <_init>
   8ad20:	1b76      	subs	r6, r6, r5
   8ad22:	10b6      	asrs	r6, r6, #2
   8ad24:	d008      	beq.n	8ad38 <__libc_init_array+0x3c>
   8ad26:	3d04      	subs	r5, #4
   8ad28:	2400      	movs	r4, #0
   8ad2a:	3401      	adds	r4, #1
   8ad2c:	f855 3f04 	ldr.w	r3, [r5, #4]!
   8ad30:	4798      	blx	r3
   8ad32:	42a6      	cmp	r6, r4
   8ad34:	d1f9      	bne.n	8ad2a <__libc_init_array+0x2e>
   8ad36:	bd70      	pop	{r4, r5, r6, pc}
   8ad38:	bd70      	pop	{r4, r5, r6, pc}
   8ad3a:	bf00      	nop
   8ad3c:	0008b1a4 	.word	0x0008b1a4
   8ad40:	0008b1a4 	.word	0x0008b1a4
   8ad44:	0008b1ac 	.word	0x0008b1ac
   8ad48:	0008b1a4 	.word	0x0008b1a4

0008ad4c <memcmp>:
   8ad4c:	2a03      	cmp	r2, #3
   8ad4e:	b470      	push	{r4, r5, r6}
   8ad50:	d928      	bls.n	8ada4 <memcmp+0x58>
   8ad52:	ea40 0301 	orr.w	r3, r0, r1
   8ad56:	079b      	lsls	r3, r3, #30
   8ad58:	d013      	beq.n	8ad82 <memcmp+0x36>
   8ad5a:	7805      	ldrb	r5, [r0, #0]
   8ad5c:	780c      	ldrb	r4, [r1, #0]
   8ad5e:	42a5      	cmp	r5, r4
   8ad60:	d124      	bne.n	8adac <memcmp+0x60>
   8ad62:	3a01      	subs	r2, #1
   8ad64:	2300      	movs	r3, #0
   8ad66:	e005      	b.n	8ad74 <memcmp+0x28>
   8ad68:	f810 5f01 	ldrb.w	r5, [r0, #1]!
   8ad6c:	f811 4f01 	ldrb.w	r4, [r1, #1]!
   8ad70:	42a5      	cmp	r5, r4
   8ad72:	d11b      	bne.n	8adac <memcmp+0x60>
   8ad74:	4293      	cmp	r3, r2
   8ad76:	f103 0301 	add.w	r3, r3, #1
   8ad7a:	d1f5      	bne.n	8ad68 <memcmp+0x1c>
   8ad7c:	2000      	movs	r0, #0
   8ad7e:	bc70      	pop	{r4, r5, r6}
   8ad80:	4770      	bx	lr
   8ad82:	460c      	mov	r4, r1
   8ad84:	4603      	mov	r3, r0
   8ad86:	6825      	ldr	r5, [r4, #0]
   8ad88:	681e      	ldr	r6, [r3, #0]
   8ad8a:	4621      	mov	r1, r4
   8ad8c:	42ae      	cmp	r6, r5
   8ad8e:	4618      	mov	r0, r3
   8ad90:	f104 0404 	add.w	r4, r4, #4
   8ad94:	f103 0304 	add.w	r3, r3, #4
   8ad98:	d104      	bne.n	8ada4 <memcmp+0x58>
   8ad9a:	3a04      	subs	r2, #4
   8ad9c:	2a03      	cmp	r2, #3
   8ad9e:	4618      	mov	r0, r3
   8ada0:	4621      	mov	r1, r4
   8ada2:	d8f0      	bhi.n	8ad86 <memcmp+0x3a>
   8ada4:	2a00      	cmp	r2, #0
   8ada6:	d1d8      	bne.n	8ad5a <memcmp+0xe>
   8ada8:	4610      	mov	r0, r2
   8adaa:	e7e8      	b.n	8ad7e <memcmp+0x32>
   8adac:	1b28      	subs	r0, r5, r4
   8adae:	bc70      	pop	{r4, r5, r6}
   8adb0:	4770      	bx	lr
   8adb2:	bf00      	nop

0008adb4 <memcpy>:
   8adb4:	4684      	mov	ip, r0
   8adb6:	ea41 0300 	orr.w	r3, r1, r0
   8adba:	f013 0303 	ands.w	r3, r3, #3
   8adbe:	d149      	bne.n	8ae54 <memcpy+0xa0>
   8adc0:	3a40      	subs	r2, #64	; 0x40
   8adc2:	d323      	bcc.n	8ae0c <memcpy+0x58>
   8adc4:	680b      	ldr	r3, [r1, #0]
   8adc6:	6003      	str	r3, [r0, #0]
   8adc8:	684b      	ldr	r3, [r1, #4]
   8adca:	6043      	str	r3, [r0, #4]
   8adcc:	688b      	ldr	r3, [r1, #8]
   8adce:	6083      	str	r3, [r0, #8]
   8add0:	68cb      	ldr	r3, [r1, #12]
   8add2:	60c3      	str	r3, [r0, #12]
   8add4:	690b      	ldr	r3, [r1, #16]
   8add6:	6103      	str	r3, [r0, #16]
   8add8:	694b      	ldr	r3, [r1, #20]
   8adda:	6143      	str	r3, [r0, #20]
   8addc:	698b      	ldr	r3, [r1, #24]
   8adde:	6183      	str	r3, [r0, #24]
   8ade0:	69cb      	ldr	r3, [r1, #28]
   8ade2:	61c3      	str	r3, [r0, #28]
   8ade4:	6a0b      	ldr	r3, [r1, #32]
   8ade6:	6203      	str	r3, [r0, #32]
   8ade8:	6a4b      	ldr	r3, [r1, #36]	; 0x24
   8adea:	6243      	str	r3, [r0, #36]	; 0x24
   8adec:	6a8b      	ldr	r3, [r1, #40]	; 0x28
   8adee:	6283      	str	r3, [r0, #40]	; 0x28
   8adf0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
   8adf2:	62c3      	str	r3, [r0, #44]	; 0x2c
   8adf4:	6b0b      	ldr	r3, [r1, #48]	; 0x30
   8adf6:	6303      	str	r3, [r0, #48]	; 0x30
   8adf8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
   8adfa:	6343      	str	r3, [r0, #52]	; 0x34
   8adfc:	6b8b      	ldr	r3, [r1, #56]	; 0x38
   8adfe:	6383      	str	r3, [r0, #56]	; 0x38
   8ae00:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
   8ae02:	63c3      	str	r3, [r0, #60]	; 0x3c
   8ae04:	3040      	adds	r0, #64	; 0x40
   8ae06:	3140      	adds	r1, #64	; 0x40
   8ae08:	3a40      	subs	r2, #64	; 0x40
   8ae0a:	d2db      	bcs.n	8adc4 <memcpy+0x10>
   8ae0c:	3230      	adds	r2, #48	; 0x30
   8ae0e:	d30b      	bcc.n	8ae28 <memcpy+0x74>
   8ae10:	680b      	ldr	r3, [r1, #0]
   8ae12:	6003      	str	r3, [r0, #0]
   8ae14:	684b      	ldr	r3, [r1, #4]
   8ae16:	6043      	str	r3, [r0, #4]
   8ae18:	688b      	ldr	r3, [r1, #8]
   8ae1a:	6083      	str	r3, [r0, #8]
   8ae1c:	68cb      	ldr	r3, [r1, #12]
   8ae1e:	60c3      	str	r3, [r0, #12]
   8ae20:	3010      	adds	r0, #16
   8ae22:	3110      	adds	r1, #16
   8ae24:	3a10      	subs	r2, #16
   8ae26:	d2f3      	bcs.n	8ae10 <memcpy+0x5c>
   8ae28:	320c      	adds	r2, #12
   8ae2a:	d305      	bcc.n	8ae38 <memcpy+0x84>
   8ae2c:	f851 3b04 	ldr.w	r3, [r1], #4
   8ae30:	f840 3b04 	str.w	r3, [r0], #4
   8ae34:	3a04      	subs	r2, #4
   8ae36:	d2f9      	bcs.n	8ae2c <memcpy+0x78>
   8ae38:	3204      	adds	r2, #4
   8ae3a:	d008      	beq.n	8ae4e <memcpy+0x9a>
   8ae3c:	07d2      	lsls	r2, r2, #31
   8ae3e:	bf1c      	itt	ne
   8ae40:	f811 3b01 	ldrbne.w	r3, [r1], #1
   8ae44:	f800 3b01 	strbne.w	r3, [r0], #1
   8ae48:	d301      	bcc.n	8ae4e <memcpy+0x9a>
   8ae4a:	880b      	ldrh	r3, [r1, #0]
   8ae4c:	8003      	strh	r3, [r0, #0]
   8ae4e:	4660      	mov	r0, ip
   8ae50:	4770      	bx	lr
   8ae52:	bf00      	nop
   8ae54:	2a08      	cmp	r2, #8
   8ae56:	d313      	bcc.n	8ae80 <memcpy+0xcc>
   8ae58:	078b      	lsls	r3, r1, #30
   8ae5a:	d0b1      	beq.n	8adc0 <memcpy+0xc>
   8ae5c:	f010 0303 	ands.w	r3, r0, #3
   8ae60:	d0ae      	beq.n	8adc0 <memcpy+0xc>
   8ae62:	f1c3 0304 	rsb	r3, r3, #4
   8ae66:	1ad2      	subs	r2, r2, r3
   8ae68:	07db      	lsls	r3, r3, #31
   8ae6a:	bf1c      	itt	ne
   8ae6c:	f811 3b01 	ldrbne.w	r3, [r1], #1
   8ae70:	f800 3b01 	strbne.w	r3, [r0], #1
   8ae74:	d3a4      	bcc.n	8adc0 <memcpy+0xc>
   8ae76:	f831 3b02 	ldrh.w	r3, [r1], #2
   8ae7a:	f820 3b02 	strh.w	r3, [r0], #2
   8ae7e:	e79f      	b.n	8adc0 <memcpy+0xc>
   8ae80:	3a04      	subs	r2, #4
   8ae82:	d3d9      	bcc.n	8ae38 <memcpy+0x84>
   8ae84:	3a01      	subs	r2, #1
   8ae86:	f811 3b01 	ldrb.w	r3, [r1], #1
   8ae8a:	f800 3b01 	strb.w	r3, [r0], #1
   8ae8e:	d2f9      	bcs.n	8ae84 <memcpy+0xd0>
   8ae90:	780b      	ldrb	r3, [r1, #0]
   8ae92:	7003      	strb	r3, [r0, #0]
   8ae94:	784b      	ldrb	r3, [r1, #1]
   8ae96:	7043      	strb	r3, [r0, #1]
   8ae98:	788b      	ldrb	r3, [r1, #2]
   8ae9a:	7083      	strb	r3, [r0, #2]
   8ae9c:	4660      	mov	r0, ip
   8ae9e:	4770      	bx	lr

0008aea0 <memset>:
   8aea0:	b4f0      	push	{r4, r5, r6, r7}
   8aea2:	0784      	lsls	r4, r0, #30
   8aea4:	d043      	beq.n	8af2e <memset+0x8e>
   8aea6:	1e54      	subs	r4, r2, #1
   8aea8:	2a00      	cmp	r2, #0
   8aeaa:	d03e      	beq.n	8af2a <memset+0x8a>
   8aeac:	b2cd      	uxtb	r5, r1
   8aeae:	4603      	mov	r3, r0
   8aeb0:	e003      	b.n	8aeba <memset+0x1a>
   8aeb2:	1e62      	subs	r2, r4, #1
   8aeb4:	2c00      	cmp	r4, #0
   8aeb6:	d038      	beq.n	8af2a <memset+0x8a>
   8aeb8:	4614      	mov	r4, r2
   8aeba:	f803 5b01 	strb.w	r5, [r3], #1
   8aebe:	079a      	lsls	r2, r3, #30
   8aec0:	d1f7      	bne.n	8aeb2 <memset+0x12>
   8aec2:	2c03      	cmp	r4, #3
   8aec4:	d92a      	bls.n	8af1c <memset+0x7c>
   8aec6:	b2cd      	uxtb	r5, r1
   8aec8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   8aecc:	2c0f      	cmp	r4, #15
   8aece:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   8aed2:	d915      	bls.n	8af00 <memset+0x60>
   8aed4:	f1a4 0710 	sub.w	r7, r4, #16
   8aed8:	093f      	lsrs	r7, r7, #4
   8aeda:	f103 0610 	add.w	r6, r3, #16
   8aede:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   8aee2:	461a      	mov	r2, r3
   8aee4:	6015      	str	r5, [r2, #0]
   8aee6:	6055      	str	r5, [r2, #4]
   8aee8:	6095      	str	r5, [r2, #8]
   8aeea:	60d5      	str	r5, [r2, #12]
   8aeec:	3210      	adds	r2, #16
   8aeee:	42b2      	cmp	r2, r6
   8aef0:	d1f8      	bne.n	8aee4 <memset+0x44>
   8aef2:	f004 040f 	and.w	r4, r4, #15
   8aef6:	3701      	adds	r7, #1
   8aef8:	2c03      	cmp	r4, #3
   8aefa:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   8aefe:	d90d      	bls.n	8af1c <memset+0x7c>
   8af00:	461e      	mov	r6, r3
   8af02:	4622      	mov	r2, r4
   8af04:	3a04      	subs	r2, #4
   8af06:	2a03      	cmp	r2, #3
   8af08:	f846 5b04 	str.w	r5, [r6], #4
   8af0c:	d8fa      	bhi.n	8af04 <memset+0x64>
   8af0e:	1f22      	subs	r2, r4, #4
   8af10:	f022 0203 	bic.w	r2, r2, #3
   8af14:	3204      	adds	r2, #4
   8af16:	4413      	add	r3, r2
   8af18:	f004 0403 	and.w	r4, r4, #3
   8af1c:	b12c      	cbz	r4, 8af2a <memset+0x8a>
   8af1e:	b2c9      	uxtb	r1, r1
   8af20:	441c      	add	r4, r3
   8af22:	f803 1b01 	strb.w	r1, [r3], #1
   8af26:	42a3      	cmp	r3, r4
   8af28:	d1fb      	bne.n	8af22 <memset+0x82>
   8af2a:	bcf0      	pop	{r4, r5, r6, r7}
   8af2c:	4770      	bx	lr
   8af2e:	4614      	mov	r4, r2
   8af30:	4603      	mov	r3, r0
   8af32:	e7c6      	b.n	8aec2 <memset+0x22>

0008af34 <register_fini>:
   8af34:	4b02      	ldr	r3, [pc, #8]	; (8af40 <register_fini+0xc>)
   8af36:	b113      	cbz	r3, 8af3e <register_fini+0xa>
   8af38:	4802      	ldr	r0, [pc, #8]	; (8af44 <register_fini+0x10>)
   8af3a:	f000 b805 	b.w	8af48 <atexit>
   8af3e:	4770      	bx	lr
   8af40:	00000000 	.word	0x00000000
   8af44:	0008af55 	.word	0x0008af55

0008af48 <atexit>:
   8af48:	4601      	mov	r1, r0
   8af4a:	2000      	movs	r0, #0
   8af4c:	4602      	mov	r2, r0
   8af4e:	4603      	mov	r3, r0
   8af50:	f000 b818 	b.w	8af84 <__register_exitproc>

0008af54 <__libc_fini_array>:
   8af54:	b538      	push	{r3, r4, r5, lr}
   8af56:	4d09      	ldr	r5, [pc, #36]	; (8af7c <__libc_fini_array+0x28>)
   8af58:	4c09      	ldr	r4, [pc, #36]	; (8af80 <__libc_fini_array+0x2c>)
   8af5a:	1b64      	subs	r4, r4, r5
   8af5c:	10a4      	asrs	r4, r4, #2
   8af5e:	bf18      	it	ne
   8af60:	eb05 0584 	addne.w	r5, r5, r4, lsl #2
   8af64:	d005      	beq.n	8af72 <__libc_fini_array+0x1e>
   8af66:	3c01      	subs	r4, #1
   8af68:	f855 3d04 	ldr.w	r3, [r5, #-4]!
   8af6c:	4798      	blx	r3
   8af6e:	2c00      	cmp	r4, #0
   8af70:	d1f9      	bne.n	8af66 <__libc_fini_array+0x12>
   8af72:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
   8af76:	f000 b919 	b.w	8b1ac <_fini>
   8af7a:	bf00      	nop
   8af7c:	0008b1b8 	.word	0x0008b1b8
   8af80:	0008b1bc 	.word	0x0008b1bc

0008af84 <__register_exitproc>:
   8af84:	b5f0      	push	{r4, r5, r6, r7, lr}
   8af86:	4c27      	ldr	r4, [pc, #156]	; (8b024 <__register_exitproc+0xa0>)
   8af88:	b085      	sub	sp, #20
   8af8a:	6826      	ldr	r6, [r4, #0]
   8af8c:	4607      	mov	r7, r0
   8af8e:	f8d6 4148 	ldr.w	r4, [r6, #328]	; 0x148
   8af92:	2c00      	cmp	r4, #0
   8af94:	d040      	beq.n	8b018 <__register_exitproc+0x94>
   8af96:	6865      	ldr	r5, [r4, #4]
   8af98:	2d1f      	cmp	r5, #31
   8af9a:	dd1e      	ble.n	8afda <__register_exitproc+0x56>
   8af9c:	4822      	ldr	r0, [pc, #136]	; (8b028 <__register_exitproc+0xa4>)
   8af9e:	b918      	cbnz	r0, 8afa8 <__register_exitproc+0x24>
   8afa0:	f04f 30ff 	mov.w	r0, #4294967295
   8afa4:	b005      	add	sp, #20
   8afa6:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8afa8:	f44f 70c8 	mov.w	r0, #400	; 0x190
   8afac:	9103      	str	r1, [sp, #12]
   8afae:	9202      	str	r2, [sp, #8]
   8afb0:	9301      	str	r3, [sp, #4]
   8afb2:	f3af 8000 	nop.w
   8afb6:	9903      	ldr	r1, [sp, #12]
   8afb8:	4604      	mov	r4, r0
   8afba:	9a02      	ldr	r2, [sp, #8]
   8afbc:	9b01      	ldr	r3, [sp, #4]
   8afbe:	2800      	cmp	r0, #0
   8afc0:	d0ee      	beq.n	8afa0 <__register_exitproc+0x1c>
   8afc2:	f8d6 5148 	ldr.w	r5, [r6, #328]	; 0x148
   8afc6:	2000      	movs	r0, #0
   8afc8:	6025      	str	r5, [r4, #0]
   8afca:	6060      	str	r0, [r4, #4]
   8afcc:	4605      	mov	r5, r0
   8afce:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
   8afd2:	f8c4 0188 	str.w	r0, [r4, #392]	; 0x188
   8afd6:	f8c4 018c 	str.w	r0, [r4, #396]	; 0x18c
   8afda:	b93f      	cbnz	r7, 8afec <__register_exitproc+0x68>
   8afdc:	1c6b      	adds	r3, r5, #1
   8afde:	2000      	movs	r0, #0
   8afe0:	3502      	adds	r5, #2
   8afe2:	6063      	str	r3, [r4, #4]
   8afe4:	f844 1025 	str.w	r1, [r4, r5, lsl #2]
   8afe8:	b005      	add	sp, #20
   8afea:	bdf0      	pop	{r4, r5, r6, r7, pc}
   8afec:	2601      	movs	r6, #1
   8afee:	40ae      	lsls	r6, r5
   8aff0:	eb04 0085 	add.w	r0, r4, r5, lsl #2
   8aff4:	f8c0 2088 	str.w	r2, [r0, #136]	; 0x88
   8aff8:	f8d4 2188 	ldr.w	r2, [r4, #392]	; 0x188
   8affc:	2f02      	cmp	r7, #2
   8affe:	ea42 0206 	orr.w	r2, r2, r6
   8b002:	f8c4 2188 	str.w	r2, [r4, #392]	; 0x188
   8b006:	f8c0 3108 	str.w	r3, [r0, #264]	; 0x108
   8b00a:	d1e7      	bne.n	8afdc <__register_exitproc+0x58>
   8b00c:	f8d4 318c 	ldr.w	r3, [r4, #396]	; 0x18c
   8b010:	431e      	orrs	r6, r3
   8b012:	f8c4 618c 	str.w	r6, [r4, #396]	; 0x18c
   8b016:	e7e1      	b.n	8afdc <__register_exitproc+0x58>
   8b018:	f506 74a6 	add.w	r4, r6, #332	; 0x14c
   8b01c:	f8c6 4148 	str.w	r4, [r6, #328]	; 0x148
   8b020:	e7b9      	b.n	8af96 <__register_exitproc+0x12>
   8b022:	bf00      	nop
   8b024:	0008b194 	.word	0x0008b194
   8b028:	00000000 	.word	0x00000000
   8b02c:	00004e4f 	.word	0x00004e4f
   8b030:	00004e4f 	.word	0x00004e4f
   8b034:	00004e4f 	.word	0x00004e4f

0008b038 <ulLED>:
   8b038:	00000057 00000056 0000003b 00000055     W...V...;...U...
   8b048:	00006b68 6d612069 64617320 00000000     hk..i am sad....
   8b058:	0067736d 59530d0a 4d455453 52412053     msg...SYSTEMS AR
   8b068:	4f4e2045 414e494d 53202c4c 0a2e5249     E NOMINAL, SIR..
   8b078:	0000000d 55530d0a 53595342 204d4554     ......SUBSYSTEM 
   8b088:	504d4554 54415245 20455255 00205349     TEMPERATURE IS .
   8b098:	0d0a4320 00000000 4f440d0a 554f5920      C........DO YOU
   8b0a8:	4e415720 20412054 43534942 3f544955      WANT A BISCUIT?
   8b0b8:	00000d0a 20410d0a 5353454d 20454741     ......A MESSAGE 
   8b0c8:	20534157 45434552 44455649 4f524620     WAS RECEIVED FRO
   8b0d8:	4f43204d 203a534d 00000000 00000d0a     M COMS: ........
   8b0e8:	00009600 000000c0 00000800 00000000     ................
	...

0008b100 <can_bit_time>:
   8b100:	02020308 02094b03 43020303 0303030a     .....K.....C....
   8b110:	040b4603 48040303 0404030c 040d4304     .F.....H.....C..
   8b120:	4d040404 0504040e 040f4004 43040505     ...M.....@.....C
   8b130:	05050510 06114504 47040505 06060512     .....E.....G....
   8b140:	06134304 44040606 06060714 08154604     .C.....D.....F..
   8b150:	47040606 07070716 08174404 46040708     ...G.....D.....F
   8b160:	08080718 08194304 44040808 454c4449     .....C.....DIDLE
   8b170:	00000000                                ....

0008b174 <ucExpectedStackBytes.5295>:
   8b174:	a5a5a5a5 a5a5a5a5 a5a5a5a5 a5a5a5a5     ................
   8b184:	a5a5a5a5 20726d54 00637653 00000043     ....Tmr Svc.C...

0008b194 <_global_impure_ptr>:
   8b194:	20070010                                ... 

0008b198 <_init>:
   8b198:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8b19a:	bf00      	nop
   8b19c:	bcf8      	pop	{r3, r4, r5, r6, r7}
   8b19e:	bc08      	pop	{r3}
   8b1a0:	469e      	mov	lr, r3
   8b1a2:	4770      	bx	lr

0008b1a4 <__init_array_start>:
   8b1a4:	0008af35 	.word	0x0008af35

0008b1a8 <__frame_dummy_init_array_entry>:
   8b1a8:	00080119                                ....

0008b1ac <_fini>:
   8b1ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   8b1ae:	bf00      	nop
   8b1b0:	bcf8      	pop	{r3, r4, r5, r6, r7}
   8b1b2:	bc08      	pop	{r3}
   8b1b4:	469e      	mov	lr, r3
   8b1b6:	4770      	bx	lr

0008b1b8 <__fini_array_start>:
   8b1b8:	000800f5 	.word	0x000800f5
